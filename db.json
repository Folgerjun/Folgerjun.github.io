{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-melody/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/melody-favicon.ico","path":"melody-favicon.ico","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/css/404.styl","path":"css/404.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/copy.js","path":"js/copy.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/fireworks.js","path":"js/fireworks.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/head.js","path":"js/head.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/katex.js","path":"js/katex.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/scroll.js","path":"js/scroll.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/transition.js","path":"js/transition.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/categories/index.md","hash":"4921d9e33602f074b62d271c511e4b00d5014151","modified":1526962866000},{"_id":"source/about/index.md","hash":"09f0e9cfec638c68be9379e1ab7308aeb09b7eb6","modified":1703349862243},{"_id":"source/_posts/Integer-practical-notcommon-methods.md","hash":"5ef3143c5a27c0c9a6f2ea09bb0ae6b221ab157a","modified":1703345723827},{"_id":"source/_posts/DP-01backpack.md","hash":"bcb210f2b0fdaf2d41fd46bcecf8240a12ea7f45","modified":1703345723826},{"_id":"source/_posts/JVM-Class-File.md","hash":"f0d294978d774112e97c6b7ee0ca7b8bd56d1985","modified":1703345723827},{"_id":"source/_posts/JVM-MemoryArea.md","hash":"59137893b773a9f2c4659a48b2177b9c9bf3d2bb","modified":1703345723827},{"_id":"source/_posts/JVM-Class-Load.md","hash":"289f48b2ee96b3a15aa9473cdff470724424d423","modified":1703345723827},{"_id":"source/_posts/JVM-Parameter.md","hash":"98eb1d1dc09d55b23c6d94592459f95e0b21d14b","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-Eight.md","hash":"eef8c280a0dce6d28813d81a8c7470218240ba17","modified":1703345723827},{"_id":"source/_posts/JVM-GC.md","hash":"91e3705ceec4666e972ea637fa446d32eff4f273","modified":1703345723827},{"_id":"source/_posts/JVM-Code-Execution-Engine.md","hash":"1512b7986871a58fa88c1793376d1a19351cf490","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-Five.md","hash":"fe8bec67a7bc3ade4609fab5459a56510b7cf8b8","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-Eleven.md","hash":"796654a50fb262141e3cc20908f66f75b52eb995","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-Nine.md","hash":"022acabff4d6cf29fe997f925c0156d95073998c","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-Seven.md","hash":"05ac1b4c1f33ed24a812e7355f28b96fa1a924d9","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-One.md","hash":"c9f351fce3e6962570ef4c2b311ffde5babbd961","modified":1703345723827},{"_id":"source/_posts/Multithreading-Chapter-Three.md","hash":"922876f48ef2eefe390e44ee4f41d052ca467ef1","modified":1703345723828},{"_id":"source/_posts/Multithreading-Chapter-Two.md","hash":"3bcc5bbc0e0c0708817d4b9150a8f17c4d0bb742","modified":1703345723828},{"_id":"source/_posts/Multithreading-Chapter-Six.md","hash":"0f5ee57242c2580a86d4066466b7eaab60158ea5","modified":1703345723828},{"_id":"source/_posts/Multithreading-Chapter-Twelve.md","hash":"756703abb73580f262caa4432709b9a074e928e3","modified":1703345723828},{"_id":"source/_posts/My97DatePicker.md","hash":"4be2c122d85b15ad8dd1b7dc51e4cc6acf3ac0a2","modified":1703345723828},{"_id":"source/_posts/annotation-java-runtime.md","hash":"8c9194dde2537c3c32a582bd2e4e4d29814bf59c","modified":1703345723828},{"_id":"source/_posts/arrcopy-beancopy.md","hash":"ed1a09052c47fb21c2ecc86d9b22bb084aac9770","modified":1703345723828},{"_id":"source/_posts/Multithreading-Chapter-Four.md","hash":"85037266bc49a7de7b5ecbec7556e148c2f4ba87","modified":1703345723827},{"_id":"source/_posts/autumn-september.md","hash":"a2e1695366dfb7793beef20ef9a9567795463bbd","modified":1703345723824},{"_id":"source/_posts/beat-january.md","hash":"d8b9121f63a2d9aaba15da084b0eaa3e6ffae883","modified":1703345723823},{"_id":"source/_posts/anxiety-june.md","hash":"25494dfe0bcb32011f929aa874d0365d25b8e1d1","modified":1703345723823},{"_id":"source/_posts/better-june.md","hash":"7e6e69a5d6a19317aa2223ffc48536b91d50e5b9","modified":1703345723825},{"_id":"source/_posts/binary-search.md","hash":"a8097e97b019dae47b7e15cdee2e561875c4cedf","modified":1703345723828},{"_id":"source/_posts/black-june-2018.md","hash":"3e8c9d59a8a1ab17ad17f8d67630fd4a84e25976","modified":1703345723828},{"_id":"source/_posts/busy-march.md","hash":"db743c966db8ecf8ddd2a0cc4a22f655360fb16c","modified":1703345723823},{"_id":"source/_posts/broken-april.md","hash":"33fcca315a547d8799c4d95264f19f0724f5801c","modified":1703345723826},{"_id":"source/_posts/bless-february.md","hash":"f87855839e3b31e9db4f9d289e6865332b12581e","modified":1703345723824},{"_id":"source/_posts/busy-may.md","hash":"42417a00fa454fbaaf0627e1d98001e0a5f3753f","modified":1703345723826},{"_id":"source/_posts/bleak-october.md","hash":"08736097a9126433dd0f2368caa19ffddcec1027","modified":1703345723824},{"_id":"source/_posts/bustle-october.md","hash":"3aa5c2f082f640e91d473213eb6b97fbf6a0d62d","modified":1703345723824},{"_id":"source/_posts/busy-november-2018.md","hash":"f0e47b84154b396f109fc1697001b896f4291e33","modified":1703345723828},{"_id":"source/_posts/chophand-november.md","hash":"3705d784e1aa06b1fb89d8f8fdaeb791661763f7","modified":1703345723823},{"_id":"source/_posts/comfortable-september.md","hash":"967cf9d9ada3ddfc3dea0c4991ee403f820cd6e7","modified":1703345723825},{"_id":"source/_posts/common-instructions.md","hash":"905995a3eefe9bca33d618ba21af86fe3fa17b2d","modified":1703345723829},{"_id":"source/_posts/cool-september-2018.md","hash":"bb5ce3c140750e4356883f27a4e9226c59e5d2ff","modified":1703345723829},{"_id":"source/_posts/collections-addF-jdk1.8.md","hash":"c89c79fae50d8815d81799241462471ac009aef8","modified":1703345723829},{"_id":"source/_posts/clickhouse-in-action-pv-uv.md","hash":"b3630db18106e9d6fb8ebc2f263f9ade0febef5e","modified":1703345723825},{"_id":"source/_posts/dizzy-september.md","hash":"171c5896b5bd76d80565ad76196ddaff240a5c7e","modified":1703345723823},{"_id":"source/_posts/danger-december.md","hash":"59e2f1abd5e94d403f33da1f9eb299685caa228b","modified":1703345723825},{"_id":"source/_posts/face-java.md","hash":"e97c9cda3330371d5c78430b07d5d3a7b9afb47d","modified":1703345723829},{"_id":"source/_posts/exchange-august.md","hash":"eddf309457826b5114c188adc0e3923f74ff0c55","modified":1703345723825},{"_id":"source/_posts/expect-january.md","hash":"2ff13f91c8f7d2d0daed4397f15b9571a7bc8256","modified":1703345723825},{"_id":"source/_posts/fruit-august.md","hash":"71c6fb1c7d561c31159b03afe781c567f0a1b5d6","modified":1703345723826},{"_id":"source/_posts/exciting-april.md","hash":"93d2f0a7e6e785b814f5911facdfdfcbb4899017","modified":1703345723823},{"_id":"source/_posts/free-may.md","hash":"10ac981d57b0f2542aed4a98dc957f11ce27d53b","modified":1703345723825},{"_id":"source/_posts/green-october.md","hash":"779268f4bda33567df6e755ae42bda6a2fe3d036","modified":1703345723825},{"_id":"source/_posts/foolish-august.md","hash":"b68d25119cd1b85dbe2d37f0b76475dc770b4d7e","modified":1703345723823},{"_id":"source/_posts/goldenautumn-october.md","hash":"e1b64d112ba62ce5180f3a1c66137f3fbd9e4af3","modified":1703345723823},{"_id":"source/_posts/happy-may.md","hash":"d9111c290dbacc50b59715ebd3fe55dbe0844a3a","modified":1703345723823},{"_id":"source/_posts/hello-2019.md","hash":"ffe64d85dae15e04cf86a40f6e7245904fb15f7b","modified":1703345723829},{"_id":"source/_posts/hello-2022.md","hash":"c2a1617dcc4aaa457392560dd4ecfb9cc293910c","modified":1703345723825},{"_id":"source/_posts/hello-2023.md","hash":"0cb737906e954d0caaa2ef22656dd6899bd03a13","modified":1703345723825},{"_id":"source/_posts/home-april.md","hash":"db40191ac5e3d9edcf354bdecd2c5081c624b8ea","modified":1703345723826},{"_id":"source/_posts/hello-2021.md","hash":"fd0fb8c452d018ced98ae5b3c4018800673c740f","modified":1703345723824},{"_id":"source/_posts/hot-july.md","hash":"1296355a508fe96cb92c50d0bfc9828d63920486","modified":1703345723826},{"_id":"source/_posts/hello-2020.md","hash":"ec21ec54dc7350251f2a97f8db38f37981e0a71f","modified":1703345723823},{"_id":"source/_posts/hello-world.md","hash":"4e793f7d44322804a8274d31ffde4e385d39cac5","modified":1703345723829},{"_id":"source/_posts/hot-september.md","hash":"ea921a9f0dddbf9b38cb288640bf8a7f7072a49e","modified":1703345723825},{"_id":"source/_posts/hurry-march.md","hash":"5e08b9682ef203ababe1833fe0575f52c02ec5c6","modified":1703345723825},{"_id":"source/_posts/indexedDB.md","hash":"50fa793fbe38945d61a3ec824b5ddc81368b9104","modified":1703345723829},{"_id":"source/_posts/hot-july-2022.md","hash":"7ac5cc23aa29610406c54b4b669899ddcf0f7f4f","modified":1703345723826},{"_id":"source/_posts/indulgence-february.md","hash":"1c0b8679f13315d4f22d654c8fd6fa6069fd7f37","modified":1703345723823},{"_id":"source/_posts/kong-custom-plugin.md","hash":"17bfbe27dab5247d378743db37cf6511a1ab242a","modified":1703345723826},{"_id":"source/_posts/laught-often.md","hash":"c27cd7ba3b9c3b21e7d4207279b9a964a4848fe6","modified":1703345723829},{"_id":"source/_posts/leetcode-binary-tree-traversal.md","hash":"1bd971364d9019c269ad31b76ded5edc435adb8c","modified":1703345723829},{"_id":"source/_posts/leetcode-combination-sum.md","hash":"76821951f2a7b00f076a62b8c828de6dc1faede4","modified":1703345723829},{"_id":"source/_posts/leetcode-longest-common-prefix.md","hash":"1b13756b9c2c45f91b5ddc440ef184ba66daf85c","modified":1703345723829},{"_id":"source/_posts/leetcode-detect-capital.md","hash":"6b81ed12b19eeebd745efd00433c52bf3212017c","modified":1703345723829},{"_id":"source/_posts/leetcode-palindrome-number.md","hash":"39747584aa85ee82f2dab2ca2261d741881ddf90","modified":1703345723829},{"_id":"source/_posts/leetcode-pairsofsongswithtotaldurationsdivisibleby60.md","hash":"6f33641c98b6302a5b2df440adccae5418ea7ea5","modified":1703345723829},{"_id":"source/_posts/leetcode-n-sum.md","hash":"fbbf82e94e3c2217a27840a8d31ec8dd01e82e90","modified":1703345723829},{"_id":"source/_posts/leetcode-permutations.md","hash":"4863155390a3113b1a6c566e468c10ba5a3f876e","modified":1703345723829},{"_id":"source/_posts/leetcode-reverse-linkedlist.md","hash":"a4d972ffa5a33e9892a45c9767077f6d0cce4f76","modified":1703345723830},{"_id":"source/_posts/leetcode-triangle.md","hash":"01bf260487537669d77493f51dc29fa54ced4c15","modified":1703345723830},{"_id":"source/_posts/my-blog-ok.md","hash":"7db5fe1b084fc1381c447c809590f807eda784f0","modified":1703345723830},{"_id":"source/_posts/mysql-index.md","hash":"be978f21a133ef6e3af9fe0efb88ea862ecf8694","modified":1703345723828},{"_id":"source/_posts/mysql-sql-optimization.md","hash":"2f7fa81a70bc88108a5b16264b2738ae03ae54b8","modified":1703345723828},{"_id":"source/_posts/mysql-engine.md","hash":"c887e787443c060de1ad23fa6ea7fb53d6959efc","modified":1703345723828},{"_id":"source/_posts/mysql-database-backup.md","hash":"baabcc6619a91e7cc7ffd257f4d96b9b366e50a7","modified":1703345723824},{"_id":"source/_posts/mysql-sql.md","hash":"fc3a023566e6b23266d85d55e8a6cd4f1ea5ea91","modified":1703345723828},{"_id":"source/_posts/netty4-datatrans.md","hash":"f7d61d7d5d4daeeab38ecbff925156385847f947","modified":1703345723823},{"_id":"source/_posts/node-list-close-loop.md","hash":"db73a5a40f37ca62d5a4f605afd9d270ec8e1717","modified":1703345723830},{"_id":"source/_posts/mysql-distributed-transaction.md","hash":"024d636c1bccad693636e5caaee897ed7d2bbb2b","modified":1703345723828},{"_id":"source/_posts/normal-november.md","hash":"89c9e097ad9369399efdb18ef76a42e947637246","modified":1703345723825},{"_id":"source/_posts/new-january.md","hash":"014e2ea49d057ae9fe2d93ce81ab206baf938c98","modified":1703345723825},{"_id":"source/_posts/life-june.md","hash":"11565f9d708a766a167ea60f1382fbffea541987","modified":1703345723825},{"_id":"source/_posts/new-may.md","hash":"b7bd01d4d04b401d553a346a56936e9404843402","modified":1703345723824},{"_id":"source/_posts/note-transactions.md","hash":"99265b2ff4ec12586cdbdb8c2026c525940121a2","modified":1703345723825},{"_id":"source/_posts/not-enough-july.md","hash":"ee02d66cfa1261f94ed38cc2f9858c5d9296e180","modified":1703345723824},{"_id":"source/_posts/prepare-marry-september.md","hash":"0d35c10954f904dad8a34f86bdfb6d5fc52be8f4","modified":1703345723826},{"_id":"source/_posts/play-october.md","hash":"5892e842d5bdd1b99e38b0fbae68ebe62ed48c2a","modified":1703345723826},{"_id":"source/_posts/rain-june.md","hash":"497a86e50e11444b63b10c29b64c7a4363ea4f4b","modified":1703345723826},{"_id":"source/_posts/red-november.md","hash":"99b5d5fda2fd78a222887df75337ed9fcdb4d4be","modified":1703345723826},{"_id":"source/_posts/relax-february.md","hash":"6bf7f8c4f077f787ad785b27c0169e4a5e3b74e7","modified":1703345723825},{"_id":"source/_posts/opposite-build.md","hash":"09f4b2f96e10ba038659bb1a7c25d5b6c1fdf780","modified":1703345723830},{"_id":"source/_posts/reunion-february.md","hash":"18ed751c707cebf2e6cdd87c6b0ee48dd75a233c","modified":1703345723826},{"_id":"source/_posts/restless-march.md","hash":"d21580aaf322d0543e2b7cbdc585d0688704a32b","modified":1703345723826},{"_id":"source/_posts/restful-url-api.md","hash":"b968ca362f5fb41574b11439baf19e555a173176","modified":1703345723824},{"_id":"source/_posts/rain-june-2020.md","hash":"28e446c2e670e5a2d9f5de772ecda13038e41775","modified":1703345723824},{"_id":"source/_posts/shell-restart.md","hash":"a7a275ad75a7fd6890636da07a33a5ddd14e1a07","modified":1703345723824},{"_id":"source/_posts/sort-algorithm.md","hash":"342214e3be1e3ecb20b3830ad63c9c210a0ac55e","modified":1703345723830},{"_id":"source/_posts/science-fiction-october-2018.md","hash":"7b83cdec5c0d26b62efb874b2564839a263a7416","modified":1703345723830},{"_id":"source/_posts/spirit-august.md","hash":"8a219ad02b1d6f7b850a0917c056e2ae56bf9e0a","modified":1703345723824},{"_id":"source/_posts/spring-february.md","hash":"06aeb2e70b82b68235805a8ca0710ee599fb9943","modified":1703345723826},{"_id":"source/_posts/self-regulation.md","hash":"0222f57774e9a58f888068bcac955e468e4fc455","modified":1703345723830},{"_id":"source/_posts/spring-march.md","hash":"999a7bb8969b316509bd92e59511c8aec28655ee","modified":1703345723824},{"_id":"source/_posts/spring-data-jpa.md","hash":"73d80e71055071a03986274acb4587cfd0d3f749","modified":1703345723830},{"_id":"source/_posts/scholarly-august-2018.md","hash":"e82b15f42cc6ac7c8b76abc29bc4cb89994c7449","modified":1703345723830},{"_id":"source/_posts/springboot2-sharding-jdbc.md","hash":"07cda75c14517a38af82f9a61f2e84c632e24518","modified":1703345723830},{"_id":"source/_posts/springboot2-websocket.md","hash":"0eb21a78d1b82efa95118386b9869fa39ccb4031","modified":1703345723830},{"_id":"source/_posts/springboot2-datajpa-rest.md","hash":"bcfbddddd47182b23bdb4ac7e574fd1df43eb8b8","modified":1703345723823},{"_id":"source/_posts/springboot2-mail.md","hash":"6361a4d0c105595422dce7faa18eac247853fc5e","modified":1703345723824},{"_id":"source/_posts/ssh-nat-ubuntu.md","hash":"0fadad0eec552d975e776cfe55d68e085c0ef43e","modified":1703345723830},{"_id":"source/_posts/sultry-july.md","hash":"5dfd44810b3a2d09da77f929280caf67f8764834","modified":1703345723824},{"_id":"source/_posts/summary-180531.md","hash":"c87f44f41e4a5b63389aeca6221de0851aa0518a","modified":1703345723830},{"_id":"source/_posts/summary-180704.md","hash":"3b5c3a9967c22d530641008bff461b38f1871544","modified":1703345723830},{"_id":"source/_posts/summary-180803.md","hash":"531d04ba1c74aaca804fc79b01aee584d85d13a0","modified":1703345723830},{"_id":"source/_posts/talk-november.md","hash":"dadc538ccb0b907c76c227e3412a4859cc09fbdb","modified":1703345723824},{"_id":"source/_posts/surprise-april.md","hash":"95e176e9f4de0419bba93cc48633ca8ac7884c6f","modified":1703345723825},{"_id":"source/_posts/sway-april.md","hash":"c74455a64f02576c94c2715dd20ecf0c64a9ef58","modified":1703345723824},{"_id":"source/_posts/stream-jdk1.8.md","hash":"827b9b80f9d812c3c8c2230cee503b58896d41fc","modified":1703345723830},{"_id":"source/_posts/that-day.md","hash":"59c325a3de7b0df680326da599e6def0f6e30f34","modified":1703345723830},{"_id":"source/_posts/tour-may.md","hash":"040bce1abdd9f1493f05e4a662d52ecfad1de101","modified":1703345723825},{"_id":"source/_posts/tired-january.md","hash":"35fbf61d31e4743a3f40c9c47dd406f71ea7aa3e","modified":1703345723824},{"_id":"source/_posts/turbulent-july.md","hash":"f9e058c8fde9711cea63f845bf2fd943b0444940","modified":1703345723825},{"_id":"source/_posts/trial-period-summary.md","hash":"4c8a1cb2e59770beb73bce5a3588a7e11577cd3d","modified":1703345723831},{"_id":"source/_posts/turbulent-november.md","hash":"4a2eff6b4d17e781a0e2cd872d7f9e540ec31f6e","modified":1703345723826},{"_id":"source/_posts/warm-march.md","hash":"d2023b745b066b445122cd58f4caffd8884d8807","modified":1703345723826},{"_id":"source/_posts/tutu-august.md","hash":"03dd095969a08f52a3fb8b5829a15b30b569e700","modified":1703345723826},{"_id":"source/_posts/wonderful-life.md","hash":"71f7ae77f49f883daf4cf8cec4937b8e504701f2","modified":1703345723824},{"_id":"source/_posts/yang-december.md","hash":"e80fd9bb92b4a9b3ea093b1d6fdb7270c5297972","modified":1703345723826},{"_id":"source/slides/index.md","hash":"5df262c36a6adf93f89a656ad3af295588705ad6","modified":1526878362000},{"_id":"source/gallery/index.md","hash":"1eff78852cfb04cb39283a2a546aa6f6f3b4da84","modified":1526878408000},{"_id":"source/tags/index.md","hash":"1393a6a3363fe83f70a4aeff67e77d93d5e3f4a0","modified":1526962856000},{"_id":"source/_posts/year-january.md","hash":"e10b961c9c788934905e80142c66081296195331","modified":1703345723826},{"_id":"node_modules/hexo-theme-melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1703348124797},{"_id":"node_modules/hexo-theme-melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1703348123076},{"_id":"node_modules/hexo-theme-melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1703348123566},{"_id":"node_modules/hexo-theme-melody/FAQ.md","hash":"5984dd5335f8ead64f14d3885de5cc5ef09dfff8","modified":1703348123555},{"_id":"node_modules/hexo-theme-melody/package.json","hash":"7ec07ad0717da8ca91fb04d264902edbd2a550c0","modified":1703348123554},{"_id":"node_modules/hexo-theme-melody/CHANGELOG.md","hash":"a3fdc0bf95738aa013b0de6dcd1c6523512dcddf","modified":1703348123554},{"_id":"node_modules/hexo-theme-melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1703348124798},{"_id":"node_modules/hexo-theme-melody/LICENSE","hash":"dbbc2e6e42affa5ac962826f01bffa8c7aecd6b8","modified":1703348122773},{"_id":"node_modules/hexo-theme-melody/languages/default.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1703348124800},{"_id":"node_modules/hexo-theme-melody/languages/en.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1703348124800},{"_id":"node_modules/hexo-theme-melody/_config.yml","hash":"5efa43b59d4112bacb83f2a23c50fc20948d57cf","modified":1703348124798},{"_id":"node_modules/hexo-theme-melody/languages/zh-Hans.yml","hash":"68c5794ec57227daec2e3afe2c5d502fa0a7092a","modified":1703348124800},{"_id":"node_modules/hexo-theme-melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1703348123560},{"_id":"node_modules/hexo-theme-melody/layout/404.pug","hash":"0ad5d251ba70edad5c04a45d13ca6a8db3bf7b42","modified":1703348123557},{"_id":"node_modules/hexo-theme-melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1703348123558},{"_id":"node_modules/hexo-theme-melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1703348123562},{"_id":"node_modules/hexo-theme-melody/layout/page.pug","hash":"09c1c7c4ffff114c886b097ec82e046399ab79e1","modified":1703348123565},{"_id":"node_modules/hexo-theme-melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1703348123563},{"_id":"node_modules/hexo-theme-melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1703348123075},{"_id":"node_modules/hexo-theme-melody/README.md","hash":"f0197363be56ef95b40854c4115bac4c8bbe93e8","modified":1703348123555},{"_id":"node_modules/hexo-theme-melody/scripts/replace-config.js","hash":"a8e9a18b2798d3c694a3efa8036f82046c3eb037","modified":1703348123302},{"_id":"node_modules/hexo-theme-melody/source/favicon.ico","hash":"12c3523f17e72f15b8c8b8d1cba8bc850bae5304","modified":1545105850000},{"_id":"node_modules/hexo-theme-melody/source/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1703348122778},{"_id":"node_modules/hexo-theme-melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1703348123568},{"_id":"node_modules/hexo-theme-melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1703348123568},{"_id":"node_modules/hexo-theme-melody/layout/includes/additional-js.pug","hash":"c4ca62466684758d5a26e5866f9ed87b5c9401b8","modified":1703348123558},{"_id":"node_modules/hexo-theme-melody/layout/post.pug","hash":"436bb1b7d14e29cba8010d3ea14df19681fbb5fe","modified":1703348123566},{"_id":"node_modules/hexo-theme-melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1703348123561},{"_id":"node_modules/hexo-theme-melody/layout/includes/layout.pug","hash":"58856b5048fb64e7dab75a6ae32cc2a0ad94de4f","modified":1703348123564},{"_id":"node_modules/hexo-theme-melody/layout/includes/header.pug","hash":"f440a9741eeacfa62f0a0e7ef470a104f1cb510c","modified":1703348123562},{"_id":"node_modules/hexo-theme-melody/layout/includes/head.pug","hash":"bf287d6440011cb17d15dbaf5945517d36918800","modified":1703348123562},{"_id":"node_modules/hexo-theme-melody/layout/includes/nav.pug","hash":"3f1fe059784df45f923587b81cc972659ed22e01","modified":1703348123565},{"_id":"node_modules/hexo-theme-melody/layout/includes/pagination.pug","hash":"fe33a94d90836b767c42654ccc4c4de7d7f227fc","modified":1703348123566},{"_id":"node_modules/hexo-theme-melody/layout/includes/recent-posts.pug","hash":"128c448f5bab71f59912516edff9d476ff6b8afe","modified":1703348123566},{"_id":"node_modules/hexo-theme-melody/layout/includes/sidebar.pug","hash":"211b8ecfdb7b5dd836c87436def410a52dfa5ecd","modified":1703348123567},{"_id":"node_modules/hexo-theme-melody/source/css/404.styl","hash":"b7a0f8b23cb137b1a6c4fa0f9a35e06e93065b2c","modified":1703348123569},{"_id":"node_modules/hexo-theme-melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1703348123556},{"_id":"node_modules/hexo-theme-melody/layout/includes/config.pug","hash":"66e384b1cfe58a57b80f7dff0388bf00bb8bfdf8","modified":1703348123560},{"_id":"node_modules/hexo-theme-melody/source/css/index.styl","hash":"2053ba56db707e7a03796ba59f77103765b02353","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1703348124795},{"_id":"node_modules/hexo-theme-melody/source/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1703348123072},{"_id":"node_modules/hexo-theme-melody/source/js/fireworks.js","hash":"4b6428da34535f0e8fe5a11976b8d89c48736500","modified":1703348123075},{"_id":"node_modules/hexo-theme-melody/source/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1703348123075},{"_id":"node_modules/hexo-theme-melody/source/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1703348123074},{"_id":"node_modules/hexo-theme-melody/source/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1703348123302},{"_id":"node_modules/hexo-theme-melody/source/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1703348123303},{"_id":"node_modules/hexo-theme-melody/source/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1703348123303},{"_id":"node_modules/hexo-theme-melody/layout/includes/404/404-nav.pug","hash":"4cd894857bb90fe44b55e852864692ed06588b8e","modified":1703348123557},{"_id":"node_modules/hexo-theme-melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1703348123303},{"_id":"node_modules/hexo-theme-melody/layout/includes/404/layout.pug","hash":"9c7cdf16a9b9b4aa251dba9378a0f00d985101de","modified":1703348123563},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/disqus.pug","hash":"e62b73df92566806bfb170f204295cffd7074215","modified":1703348123561},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1703348123563},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1703348123562},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/valine.pug","hash":"bc58746ed5c8cc001ad47f1db30e3bdb1aab5fa9","modified":1703348123569},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/index.pug","hash":"30db5b0fb5662ecea0012b21d4de28d3963e272f","modified":1703348123562},{"_id":"node_modules/hexo-theme-melody/source/css/var.styl","hash":"259feee66bf9c326e781bb63a177627dbe3eb539","modified":1703348123573},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/gitment.pug","hash":"0b7cd8b0b114876238ca022abda4c1fcdfaee12f","modified":1703348123562},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/vssue.pug","hash":"4ee6cea08286cbac2648a6032f73e5f8d2b88380","modified":1703348123569},{"_id":"node_modules/hexo-theme-melody/source/js/scroll.js","hash":"e9aaeeae8958b8a06e016edbd17c84b63aea9255","modified":1703348123302},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/waline.pug","hash":"1b2cfeb2b2c67b49f94107c230a64ed0a35eae8d","modified":1703348123569},{"_id":"node_modules/hexo-theme-melody/layout/includes/count/busuanzi.pug","hash":"4df5e63ab0113efb93f05ef781b2a7e3f34ba753","modified":1703348123559},{"_id":"node_modules/hexo-theme-melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1703348123564},{"_id":"node_modules/hexo-theme-melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1703348123558},{"_id":"node_modules/hexo-theme-melody/layout/includes/share/index.pug","hash":"a2ec6da33cf5fa0ba6c8c38ec3841a0b0003ce98","modified":1703348123563},{"_id":"node_modules/hexo-theme-melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1703348123568},{"_id":"node_modules/hexo-theme-melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1703348123558},{"_id":"node_modules/hexo-theme-melody/layout/includes/search/local-search.pug","hash":"f88070a84379bc06fb385e1193448fae6a8a54e1","modified":1703348123565},{"_id":"node_modules/hexo-theme-melody/layout/includes/mixins/article-sort.pug","hash":"297b098dc6bba73b76bac4cf6bcd0c29d5dcb2ed","modified":1703348123559},{"_id":"node_modules/hexo-theme-melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1703348123563},{"_id":"node_modules/hexo-theme-melody/layout/includes/share/share-js.pug","hash":"e612725ba48711fc119f91c6196287ad13f5a2ba","modified":1703348123567},{"_id":"node_modules/hexo-theme-melody/layout/includes/slide/layout.pug","hash":"e6963fb20340f60fe9bd2c9dbfff50decee159b3","modified":1703348123565},{"_id":"node_modules/hexo-theme-melody/layout/includes/third-party/canvas-ribbon.pug","hash":"39a03f188ac415642766b062a80b1b710f3ea609","modified":1703348123560},{"_id":"node_modules/hexo-theme-melody/layout/includes/third-party/katex.pug","hash":"79b2336ad8d921907a5b1badc10ba1651c92843b","modified":1703348123563},{"_id":"node_modules/hexo-theme-melody/layout/includes/slide/script.pug","hash":"e19439122c18a8bca10819b635cdfed6e9135e46","modified":1703348123567},{"_id":"node_modules/hexo-theme-melody/layout/includes/third-party/mathjax.pug","hash":"33b350f9826795cd59d9e277a24accc8a9bc9076","modified":1703348123565},{"_id":"node_modules/hexo-theme-melody/source/css/_global/index.styl","hash":"2a6195ce7e822362633ebf403c9438b42fa126bb","modified":1703348123571},{"_id":"node_modules/hexo-theme-melody/source/css/_highlight/highlight.styl","hash":"016c800bf7a0ef6d520e135ab69ef072760483cb","modified":1703348123570},{"_id":"node_modules/hexo-theme-melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1703348123570},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/footer.styl","hash":"ca8c816bdb144503bec7e755344fb0e4e370a7bf","modified":1703348123570},{"_id":"node_modules/hexo-theme-melody/source/css/_highlight/diff.styl","hash":"ffdfbf088da7bf33899557395abcac0d2bffd67d","modified":1703348123570},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/head.styl","hash":"73488de3f36369c29ecd5e0be9661bb2b508548c","modified":1703348123570},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/post.styl","hash":"34a421a32abb8003d7d83de53f42639be4e54daf","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/sidebar.styl","hash":"e8315401a6c791d00617c031be01f45df70fe7fd","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/page.styl","hash":"38f0efbc9985d2d4e3699d9ac06ab3dba150ce6e","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/css/_search/algolia.styl","hash":"534e5641e3efe2452db95cc25ec8da0111ceadcf","modified":1703348123570},{"_id":"node_modules/hexo-theme-melody/source/css/_search/index.styl","hash":"63cae4465ac54b71361c1795206534c7f2e6e5b1","modified":1703348123571},{"_id":"node_modules/hexo-theme-melody/source/css/_search/local-search.styl","hash":"d7970b385265fef782cdcaaf4fe68a2217625467","modified":1703348123572},{"_id":"node_modules/hexo-theme-melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1703348122777},{"_id":"node_modules/hexo-theme-melody/source/js/search/local-search.js","hash":"c58bbe874fcdc512cca5244db487745e6a49ef48","modified":1703348123302},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1703348123071},{"_id":"node_modules/hexo-theme-melody/source/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1703348122779},{"_id":"node_modules/hexo-theme-melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1703348122776},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/anime.min.js","hash":"332031949d78a49e8a18611556253660574e47db","modified":1703348123068},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1703348123552},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1703348123078},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1703348123357},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1703348123076},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1703348123301},{"_id":"public/about/index.html","hash":"0424a54dede84ea939c36f5fc32619ae5b86bd92","modified":1703356650782},{"_id":"public/gallery/index.html","hash":"8a7de1d60ca7db62bf51abdd1259a8dab183470a","modified":1703356650782},{"_id":"public/categories/index.html","hash":"801d18452eebdb6bcbeec09fce4a75cbe0372dec","modified":1703356650782},{"_id":"public/slides/index.html","hash":"bbf41fb4183b17d16062b84136d599d63d361890","modified":1703356650782},{"_id":"public/tags/index.html","hash":"4f55dbc558ad9d09f1b715333479feb48febe6ce","modified":1703356650782},{"_id":"public/2023/12/01/turbulent-november/index.html","hash":"3f42e9787653f12dacdab138b0ff4364d35c9629","modified":1703356650782},{"_id":"public/2023/11/08/play-october/index.html","hash":"eaaeac9d1acaea66cdbdf79b305c677b5a4eac9f","modified":1703356650782},{"_id":"public/2023/10/09/prepare-marry-september/index.html","hash":"a6ae254df265969c1d7713e5ff0a457150fb72e7","modified":1703356650782},{"_id":"public/2023/09/08/fruit-august/index.html","hash":"15c515ac971d59bb32bc50dcff23dfd784e7affe","modified":1703356650782},{"_id":"public/2023/08/08/hot-july/index.html","hash":"2fba1bb34bfd34ce1d8bc65824fca4b243e9ff43","modified":1703356650782},{"_id":"public/2023/06/28/rain-june/index.html","hash":"44b716d035e9f4d4d3579d85bef9a3e99420dff3","modified":1703356650782},{"_id":"public/2023/06/10/kong-custom-plugin/index.html","hash":"60cf34cffbfd8890aeefd4a903a1285e2addea02","modified":1703356650782},{"_id":"public/2023/05/28/busy-may/index.html","hash":"d6b21a6360c496568327ee010efd397d10428f33","modified":1703356650782},{"_id":"public/2023/05/02/broken-april/index.html","hash":"6df033a6de0a4d7d93d9654282dd251afdc6ced3","modified":1703356650782},{"_id":"public/2023/04/01/warm-march/index.html","hash":"8ad663ecbcac235791e6e70ef137b839097818dc","modified":1703356650782},{"_id":"public/2023/03/08/spring-february/index.html","hash":"711120d2174203370d727162514bb36844e6efe9","modified":1703356650782},{"_id":"public/2023/02/05/year-january/index.html","hash":"78fe71d894b723557b373bff4bce8daee3f3284c","modified":1703356650782},{"_id":"public/2023/01/10/hello-2023/index.html","hash":"11b785acd2c2c686ce59b34746b72732434e1e29","modified":1703356650782},{"_id":"public/2022/12/25/yang-december/index.html","hash":"58f676f5a3bcb3a977cb4a7c180e550f58b449ab","modified":1703356650782},{"_id":"public/2022/11/30/red-november/index.html","hash":"9521b48fba017f72dad168af0de3a970ef20b95c","modified":1703356650782},{"_id":"public/2022/10/30/green-october/index.html","hash":"2dcf90c9cba5e3f63ea6dcea3d68e084bd2afcf2","modified":1703356650782},{"_id":"public/2022/09/30/comfortable-september/index.html","hash":"65025690d8c7964bdda901b3e737a4adac7bbb3a","modified":1703356650782},{"_id":"public/2022/08/30/tutu-august/index.html","hash":"44a3f43db0132d241453e958b7c94ca8eb49dbf5","modified":1703356650782},{"_id":"public/2022/07/30/hot-july-2022/index.html","hash":"e5c0922c6d6bff78c4bc4c7b8e82667b1ec2f5e8","modified":1703356650782},{"_id":"public/2022/06/30/better-june/index.html","hash":"8600960708d54a9947b3fef1d0b921b0e719e65f","modified":1703356650782},{"_id":"public/2022/06/01/free-may/index.html","hash":"2da989321d81d9451da0a1f53baaf5f57c6af9a1","modified":1703356650782},{"_id":"public/2022/05/01/home-april/index.html","hash":"bb9621520c33785196799b8ef520b0d074e7cbcd","modified":1703356650782},{"_id":"public/2022/03/31/restless-march/index.html","hash":"35621d67a7c0f6051d22e985193f028c074ca66e","modified":1703356650782},{"_id":"public/2022/03/08/clickhouse-in-action-pv-uv/index.html","hash":"d68dd6920d73a9d35e2db939bf2e2ab1e4041edf","modified":1703356650782},{"_id":"public/2022/03/03/reunion-february/index.html","hash":"65b1a7dc72289e260e72cd11db33b912a6d6f040","modified":1703356650782},{"_id":"public/2022/01/25/expect-january/index.html","hash":"a943a6f80e5b31c746cb2565910d2e38e518da1f","modified":1703356650782},{"_id":"public/2022/01/01/danger-december/index.html","hash":"b863480db7c1a6cf994c70a96b1be838f75fe7aa","modified":1703356650782},{"_id":"public/2021/12/30/hello-2022/index.html","hash":"68c876c6368891937bb354940dbe8f45ab74b1a2","modified":1703356650782},{"_id":"public/2021/11/27/normal-november/index.html","hash":"8017fb8a01d84bcdc081b6fbab89503f5855510e","modified":1703356650782},{"_id":"public/2021/10/30/bleak-october/index.html","hash":"9a7f381bc00890eff48c5b68741c8e60027b0ee7","modified":1703356650782},{"_id":"public/2021/09/25/hot-september/index.html","hash":"de09fa8e35242738bb214ec79d6b6defe62c4474","modified":1703356650782},{"_id":"public/2021/08/26/exchange-august/index.html","hash":"19a563c812b9fe667ea2cb93443bc73a3bc038c4","modified":1703356650782},{"_id":"public/2021/07/30/turbulent-july/index.html","hash":"96548dee4c5d86a47767215566d74202e09b2031","modified":1703356650782},{"_id":"public/2021/07/01/life-june/index.html","hash":"7b3b81519efca641d2da1874c21aae69816e27a0","modified":1703356650782},{"_id":"public/2021/05/31/tour-may/index.html","hash":"73ef2f59a2ccfafd9e16fd1e91a2ad563383cae9","modified":1703356650782},{"_id":"public/2021/05/01/surprise-april/index.html","hash":"61b8236b0bbee5bf0128106a4d363348cc01033c","modified":1703356650782},{"_id":"public/2021/03/31/hurry-march/index.html","hash":"3f9b9f1caf0242f6e80ac0ae25e1c5ba5df66580","modified":1703356650782},{"_id":"public/2021/03/06/note-transactions/index.html","hash":"720bcd4746b80a7603eaf4162fb0bbcd9139c0b1","modified":1703356650782},{"_id":"public/2021/02/28/relax-february/index.html","hash":"8bbeafa98796d9be08140ef45c39e7c226f5613e","modified":1703356650782},{"_id":"public/2021/01/29/new-january/index.html","hash":"1fad807890d9b9d5882ccf25101780bcc143c170","modified":1703356650782},{"_id":"public/2020/12/29/hello-2021/index.html","hash":"61d51ed7e17753ee9f3b9e94439c21880d54c09c","modified":1703356650782},{"_id":"public/2020/11/29/shell-restart/index.html","hash":"df30490e5132a27d4a250ba911fbf7fe53093010","modified":1703356650782},{"_id":"public/2020/11/29/talk-november/index.html","hash":"386fe2c7c446d64b8508c82899244b6b9614aa24","modified":1703356650782},{"_id":"public/2020/10/29/bustle-october/index.html","hash":"ae6eb071e88f0a3077ac312a2e55e2ca8d4376e5","modified":1703356650782},{"_id":"public/2020/09/29/autumn-september/index.html","hash":"0ad08d0d240031a16364a00e72b72bbde5766233","modified":1703356650782},{"_id":"public/2020/08/29/spirit-august/index.html","hash":"9c786392061c225223fc430cc1eb701124c99229","modified":1703356650782},{"_id":"public/2020/08/22/wonderful-life/index.html","hash":"6af386efabfd3929ce2e6b265c53d35c9be446ce","modified":1703356650782},{"_id":"public/2020/08/04/restful-url-api/index.html","hash":"e9224123679b4d7bfc2a2ba1a5abee97a50eaa0b","modified":1703356650782},{"_id":"public/2020/07/30/not-enough-july/index.html","hash":"d37f649dd0603eac0530fd958e92ec833ad55447","modified":1703356650782},{"_id":"public/2020/06/30/rain-june-2020/index.html","hash":"4f7110e64b2c50e73b69e91fa81858e77b9d5b79","modified":1703356650782},{"_id":"public/2020/05/31/new-may/index.html","hash":"bfc9d8d00cf32a36ecf26df00e69b5a4848b4e1f","modified":1703356650782},{"_id":"public/2020/05/12/leetcode-detect-capital/index.html","hash":"a0b8541cdb2f4653021da666983334da89a38bd8","modified":1703356650782},{"_id":"public/2020/04/25/sway-april/index.html","hash":"8ef5ab5be3d159aca66fbcece6a67c1f96ded614","modified":1703356650782},{"_id":"public/2020/04/11/mysql-database-backup/index.html","hash":"3be52f9df18c8ddfd5e67532974c20db6d32dac5","modified":1703356650782},{"_id":"public/2020/03/24/spring-march/index.html","hash":"ad4470103604e2f1a81ab1972d8833083f6387f2","modified":1703356650782},{"_id":"public/2020/02/20/bless-february/index.html","hash":"ce116288b2b56d011db15627cc390f99d2f231f0","modified":1703356650782},{"_id":"public/2020/01/20/tired-january/index.html","hash":"e567b9773132ad6977be6ad41988d77b9a491dfe","modified":1703356650782},{"_id":"public/2019/12/27/hello-2020/index.html","hash":"fc208c292e7e17f4c72b2e5290372239b8991a9e","modified":1703356650782},{"_id":"public/2019/11/27/chophand-november/index.html","hash":"6285027d160281a91d89740a17f938f64bfde8a4","modified":1703356650782},{"_id":"public/2019/10/28/goldenautumn-october/index.html","hash":"1724883d64c8d5dbf88b7270dfa1d4f129a2a279","modified":1703356650782},{"_id":"public/2019/10/11/netty4-datatrans/index.html","hash":"d16ba3ff13e3756d7c8b6822323042d2dad81cfe","modified":1703356650782},{"_id":"public/2019/09/28/dizzy-september/index.html","hash":"17932d07912c22dc7007d5f3b54ccb1ca074fabe","modified":1703356650782},{"_id":"public/2019/09/13/Multithreading-Chapter-Twelve/index.html","hash":"66b0d776cef00df13c900d9d7ccf84a10ebe2c2c","modified":1703356650782},{"_id":"public/2019/09/08/Multithreading-Chapter-Eleven/index.html","hash":"8fc20f0942a0edf355981ae76ad61673b353f0a2","modified":1703356650782},{"_id":"public/2019/09/01/Multithreading-Chapter-Nine/index.html","hash":"2c80d392fdd8777172e7caf5fdd11c5457078d99","modified":1703356650782},{"_id":"public/2019/09/01/Multithreading-Chapter-Eight/index.html","hash":"696db7753e69ea6e5ebccc35a0448ed75a887ce6","modified":1703356650782},{"_id":"public/2019/08/28/foolish-august/index.html","hash":"55134e22d6c0244d09f26a4cb41de972013a52f3","modified":1703356650782},{"_id":"public/2019/08/25/Multithreading-Chapter-Seven/index.html","hash":"cff0c4eb38a13ebff45025256c48fcef5bb5f647","modified":1703356650782},{"_id":"public/2019/08/24/springboot2-datajpa-rest/index.html","hash":"c2bb73ccd97454d53936bfb3f166f1c1bf3c1f69","modified":1703356650782},{"_id":"public/2019/08/18/Multithreading-Chapter-Six/index.html","hash":"6b0d538833733d6116a789f1819c23b4406bed41","modified":1703356650782},{"_id":"public/2019/07/28/Multithreading-Chapter-Five/index.html","hash":"15b1acde70bc24b7e345b39d56abeb61038a440c","modified":1703356650782},{"_id":"public/2019/07/24/sultry-july/index.html","hash":"e0fbf9f11382fd56d3f506612dbc9f2ab66487fe","modified":1703356650782},{"_id":"public/2019/07/21/Multithreading-Chapter-Four/index.html","hash":"85d4d38666154d479002302bb596773accf6ad94","modified":1703356650782},{"_id":"public/2019/07/13/Multithreading-Chapter-Three/index.html","hash":"2d78e66739d76c8fe206579210e7d4bcd5be62f3","modified":1703356650782},{"_id":"public/2019/07/08/Multithreading-Chapter-Two/index.html","hash":"07386d1fada7e88c4b9462acfb3dd825b0e69cbb","modified":1703356650782},{"_id":"public/2019/06/24/anxiety-june/index.html","hash":"334e055a671da403f856f5c1094e21c399385e45","modified":1703356650782},{"_id":"public/2019/06/15/Multithreading-Chapter-One/index.html","hash":"a2219cc3f0835020a3c7de37cae7b23980c79010","modified":1703356650782},{"_id":"public/2019/06/04/springboot2-mail/index.html","hash":"559bee7d069487ba41bc3a918b86583b2ac84bed","modified":1703356650782},{"_id":"public/2019/05/23/happy-may/index.html","hash":"03ec5d70961e1d54e1b6f64e2285a4bf740083f4","modified":1703356650782},{"_id":"public/2019/04/28/exciting-april/index.html","hash":"4202394372d997e30c0dbad04e3fc8e7d0acc343","modified":1703356650782},{"_id":"public/2019/02/27/indulgence-february/index.html","hash":"bbc22473fc7aa3fb51efd0c381765b3b35719c0e","modified":1703356650782},{"_id":"public/2019/02/21/JVM-Parameter/index.html","hash":"51e95bd8864f070a41737f14f07b148f94ef5209","modified":1703356650782},{"_id":"public/2019/04/03/busy-march/index.html","hash":"d6d896a5e37a93c4ee3e02018999fcc4d415be8c","modified":1703356650782},{"_id":"public/2019/04/19/leetcode-pairsofsongswithtotaldurationsdivisibleby60/index.html","hash":"d95995c9692eb88dcd121574ea364a1a274b7431","modified":1703356650782},{"_id":"public/2019/02/19/leetcode-reverse-linkedlist/index.html","hash":"7dd0d50f75c25960afbe6d81712401b1d7492ec4","modified":1703356650782},{"_id":"public/2019/02/13/mysql-sql/index.html","hash":"dec7cc2b95b821200b76d32fc8994b1355b14d35","modified":1703356650782},{"_id":"public/2019/02/13/mysql-index/index.html","hash":"c1f7e1c26a8a35cff93824d152ed51774fb69e7c","modified":1703356650782},{"_id":"public/2019/02/13/mysql-sql-optimization/index.html","hash":"68962721601981c2770f1b232c08f8fb9ef1a6a5","modified":1703356650782},{"_id":"public/2019/02/12/mysql-distributed-transaction/index.html","hash":"b77c27aafcdd4d4a568c6f841c0292a9e9c9d39c","modified":1703356650782},{"_id":"public/2019/02/11/mysql-engine/index.html","hash":"df5d68b5ea0c0d321d9569de2c29fc6a51fbf248","modified":1703356650782},{"_id":"public/2019/01/28/beat-january/index.html","hash":"7cf701fd35b9d1507f0cd784a6e8429310d021e1","modified":1703356650782},{"_id":"public/2018/12/29/leetcode-permutations/index.html","hash":"b6a519fb9f38f909a39a8672b43de8e6395c73ac","modified":1703356650782},{"_id":"public/2018/12/13/opposite-build/index.html","hash":"809de7784404fb88094559beafa0d89fb21c240a","modified":1703356650782},{"_id":"public/2018/12/27/springboot2-sharding-jdbc/index.html","hash":"45c2ae0aa523c3515d2fbe0d0a1ca69c76660f67","modified":1703356650782},{"_id":"public/2018/12/03/leetcode-triangle/index.html","hash":"347cec9baf86c15c4643ff64fb155a9ddbbd5ebf","modified":1703356650782},{"_id":"public/2018/12/18/hello-2019/index.html","hash":"7dad5a3ea4f39134d91efe93f2418891ef629921","modified":1703356650782},{"_id":"public/2018/11/27/busy-november-2018/index.html","hash":"80557acfddad97424822350863e8ff2ca880b219","modified":1703356650782},{"_id":"public/2018/12/01/JVM-Code-Execution-Engine/index.html","hash":"3b74f85a40ca9629bdc80b4fc42180f7ee828870","modified":1703356650782},{"_id":"public/2018/11/27/leetcode-binary-tree-traversal/index.html","hash":"021fb9da7d1340433dc63b8e2e1f59e831f1bbd6","modified":1703356650782},{"_id":"public/2018/11/25/JVM-Class-Load/index.html","hash":"30423d8463c6209823e55fac2c8db025cf3ea80b","modified":1703356650782},{"_id":"public/2018/11/24/JVM-Class-File/index.html","hash":"a19b3db67fe83a8f78ca71311628e7c77549eea6","modified":1703356650782},{"_id":"public/2018/11/19/JVM-GC/index.html","hash":"b7d9a2ca3c230d64d97af5cb66360de03b9773ed","modified":1703356650782},{"_id":"public/2018/11/19/leetcode-n-sum/index.html","hash":"81ff31fbb42ab9a7343609c16734ab144546113a","modified":1703356650782},{"_id":"public/2018/11/19/leetcode-palindrome-number/index.html","hash":"e3bac8830d1ab4733d2c74070289c05b35f1ff2f","modified":1703356650782},{"_id":"public/2018/11/19/JVM-MemoryArea/index.html","hash":"ac3c3e49a78b3886ab906a525d8d1dee7624bf75","modified":1703356650782},{"_id":"public/2018/11/14/leetcode-longest-common-prefix/index.html","hash":"5bcbf6f9ee1c828f61d7f06360bda0967d5ea723","modified":1703356650782},{"_id":"public/2018/11/14/leetcode-combination-sum/index.html","hash":"106c28707542c19aa027ad3d5ee1943cb9cfd015","modified":1703356650782},{"_id":"public/2018/11/03/ssh-nat-ubuntu/index.html","hash":"96f99debf2cf780b0f360df24d05f1cb01a11ce2","modified":1703356650782},{"_id":"public/2018/10/29/science-fiction-october-2018/index.html","hash":"d1a8e959b7c8d2e5f3d55c05c04c567dfbb37ac1","modified":1703356650782},{"_id":"public/2018/10/23/node-list-close-loop/index.html","hash":"aebb7b7b9397b471412c38d195f29d1029633667","modified":1703356650782},{"_id":"public/2018/10/15/binary-search/index.html","hash":"8e2d17414f16cfdc593e8fa49eb46f5d01cef2cb","modified":1703356650782},{"_id":"public/2018/09/30/cool-september-2018/index.html","hash":"54729515a476cf5dcfad8451723e457e3c967354","modified":1703356650782},{"_id":"public/2018/09/26/Integer-practical-notcommon-methods/index.html","hash":"7cdf1cb8023fc6ad43fd48464d0bc55a8d4654cd","modified":1703356650782},{"_id":"public/2018/09/26/DP-01backpack/index.html","hash":"1210c729d3e2f15c3ea58fc8a125c37623b9710e","modified":1703356650782},{"_id":"public/2018/09/13/laught-often/index.html","hash":"ccbe79a746943dddb7d2be5646d86d18f5543f50","modified":1703356650782},{"_id":"public/2018/09/11/springboot2-websocket/index.html","hash":"1d33fe4a22939a70ff7b7e84c2c6f3b7631129d7","modified":1703356650782},{"_id":"public/2018/09/07/annotation-java-runtime/index.html","hash":"6a7794ca5d0e253bc8007457efbe38bcb89037df","modified":1703356650782},{"_id":"public/2018/09/03/scholarly-august-2018/index.html","hash":"013183fdc4299b024b6f87d1e38021a517e62a3d","modified":1703356650782},{"_id":"public/2018/08/24/arrcopy-beancopy/index.html","hash":"700d8ebdeccfcec98581c29ab703d3a7af05fa6b","modified":1703356650782},{"_id":"public/2018/08/10/sort-algorithm/index.html","hash":"2f4f32a8be8cf738d835e9750a398eb812a8907b","modified":1703356650782},{"_id":"public/2018/08/03/summary-180803/index.html","hash":"a1e1742968d60134875f1dbe324cba9645f44b4e","modified":1703356650782},{"_id":"public/2018/08/17/collections-addF-jdk1.8/index.html","hash":"bf1ccd97c0f6b99171efbd50af3988a725d1a716","modified":1703356650782},{"_id":"public/2018/07/13/stream-jdk1.8/index.html","hash":"196d6265d14da458dbac167a1b01ce1d204be66d","modified":1703356650782},{"_id":"public/2018/07/11/self-regulation/index.html","hash":"2a5ff4bae3c404254b76bb45456f2915713920bd","modified":1703356650782},{"_id":"public/2018/07/06/black-june-2018/index.html","hash":"fa8d7042ddf0cce85f14c3e850a8598f4365cc12","modified":1703356650782},{"_id":"public/2018/07/04/summary-180704/index.html","hash":"41961b7b71829f418def0984eb6212973356feb4","modified":1703356650782},{"_id":"public/2018/06/25/trial-period-summary/index.html","hash":"a63ea3cc592c5bddff96251950e9c6db47ea901a","modified":1703356650782},{"_id":"public/2018/07/10/indexedDB/index.html","hash":"4b6fa24d3d740287bb8f409b9470a4ba51c7596a","modified":1703356650782},{"_id":"public/2018/06/25/My97DatePicker/index.html","hash":"109b3da7d2bfd14321b3aaa8e9b02a9bd999638e","modified":1703356650782},{"_id":"public/2018/06/21/spring-data-jpa/index.html","hash":"3ab50c1569a023589ad1230252d0a33f9177ff28","modified":1703356650782},{"_id":"public/2018/06/06/common-instructions/index.html","hash":"9175b4aef292bacf21f11a63fb014a160c504adc","modified":1703356650782},{"_id":"public/2018/05/31/summary-180531/index.html","hash":"28d72d47e154abb5f11db38081386509dab73e29","modified":1703356650782},{"_id":"public/2018/05/24/face-java/index.html","hash":"871ba7c0fb7bf0416f97f65de0229b25b17b3b26","modified":1703356650782},{"_id":"public/2018/05/23/that-day/index.html","hash":"bb814f3154a4f41cb3c4da0e866c2f740b9ce2ec","modified":1703356650782},{"_id":"public/2018/05/22/my-blog-ok/index.html","hash":"a92e87432bfcd5c28b982ef2d98badf57298108b","modified":1703356650782},{"_id":"public/2018/05/21/hello-world/index.html","hash":"0911118f918925a34ba555cc425cd6c352473357","modified":1703356650782},{"_id":"public/archives/index.html","hash":"b1c2e2310f96ff82f1a4590e682d1c0619514a04","modified":1703356650782},{"_id":"public/archives/page/2/index.html","hash":"401d763077a9688b89f4c6634e496e63e862112c","modified":1703356650782},{"_id":"public/archives/page/3/index.html","hash":"a5853e2776afc7fed10082f25f99702f16a96734","modified":1703356650782},{"_id":"public/archives/page/4/index.html","hash":"0f32834a6196a7cbf038dbaf780d0ecf3f6a11a5","modified":1703356650782},{"_id":"public/archives/page/6/index.html","hash":"61b7ae4d1747e5f61c0eb2fb2ad39c488904e9d8","modified":1703356650782},{"_id":"public/archives/page/7/index.html","hash":"208dca72a6814a4c7b42d04c400189fc8507cccf","modified":1703356650782},{"_id":"public/archives/page/5/index.html","hash":"5e4f990fbe284ff0d7c1c677fe5445b695cf5225","modified":1703356650782},{"_id":"public/archives/page/8/index.html","hash":"e61958323322772fa060a2fa4d124ddf4be8015a","modified":1703356650782},{"_id":"public/archives/page/9/index.html","hash":"d817d0395dfe70273e0303fec9e0e2d930987b8c","modified":1703356650782},{"_id":"public/archives/page/10/index.html","hash":"5797c2e8a4da9090abcfe2b14f4f6fbf2f248898","modified":1703356650782},{"_id":"public/archives/page/11/index.html","hash":"64ba2a7a7cbe78ff81e56b711c8765dc118917f9","modified":1703356650782},{"_id":"public/archives/page/12/index.html","hash":"b684b21a96542a06fa34f51963986a6831d2db97","modified":1703356650782},{"_id":"public/archives/page/13/index.html","hash":"2b1f50a8e74f24b7f433ac236e9a5c0c681082a1","modified":1703356650782},{"_id":"public/archives/page/14/index.html","hash":"5f47c9ba027ff3402f7cfa8586a3500acda66848","modified":1703356650782},{"_id":"public/archives/2018/index.html","hash":"146148c6e250ba14f4bc3c404ddabc3805e1fa16","modified":1703356650782},{"_id":"public/archives/2018/page/2/index.html","hash":"b064e901369cf4fdd87636d0490e193b967ce05c","modified":1703356650782},{"_id":"public/archives/2018/page/3/index.html","hash":"969db77d68c27ca87d95f3b2aadc1e20ee1f61c5","modified":1703356650782},{"_id":"public/archives/2018/page/4/index.html","hash":"5c08ef1d88fbc636a6d8b3f38abd4e8e4c305151","modified":1703356650782},{"_id":"public/archives/2018/page/5/index.html","hash":"996e569c769271b5b47b15f0eb8f402b89acdfb8","modified":1703356650782},{"_id":"public/archives/2018/06/index.html","hash":"8b831d7bef09aeb712db509551006000703da27c","modified":1703356650782},{"_id":"public/archives/2018/07/index.html","hash":"0ecb53b2edbb8fa5b1e5361f760cec255a0167ec","modified":1703356650782},{"_id":"public/archives/2018/08/index.html","hash":"74b735fccf5d00c2f0b3e072849ede75b1723f3b","modified":1703356650782},{"_id":"public/archives/2018/09/index.html","hash":"f7b9c9c8c9984177b389c526aad582c065fd136d","modified":1703356650782},{"_id":"public/archives/2018/10/index.html","hash":"fe5876bce69d046d3e2a5b6e9d5c9adcfad253d2","modified":1703356650782},{"_id":"public/archives/2018/05/index.html","hash":"f3f6de035bcd4ebceb0733ee86f4c7d236df96c3","modified":1703356650782},{"_id":"public/archives/2018/11/index.html","hash":"8570aa288bb38e272fa714c12e14eee6d31b0503","modified":1703356650782},{"_id":"public/archives/2018/11/page/2/index.html","hash":"d8c3dd32db2a3d70b8ac6b862920593599bfb838","modified":1703356650782},{"_id":"public/archives/2018/12/index.html","hash":"e4bc1c49d58a35d63f9b1355ae76bc6307cbd457","modified":1703356650782},{"_id":"public/archives/2019/index.html","hash":"a1009c0d21d3ddd5ed6fae657d1299d45c4ad992","modified":1703356650782},{"_id":"public/archives/2019/page/3/index.html","hash":"803fc76899128ab8d542e6246cec26aec3da95ca","modified":1703356650782},{"_id":"public/archives/2019/page/4/index.html","hash":"ea2c8ae0ceafdc12080cecb47c2865251dffcead","modified":1703356650782},{"_id":"public/archives/2019/01/index.html","hash":"502518ebcb9905e0af5c47fb306034d973da265d","modified":1703356650782},{"_id":"public/archives/2019/02/index.html","hash":"23308a2bac398317dedd4f5a94afcd89e6578a6b","modified":1703356650782},{"_id":"public/archives/2019/05/index.html","hash":"4f5b2b01062a3e005e2ee3600a1967e1048ed5ef","modified":1703356650782},{"_id":"public/archives/2019/page/2/index.html","hash":"47d2492c1a7e729ebaea2e60b75737d5743effca","modified":1703356650782},{"_id":"public/archives/2019/04/index.html","hash":"02fcbbedc255182fb45992b5430dd2550ac4269b","modified":1703356650782},{"_id":"public/archives/2019/06/index.html","hash":"659cea0a8fbc83673a6a9c6428fdbc8a00fd4de2","modified":1703356650782},{"_id":"public/archives/2019/07/index.html","hash":"a949fc816819e563a3877c57950b31b237a4d392","modified":1703356650782},{"_id":"public/archives/2019/08/index.html","hash":"37e36fb424c883430bda6c040abe7bc867d89f1d","modified":1703356650782},{"_id":"public/archives/2019/09/index.html","hash":"d2b6664c03698b9f340c0533e4ea7d3afa9de905","modified":1703356650782},{"_id":"public/archives/2019/10/index.html","hash":"ec1daf39021e445b0e32e32176966240260dd48f","modified":1703356650782},{"_id":"public/archives/2019/11/index.html","hash":"27956d855083e1a4c2bd38a92866282f8bb5b2a2","modified":1703356650782},{"_id":"public/archives/2019/12/index.html","hash":"babc6361f45b6785ef730e4b9fcbb39699472754","modified":1703356650782},{"_id":"public/archives/2020/index.html","hash":"444863e1fa25e462593c5da6e613984276edaeea","modified":1703356650782},{"_id":"public/archives/2020/page/2/index.html","hash":"1800c50bf266b9a0e6168ae1e3a1c581fb42c26b","modified":1703356650782},{"_id":"public/archives/2020/01/index.html","hash":"52ae83adc2e4513626c697497cb11e9b07b38a8e","modified":1703356650782},{"_id":"public/archives/2020/02/index.html","hash":"ec37a86aaf5e8f31d911f495ff136ad29b49bdad","modified":1703356650782},{"_id":"public/archives/2020/03/index.html","hash":"f9d39c8a9258daa9a435c84299aebceb1ebddb92","modified":1703356650782},{"_id":"public/archives/2020/04/index.html","hash":"daf1b3ad473c24a70ca5a01cfed6a0871ea91122","modified":1703356650782},{"_id":"public/archives/2020/05/index.html","hash":"0443e123ffe1c5e8349eaa79d938f7af122b636b","modified":1703356650782},{"_id":"public/archives/2020/06/index.html","hash":"a3835da8c3a69145aca86ea9a9d49588addfd9b9","modified":1703356650782},{"_id":"public/archives/2020/07/index.html","hash":"e57d816fed8679e7767261e3821709c29a0cd413","modified":1703356650782},{"_id":"public/archives/2020/08/index.html","hash":"ba7175c5188bfd49754e2afc114e7517e46f4a06","modified":1703356650782},{"_id":"public/archives/2020/09/index.html","hash":"4f9344a96bb66345ffbef2c97a4b432d06326af5","modified":1703356650782},{"_id":"public/archives/2020/10/index.html","hash":"89c0a39103478661cd4c65f09eede77c1842e29c","modified":1703356650782},{"_id":"public/archives/2020/11/index.html","hash":"8439f2fa46746f0d69991baf7d9d795b4e39b480","modified":1703356650782},{"_id":"public/archives/2020/12/index.html","hash":"63682fecb16f312aac52dbcaaa98f43c7b0dd5b6","modified":1703356650782},{"_id":"public/archives/2021/index.html","hash":"fca224989c84cff06d876d7c8b1c1d6be84af7b5","modified":1703356650782},{"_id":"public/archives/2021/page/2/index.html","hash":"2d4a27ed272f9e1337c327d8d844f07671c0d2ef","modified":1703356650782},{"_id":"public/archives/2021/01/index.html","hash":"17027259d82b92c9760d9774113b965cbae88e81","modified":1703356650782},{"_id":"public/archives/2021/02/index.html","hash":"a382ffafe1d46533c4c1dfab264ea8855c4b2430","modified":1703356650782},{"_id":"public/archives/2021/03/index.html","hash":"9723cf2472ac195fbfb4631d0b91cd1797f727c5","modified":1703356650782},{"_id":"public/archives/2021/05/index.html","hash":"e1b356347589582eb65bb3b64870ee023fcf3d31","modified":1703356650782},{"_id":"public/archives/2021/07/index.html","hash":"9cc5c9b295861019061814b04f8610e7e4566bdc","modified":1703356650782},{"_id":"public/archives/2021/08/index.html","hash":"4c6be31f0f0d6a63fc255d62d49df128c57b8954","modified":1703356650782},{"_id":"public/archives/2021/09/index.html","hash":"a3b6d45c07ac5b3fa01edd0682c90a1a3fbf32cc","modified":1703356650782},{"_id":"public/archives/2021/10/index.html","hash":"c7c30cd4e3742b17abd596ce231b1bec0c958eb3","modified":1703356650782},{"_id":"public/archives/2021/12/index.html","hash":"c3f30037e053678fc1f909b2126358310e64686f","modified":1703356650782},{"_id":"public/archives/2021/11/index.html","hash":"512373f2c690e69278916ecb0dd96c57bf245b80","modified":1703356650782},{"_id":"public/archives/2022/index.html","hash":"76fdbc9bccd2fbe4de3eec454b65a4312350808a","modified":1703356650782},{"_id":"public/archives/2022/page/2/index.html","hash":"572f6ce53e5431e0317ea6fccc3b482730aefecf","modified":1703356650782},{"_id":"public/archives/2022/01/index.html","hash":"5d9192e87e18af413fe2de9a7765b4852fdec294","modified":1703356650782},{"_id":"public/archives/2022/03/index.html","hash":"505a489eecb0ebece4d8db1774ba155ebb776785","modified":1703356650782},{"_id":"public/archives/2022/05/index.html","hash":"8a89713da36ef903aa658bc75c62ef13a2dd0c83","modified":1703356650782},{"_id":"public/archives/2022/06/index.html","hash":"4776e156d7cc85c554769dcdd65a2c10d1b96bf7","modified":1703356650782},{"_id":"public/archives/2022/07/index.html","hash":"e08cc2a50444f2f5191c4440e6808a7f5854e496","modified":1703356650782},{"_id":"public/archives/2022/08/index.html","hash":"b11ac1687c06705d1e240f5e238fdf22a726e2c8","modified":1703356650782},{"_id":"public/archives/2022/09/index.html","hash":"516321b24f6f8bf9503cfe37434bf884e4ee7e36","modified":1703356650782},{"_id":"public/archives/2022/10/index.html","hash":"34caf70eeb7f0cd12d0c2b7a5d1f63b2be879867","modified":1703356650782},{"_id":"public/archives/2022/11/index.html","hash":"f89482c185a01bada6bc22c64d3ee1f94f05863d","modified":1703356650782},{"_id":"public/archives/2022/12/index.html","hash":"3f7a51982d42ce62948b21b46b2f7667ba869f71","modified":1703356650782},{"_id":"public/archives/2023/index.html","hash":"85dda62ea097f5581d39ef46ad5f6991680819dd","modified":1703356650782},{"_id":"public/archives/2023/page/2/index.html","hash":"d4e8a7087131ba79bbe152137d72394f5377dce2","modified":1703356650782},{"_id":"public/archives/2023/01/index.html","hash":"57cb7e2ef197fe864b7914a7867faccf3e82f646","modified":1703356650782},{"_id":"public/archives/2023/02/index.html","hash":"6725989476111f37a511bf999f628160030118f1","modified":1703356650782},{"_id":"public/archives/2023/04/index.html","hash":"a95c6a69f69df039cd41928e551641ea7405b0d4","modified":1703356650782},{"_id":"public/archives/2023/03/index.html","hash":"1e663bf5ddddd006f17a1c50252c2baf2f664655","modified":1703356650782},{"_id":"public/archives/2023/05/index.html","hash":"73f775ab2b9e2635b5d630d254fdbc4c21017a32","modified":1703356650782},{"_id":"public/archives/2023/06/index.html","hash":"4ecbe176670734fdc244501a46f47dfa13b05834","modified":1703356650782},{"_id":"public/archives/2023/08/index.html","hash":"d251e4e13135369972000060c6e3277719fbd446","modified":1703356650782},{"_id":"public/archives/2023/09/index.html","hash":"11f3f736aa85434bd1d2a1f2eac32c1f1e424579","modified":1703356650782},{"_id":"public/archives/2023/10/index.html","hash":"380245a00caa5e01c56b09963b63f1dcb36955b6","modified":1703356650782},{"_id":"public/archives/2023/11/index.html","hash":"ec0e3d65f1580600b0e65f3a2c5b6a61236ab94b","modified":1703356650782},{"_id":"public/archives/2023/12/index.html","hash":"62d3d1ae6295c652377f6371e5c82bd884650ae9","modified":1703356650782},{"_id":"public/categories/开发/index.html","hash":"1e2b7147fc025f84ba025a54e5df90cfb621716d","modified":1703356650782},{"_id":"public/categories/开发/page/2/index.html","hash":"f2ac761d261b9b9dff913eb2a998d8404ef5e232","modified":1703356650782},{"_id":"public/categories/开发/page/3/index.html","hash":"8e8abd001c2709b3e3dd3474c349b8d778f0fd26","modified":1703356650782},{"_id":"public/categories/开发/page/4/index.html","hash":"504b6627cb5a711e15fad22bb56c47a80627e0d1","modified":1703356650782},{"_id":"public/categories/开发/page/5/index.html","hash":"b09b765247d75498641d9452fc0351ae5fca7bce","modified":1703356650782},{"_id":"public/categories/开发/page/6/index.html","hash":"00a4ed9177e78b547e83e659926009c52f6f1cfa","modified":1703356650782},{"_id":"public/categories/开发/page/7/index.html","hash":"22f5139175384cf0a9f67fe21d3904f365d9459d","modified":1703356650782},{"_id":"public/categories/开发/JVM/index.html","hash":"6a3bab2d97872ad01b2d01ee74a6b2254bc5b950","modified":1703356650782},{"_id":"public/categories/开发/算法/index.html","hash":"9ce05dc1f78d2bfad4a8ec495bc7bd7d4cc26883","modified":1703356650782},{"_id":"public/categories/开发/算法/page/2/index.html","hash":"4be67e511df2c3d4d9f0263b6942fabba13d31cb","modified":1703356650782},{"_id":"public/categories/开发/总结/index.html","hash":"659cb05cfc24f15708fb877bb237f95547ec0675","modified":1703356650782},{"_id":"public/categories/开发/总结/page/2/index.html","hash":"7f0d0d8d2d1c15807e8ce8920d3a94ae7372aaa6","modified":1703356650782},{"_id":"public/categories/开发/多线程/index.html","hash":"c74cba8bcb874de955ff9301a6490e1c82b02600","modified":1703356650782},{"_id":"public/categories/开发/多线程/page/2/index.html","hash":"1b62bb6f281a84d3bfb1175a68c2abf637ab14ff","modified":1703356650782},{"_id":"public/categories/开发/Web/index.html","hash":"697cbd43c16002e2316adf0bf2e131180126b5f2","modified":1703356650782},{"_id":"public/categories/生活/index.html","hash":"53232852a2169693c052a8ca671fa034a5522d51","modified":1703356650782},{"_id":"public/categories/生活/page/2/index.html","hash":"6b1971026574da490124d625babca8c3eee8bbf0","modified":1703356650782},{"_id":"public/categories/生活/page/3/index.html","hash":"51f8c10289412c61b79da95f0fee99883ec34013","modified":1703356650782},{"_id":"public/categories/生活/page/4/index.html","hash":"e7b72c42c73363066068933fe6e66e90de50da1d","modified":1703356650782},{"_id":"public/categories/生活/page/5/index.html","hash":"95cd1691223c57aea76c52cb29e20255b8212fba","modified":1703356650782},{"_id":"public/categories/生活/page/6/index.html","hash":"06d48248803f0e3492dfaeb979013cecca730bf0","modified":1703356650782},{"_id":"public/categories/生活/page/7/index.html","hash":"7b6e8cfaa18005719d1a2725ef0d7858387e1c1c","modified":1703356650782},{"_id":"public/categories/生活/page/8/index.html","hash":"2b60ed4962c6a3f2691eddb88f3dc7ca2bb1efb5","modified":1703356650782},{"_id":"public/categories/开发/数据库/index.html","hash":"d9c8c8c826487871c6085edc3868a9de2616b920","modified":1703356650782},{"_id":"public/categories/生活/杂侃/index.html","hash":"7ea8a807bec027b606ed1a3cba2de1360ee0b668","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/2/index.html","hash":"f4e2c473fdb3e6e944e8d647c7149dc61a17d2bc","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/3/index.html","hash":"d53d33b418927df88b63d42e57d9a9b50ae0c9c8","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/4/index.html","hash":"7218a41c235c2820f653995817d2ce501af7cd57","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/5/index.html","hash":"e424d6044f730f7543d035fbc33166dfa4b6b40b","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/6/index.html","hash":"561d051ff3a1e3536e1056fbabf26a3835ab6dff","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/7/index.html","hash":"f63c6e881c2339e25a676f238c0eee8fc8ab1ed8","modified":1703356650782},{"_id":"public/categories/生活/杂侃/page/8/index.html","hash":"558eaa88bbc65846a480a0eb16e3eb1c8abaac97","modified":1703356650782},{"_id":"public/categories/文学/index.html","hash":"60f60731a766c82bd0c53b898c17c9bd85214819","modified":1703356650782},{"_id":"public/categories/开发/运维/index.html","hash":"30d568442584266185f1d5641479afb2d38c55ef","modified":1703356650782},{"_id":"public/categories/文学/散文鉴赏/index.html","hash":"22b5b4039b7dfd2a82b6e9885cbf2b0df009e707","modified":1703356650782},{"_id":"public/categories/文学/诗词鉴赏/index.html","hash":"f7abee483527c694a8a08e439abfd9afef5e51a7","modified":1703356650782},{"_id":"public/index.html","hash":"05a61624e0f062f7cd51b79212c08806acfc64a2","modified":1703356650782},{"_id":"public/page/2/index.html","hash":"7e9bffe7743c3a8a23adee225fa81685bb0650a6","modified":1703356650782},{"_id":"public/page/3/index.html","hash":"d8a095172b9593bcfa5492e8e55c13dceff61fa5","modified":1703356650782},{"_id":"public/page/4/index.html","hash":"4f91811378b34733e9e60e2dcd0f9d0b95350d53","modified":1703356650782},{"_id":"public/page/5/index.html","hash":"56e59df384a7e2002edf494fff121aa29a4d547f","modified":1703356650782},{"_id":"public/page/6/index.html","hash":"277950f027968bae17be96432bc28f910ab6ac82","modified":1703356650782},{"_id":"public/page/8/index.html","hash":"e22a86b580c05c47d0353199bb4a319ac9ff12bb","modified":1703356650782},{"_id":"public/page/9/index.html","hash":"ebc01fbd6a02dafae5218456c11601e622d3b030","modified":1703356650782},{"_id":"public/page/10/index.html","hash":"e5db7074f1dd7be3278039dcb90ecbc2494f8177","modified":1703356650782},{"_id":"public/page/11/index.html","hash":"000dc80afb03dbb8248191f9f6debe4ce5d1a130","modified":1703356650782},{"_id":"public/page/7/index.html","hash":"0c7afce4b55cd8f8bc7eb74e4eebc918898a57e6","modified":1703356650782},{"_id":"public/page/12/index.html","hash":"fc4cbc4af4f0b76756a01e9d95ef9536ef7a6865","modified":1703356650782},{"_id":"public/page/13/index.html","hash":"d08e5b1de218c05b6bc237d98374d6f4a704b4bc","modified":1703356650782},{"_id":"public/page/14/index.html","hash":"2edc6ba4f963c0b24aacbaabfa3fc231f5491f67","modified":1703356650782},{"_id":"public/tags/算法/index.html","hash":"e20d525098ac20bcea4f5f20715eec6b6dd64f71","modified":1703356650782},{"_id":"public/tags/算法/page/2/index.html","hash":"da8324efcc324de1190c4d50111260ddfad2b78f","modified":1703356650782},{"_id":"public/tags/Java/index.html","hash":"83bf235f61b0afb5576450232a91eb845870330d","modified":1703356650782},{"_id":"public/tags/Java/page/2/index.html","hash":"0426393733f4f75515a3eb5d58f259e9822c4acc","modified":1703356650782},{"_id":"public/tags/Java/page/3/index.html","hash":"11ace28048655ad6ab057e7f2a9df2c921cebaa8","modified":1703356650782},{"_id":"public/tags/Java/page/4/index.html","hash":"ea10ea82171d5bd50334957689b025038cc3127e","modified":1703356650782},{"_id":"public/tags/Java/page/5/index.html","hash":"3a6361df58181646bec9f55cf17c280c1d25b194","modified":1703356650782},{"_id":"public/tags/动态规划/index.html","hash":"830375ae31173354be84e57fb4c017a4082210af","modified":1703356650782},{"_id":"public/tags/JVM/index.html","hash":"c39d7eebc6ef52a414e3789fdde3ad5c4fe69fb3","modified":1703356650782},{"_id":"public/tags/多线程/index.html","hash":"68f2a7e7331175d0f2de8571a9ccea9efaf1474a","modified":1703356650782},{"_id":"public/tags/多线程/page/2/index.html","hash":"b9cc3a553e45e5be881dfb054b56d0edbeac714c","modified":1703356650782},{"_id":"public/tags/反射/index.html","hash":"a40a17240a515f5592adfbe7a053422ef9b1364d","modified":1703356650782},{"_id":"public/tags/注解/index.html","hash":"d48f1b589a0981b5c181e32e02e8cc86f6cd302f","modified":1703356650782},{"_id":"public/tags/二分搜索/index.html","hash":"ac46b9af73d158d3532c66f56972b3ee58501de8","modified":1703356650782},{"_id":"public/tags/ClickHouse/index.html","hash":"3bc5cd36ae74e3c7d90b183620a7b7dbf3f0415c","modified":1703356650782},{"_id":"public/tags/Lambda/index.html","hash":"73044836a44f98865bd9917c69b7a24dd5b10207","modified":1703356650782},{"_id":"public/tags/Windows/index.html","hash":"3e29fd1342c5ef8c7c2c512a60732a90542f25e1","modified":1703356650782},{"_id":"public/tags/CMD/index.html","hash":"0a4f9001f8239cb57a724c0070f1b635a80462a0","modified":1703356650782},{"_id":"public/tags/js/index.html","hash":"d43da6506900e101ce6770c7b869125474c87cba","modified":1703356650782},{"_id":"public/tags/Linux/index.html","hash":"97c1774858f68e763c6194144ecc8385b841eb16","modified":1703356650782},{"_id":"public/tags/Git/index.html","hash":"b9d930aa8753a4221c3486c7e9309ddb5cd8c0fb","modified":1703356650782},{"_id":"public/tags/Face/index.html","hash":"8ef7f143a24451dbeee76c1e18d729eea75a1e0f","modified":1703356650782},{"_id":"public/tags/BootStrapFileInput/index.html","hash":"bd24facc9afb62ec9efc94a9671b57009581080b","modified":1703356650782},{"_id":"public/tags/indexedDB/index.html","hash":"1181aaa230647939aa00e26413e5ebb547cb3be5","modified":1703356650782},{"_id":"public/tags/Kong/index.html","hash":"8b79825c2390beb4abfe82c3ad5a5d4ceaa67054","modified":1703356650782},{"_id":"public/tags/文学/index.html","hash":"c57bd62bbaeffa60083916b089fc64d4b5744afe","modified":1703356650782},{"_id":"public/tags/散文/index.html","hash":"a1d511d9b30b5d8464ceb86f3cc394e2a07730f0","modified":1703356650782},{"_id":"public/tags/LeetCode/index.html","hash":"665d3bfbab1a769f03237c4548e36cf31166bc4d","modified":1703356650782},{"_id":"public/tags/Hexo/index.html","hash":"c410306161b81f93f09791c4b8c57965ea1b1ecc","modified":1703356650782},{"_id":"public/tags/melody/index.html","hash":"764a6e9e79fd8b015c823e4b9a9ad1f1b109a8d4","modified":1703356650782},{"_id":"public/tags/blog/index.html","hash":"2afca791d3f54b80457c827a33fab7b1d9270cb5","modified":1703356650782},{"_id":"public/tags/MySQL/index.html","hash":"402aa83dca48387958ffbff21dbc573fb949d3fd","modified":1703356650782},{"_id":"public/tags/Netty4/index.html","hash":"edaf078edb181690eaedd67a987921046f6354b9","modified":1703356650782},{"_id":"public/tags/链表/index.html","hash":"7c767897d928881cd3f53b9804b945e476b6173d","modified":1703356650782},{"_id":"public/tags/事务/index.html","hash":"db18bf20533a7ac643a447f89f2f51d89cb0ff98","modified":1703356650782},{"_id":"public/tags/RESTful/index.html","hash":"df836a865e480bbadebd0fa933da393d189e2739","modified":1703356650782},{"_id":"public/tags/自律/index.html","hash":"d8c50d1080768ba922129dc226ef4cb0e0010e9d","modified":1703356650782},{"_id":"public/tags/Shell/index.html","hash":"02a0abb97dba5dcbaaef567467bcff32510e7b8e","modified":1703356650782},{"_id":"public/tags/Spring-Data-JPA/index.html","hash":"49eb31b6fe2dd9a6080995bdf390ed5d65784338","modified":1703356650782},{"_id":"public/tags/SpringBoot2/index.html","hash":"c3eae3b9064b6dc94289e8e7dad8e006ab0fbbea","modified":1703356650782},{"_id":"public/tags/JPA/index.html","hash":"3326c6d8eaff183aad10d07fd7e3e331ba31d7d8","modified":1703356650782},{"_id":"public/tags/REST/index.html","hash":"c6670f22e96b80c7e98b490eac7a58c08a44ab6e","modified":1703356650782},{"_id":"public/tags/SpingBoot2/index.html","hash":"9fcbe705393fa8fec4464da9caa8191ca538fbe7","modified":1703356650782},{"_id":"public/tags/ShardingJDBC/index.html","hash":"4c7789051b10d303b360fd7cb8f441079dff0413","modified":1703356650782},{"_id":"public/tags/WebSocket/index.html","hash":"b1d6eb134d1f3df64453edf3ccb2fc3798d45881","modified":1703356650782},{"_id":"public/tags/Ubuntu/index.html","hash":"3c2add63c1f3b2f480ff4a5688da0c8c37eded2a","modified":1703356650782},{"_id":"public/tags/ssh/index.html","hash":"bc7d7b757fbf7ca4e94141a61d60705386fe5420","modified":1703356650782},{"_id":"public/tags/脚本/index.html","hash":"d32c8eae87e76be657806aecf2dfcf36cb28d7e9","modified":1703356650782},{"_id":"public/tags/开机自启/index.html","hash":"f4a2f13c672f3303c12a379a4233126de1dcd5d6","modified":1703356650782},{"_id":"public/tags/Stream/index.html","hash":"ec7dc8daa2c2d31f618b5e19635e0abef1d3a9c9","modified":1703356650782},{"_id":"public/tags/仓央嘉措/index.html","hash":"fb113227587b7e7d4d03812923511e85d83f448b","modified":1703356650782},{"_id":"public/tags/诗词/index.html","hash":"4f0e8f1f2a192ea401ee8a561e3cc52adcd59af0","modified":1703356650782},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1703356650782},{"_id":"public/favicon.ico","hash":"12c3523f17e72f15b8c8b8d1cba8bc850bae5304","modified":1703356650782},{"_id":"public/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1703356650782},{"_id":"public/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1703356650782},{"_id":"public/css/index.css","hash":"6cb4a3045e2009a9328c7e5e0e3ba8c6574a7979","modified":1703356650782},{"_id":"public/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1703356650782},{"_id":"public/css/404.css","hash":"712ecbf4ac203ab5f1ea92989c0f0062a3d0aca9","modified":1703356650782},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1703356650782},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1703356650782},{"_id":"public/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1703356650782},{"_id":"public/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1703356650782},{"_id":"public/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1703356650782},{"_id":"public/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1703356650782},{"_id":"public/js/fireworks.js","hash":"4b6428da34535f0e8fe5a11976b8d89c48736500","modified":1703356650782},{"_id":"public/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1703356650782},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1703356650782},{"_id":"public/js/search/local-search.js","hash":"c58bbe874fcdc512cca5244db487745e6a49ef48","modified":1703356650782},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1703356650782},{"_id":"public/js/scroll.js","hash":"e9aaeeae8958b8a06e016edbd17c84b63aea9255","modified":1703356650782},{"_id":"public/js/third-party/anime.min.js","hash":"332031949d78a49e8a18611556253660574e47db","modified":1703356650782},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1703356650782},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1703356650782},{"_id":"public/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1703356650782},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1703356650782},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1703356650782},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1703356650782}],"Category":[{"name":"开发","_id":"clqiekjh20004k9i13bhcbe93"},{"name":"JVM","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh5000kk9i1eofgdcjn"},{"name":"算法","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh6000pk9i19jhr1msr"},{"name":"总结","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh70019k9i185dsevf7"},{"name":"多线程","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh90022k9i1cten7lj7"},{"name":"Web","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhe004kk9i188myaqxi"},{"name":"生活","_id":"clqiekjhf004tk9i18nej76og"},{"name":"数据库","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhj007ak9i19lkl8xyt"},{"name":"杂侃","parent":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhn009tk9i1a87z944p"},{"name":"文学","_id":"clqiekjhv00ekk9i1g8hmfza7"},{"name":"运维","parent":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhy00hvk9i18mb2940r"},{"name":"散文鉴赏","parent":"clqiekjhv00ekk9i1g8hmfza7","_id":"clqiekjhz00i4k9i1daco6cuz"},{"name":"诗词鉴赏","parent":"clqiekjhv00ekk9i1g8hmfza7","_id":"clqiekjhz00i7k9i14n1oc0jo"}],"Data":[],"Page":[{"title":"About Me","date":"2018-05-22T01:21:32.000Z","type":"about","comments":1,"_content":"<center>\n**生死本无常，<br>\n人应多思量；<br>\n不观生命本真，<br>\n智者也同愚人一样。**\n</center>\n\n----------\n\n## Demo\n- [lay.putop.top](http://lay.putop.top/) SpringBoot + layui 数据展示页面\n- [face.putop.top](http://face.putop.top/) SpringBoot + BootStrap Face++ 与 Java 简单应用\n- [fiot-server](https://github.com/Folgerjun/fiot-server) Spring Boot 2.0 + Spring Data JPA 动态切换数据源实现类似多租户功能\n- [fiot-web](https://github.com/Folgerjun/fiot-web) Vue CLI + ElementUI 简易 Web 项目\n- [netty4-datatrans](https://github.com/Folgerjun/netty4-datatrans) 用 Netty4 实现数据报文的接收/拆包/重组/转发\n- [database-backup](https://github.com/Folgerjun/database-backup) 数据库备份轻便脚本\n\n**GitHub均有同名代码**\n\n----------\n\n## Link\n- [GitHub](https://github.com/Folgerjun)\n- [CSDN](https://blog.csdn.net/ffj0721)\n- 我的个人简历：[Resume](https://github.com/Folgerjun/resume \"我的个人简历\")\n- 个人微信公众号（品味诗词）：[普度狗生](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg)","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2018-05-22 09:21:32\ntype: \"about\"\ncomments: true\n---\n<center>\n**生死本无常，<br>\n人应多思量；<br>\n不观生命本真，<br>\n智者也同愚人一样。**\n</center>\n\n----------\n\n## Demo\n- [lay.putop.top](http://lay.putop.top/) SpringBoot + layui 数据展示页面\n- [face.putop.top](http://face.putop.top/) SpringBoot + BootStrap Face++ 与 Java 简单应用\n- [fiot-server](https://github.com/Folgerjun/fiot-server) Spring Boot 2.0 + Spring Data JPA 动态切换数据源实现类似多租户功能\n- [fiot-web](https://github.com/Folgerjun/fiot-web) Vue CLI + ElementUI 简易 Web 项目\n- [netty4-datatrans](https://github.com/Folgerjun/netty4-datatrans) 用 Netty4 实现数据报文的接收/拆包/重组/转发\n- [database-backup](https://github.com/Folgerjun/database-backup) 数据库备份轻便脚本\n\n**GitHub均有同名代码**\n\n----------\n\n## Link\n- [GitHub](https://github.com/Folgerjun)\n- [CSDN](https://blog.csdn.net/ffj0721)\n- 我的个人简历：[Resume](https://github.com/Folgerjun/resume \"我的个人简历\")\n- 个人微信公众号（品味诗词）：[普度狗生](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg)","updated":"2023-12-23T16:44:22.243Z","path":"about/index.html","layout":"page","_id":"clqiekjgz0000k9i1g0cw7ona","content":"<center>\n**生死本无常，<br>\n人应多思量；<br>\n不观生命本真，<br>\n智者也同愚人一样。**\n</center>\n\n<hr>\n<h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><ul>\n<li><a href=\"http://lay.putop.top/\">lay.putop.top</a> SpringBoot + layui 数据展示页面</li>\n<li><a href=\"http://face.putop.top/\">face.putop.top</a> SpringBoot + BootStrap Face++ 与 Java 简单应用</li>\n<li><a href=\"https://github.com/Folgerjun/fiot-server\">fiot-server</a> Spring Boot 2.0 + Spring Data JPA 动态切换数据源实现类似多租户功能</li>\n<li><a href=\"https://github.com/Folgerjun/fiot-web\">fiot-web</a> Vue CLI + ElementUI 简易 Web 项目</li>\n<li><a href=\"https://github.com/Folgerjun/netty4-datatrans\">netty4-datatrans</a> 用 Netty4 实现数据报文的接收&#x2F;拆包&#x2F;重组&#x2F;转发</li>\n<li><a href=\"https://github.com/Folgerjun/database-backup\">database-backup</a> 数据库备份轻便脚本</li>\n</ul>\n<p><strong>GitHub均有同名代码</strong></p>\n<hr>\n<h2 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h2><ul>\n<li><a href=\"https://github.com/Folgerjun\">GitHub</a></li>\n<li><a href=\"https://blog.csdn.net/ffj0721\">CSDN</a></li>\n<li>我的个人简历：<a href=\"https://github.com/Folgerjun/resume\" title=\"我的个人简历\">Resume</a></li>\n<li>个人微信公众号（品味诗词）：<a href=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\">普度狗生</a></li>\n</ul>\n","excerpt":"","more":"<center>\n**生死本无常，<br>\n人应多思量；<br>\n不观生命本真，<br>\n智者也同愚人一样。**\n</center>\n\n<hr>\n<h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><ul>\n<li><a href=\"http://lay.putop.top/\">lay.putop.top</a> SpringBoot + layui 数据展示页面</li>\n<li><a href=\"http://face.putop.top/\">face.putop.top</a> SpringBoot + BootStrap Face++ 与 Java 简单应用</li>\n<li><a href=\"https://github.com/Folgerjun/fiot-server\">fiot-server</a> Spring Boot 2.0 + Spring Data JPA 动态切换数据源实现类似多租户功能</li>\n<li><a href=\"https://github.com/Folgerjun/fiot-web\">fiot-web</a> Vue CLI + ElementUI 简易 Web 项目</li>\n<li><a href=\"https://github.com/Folgerjun/netty4-datatrans\">netty4-datatrans</a> 用 Netty4 实现数据报文的接收&#x2F;拆包&#x2F;重组&#x2F;转发</li>\n<li><a href=\"https://github.com/Folgerjun/database-backup\">database-backup</a> 数据库备份轻便脚本</li>\n</ul>\n<p><strong>GitHub均有同名代码</strong></p>\n<hr>\n<h2 id=\"Link\"><a href=\"#Link\" class=\"headerlink\" title=\"Link\"></a>Link</h2><ul>\n<li><a href=\"https://github.com/Folgerjun\">GitHub</a></li>\n<li><a href=\"https://blog.csdn.net/ffj0721\">CSDN</a></li>\n<li>我的个人简历：<a href=\"https://github.com/Folgerjun/resume\" title=\"我的个人简历\">Resume</a></li>\n<li>个人微信公众号（品味诗词）：<a href=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\">普度狗生</a></li>\n</ul>\n"},{"title":"gallery","date":"2018-05-21T04:53:14.000Z","type":"gallery","_content":"","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate: 2018-05-21 12:53:14\ntype: \"gallery\"\n---\n","updated":"2018-05-21T04:53:28.000Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"clqiekjh10002k9i1h0j2g5sh","content":"","excerpt":"","more":""},{"title":"categories","date":"2018-05-21T04:34:53.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-05-21 12:34:53\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-05-22T04:21:06.000Z","path":"categories/index.html","layout":"page","_id":"clqiekjh30006k9i17ll45c8h","content":"","excerpt":"","more":""},{"title":"slides","date":"2018-05-21T04:52:24.000Z","type":"slides","_content":"","source":"slides/index.md","raw":"---\ntitle: slides\ndate: 2018-05-21 12:52:24\ntype: \"slides\"\n---\n","updated":"2018-05-21T04:52:42.000Z","path":"slides/index.html","comments":1,"layout":"page","_id":"clqiekjh30008k9i12ojc4gza","content":"","excerpt":"","more":""},{"title":"tags","date":"2018-05-21T04:33:21.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-05-21 12:33:21\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-05-22T04:20:56.000Z","path":"tags/index.html","layout":"page","_id":"clqiekjh4000ak9i1axrgfzqu","content":"","excerpt":"","more":""}],"Post":[{"title":"动态规划之 0-1 背包问题详解","date":"2018-09-26T03:13:12.000Z","_content":"\n## 前言\n背包问题是比较经典的动态规划算法题，之前没接触过算法都没听说过这个，也是后来在 leetcode 中刷题时才了解到，惭愧惭愧啊。算法的世界太奇妙，数学一直都是那么令人着迷。今天来总结一下这个 01 背包问题。**注：这里的物品不可拆分。**\n\n## 动态规划\n首先了解下什么是动态规划。动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。\n\n动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。\n\n详情可见：[动态规划](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin)\n\n## 问题详解\n\n### 问题描述\n给定 N 种物品和一个背包。物品i的重量是 Wi，其价值位 Vi，背包的容量为 C。问应该如何选择装入背包的物品，使得转入背包的物品的总价值为最大。\n\n### 问题分析\n在选择物品的时候，对每种物品只有两种选择，要么装入，要么不装入。因此，此为一个 0-1 背包问题。\n01 背包的递归公式为：\n```\nm[i,0] = m[0,j] = 0\nm[i,j] = m[i-1,j] ,j < wi\nm[i,j] = max(m[i-1,j-wi]+vi, m[i-1,j]) ,j >= wi\n```\n其中，m[i,j]为前 i 件物品中选择若干件，放入承重为 j 的背包中，得到的最大的价值。<br>\nwi 为第 i 件商品的重量。<br>\nvi 为第 i 件商品的价值。\n\n### 例题讲解\n有编号为 a,b,c,d,e 的五件物品，他们的重量分别为 4,5,6,2,2，价值分别为 6,4,5,3,6，现在给你一个承重为 10 的背包，怎么实现价值最大。\n\n根据上述公式可以得到一个数据表，表从上向下生成：\n\n\n|name|weight|value|1|2|3|4|5|6|7|8|9|10|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|a|4|6|0|0|0|6|6|6|6|6|6|6|\n|b|5|4|0|0|0|6|6|6|6|6|10|10|\n|c|6|5|0|0|0|6|6|6|6|6|10|11|\n|d|2|3|0|3|3|6|6|9|9|9|10|11|\n|e|2|6|0|6|6|9|9|12|12|15|15|15|\n\n故可以根据公式码出如下实现代码：\n```\n    public static void main(String[] args) {\n\n        int n = 5;// 5件物品,物品编号为a,b,c,d,e（下面为多加一件物品，第一个物品为虚拟的物品）\n        int weight[] = { 0, 4, 5, 6, 2, 2 };// 物品的重量\n        int value[] = { 0, 6, 4, 5, 3, 6 }; // 对应物品的价值\n        int c = 10; // 背包容量\n        int state[] = { 0, 0, 0, 0, 0, 0 };// 开始状态\n        char name[] = { ' ', 'a', 'b', 'c', 'd', 'e' };\n        int maxValue = getMaxValue(n, weight, value, state, c);\n        System.out.println(\"最大价值为 = \" + maxValue);\n        System.out.print(\"放入的物品为 ：\");\n        for (int i = 1; i <= 5; i++) {\n            if (state[i] == 1) {\n                System.out.print(name[i] + \"  \");\n            }\n        }\n\n        // System.out.println();\n    }\n\n    /**\n     * \n     * @param n\n     *            物品数量\n     * @param weight\n     *            物品对应重量（数组下标从0开始，故第一个物品为虚拟物品）\n     * @param value\n     *            物品对应价值（数组下标从0开始，故第一个物品为虚拟物品）\n     * @param state\n     *            物品的开始状态\n     * @param c\n     *            背包的容量\n     * @return\n     */\n    public static int getMaxValue(int n, int weight[], int value[], int state[], int c) {\n        // n 为物品的数量，数组时需要加 1，此时可以从 0,1,...n 个物品，共 n+1 个商品，其中第 0 个为虚构物品\n        // 对于物品的价值，可以写成 2 维数组\n        int m[][] = new int[n + 1][c + 1]; // n 为 0,1,2...(n-1),背包重量为 0,1,2...C\n        int i, j;\n\n        for (i = 0; i <= n; i++) {\n            m[i][0] = 0;\n        }\n        for (j = 0; j <= c; j++) {\n            m[0][j] = 0;\n        }\n\n        for (i = 1; i <= n; i++) {\n            // System.out.println();\n            for (j = 1; j <= c; j++) {\n                if (j < weight[i]) { // 新的物品太重，无法放下\n                    m[i][j] = m[i - 1][j];\n                } else {// 分为放和不放 取较大值\n                    m[i][j] = Math.max(m[i - 1][j - weight[i]] + value[i], m[i - 1][j]);\n                }\n                // System.out.print(\"m[\"+i+\"][\"+j+\"]=\"+m[i][j]+\" \");\n                // System.out.print(m[i][j]+\" \");\n            }\n        }\n\n        // 根据其最大价值，反向推断是否添加了物品 i\n\n        j = c;\n        for (i = n; i > 0; i--) {\n            if (m[i][j] > m[i - 1][j]) {// 物品 i 添加到了序列列表\n                state[i] = 1;\n                j = j - weight[i];\n            } else { // 没有添加\n                state[i] = 0;\n            }\n        }\n\n        return m[n][c]; // 最大价值\n    }\n```\n\n输出结果为：\n```\n最大价值为 = 15\n放入的物品为 ：a  d  e  \n```\n\n具体实现看上述代码即可，注释齐全，简单易懂。\n\n## 参考资料\n- [动态规划之01背包问题（最易理解的讲解）](http://blog.csdn.net/mu399/article/details/7722810)\n- [算法设计与分析--01背包问题（动态规划法解决）](http://www.cnblogs.com/qinyg/archive/2012/04/26/2471829.html)\n- [01背包问题](https://yq.aliyun.com/ziliao/504852)","source":"_posts/DP-01backpack.md","raw":"---\ntitle: 动态规划之 0-1 背包问题详解\ndate: 2018-9-26 11:13:12\ncategories: [开发,算法]\ntags: [算法,Java,动态规划]\n---\n\n## 前言\n背包问题是比较经典的动态规划算法题，之前没接触过算法都没听说过这个，也是后来在 leetcode 中刷题时才了解到，惭愧惭愧啊。算法的世界太奇妙，数学一直都是那么令人着迷。今天来总结一下这个 01 背包问题。**注：这里的物品不可拆分。**\n\n## 动态规划\n首先了解下什么是动态规划。动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。\n\n动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。\n\n详情可见：[动态规划](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin)\n\n## 问题详解\n\n### 问题描述\n给定 N 种物品和一个背包。物品i的重量是 Wi，其价值位 Vi，背包的容量为 C。问应该如何选择装入背包的物品，使得转入背包的物品的总价值为最大。\n\n### 问题分析\n在选择物品的时候，对每种物品只有两种选择，要么装入，要么不装入。因此，此为一个 0-1 背包问题。\n01 背包的递归公式为：\n```\nm[i,0] = m[0,j] = 0\nm[i,j] = m[i-1,j] ,j < wi\nm[i,j] = max(m[i-1,j-wi]+vi, m[i-1,j]) ,j >= wi\n```\n其中，m[i,j]为前 i 件物品中选择若干件，放入承重为 j 的背包中，得到的最大的价值。<br>\nwi 为第 i 件商品的重量。<br>\nvi 为第 i 件商品的价值。\n\n### 例题讲解\n有编号为 a,b,c,d,e 的五件物品，他们的重量分别为 4,5,6,2,2，价值分别为 6,4,5,3,6，现在给你一个承重为 10 的背包，怎么实现价值最大。\n\n根据上述公式可以得到一个数据表，表从上向下生成：\n\n\n|name|weight|value|1|2|3|4|5|6|7|8|9|10|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|a|4|6|0|0|0|6|6|6|6|6|6|6|\n|b|5|4|0|0|0|6|6|6|6|6|10|10|\n|c|6|5|0|0|0|6|6|6|6|6|10|11|\n|d|2|3|0|3|3|6|6|9|9|9|10|11|\n|e|2|6|0|6|6|9|9|12|12|15|15|15|\n\n故可以根据公式码出如下实现代码：\n```\n    public static void main(String[] args) {\n\n        int n = 5;// 5件物品,物品编号为a,b,c,d,e（下面为多加一件物品，第一个物品为虚拟的物品）\n        int weight[] = { 0, 4, 5, 6, 2, 2 };// 物品的重量\n        int value[] = { 0, 6, 4, 5, 3, 6 }; // 对应物品的价值\n        int c = 10; // 背包容量\n        int state[] = { 0, 0, 0, 0, 0, 0 };// 开始状态\n        char name[] = { ' ', 'a', 'b', 'c', 'd', 'e' };\n        int maxValue = getMaxValue(n, weight, value, state, c);\n        System.out.println(\"最大价值为 = \" + maxValue);\n        System.out.print(\"放入的物品为 ：\");\n        for (int i = 1; i <= 5; i++) {\n            if (state[i] == 1) {\n                System.out.print(name[i] + \"  \");\n            }\n        }\n\n        // System.out.println();\n    }\n\n    /**\n     * \n     * @param n\n     *            物品数量\n     * @param weight\n     *            物品对应重量（数组下标从0开始，故第一个物品为虚拟物品）\n     * @param value\n     *            物品对应价值（数组下标从0开始，故第一个物品为虚拟物品）\n     * @param state\n     *            物品的开始状态\n     * @param c\n     *            背包的容量\n     * @return\n     */\n    public static int getMaxValue(int n, int weight[], int value[], int state[], int c) {\n        // n 为物品的数量，数组时需要加 1，此时可以从 0,1,...n 个物品，共 n+1 个商品，其中第 0 个为虚构物品\n        // 对于物品的价值，可以写成 2 维数组\n        int m[][] = new int[n + 1][c + 1]; // n 为 0,1,2...(n-1),背包重量为 0,1,2...C\n        int i, j;\n\n        for (i = 0; i <= n; i++) {\n            m[i][0] = 0;\n        }\n        for (j = 0; j <= c; j++) {\n            m[0][j] = 0;\n        }\n\n        for (i = 1; i <= n; i++) {\n            // System.out.println();\n            for (j = 1; j <= c; j++) {\n                if (j < weight[i]) { // 新的物品太重，无法放下\n                    m[i][j] = m[i - 1][j];\n                } else {// 分为放和不放 取较大值\n                    m[i][j] = Math.max(m[i - 1][j - weight[i]] + value[i], m[i - 1][j]);\n                }\n                // System.out.print(\"m[\"+i+\"][\"+j+\"]=\"+m[i][j]+\" \");\n                // System.out.print(m[i][j]+\" \");\n            }\n        }\n\n        // 根据其最大价值，反向推断是否添加了物品 i\n\n        j = c;\n        for (i = n; i > 0; i--) {\n            if (m[i][j] > m[i - 1][j]) {// 物品 i 添加到了序列列表\n                state[i] = 1;\n                j = j - weight[i];\n            } else { // 没有添加\n                state[i] = 0;\n            }\n        }\n\n        return m[n][c]; // 最大价值\n    }\n```\n\n输出结果为：\n```\n最大价值为 = 15\n放入的物品为 ：a  d  e  \n```\n\n具体实现看上述代码即可，注释齐全，简单易懂。\n\n## 参考资料\n- [动态规划之01背包问题（最易理解的讲解）](http://blog.csdn.net/mu399/article/details/7722810)\n- [算法设计与分析--01背包问题（动态规划法解决）](http://www.cnblogs.com/qinyg/archive/2012/04/26/2471829.html)\n- [01背包问题](https://yq.aliyun.com/ziliao/504852)","slug":"DP-01backpack","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh00001k9i1ggtr0x4a","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>背包问题是比较经典的动态规划算法题，之前没接触过算法都没听说过这个，也是后来在 leetcode 中刷题时才了解到，惭愧惭愧啊。算法的世界太奇妙，数学一直都是那么令人着迷。今天来总结一下这个 01 背包问题。<strong>注：这里的物品不可拆分。</strong></p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>首先了解下什么是动态规划。动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。</p>\n<p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>\n<p>详情可见：<a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin\">动态规划</a></p>\n<h2 id=\"问题详解\"><a href=\"#问题详解\" class=\"headerlink\" title=\"问题详解\"></a>问题详解</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>给定 N 种物品和一个背包。物品i的重量是 Wi，其价值位 Vi，背包的容量为 C。问应该如何选择装入背包的物品，使得转入背包的物品的总价值为最大。</p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>在选择物品的时候，对每种物品只有两种选择，要么装入，要么不装入。因此，此为一个 0-1 背包问题。<br>01 背包的递归公式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m[i,0] = m[0,j] = 0</span><br><span class=\"line\">m[i,j] = m[i-1,j] ,j &lt; wi</span><br><span class=\"line\">m[i,j] = max(m[i-1,j-wi]+vi, m[i-1,j]) ,j &gt;= wi</span><br></pre></td></tr></table></figure>\n<p>其中，m[i,j]为前 i 件物品中选择若干件，放入承重为 j 的背包中，得到的最大的价值。<br><br>wi 为第 i 件商品的重量。<br><br>vi 为第 i 件商品的价值。</p>\n<h3 id=\"例题讲解\"><a href=\"#例题讲解\" class=\"headerlink\" title=\"例题讲解\"></a>例题讲解</h3><p>有编号为 a,b,c,d,e 的五件物品，他们的重量分别为 4,5,6,2,2，价值分别为 6,4,5,3,6，现在给你一个承重为 10 的背包，怎么实现价值最大。</p>\n<p>根据上述公式可以得到一个数据表，表从上向下生成：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">weight</th>\n<th align=\"center\">value</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n<th align=\"center\">10</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">5</td>\n<td align=\"center\">4</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">10</td>\n<td align=\"center\">10</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">6</td>\n<td align=\"center\">5</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">10</td>\n<td align=\"center\">11</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">0</td>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">9</td>\n<td align=\"center\">9</td>\n<td align=\"center\">9</td>\n<td align=\"center\">10</td>\n<td align=\"center\">11</td>\n</tr>\n<tr>\n<td align=\"center\">e</td>\n<td align=\"center\">2</td>\n<td align=\"center\">6</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">9</td>\n<td align=\"center\">9</td>\n<td align=\"center\">12</td>\n<td align=\"center\">12</td>\n<td align=\"center\">15</td>\n<td align=\"center\">15</td>\n<td align=\"center\">15</td>\n</tr>\n</tbody></table>\n<p>故可以根据公式码出如下实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n = 5;// 5件物品,物品编号为a,b,c,d,e（下面为多加一件物品，第一个物品为虚拟的物品）</span><br><span class=\"line\">    int weight[] = &#123; 0, 4, 5, 6, 2, 2 &#125;;// 物品的重量</span><br><span class=\"line\">    int value[] = &#123; 0, 6, 4, 5, 3, 6 &#125;; // 对应物品的价值</span><br><span class=\"line\">    int c = 10; // 背包容量</span><br><span class=\"line\">    int state[] = &#123; 0, 0, 0, 0, 0, 0 &#125;;// 开始状态</span><br><span class=\"line\">    char name[] = &#123; &#x27; &#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; &#125;;</span><br><span class=\"line\">    int maxValue = getMaxValue(n, weight, value, state, c);</span><br><span class=\"line\">    System.out.println(&quot;最大价值为 = &quot; + maxValue);</span><br><span class=\"line\">    System.out.print(&quot;放入的物品为 ：&quot;);</span><br><span class=\"line\">    for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class=\"line\">        if (state[i] == 1) &#123;</span><br><span class=\"line\">            System.out.print(name[i] + &quot;  &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // System.out.println();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param n</span><br><span class=\"line\"> *            物品数量</span><br><span class=\"line\"> * @param weight</span><br><span class=\"line\"> *            物品对应重量（数组下标从0开始，故第一个物品为虚拟物品）</span><br><span class=\"line\"> * @param value</span><br><span class=\"line\"> *            物品对应价值（数组下标从0开始，故第一个物品为虚拟物品）</span><br><span class=\"line\"> * @param state</span><br><span class=\"line\"> *            物品的开始状态</span><br><span class=\"line\"> * @param c</span><br><span class=\"line\"> *            背包的容量</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int getMaxValue(int n, int weight[], int value[], int state[], int c) &#123;</span><br><span class=\"line\">    // n 为物品的数量，数组时需要加 1，此时可以从 0,1,...n 个物品，共 n+1 个商品，其中第 0 个为虚构物品</span><br><span class=\"line\">    // 对于物品的价值，可以写成 2 维数组</span><br><span class=\"line\">    int m[][] = new int[n + 1][c + 1]; // n 为 0,1,2...(n-1),背包重量为 0,1,2...C</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        m[i][0] = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (j = 0; j &lt;= c; j++) &#123;</span><br><span class=\"line\">        m[0][j] = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 1; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        // System.out.println();</span><br><span class=\"line\">        for (j = 1; j &lt;= c; j++) &#123;</span><br><span class=\"line\">            if (j &lt; weight[i]) &#123; // 新的物品太重，无法放下</span><br><span class=\"line\">                m[i][j] = m[i - 1][j];</span><br><span class=\"line\">            &#125; else &#123;// 分为放和不放 取较大值</span><br><span class=\"line\">                m[i][j] = Math.max(m[i - 1][j - weight[i]] + value[i], m[i - 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // System.out.print(&quot;m[&quot;+i+&quot;][&quot;+j+&quot;]=&quot;+m[i][j]+&quot; &quot;);</span><br><span class=\"line\">            // System.out.print(m[i][j]+&quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据其最大价值，反向推断是否添加了物品 i</span><br><span class=\"line\"></span><br><span class=\"line\">    j = c;</span><br><span class=\"line\">    for (i = n; i &gt; 0; i--) &#123;</span><br><span class=\"line\">        if (m[i][j] &gt; m[i - 1][j]) &#123;// 物品 i 添加到了序列列表</span><br><span class=\"line\">            state[i] = 1;</span><br><span class=\"line\">            j = j - weight[i];</span><br><span class=\"line\">        &#125; else &#123; // 没有添加</span><br><span class=\"line\">            state[i] = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return m[n][c]; // 最大价值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大价值为 = 15</span><br><span class=\"line\">放入的物品为 ：a  d  e  </span><br></pre></td></tr></table></figure>\n\n<p>具体实现看上述代码即可，注释齐全，简单易懂。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://blog.csdn.net/mu399/article/details/7722810\">动态规划之01背包问题（最易理解的讲解）</a></li>\n<li><a href=\"http://www.cnblogs.com/qinyg/archive/2012/04/26/2471829.html\">算法设计与分析–01背包问题（动态规划法解决）</a></li>\n<li><a href=\"https://yq.aliyun.com/ziliao/504852\">01背包问题</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>背包问题是比较经典的动态规划算法题，之前没接触过算法都没听说过这个，也是后来在 leetcode 中刷题时才了解到，惭愧惭愧啊。算法的世界太奇妙，数学一直都是那么令人着迷。今天来总结一下这个 01 背包问题。<strong>注：这里的物品不可拆分。</strong></p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>首先了解下什么是动态规划。动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。</p>\n<p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>\n<p>详情可见：<a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin\">动态规划</a></p>\n<h2 id=\"问题详解\"><a href=\"#问题详解\" class=\"headerlink\" title=\"问题详解\"></a>问题详解</h2><h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>给定 N 种物品和一个背包。物品i的重量是 Wi，其价值位 Vi，背包的容量为 C。问应该如何选择装入背包的物品，使得转入背包的物品的总价值为最大。</p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>在选择物品的时候，对每种物品只有两种选择，要么装入，要么不装入。因此，此为一个 0-1 背包问题。<br>01 背包的递归公式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m[i,0] = m[0,j] = 0</span><br><span class=\"line\">m[i,j] = m[i-1,j] ,j &lt; wi</span><br><span class=\"line\">m[i,j] = max(m[i-1,j-wi]+vi, m[i-1,j]) ,j &gt;= wi</span><br></pre></td></tr></table></figure>\n<p>其中，m[i,j]为前 i 件物品中选择若干件，放入承重为 j 的背包中，得到的最大的价值。<br><br>wi 为第 i 件商品的重量。<br><br>vi 为第 i 件商品的价值。</p>\n<h3 id=\"例题讲解\"><a href=\"#例题讲解\" class=\"headerlink\" title=\"例题讲解\"></a>例题讲解</h3><p>有编号为 a,b,c,d,e 的五件物品，他们的重量分别为 4,5,6,2,2，价值分别为 6,4,5,3,6，现在给你一个承重为 10 的背包，怎么实现价值最大。</p>\n<p>根据上述公式可以得到一个数据表，表从上向下生成：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">name</th>\n<th align=\"center\">weight</th>\n<th align=\"center\">value</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n<th align=\"center\">10</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">a</td>\n<td align=\"center\">4</td>\n<td align=\"center\">6</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">b</td>\n<td align=\"center\">5</td>\n<td align=\"center\">4</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">10</td>\n<td align=\"center\">10</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">6</td>\n<td align=\"center\">5</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">10</td>\n<td align=\"center\">11</td>\n</tr>\n<tr>\n<td align=\"center\">d</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">0</td>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">9</td>\n<td align=\"center\">9</td>\n<td align=\"center\">9</td>\n<td align=\"center\">10</td>\n<td align=\"center\">11</td>\n</tr>\n<tr>\n<td align=\"center\">e</td>\n<td align=\"center\">2</td>\n<td align=\"center\">6</td>\n<td align=\"center\">0</td>\n<td align=\"center\">6</td>\n<td align=\"center\">6</td>\n<td align=\"center\">9</td>\n<td align=\"center\">9</td>\n<td align=\"center\">12</td>\n<td align=\"center\">12</td>\n<td align=\"center\">15</td>\n<td align=\"center\">15</td>\n<td align=\"center\">15</td>\n</tr>\n</tbody></table>\n<p>故可以根据公式码出如下实现代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n = 5;// 5件物品,物品编号为a,b,c,d,e（下面为多加一件物品，第一个物品为虚拟的物品）</span><br><span class=\"line\">    int weight[] = &#123; 0, 4, 5, 6, 2, 2 &#125;;// 物品的重量</span><br><span class=\"line\">    int value[] = &#123; 0, 6, 4, 5, 3, 6 &#125;; // 对应物品的价值</span><br><span class=\"line\">    int c = 10; // 背包容量</span><br><span class=\"line\">    int state[] = &#123; 0, 0, 0, 0, 0, 0 &#125;;// 开始状态</span><br><span class=\"line\">    char name[] = &#123; &#x27; &#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; &#125;;</span><br><span class=\"line\">    int maxValue = getMaxValue(n, weight, value, state, c);</span><br><span class=\"line\">    System.out.println(&quot;最大价值为 = &quot; + maxValue);</span><br><span class=\"line\">    System.out.print(&quot;放入的物品为 ：&quot;);</span><br><span class=\"line\">    for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class=\"line\">        if (state[i] == 1) &#123;</span><br><span class=\"line\">            System.out.print(name[i] + &quot;  &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // System.out.println();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param n</span><br><span class=\"line\"> *            物品数量</span><br><span class=\"line\"> * @param weight</span><br><span class=\"line\"> *            物品对应重量（数组下标从0开始，故第一个物品为虚拟物品）</span><br><span class=\"line\"> * @param value</span><br><span class=\"line\"> *            物品对应价值（数组下标从0开始，故第一个物品为虚拟物品）</span><br><span class=\"line\"> * @param state</span><br><span class=\"line\"> *            物品的开始状态</span><br><span class=\"line\"> * @param c</span><br><span class=\"line\"> *            背包的容量</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int getMaxValue(int n, int weight[], int value[], int state[], int c) &#123;</span><br><span class=\"line\">    // n 为物品的数量，数组时需要加 1，此时可以从 0,1,...n 个物品，共 n+1 个商品，其中第 0 个为虚构物品</span><br><span class=\"line\">    // 对于物品的价值，可以写成 2 维数组</span><br><span class=\"line\">    int m[][] = new int[n + 1][c + 1]; // n 为 0,1,2...(n-1),背包重量为 0,1,2...C</span><br><span class=\"line\">    int i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 0; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        m[i][0] = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (j = 0; j &lt;= c; j++) &#123;</span><br><span class=\"line\">        m[0][j] = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (i = 1; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        // System.out.println();</span><br><span class=\"line\">        for (j = 1; j &lt;= c; j++) &#123;</span><br><span class=\"line\">            if (j &lt; weight[i]) &#123; // 新的物品太重，无法放下</span><br><span class=\"line\">                m[i][j] = m[i - 1][j];</span><br><span class=\"line\">            &#125; else &#123;// 分为放和不放 取较大值</span><br><span class=\"line\">                m[i][j] = Math.max(m[i - 1][j - weight[i]] + value[i], m[i - 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // System.out.print(&quot;m[&quot;+i+&quot;][&quot;+j+&quot;]=&quot;+m[i][j]+&quot; &quot;);</span><br><span class=\"line\">            // System.out.print(m[i][j]+&quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据其最大价值，反向推断是否添加了物品 i</span><br><span class=\"line\"></span><br><span class=\"line\">    j = c;</span><br><span class=\"line\">    for (i = n; i &gt; 0; i--) &#123;</span><br><span class=\"line\">        if (m[i][j] &gt; m[i - 1][j]) &#123;// 物品 i 添加到了序列列表</span><br><span class=\"line\">            state[i] = 1;</span><br><span class=\"line\">            j = j - weight[i];</span><br><span class=\"line\">        &#125; else &#123; // 没有添加</span><br><span class=\"line\">            state[i] = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return m[n][c]; // 最大价值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大价值为 = 15</span><br><span class=\"line\">放入的物品为 ：a  d  e  </span><br></pre></td></tr></table></figure>\n\n<p>具体实现看上述代码即可，注释齐全，简单易懂。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://blog.csdn.net/mu399/article/details/7722810\">动态规划之01背包问题（最易理解的讲解）</a></li>\n<li><a href=\"http://www.cnblogs.com/qinyg/archive/2012/04/26/2471829.html\">算法设计与分析–01背包问题（动态规划法解决）</a></li>\n<li><a href=\"https://yq.aliyun.com/ziliao/504852\">01背包问题</a></li>\n</ul>\n"},{"title":"整理一些 JDK 中 Integer 实用但不常用的方法","date":"2018-09-26T07:14:30.000Z","_content":"\n直接开搞。\n\n## toString\n该方法进行了重载，一种是 `toString(int i, int radix)`，另一个是 `toString(int i)`。一个参数的方法就相当于 `toString(int i, 10)`，看代码便知，何况其官网注释也有：\n```\n    public static String toString(int i, int radix) {\n        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n            radix = 10;\n\n        /* Use the faster version */\n        if (radix == 10) {\n            return toString(i);\n        }\n        // int 32位\n        char buf[] = new char[33];\n        boolean negative = (i < 0);\n        int charPos = 32;\n\n        if (!negative) {\n            i = -i;\n        }\n        // 根据进制取余转换\n        while (i <= -radix) {\n            buf[charPos--] = digits[-(i % radix)];\n            i = i / radix;\n        }\n        buf[charPos] = digits[-i];\n\n        if (negative) {\n            buf[--charPos] = '-';\n        }\n\n        return new String(buf, charPos, (33 - charPos));\n    }\n```\n**不过该方法需注意：** `If the first argument is negative, the first element of the result is the ASCII minus character '-' ('\\u005Cu002D'). If the first argument is not negative, no sign character appears in the result. `例如：\n```\nInteger.toString(-44, 2)  // -101100\nInteger.toBinaryString(-44) // 11111111111111111111111111010100\n```\n若是负数，用该方法求得的值只是正数前加了个 \"-\" 。\n\n## toBinaryString\n类似的几个方法也一并列出了。 `toBinaryString(int i)` 转二进制方法，`toOctalString(int i)` 转八进制方法，`toHexString(int i)` 转十六进制方法。\n```\nInteger.toBinaryString(-44) // 11111111111111111111111111010100\nInteger.toOctalString(44) // 54\nInteger.toHexString(44) // 2c\n```\n\n## parseUnsignedInt\n与 toString 方法一样进行了重载。 `parseUnsignedInt(String s)` 与 `parseUnsignedInt(String s, int radix)` 这是 JDK 1.8 新增的方法，作用就是将字符串参数解析为第二个参数指定的基数中的无符号整数。\n```\nInteger.parseUnsignedInt(\"11111111111111111111111111010100\", 2) // -44\nInteger.parseUnsignedInt(\"44\", 10) // 44\nInteger.parseUnsignedInt(\"44\") // 44\n```\n\n## decode\n该方法将 String 解码为整数。 接受指定语法的十进制，十六进制和八进制数。源码如下：\n```\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix = 10;\n        int index = 0;\n        boolean negative = false;\n        Integer result;\n\n        if (nm.length() == 0)\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar = nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar == '-') {\n            negative = true;\n            index++;\n        } else if (firstChar == '+')\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index += 2;\n            radix = 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix = 16;\n        }\n        else if (nm.startsWith(\"0\", index) && nm.length() > 1 + index) { // 0 后面长度要大于 1\n            index ++;\n            radix = 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result = Integer.valueOf(nm.substring(index), radix);\n            result = negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we'll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant = negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result = Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n```\n使用测试如下：\n```\nInteger.decode(\"0xff\") // 255\nInteger.decode(\"#ff\") // 255\nInteger.decode(\"-07\") // -7\nInteger.decode(\"-071\") // -57\n```\n\n## highestOneBit\n该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最高位（“最左侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。\n```\nInteger.highestOneBit(44) // 32\n```\n44 对应的二进制为 0010 1100，只选中其最左侧的 “1” 那就是 0010 0000，也就是 2<sup>5</sup> = 32\n\n## lowestOneBit\n该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最低位（“最右侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。\n```\nInteger.lowestOneBit(44) // 4\n```\n44 对应的二进制为 0010 1100，只选中其最右侧的 “1” 那就是 0000 0100，也就是 2<sup>2</sup> = 4\n\n## numberOfLeadingZeros\n该方法计算首部零的个数。\n```\n    /**\n     * 首先在 jvm 中一个 int 类型的数据占 4 个字节，共 32 位，其实就相当于一个长度为 32 的数组。\n     *\n     * 那我们要计算首部 0 的个数，就是从左边第一个位开始累加 0 的个数，直到遇到一个非零值。\n     */\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Figure 5-6\n        if (i == 0)\n            return 32;\n        int n = 1;\n        // 下面的代码就是定位从左边开始第一个非零值的位置，在定位过程中顺便累加从左边开始 0 的个数\n        // 将 i 无符号右移 16 位后，有二种情况；\n        //   情况1. i=0,则第一个非零值位于低 16 位，i 至少有 16 个 0，同时将 i 左移 16 位（把低 16 位移到原高 16 位的位置，这样情况 1 和情况 2 就能统一后续的判断方式）\n        //   情况2. i!=0,则第一个非零值位于高 16 位，后续在高 16 位中继续判断\n        // 这个思路就是二分查找，首先把32位的数分为高低 16 位，如果非零值位于高 16 位，后续再将高 16 位继续二分为高低 8 位，一直二分到集合中只有 1 个元素\n        if (i >>> 16 == 0) { n += 16; i <<= 16; }\n        // 判断第一个非零值是否位于高 8 位\n        if (i >>> 24 == 0) { n +=  8; i <<=  8; }\n        // 判断第一个非零值是否位于高 4 位\n        if (i >>> 28 == 0) { n +=  4; i <<=  4; }\n        // 判断第一个非零值是否位于高 2 位\n        if (i >>> 30 == 0) { n +=  2; i <<=  2; }\n        n -= i >>> 31;\n        return n;\n    }\n```\n测试看看：\n```\nInteger.numberOfLeadingZeros(44) // 26\n```\nint 4 个字节，一个字节八位，所以有 32 位。44 对应完整二进制就是 0000 0000 0000 0000 0000 0000 0010 1100。所以从左边开始数起共有 26 个零。\n\n## numberOfTrailingZeros\n返回指定 int 值的二进制补码表达式中最低位（“最右侧”）1 之后的零位数。\n```\nInteger.numberOfTrailingZeros(44) // 2\n```\n44 对应二进制 0010 1100。其最右侧 “1” 之后的零的个数就是 2。\n\n## bitCount\n返回指定 int 值的二进制补码中 1 的个数。\n```\nInteger.bitCount(44) // 3\nInteger.bitCount(-44) // 28\n```\n44 对应的二进制补码为 0000 0000 0000 0000 0000 0000 0010 1100。1 有 3 个。<br>\n-44 对应的二进制补码为 1111 1111 1111 1111 1111 1111 1101 0100。1 有 28 个。","source":"_posts/Integer-practical-notcommon-methods.md","raw":"---\ntitle: 整理一些 JDK 中 Integer 实用但不常用的方法\ndate: 2018-9-26 15:14:30\ncategories: [开发,总结]\ntags: [Java]\n---\n\n直接开搞。\n\n## toString\n该方法进行了重载，一种是 `toString(int i, int radix)`，另一个是 `toString(int i)`。一个参数的方法就相当于 `toString(int i, 10)`，看代码便知，何况其官网注释也有：\n```\n    public static String toString(int i, int radix) {\n        if (radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n            radix = 10;\n\n        /* Use the faster version */\n        if (radix == 10) {\n            return toString(i);\n        }\n        // int 32位\n        char buf[] = new char[33];\n        boolean negative = (i < 0);\n        int charPos = 32;\n\n        if (!negative) {\n            i = -i;\n        }\n        // 根据进制取余转换\n        while (i <= -radix) {\n            buf[charPos--] = digits[-(i % radix)];\n            i = i / radix;\n        }\n        buf[charPos] = digits[-i];\n\n        if (negative) {\n            buf[--charPos] = '-';\n        }\n\n        return new String(buf, charPos, (33 - charPos));\n    }\n```\n**不过该方法需注意：** `If the first argument is negative, the first element of the result is the ASCII minus character '-' ('\\u005Cu002D'). If the first argument is not negative, no sign character appears in the result. `例如：\n```\nInteger.toString(-44, 2)  // -101100\nInteger.toBinaryString(-44) // 11111111111111111111111111010100\n```\n若是负数，用该方法求得的值只是正数前加了个 \"-\" 。\n\n## toBinaryString\n类似的几个方法也一并列出了。 `toBinaryString(int i)` 转二进制方法，`toOctalString(int i)` 转八进制方法，`toHexString(int i)` 转十六进制方法。\n```\nInteger.toBinaryString(-44) // 11111111111111111111111111010100\nInteger.toOctalString(44) // 54\nInteger.toHexString(44) // 2c\n```\n\n## parseUnsignedInt\n与 toString 方法一样进行了重载。 `parseUnsignedInt(String s)` 与 `parseUnsignedInt(String s, int radix)` 这是 JDK 1.8 新增的方法，作用就是将字符串参数解析为第二个参数指定的基数中的无符号整数。\n```\nInteger.parseUnsignedInt(\"11111111111111111111111111010100\", 2) // -44\nInteger.parseUnsignedInt(\"44\", 10) // 44\nInteger.parseUnsignedInt(\"44\") // 44\n```\n\n## decode\n该方法将 String 解码为整数。 接受指定语法的十进制，十六进制和八进制数。源码如下：\n```\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix = 10;\n        int index = 0;\n        boolean negative = false;\n        Integer result;\n\n        if (nm.length() == 0)\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar = nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar == '-') {\n            negative = true;\n            index++;\n        } else if (firstChar == '+')\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index += 2;\n            radix = 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix = 16;\n        }\n        else if (nm.startsWith(\"0\", index) && nm.length() > 1 + index) { // 0 后面长度要大于 1\n            index ++;\n            radix = 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result = Integer.valueOf(nm.substring(index), radix);\n            result = negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we'll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant = negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result = Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n```\n使用测试如下：\n```\nInteger.decode(\"0xff\") // 255\nInteger.decode(\"#ff\") // 255\nInteger.decode(\"-07\") // -7\nInteger.decode(\"-071\") // -57\n```\n\n## highestOneBit\n该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最高位（“最左侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。\n```\nInteger.highestOneBit(44) // 32\n```\n44 对应的二进制为 0010 1100，只选中其最左侧的 “1” 那就是 0010 0000，也就是 2<sup>5</sup> = 32\n\n## lowestOneBit\n该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最低位（“最右侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。\n```\nInteger.lowestOneBit(44) // 4\n```\n44 对应的二进制为 0010 1100，只选中其最右侧的 “1” 那就是 0000 0100，也就是 2<sup>2</sup> = 4\n\n## numberOfLeadingZeros\n该方法计算首部零的个数。\n```\n    /**\n     * 首先在 jvm 中一个 int 类型的数据占 4 个字节，共 32 位，其实就相当于一个长度为 32 的数组。\n     *\n     * 那我们要计算首部 0 的个数，就是从左边第一个位开始累加 0 的个数，直到遇到一个非零值。\n     */\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Figure 5-6\n        if (i == 0)\n            return 32;\n        int n = 1;\n        // 下面的代码就是定位从左边开始第一个非零值的位置，在定位过程中顺便累加从左边开始 0 的个数\n        // 将 i 无符号右移 16 位后，有二种情况；\n        //   情况1. i=0,则第一个非零值位于低 16 位，i 至少有 16 个 0，同时将 i 左移 16 位（把低 16 位移到原高 16 位的位置，这样情况 1 和情况 2 就能统一后续的判断方式）\n        //   情况2. i!=0,则第一个非零值位于高 16 位，后续在高 16 位中继续判断\n        // 这个思路就是二分查找，首先把32位的数分为高低 16 位，如果非零值位于高 16 位，后续再将高 16 位继续二分为高低 8 位，一直二分到集合中只有 1 个元素\n        if (i >>> 16 == 0) { n += 16; i <<= 16; }\n        // 判断第一个非零值是否位于高 8 位\n        if (i >>> 24 == 0) { n +=  8; i <<=  8; }\n        // 判断第一个非零值是否位于高 4 位\n        if (i >>> 28 == 0) { n +=  4; i <<=  4; }\n        // 判断第一个非零值是否位于高 2 位\n        if (i >>> 30 == 0) { n +=  2; i <<=  2; }\n        n -= i >>> 31;\n        return n;\n    }\n```\n测试看看：\n```\nInteger.numberOfLeadingZeros(44) // 26\n```\nint 4 个字节，一个字节八位，所以有 32 位。44 对应完整二进制就是 0000 0000 0000 0000 0000 0000 0010 1100。所以从左边开始数起共有 26 个零。\n\n## numberOfTrailingZeros\n返回指定 int 值的二进制补码表达式中最低位（“最右侧”）1 之后的零位数。\n```\nInteger.numberOfTrailingZeros(44) // 2\n```\n44 对应二进制 0010 1100。其最右侧 “1” 之后的零的个数就是 2。\n\n## bitCount\n返回指定 int 值的二进制补码中 1 的个数。\n```\nInteger.bitCount(44) // 3\nInteger.bitCount(-44) // 28\n```\n44 对应的二进制补码为 0000 0000 0000 0000 0000 0000 0010 1100。1 有 3 个。<br>\n-44 对应的二进制补码为 1111 1111 1111 1111 1111 1111 1101 0100。1 有 28 个。","slug":"Integer-practical-notcommon-methods","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh10003k9i1ha80g54g","content":"<p>直接开搞。</p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h2><p>该方法进行了重载，一种是 <code>toString(int i, int radix)</code>，另一个是 <code>toString(int i)</code>。一个参数的方法就相当于 <code>toString(int i, 10)</code>，看代码便知，何况其官网注释也有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String toString(int i, int radix) &#123;</span><br><span class=\"line\">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</span><br><span class=\"line\">        radix = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Use the faster version */</span><br><span class=\"line\">    if (radix == 10) &#123;</span><br><span class=\"line\">        return toString(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // int 32位</span><br><span class=\"line\">    char buf[] = new char[33];</span><br><span class=\"line\">    boolean negative = (i &lt; 0);</span><br><span class=\"line\">    int charPos = 32;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!negative) &#123;</span><br><span class=\"line\">        i = -i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据进制取余转换</span><br><span class=\"line\">    while (i &lt;= -radix) &#123;</span><br><span class=\"line\">        buf[charPos--] = digits[-(i % radix)];</span><br><span class=\"line\">        i = i / radix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf[charPos] = digits[-i];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (negative) &#123;</span><br><span class=\"line\">        buf[--charPos] = &#x27;-&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return new String(buf, charPos, (33 - charPos));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不过该方法需注意：</strong> <code>If the first argument is negative, the first element of the result is the ASCII minus character &#39;-&#39; (&#39;\\u005Cu002D&#39;). If the first argument is not negative, no sign character appears in the result. </code>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.toString(-44, 2)  // -101100</span><br><span class=\"line\">Integer.toBinaryString(-44) // 11111111111111111111111111010100</span><br></pre></td></tr></table></figure>\n<p>若是负数，用该方法求得的值只是正数前加了个 “-“ 。</p>\n<h2 id=\"toBinaryString\"><a href=\"#toBinaryString\" class=\"headerlink\" title=\"toBinaryString\"></a>toBinaryString</h2><p>类似的几个方法也一并列出了。 <code>toBinaryString(int i)</code> 转二进制方法，<code>toOctalString(int i)</code> 转八进制方法，<code>toHexString(int i)</code> 转十六进制方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.toBinaryString(-44) // 11111111111111111111111111010100</span><br><span class=\"line\">Integer.toOctalString(44) // 54</span><br><span class=\"line\">Integer.toHexString(44) // 2c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"parseUnsignedInt\"><a href=\"#parseUnsignedInt\" class=\"headerlink\" title=\"parseUnsignedInt\"></a>parseUnsignedInt</h2><p>与 toString 方法一样进行了重载。 <code>parseUnsignedInt(String s)</code> 与 <code>parseUnsignedInt(String s, int radix)</code> 这是 JDK 1.8 新增的方法，作用就是将字符串参数解析为第二个参数指定的基数中的无符号整数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.parseUnsignedInt(&quot;11111111111111111111111111010100&quot;, 2) // -44</span><br><span class=\"line\">Integer.parseUnsignedInt(&quot;44&quot;, 10) // 44</span><br><span class=\"line\">Integer.parseUnsignedInt(&quot;44&quot;) // 44</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"decode\"><a href=\"#decode\" class=\"headerlink\" title=\"decode\"></a>decode</h2><p>该方法将 String 解码为整数。 接受指定语法的十进制，十六进制和八进制数。源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer decode(String nm) throws NumberFormatException &#123;</span><br><span class=\"line\">    int radix = 10;</span><br><span class=\"line\">    int index = 0;</span><br><span class=\"line\">    boolean negative = false;</span><br><span class=\"line\">    Integer result;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (nm.length() == 0)</span><br><span class=\"line\">        throw new NumberFormatException(&quot;Zero length string&quot;);</span><br><span class=\"line\">    char firstChar = nm.charAt(0);</span><br><span class=\"line\">    // Handle sign, if present</span><br><span class=\"line\">    if (firstChar == &#x27;-&#x27;) &#123;</span><br><span class=\"line\">        negative = true;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">    &#125; else if (firstChar == &#x27;+&#x27;)</span><br><span class=\"line\">        index++;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Handle radix specifier, if present</span><br><span class=\"line\">    if (nm.startsWith(&quot;0x&quot;, index) || nm.startsWith(&quot;0X&quot;, index)) &#123;</span><br><span class=\"line\">        index += 2;</span><br><span class=\"line\">        radix = 16;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nm.startsWith(&quot;#&quot;, index)) &#123;</span><br><span class=\"line\">        index ++;</span><br><span class=\"line\">        radix = 16;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nm.startsWith(&quot;0&quot;, index) &amp;&amp; nm.length() &gt; 1 + index) &#123; // 0 后面长度要大于 1</span><br><span class=\"line\">        index ++;</span><br><span class=\"line\">        radix = 8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (nm.startsWith(&quot;-&quot;, index) || nm.startsWith(&quot;+&quot;, index))</span><br><span class=\"line\">        throw new NumberFormatException(&quot;Sign character in wrong position&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        result = Integer.valueOf(nm.substring(index), radix);</span><br><span class=\"line\">        result = negative ? Integer.valueOf(-result.intValue()) : result;</span><br><span class=\"line\">    &#125; catch (NumberFormatException e) &#123;</span><br><span class=\"line\">        // If number is Integer.MIN_VALUE, we&#x27;ll end up here. The next line</span><br><span class=\"line\">        // handles this case, and causes any genuine format error to be</span><br><span class=\"line\">        // rethrown.</span><br><span class=\"line\">        String constant = negative ? (&quot;-&quot; + nm.substring(index))</span><br><span class=\"line\">                                   : nm.substring(index);</span><br><span class=\"line\">        result = Integer.valueOf(constant, radix);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用测试如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.decode(&quot;0xff&quot;) // 255</span><br><span class=\"line\">Integer.decode(&quot;#ff&quot;) // 255</span><br><span class=\"line\">Integer.decode(&quot;-07&quot;) // -7</span><br><span class=\"line\">Integer.decode(&quot;-071&quot;) // -57</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"highestOneBit\"><a href=\"#highestOneBit\" class=\"headerlink\" title=\"highestOneBit\"></a>highestOneBit</h2><p>该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最高位（“最左侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.highestOneBit(44) // 32</span><br></pre></td></tr></table></figure>\n<p>44 对应的二进制为 0010 1100，只选中其最左侧的 “1” 那就是 0010 0000，也就是 2<sup>5</sup> &#x3D; 32</p>\n<h2 id=\"lowestOneBit\"><a href=\"#lowestOneBit\" class=\"headerlink\" title=\"lowestOneBit\"></a>lowestOneBit</h2><p>该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最低位（“最右侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.lowestOneBit(44) // 4</span><br></pre></td></tr></table></figure>\n<p>44 对应的二进制为 0010 1100，只选中其最右侧的 “1” 那就是 0000 0100，也就是 2<sup>2</sup> &#x3D; 4</p>\n<h2 id=\"numberOfLeadingZeros\"><a href=\"#numberOfLeadingZeros\" class=\"headerlink\" title=\"numberOfLeadingZeros\"></a>numberOfLeadingZeros</h2><p>该方法计算首部零的个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 首先在 jvm 中一个 int 类型的数据占 4 个字节，共 32 位，其实就相当于一个长度为 32 的数组。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 那我们要计算首部 0 的个数，就是从左边第一个位开始累加 0 的个数，直到遇到一个非零值。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int numberOfLeadingZeros(int i) &#123;</span><br><span class=\"line\">    // HD, Figure 5-6</span><br><span class=\"line\">    if (i == 0)</span><br><span class=\"line\">        return 32;</span><br><span class=\"line\">    int n = 1;</span><br><span class=\"line\">    // 下面的代码就是定位从左边开始第一个非零值的位置，在定位过程中顺便累加从左边开始 0 的个数</span><br><span class=\"line\">    // 将 i 无符号右移 16 位后，有二种情况；</span><br><span class=\"line\">    //   情况1. i=0,则第一个非零值位于低 16 位，i 至少有 16 个 0，同时将 i 左移 16 位（把低 16 位移到原高 16 位的位置，这样情况 1 和情况 2 就能统一后续的判断方式）</span><br><span class=\"line\">    //   情况2. i!=0,则第一个非零值位于高 16 位，后续在高 16 位中继续判断</span><br><span class=\"line\">    // 这个思路就是二分查找，首先把32位的数分为高低 16 位，如果非零值位于高 16 位，后续再将高 16 位继续二分为高低 8 位，一直二分到集合中只有 1 个元素</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125;</span><br><span class=\"line\">    // 判断第一个非零值是否位于高 8 位</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 24 == 0) &#123; n +=  8; i &lt;&lt;=  8; &#125;</span><br><span class=\"line\">    // 判断第一个非零值是否位于高 4 位</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 28 == 0) &#123; n +=  4; i &lt;&lt;=  4; &#125;</span><br><span class=\"line\">    // 判断第一个非零值是否位于高 2 位</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 30 == 0) &#123; n +=  2; i &lt;&lt;=  2; &#125;</span><br><span class=\"line\">    n -= i &gt;&gt;&gt; 31;</span><br><span class=\"line\">    return n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试看看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.numberOfLeadingZeros(44) // 26</span><br></pre></td></tr></table></figure>\n<p>int 4 个字节，一个字节八位，所以有 32 位。44 对应完整二进制就是 0000 0000 0000 0000 0000 0000 0010 1100。所以从左边开始数起共有 26 个零。</p>\n<h2 id=\"numberOfTrailingZeros\"><a href=\"#numberOfTrailingZeros\" class=\"headerlink\" title=\"numberOfTrailingZeros\"></a>numberOfTrailingZeros</h2><p>返回指定 int 值的二进制补码表达式中最低位（“最右侧”）1 之后的零位数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.numberOfTrailingZeros(44) // 2</span><br></pre></td></tr></table></figure>\n<p>44 对应二进制 0010 1100。其最右侧 “1” 之后的零的个数就是 2。</p>\n<h2 id=\"bitCount\"><a href=\"#bitCount\" class=\"headerlink\" title=\"bitCount\"></a>bitCount</h2><p>返回指定 int 值的二进制补码中 1 的个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.bitCount(44) // 3</span><br><span class=\"line\">Integer.bitCount(-44) // 28</span><br></pre></td></tr></table></figure>\n<p>44 对应的二进制补码为 0000 0000 0000 0000 0000 0000 0010 1100。1 有 3 个。<br><br>-44 对应的二进制补码为 1111 1111 1111 1111 1111 1111 1101 0100。1 有 28 个。</p>\n","excerpt":"","more":"<p>直接开搞。</p>\n<h2 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h2><p>该方法进行了重载，一种是 <code>toString(int i, int radix)</code>，另一个是 <code>toString(int i)</code>。一个参数的方法就相当于 <code>toString(int i, 10)</code>，看代码便知，何况其官网注释也有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String toString(int i, int radix) &#123;</span><br><span class=\"line\">    if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</span><br><span class=\"line\">        radix = 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Use the faster version */</span><br><span class=\"line\">    if (radix == 10) &#123;</span><br><span class=\"line\">        return toString(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // int 32位</span><br><span class=\"line\">    char buf[] = new char[33];</span><br><span class=\"line\">    boolean negative = (i &lt; 0);</span><br><span class=\"line\">    int charPos = 32;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!negative) &#123;</span><br><span class=\"line\">        i = -i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 根据进制取余转换</span><br><span class=\"line\">    while (i &lt;= -radix) &#123;</span><br><span class=\"line\">        buf[charPos--] = digits[-(i % radix)];</span><br><span class=\"line\">        i = i / radix;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf[charPos] = digits[-i];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (negative) &#123;</span><br><span class=\"line\">        buf[--charPos] = &#x27;-&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return new String(buf, charPos, (33 - charPos));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不过该方法需注意：</strong> <code>If the first argument is negative, the first element of the result is the ASCII minus character &#39;-&#39; (&#39;\\u005Cu002D&#39;). If the first argument is not negative, no sign character appears in the result. </code>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.toString(-44, 2)  // -101100</span><br><span class=\"line\">Integer.toBinaryString(-44) // 11111111111111111111111111010100</span><br></pre></td></tr></table></figure>\n<p>若是负数，用该方法求得的值只是正数前加了个 “-“ 。</p>\n<h2 id=\"toBinaryString\"><a href=\"#toBinaryString\" class=\"headerlink\" title=\"toBinaryString\"></a>toBinaryString</h2><p>类似的几个方法也一并列出了。 <code>toBinaryString(int i)</code> 转二进制方法，<code>toOctalString(int i)</code> 转八进制方法，<code>toHexString(int i)</code> 转十六进制方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.toBinaryString(-44) // 11111111111111111111111111010100</span><br><span class=\"line\">Integer.toOctalString(44) // 54</span><br><span class=\"line\">Integer.toHexString(44) // 2c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"parseUnsignedInt\"><a href=\"#parseUnsignedInt\" class=\"headerlink\" title=\"parseUnsignedInt\"></a>parseUnsignedInt</h2><p>与 toString 方法一样进行了重载。 <code>parseUnsignedInt(String s)</code> 与 <code>parseUnsignedInt(String s, int radix)</code> 这是 JDK 1.8 新增的方法，作用就是将字符串参数解析为第二个参数指定的基数中的无符号整数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.parseUnsignedInt(&quot;11111111111111111111111111010100&quot;, 2) // -44</span><br><span class=\"line\">Integer.parseUnsignedInt(&quot;44&quot;, 10) // 44</span><br><span class=\"line\">Integer.parseUnsignedInt(&quot;44&quot;) // 44</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"decode\"><a href=\"#decode\" class=\"headerlink\" title=\"decode\"></a>decode</h2><p>该方法将 String 解码为整数。 接受指定语法的十进制，十六进制和八进制数。源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static Integer decode(String nm) throws NumberFormatException &#123;</span><br><span class=\"line\">    int radix = 10;</span><br><span class=\"line\">    int index = 0;</span><br><span class=\"line\">    boolean negative = false;</span><br><span class=\"line\">    Integer result;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (nm.length() == 0)</span><br><span class=\"line\">        throw new NumberFormatException(&quot;Zero length string&quot;);</span><br><span class=\"line\">    char firstChar = nm.charAt(0);</span><br><span class=\"line\">    // Handle sign, if present</span><br><span class=\"line\">    if (firstChar == &#x27;-&#x27;) &#123;</span><br><span class=\"line\">        negative = true;</span><br><span class=\"line\">        index++;</span><br><span class=\"line\">    &#125; else if (firstChar == &#x27;+&#x27;)</span><br><span class=\"line\">        index++;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Handle radix specifier, if present</span><br><span class=\"line\">    if (nm.startsWith(&quot;0x&quot;, index) || nm.startsWith(&quot;0X&quot;, index)) &#123;</span><br><span class=\"line\">        index += 2;</span><br><span class=\"line\">        radix = 16;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nm.startsWith(&quot;#&quot;, index)) &#123;</span><br><span class=\"line\">        index ++;</span><br><span class=\"line\">        radix = 16;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if (nm.startsWith(&quot;0&quot;, index) &amp;&amp; nm.length() &gt; 1 + index) &#123; // 0 后面长度要大于 1</span><br><span class=\"line\">        index ++;</span><br><span class=\"line\">        radix = 8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (nm.startsWith(&quot;-&quot;, index) || nm.startsWith(&quot;+&quot;, index))</span><br><span class=\"line\">        throw new NumberFormatException(&quot;Sign character in wrong position&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        result = Integer.valueOf(nm.substring(index), radix);</span><br><span class=\"line\">        result = negative ? Integer.valueOf(-result.intValue()) : result;</span><br><span class=\"line\">    &#125; catch (NumberFormatException e) &#123;</span><br><span class=\"line\">        // If number is Integer.MIN_VALUE, we&#x27;ll end up here. The next line</span><br><span class=\"line\">        // handles this case, and causes any genuine format error to be</span><br><span class=\"line\">        // rethrown.</span><br><span class=\"line\">        String constant = negative ? (&quot;-&quot; + nm.substring(index))</span><br><span class=\"line\">                                   : nm.substring(index);</span><br><span class=\"line\">        result = Integer.valueOf(constant, radix);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用测试如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.decode(&quot;0xff&quot;) // 255</span><br><span class=\"line\">Integer.decode(&quot;#ff&quot;) // 255</span><br><span class=\"line\">Integer.decode(&quot;-07&quot;) // -7</span><br><span class=\"line\">Integer.decode(&quot;-071&quot;) // -57</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"highestOneBit\"><a href=\"#highestOneBit\" class=\"headerlink\" title=\"highestOneBit\"></a>highestOneBit</h2><p>该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最高位（“最左侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.highestOneBit(44) // 32</span><br></pre></td></tr></table></figure>\n<p>44 对应的二进制为 0010 1100，只选中其最左侧的 “1” 那就是 0010 0000，也就是 2<sup>5</sup> &#x3D; 32</p>\n<h2 id=\"lowestOneBit\"><a href=\"#lowestOneBit\" class=\"headerlink\" title=\"lowestOneBit\"></a>lowestOneBit</h2><p>该方法返回一个 int 值，该值最多只有一位，位于指定 int 值中最低位（“最右侧”）1 的位置。 如果指定的值在其二进制补码表示中没有一位，即，如果它等于零，则返回零。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.lowestOneBit(44) // 4</span><br></pre></td></tr></table></figure>\n<p>44 对应的二进制为 0010 1100，只选中其最右侧的 “1” 那就是 0000 0100，也就是 2<sup>2</sup> &#x3D; 4</p>\n<h2 id=\"numberOfLeadingZeros\"><a href=\"#numberOfLeadingZeros\" class=\"headerlink\" title=\"numberOfLeadingZeros\"></a>numberOfLeadingZeros</h2><p>该方法计算首部零的个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 首先在 jvm 中一个 int 类型的数据占 4 个字节，共 32 位，其实就相当于一个长度为 32 的数组。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 那我们要计算首部 0 的个数，就是从左边第一个位开始累加 0 的个数，直到遇到一个非零值。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int numberOfLeadingZeros(int i) &#123;</span><br><span class=\"line\">    // HD, Figure 5-6</span><br><span class=\"line\">    if (i == 0)</span><br><span class=\"line\">        return 32;</span><br><span class=\"line\">    int n = 1;</span><br><span class=\"line\">    // 下面的代码就是定位从左边开始第一个非零值的位置，在定位过程中顺便累加从左边开始 0 的个数</span><br><span class=\"line\">    // 将 i 无符号右移 16 位后，有二种情况；</span><br><span class=\"line\">    //   情况1. i=0,则第一个非零值位于低 16 位，i 至少有 16 个 0，同时将 i 左移 16 位（把低 16 位移到原高 16 位的位置，这样情况 1 和情况 2 就能统一后续的判断方式）</span><br><span class=\"line\">    //   情况2. i!=0,则第一个非零值位于高 16 位，后续在高 16 位中继续判断</span><br><span class=\"line\">    // 这个思路就是二分查找，首先把32位的数分为高低 16 位，如果非零值位于高 16 位，后续再将高 16 位继续二分为高低 8 位，一直二分到集合中只有 1 个元素</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125;</span><br><span class=\"line\">    // 判断第一个非零值是否位于高 8 位</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 24 == 0) &#123; n +=  8; i &lt;&lt;=  8; &#125;</span><br><span class=\"line\">    // 判断第一个非零值是否位于高 4 位</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 28 == 0) &#123; n +=  4; i &lt;&lt;=  4; &#125;</span><br><span class=\"line\">    // 判断第一个非零值是否位于高 2 位</span><br><span class=\"line\">    if (i &gt;&gt;&gt; 30 == 0) &#123; n +=  2; i &lt;&lt;=  2; &#125;</span><br><span class=\"line\">    n -= i &gt;&gt;&gt; 31;</span><br><span class=\"line\">    return n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试看看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.numberOfLeadingZeros(44) // 26</span><br></pre></td></tr></table></figure>\n<p>int 4 个字节，一个字节八位，所以有 32 位。44 对应完整二进制就是 0000 0000 0000 0000 0000 0000 0010 1100。所以从左边开始数起共有 26 个零。</p>\n<h2 id=\"numberOfTrailingZeros\"><a href=\"#numberOfTrailingZeros\" class=\"headerlink\" title=\"numberOfTrailingZeros\"></a>numberOfTrailingZeros</h2><p>返回指定 int 值的二进制补码表达式中最低位（“最右侧”）1 之后的零位数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.numberOfTrailingZeros(44) // 2</span><br></pre></td></tr></table></figure>\n<p>44 对应二进制 0010 1100。其最右侧 “1” 之后的零的个数就是 2。</p>\n<h2 id=\"bitCount\"><a href=\"#bitCount\" class=\"headerlink\" title=\"bitCount\"></a>bitCount</h2><p>返回指定 int 值的二进制补码中 1 的个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.bitCount(44) // 3</span><br><span class=\"line\">Integer.bitCount(-44) // 28</span><br></pre></td></tr></table></figure>\n<p>44 对应的二进制补码为 0000 0000 0000 0000 0000 0000 0010 1100。1 有 3 个。<br><br>-44 对应的二进制补码为 1111 1111 1111 1111 1111 1111 1101 0100。1 有 28 个。</p>\n"},{"title":"JVM 之类文件结构","date":"2018-11-24T06:35:58.000Z","_content":"\n> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。\n\n## 无关性的基石\n实现语言无关性的基础是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。\n\n基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，**但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。**\n\n![Java 虚拟机提供的语言无关性](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-language-unrelated.png)\n\nJava 语言的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的。\n\n## Class 类文件的结构\nClass 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。\n\n根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数和表**。\n\n- 无符号数：属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。\n- 表：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。\n\n（这里有关的详细介绍还是请看《深入理解 Java 虚拟机》中的第六章节）\n\n### 魔数与 Class 文件的版本\n每个 Class 文件的头 4 个字节称为魔数，它的唯一作用是 **确定这个文件是否为一个能被虚拟机接受的 Class 文件。**\n\nClass 文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝……）\n\n紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号。\n\n### 常量池\n紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。\n\n由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值。**与 Java 中语言习惯不一样的是，这个容量计数是从 1 开始而不是 0。**\n\n在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。\n\n**常量池主要存放两大类常量：字面量和符号引用。**\n\n字面量比较接近于 Java 语言层面的常量概念，比如文本字符串、声明为 final 的常量值等。\n\n而符号引用则属于编译原理方面的概念，包括了下面三类常量：\n\n- 类和接口的全限定名\n- 字段的名称和描述符\n- 方法的名称和描述符\n\n在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。\n\n当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-06.jpg)\n\n### 访问标志\n在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：\n\n- 这个 Class 是类还是接口\n- 是否定义为 public 类型\n- 是否定义为 abstract 类型\n- 如果是类的话，是否被声明为 final\n- .....\n\n### 类索引、父类索引与接口索引集合\n类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。\n\n类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。\n\n由于 Java 语言不允许多重继承，所以父类索引只有一个，**除了 java.lang.Object 之外，所有的 Java 类都有父类**，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。\n\n接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。\n\n### 字段表集合\n字段表用于描述接口或者类中声明的变量。\n\n字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。\n\n字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。\n\n**另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。**\n\n### 方法表集合\n方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。\n\n方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。\n\n与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类的构造器“`<clinit>`”方法和实例构造器“`<init>`”方法。\n\n在 Java 语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，**也就是因为返回值不会包含在特征签名中，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。**但是在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以并存。**也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。**\n\n### 属性表集合\n在 Class 文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。\n\n#### Code 属性\nCode 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码和元数据两部分，那么在整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。\n\n**在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。**\n\n#### ConstantValue 属性\nConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。**只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。**\n\n对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 `<init>` 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 `<clinit` 方法中或者使用 ConstantValue 属性。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-07.jpg)\n\n## 字节码指令简介\nJava 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。\n\n### 字节码与数据类型\n对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。\n\n大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数据时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。\n\n### 加载和存储指令\n加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容：\n\n- 将一个局部变量加载到操作栈\n- 将一个数值从操作数栈存储到局部变量表\n- 将一个变量加载到操作数栈\n- 扩充局部变量表的访问索引的指令\n\n### 运算指令\n运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。\n\n大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。\n\nJava 虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，**如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式称为向最接近数舍入模式。**\n\n在把浮点数转换为整数时，Java 虚拟机使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。**向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。**\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-08.jpg)\n\n---\nEnd. 这一章节概念的东西比较多，讲了 Class 文件中的种种。","source":"_posts/JVM-Class-File.md","raw":"---\ntitle: JVM 之类文件结构\ndate: 2018-11-24 14:35:58\ncategories: [开发,JVM]\ntags: [Java,JVM]\n---\n\n> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。\n\n## 无关性的基石\n实现语言无关性的基础是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。\n\n基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，**但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。**\n\n![Java 虚拟机提供的语言无关性](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-language-unrelated.png)\n\nJava 语言的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的。\n\n## Class 类文件的结构\nClass 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。\n\n根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号数和表**。\n\n- 无符号数：属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。\n- 表：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。\n\n（这里有关的详细介绍还是请看《深入理解 Java 虚拟机》中的第六章节）\n\n### 魔数与 Class 文件的版本\n每个 Class 文件的头 4 个字节称为魔数，它的唯一作用是 **确定这个文件是否为一个能被虚拟机接受的 Class 文件。**\n\nClass 文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝……）\n\n紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号。\n\n### 常量池\n紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。\n\n由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值。**与 Java 中语言习惯不一样的是，这个容量计数是从 1 开始而不是 0。**\n\n在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。\n\n**常量池主要存放两大类常量：字面量和符号引用。**\n\n字面量比较接近于 Java 语言层面的常量概念，比如文本字符串、声明为 final 的常量值等。\n\n而符号引用则属于编译原理方面的概念，包括了下面三类常量：\n\n- 类和接口的全限定名\n- 字段的名称和描述符\n- 方法的名称和描述符\n\n在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。\n\n当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-06.jpg)\n\n### 访问标志\n在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：\n\n- 这个 Class 是类还是接口\n- 是否定义为 public 类型\n- 是否定义为 abstract 类型\n- 如果是类的话，是否被声明为 final\n- .....\n\n### 类索引、父类索引与接口索引集合\n类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。\n\n类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。\n\n由于 Java 语言不允许多重继承，所以父类索引只有一个，**除了 java.lang.Object 之外，所有的 Java 类都有父类**，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。\n\n接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。\n\n### 字段表集合\n字段表用于描述接口或者类中声明的变量。\n\n字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。\n\n字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。\n\n**另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。**\n\n### 方法表集合\n方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。\n\n方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。\n\n与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类的构造器“`<clinit>`”方法和实例构造器“`<init>`”方法。\n\n在 Java 语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，**也就是因为返回值不会包含在特征签名中，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。**但是在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以并存。**也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。**\n\n### 属性表集合\n在 Class 文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。\n\n#### Code 属性\nCode 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码和元数据两部分，那么在整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。\n\n**在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。**\n\n#### ConstantValue 属性\nConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。**只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。**\n\n对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 `<init>` 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 `<clinit` 方法中或者使用 ConstantValue 属性。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-07.jpg)\n\n## 字节码指令简介\nJava 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。\n\n### 字节码与数据类型\n对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。\n\n大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数据时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。\n\n### 加载和存储指令\n加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容：\n\n- 将一个局部变量加载到操作栈\n- 将一个数值从操作数栈存储到局部变量表\n- 将一个变量加载到操作数栈\n- 扩充局部变量表的访问索引的指令\n\n### 运算指令\n运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。\n\n大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。\n\nJava 虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，**如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式称为向最接近数舍入模式。**\n\n在把浮点数转换为整数时，Java 虚拟机使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。**向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。**\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-08.jpg)\n\n---\nEnd. 这一章节概念的东西比较多，讲了 Class 文件中的种种。","slug":"JVM-Class-File","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh30007k9i11wpaa9ja","content":"<blockquote>\n<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>\n</blockquote>\n<h2 id=\"无关性的基石\"><a href=\"#无关性的基石\" class=\"headerlink\" title=\"无关性的基石\"></a>无关性的基石</h2><p>实现语言无关性的基础是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。</p>\n<p>基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，<strong>但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-language-unrelated.png\" alt=\"Java 虚拟机提供的语言无关性\"></p>\n<p>Java 语言的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的。</p>\n<h2 id=\"Class-类文件的结构\"><a href=\"#Class-类文件的结构\" class=\"headerlink\" title=\"Class 类文件的结构\"></a>Class 类文件的结构</h2><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。</p>\n<p>根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong>。</p>\n<ul>\n<li>无符号数：属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li>\n<li>表：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。</li>\n</ul>\n<p>（这里有关的详细介绍还是请看《深入理解 Java 虚拟机》中的第六章节）</p>\n<h3 id=\"魔数与-Class-文件的版本\"><a href=\"#魔数与-Class-文件的版本\" class=\"headerlink\" title=\"魔数与 Class 文件的版本\"></a>魔数与 Class 文件的版本</h3><p>每个 Class 文件的头 4 个字节称为魔数，它的唯一作用是 <strong>确定这个文件是否为一个能被虚拟机接受的 Class 文件。</strong></p>\n<p>Class 文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝……）</p>\n<p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号。</p>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。</p>\n<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值。<strong>与 Java 中语言习惯不一样的是，这个容量计数是从 1 开始而不是 0。</strong></p>\n<p>在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。</p>\n<p><strong>常量池主要存放两大类常量：字面量和符号引用。</strong></p>\n<p>字面量比较接近于 Java 语言层面的常量概念，比如文本字符串、声明为 final 的常量值等。</p>\n<p>而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n<p>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</p>\n<p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-06.jpg\" alt=\"附上手稿\"></p>\n<h3 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：</p>\n<ul>\n<li>这个 Class 是类还是接口</li>\n<li>是否定义为 public 类型</li>\n<li>是否定义为 abstract 类型</li>\n<li>如果是类的话，是否被声明为 final</li>\n<li>…..</li>\n</ul>\n<h3 id=\"类索引、父类索引与接口索引集合\"><a href=\"#类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"类索引、父类索引与接口索引集合\"></a>类索引、父类索引与接口索引集合</h3><p>类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。</p>\n<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>\n<p>由于 Java 语言不允许多重继承，所以父类索引只有一个，<strong>除了 java.lang.Object 之外，所有的 Java 类都有父类</strong>，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</p>\n<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</p>\n<h3 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h3><p>字段表用于描述接口或者类中声明的变量。</p>\n<p>字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>\n<p>字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>\n<p><strong>另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</strong></p>\n<h3 id=\"方法表集合\"><a href=\"#方法表集合\" class=\"headerlink\" title=\"方法表集合\"></a>方法表集合</h3><p>方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>\n<p>方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p>\n<p>与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类的构造器“<code>&lt;clinit&gt;</code>”方法和实例构造器“<code>&lt;init&gt;</code>”方法。</p>\n<p>在 Java 语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，<strong>也就是因为返回值不会包含在特征签名中，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</strong>但是在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以并存。<strong>也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。</strong></p>\n<h3 id=\"属性表集合\"><a href=\"#属性表集合\" class=\"headerlink\" title=\"属性表集合\"></a>属性表集合</h3><p>在 Class 文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>\n<h4 id=\"Code-属性\"><a href=\"#Code-属性\" class=\"headerlink\" title=\"Code 属性\"></a>Code 属性</h4><p>Code 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码和元数据两部分，那么在整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。</p>\n<p><strong>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。</strong></p>\n<h4 id=\"ConstantValue-属性\"><a href=\"#ConstantValue-属性\" class=\"headerlink\" title=\"ConstantValue 属性\"></a>ConstantValue 属性</h4><p>ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。<strong>只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。</strong></p>\n<p>对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <code>&lt;init&gt;</code> 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 <code>&lt;clinit</code> 方法中或者使用 ConstantValue 属性。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-07.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"字节码指令简介\"><a href=\"#字节码指令简介\" class=\"headerlink\" title=\"字节码指令简介\"></a>字节码指令简介</h2><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。</p>\n<h3 id=\"字节码与数据类型\"><a href=\"#字节码与数据类型\" class=\"headerlink\" title=\"字节码与数据类型\"></a>字节码与数据类型</h3><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。</p>\n<p>大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数据时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。</p>\n<h3 id=\"加载和存储指令\"><a href=\"#加载和存储指令\" class=\"headerlink\" title=\"加载和存储指令\"></a>加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容：</p>\n<ul>\n<li>将一个局部变量加载到操作栈</li>\n<li>将一个数值从操作数栈存储到局部变量表</li>\n<li>将一个变量加载到操作数栈</li>\n<li>扩充局部变量表的访问索引的指令</li>\n</ul>\n<h3 id=\"运算指令\"><a href=\"#运算指令\" class=\"headerlink\" title=\"运算指令\"></a>运算指令</h3><p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>\n<p>大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。</p>\n<p>Java 虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，<strong>如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式称为向最接近数舍入模式。</strong></p>\n<p>在把浮点数转换为整数时，Java 虚拟机使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。<strong>向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-08.jpg\" alt=\"附上手稿\"></p>\n<hr>\n<p>End. 这一章节概念的东西比较多，讲了 Class 文件中的种种。</p>\n","excerpt":"","more":"<blockquote>\n<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>\n</blockquote>\n<h2 id=\"无关性的基石\"><a href=\"#无关性的基石\" class=\"headerlink\" title=\"无关性的基石\"></a>无关性的基石</h2><p>实现语言无关性的基础是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。</p>\n<p>基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，<strong>但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-language-unrelated.png\" alt=\"Java 虚拟机提供的语言无关性\"></p>\n<p>Java 语言的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的。</p>\n<h2 id=\"Class-类文件的结构\"><a href=\"#Class-类文件的结构\" class=\"headerlink\" title=\"Class 类文件的结构\"></a>Class 类文件的结构</h2><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。</p>\n<p>根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong>。</p>\n<ul>\n<li>无符号数：属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li>\n<li>表：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。</li>\n</ul>\n<p>（这里有关的详细介绍还是请看《深入理解 Java 虚拟机》中的第六章节）</p>\n<h3 id=\"魔数与-Class-文件的版本\"><a href=\"#魔数与-Class-文件的版本\" class=\"headerlink\" title=\"魔数与 Class 文件的版本\"></a>魔数与 Class 文件的版本</h3><p>每个 Class 文件的头 4 个字节称为魔数，它的唯一作用是 <strong>确定这个文件是否为一个能被虚拟机接受的 Class 文件。</strong></p>\n<p>Class 文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝……）</p>\n<p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号，第 7 和第 8 个字节是主版本号。</p>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。</p>\n<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值。<strong>与 Java 中语言习惯不一样的是，这个容量计数是从 1 开始而不是 0。</strong></p>\n<p>在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。</p>\n<p><strong>常量池主要存放两大类常量：字面量和符号引用。</strong></p>\n<p>字面量比较接近于 Java 语言层面的常量概念，比如文本字符串、声明为 final 的常量值等。</p>\n<p>而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>\n<ul>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n</ul>\n<p>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。</p>\n<p>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-06.jpg\" alt=\"附上手稿\"></p>\n<h3 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：</p>\n<ul>\n<li>这个 Class 是类还是接口</li>\n<li>是否定义为 public 类型</li>\n<li>是否定义为 abstract 类型</li>\n<li>如果是类的话，是否被声明为 final</li>\n<li>…..</li>\n</ul>\n<h3 id=\"类索引、父类索引与接口索引集合\"><a href=\"#类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"类索引、父类索引与接口索引集合\"></a>类索引、父类索引与接口索引集合</h3><p>类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。</p>\n<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>\n<p>由于 Java 语言不允许多重继承，所以父类索引只有一个，<strong>除了 java.lang.Object 之外，所有的 Java 类都有父类</strong>，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</p>\n<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</p>\n<h3 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h3><p>字段表用于描述接口或者类中声明的变量。</p>\n<p>字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>\n<p>字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</p>\n<p><strong>另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</strong></p>\n<h3 id=\"方法表集合\"><a href=\"#方法表集合\" class=\"headerlink\" title=\"方法表集合\"></a>方法表集合</h3><p>方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>\n<p>方法里的 Java 代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p>\n<p>与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类的构造器“<code>&lt;clinit&gt;</code>”方法和实例构造器“<code>&lt;init&gt;</code>”方法。</p>\n<p>在 Java 语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，<strong>也就是因为返回值不会包含在特征签名中，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</strong>但是在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以并存。<strong>也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。</strong></p>\n<h3 id=\"属性表集合\"><a href=\"#属性表集合\" class=\"headerlink\" title=\"属性表集合\"></a>属性表集合</h3><p>在 Class 文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>\n<h4 id=\"Code-属性\"><a href=\"#Code-属性\" class=\"headerlink\" title=\"Code 属性\"></a>Code 属性</h4><p>Code 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码和元数据两部分，那么在整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。</p>\n<p><strong>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从 1 开始计算。</strong></p>\n<h4 id=\"ConstantValue-属性\"><a href=\"#ConstantValue-属性\" class=\"headerlink\" title=\"ConstantValue 属性\"></a>ConstantValue 属性</h4><p>ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。<strong>只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。</strong></p>\n<p>对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <code>&lt;init&gt;</code> 方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器 <code>&lt;clinit</code> 方法中或者使用 ConstantValue 属性。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-07.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"字节码指令简介\"><a href=\"#字节码指令简介\" class=\"headerlink\" title=\"字节码指令简介\"></a>字节码指令简介</h2><p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。</p>\n<h3 id=\"字节码与数据类型\"><a href=\"#字节码与数据类型\" class=\"headerlink\" title=\"字节码与数据类型\"></a>字节码与数据类型</h3><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。</p>\n<p>大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数据时，也会转换为使用对应的 int 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。</p>\n<h3 id=\"加载和存储指令\"><a href=\"#加载和存储指令\" class=\"headerlink\" title=\"加载和存储指令\"></a>加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容：</p>\n<ul>\n<li>将一个局部变量加载到操作栈</li>\n<li>将一个数值从操作数栈存储到局部变量表</li>\n<li>将一个变量加载到操作数栈</li>\n<li>扩充局部变量表的访问索引的指令</li>\n</ul>\n<h3 id=\"运算指令\"><a href=\"#运算指令\" class=\"headerlink\" title=\"运算指令\"></a>运算指令</h3><p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>\n<p>大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。</p>\n<p>Java 虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，<strong>如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式称为向最接近数舍入模式。</strong></p>\n<p>在把浮点数转换为整数时，Java 虚拟机使用向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。<strong>向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-08.jpg\" alt=\"附上手稿\"></p>\n<hr>\n<p>End. 这一章节概念的东西比较多，讲了 Class 文件中的种种。</p>\n"},{"title":"JVM 之类加载机制","date":"2018-11-25T05:51:14.000Z","_content":"\n> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。\n\n## 概述\n虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。\n\n与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java 里天生可以动态扩展的语言特性就是依赖 **运行期动态加载**和 **动态连接**这个特点实现的。\n\n## 类加载的时机\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。\n\n![类的生命周期](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Period.png)\n\n加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。\n\n对于初始化阶段，虚拟机规范是严格规定了 **有且只有** 5 中情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：\n\n- 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化\n- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化\n\n**这 5 中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。**\n\n被动引用举例：\n\n- 通过子类引用父类的静态字段，不会导致子类初始化\n- 通过数组定义来引用类，不会触发此类的初始化\n- 常量在编译阶段存入常量池中，调用时不会触发定义常量的类的初始化\n\n接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊处理：接口也有初始化过程，虽然接口中不能使用 “static{}” 语句块，但编译器仍然会为接口生成 “`<clinit>()`” 类构造器，用于初始化接口中所定义的成员变量。\n\n**当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。**\n\n## 类加载的过程\n类加载的全过程也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。\n\n### 加载\n“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下 3 件事情：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口\n\n加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。\n\n加载阶段与连接阶段的部分内容是交叉进行的，如一部分字节码文件格式验证动作。\n\n### 验证\n验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n从整体上看，验证阶段大致上会完成下面 4 个阶段的校验动作：\n\n#### 文件格式验证\n第一阶段要验证字节流是否符合 Class 文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内，并且能被当前版本的虚拟机处理。\n\n该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储。\n\n#### 元数据验证\n第二阶段是对字节码描述的信息进行语义分析，对类的元数据信息进行语义校验，以保证其描述的信息符合 Java 语言规范的要求。\n\n#### 字节码验证\n第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n\n如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。**即通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。**\n\n#### 符号引用验证\n最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。\n\n符号引用验证的目的是确保解析动作能正常执行。\n\n对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要的阶段。\n\n### 准备\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。\n\n这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。\n\n`public static int value = 123;`\n\n上述的 value 变量在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 `putstatic` 指令是程序被编译后，存放于类构造器 `<clinit>()` 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。\n\n如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，如：\n\n`public static final int value = 123;`\n\n编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。\n\n### 解析\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。\n- 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。\n\n解析动作主要针对以下 7 类符号引用进行：\n\n- 类或接口的解析\n- 字段解析\n- 类方法解析\n- 接口方法解析\n- 方法类型解析\n- 方法句柄解析\n- 调用点限定符解析\n\n### 初始化\n类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。\n\n初始化阶段是执行类构造器 `<clinit>()` 方法的过程，在这执行过程中一些可能会影响程序运行行为的特点和细节：\n\n- `<clinit>()` 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，**静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。**\n- `<clinit>()` 方法与类的构造函数（或者说实例构造器 `<init>()` 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。因此在虚拟机中第一个被执行的 `<clinit>()` 方法的类肯定是 java.lang.Object。\n- 由于父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。\n- `<clinit>()` 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。\n- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()` 方法。但接口与类不同的是，执行接口的 `<clinit>()` 方法不需要先执行父接口的 `<clinit>()` 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `<clinit>()` 方法。\n- 虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。如果在一个类的 `<clinit>()` 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。\n\n## 类加载器\n虚拟机设计团队把类加载器阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。\n\n### 类与类加载器\n对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。\n\n### 双亲委派模型\n从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：\n\n- 启动类加载器，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分\n- 所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类 java.lang.ClassLoader\n\n类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到一下 3 种系统提供的类加载器：\n\n- 启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 `<JAVA_HOME>\\lib` 目录中的，或者被 `-Xbootclasspath` 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。\n- 扩展类加载器（Extension ClassLoader）：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 `<JAVA_HOME>\\lib\\ext` 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n- 应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。\n\n![类加载器双亲委派模型](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Loader.png)\n\n上图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。\n\n**双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。**\n\n---\nEnd.这一篇由于篇幅过大，故手稿就不丢出来了。还是一些概念，类加载是经常会被面试问到的知识点，可见其重要性了。该啃还是要啃的，就点醋……","source":"_posts/JVM-Class-Load.md","raw":"---\ntitle: JVM 之类加载机制\ndate: 2018-11-25 13:51:14\ncategories: [开发,JVM]\ntags: [Java,JVM]\n---\n\n> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。\n\n## 概述\n虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。\n\n与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java 里天生可以动态扩展的语言特性就是依赖 **运行期动态加载**和 **动态连接**这个特点实现的。\n\n## 类加载的时机\n类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。\n\n![类的生命周期](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Period.png)\n\n加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。\n\n对于初始化阶段，虚拟机规范是严格规定了 **有且只有** 5 中情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：\n\n- 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化\n- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化\n\n**这 5 中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。**\n\n被动引用举例：\n\n- 通过子类引用父类的静态字段，不会导致子类初始化\n- 通过数组定义来引用类，不会触发此类的初始化\n- 常量在编译阶段存入常量池中，调用时不会触发定义常量的类的初始化\n\n接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊处理：接口也有初始化过程，虽然接口中不能使用 “static{}” 语句块，但编译器仍然会为接口生成 “`<clinit>()`” 类构造器，用于初始化接口中所定义的成员变量。\n\n**当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。**\n\n## 类加载的过程\n类加载的全过程也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。\n\n### 加载\n“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下 3 件事情：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口\n\n加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。\n\n加载阶段与连接阶段的部分内容是交叉进行的，如一部分字节码文件格式验证动作。\n\n### 验证\n验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n\n从整体上看，验证阶段大致上会完成下面 4 个阶段的校验动作：\n\n#### 文件格式验证\n第一阶段要验证字节流是否符合 Class 文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内，并且能被当前版本的虚拟机处理。\n\n该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储。\n\n#### 元数据验证\n第二阶段是对字节码描述的信息进行语义分析，对类的元数据信息进行语义校验，以保证其描述的信息符合 Java 语言规范的要求。\n\n#### 字节码验证\n第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n\n如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。**即通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。**\n\n#### 符号引用验证\n最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。\n\n符号引用验证的目的是确保解析动作能正常执行。\n\n对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要的阶段。\n\n### 准备\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。\n\n这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。\n\n`public static int value = 123;`\n\n上述的 value 变量在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 `putstatic` 指令是程序被编译后，存放于类构造器 `<clinit>()` 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。\n\n如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，如：\n\n`public static final int value = 123;`\n\n编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。\n\n### 解析\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。\n\n- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。\n- 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。\n\n解析动作主要针对以下 7 类符号引用进行：\n\n- 类或接口的解析\n- 字段解析\n- 类方法解析\n- 接口方法解析\n- 方法类型解析\n- 方法句柄解析\n- 调用点限定符解析\n\n### 初始化\n类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。\n\n初始化阶段是执行类构造器 `<clinit>()` 方法的过程，在这执行过程中一些可能会影响程序运行行为的特点和细节：\n\n- `<clinit>()` 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，**静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。**\n- `<clinit>()` 方法与类的构造函数（或者说实例构造器 `<init>()` 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 `<clinit>()` 方法执行之前，父类的 `<clinit>()` 方法已经执行完毕。因此在虚拟机中第一个被执行的 `<clinit>()` 方法的类肯定是 java.lang.Object。\n- 由于父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。\n- `<clinit>()` 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法。\n- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 `<clinit>()` 方法。但接口与类不同的是，执行接口的 `<clinit>()` 方法不需要先执行父接口的 `<clinit>()` 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `<clinit>()` 方法。\n- 虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，直到活动线程执行 `<clinit>()` 方法完毕。如果在一个类的 `<clinit>()` 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。\n\n## 类加载器\n虚拟机设计团队把类加载器阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。\n\n### 类与类加载器\n对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。\n\n### 双亲委派模型\n从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：\n\n- 启动类加载器，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分\n- 所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类 java.lang.ClassLoader\n\n类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到一下 3 种系统提供的类加载器：\n\n- 启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 `<JAVA_HOME>\\lib` 目录中的，或者被 `-Xbootclasspath` 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。\n- 扩展类加载器（Extension ClassLoader）：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 `<JAVA_HOME>\\lib\\ext` 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。\n- 应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。\n\n![类加载器双亲委派模型](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Loader.png)\n\n上图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。\n\n**双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。**\n\n---\nEnd.这一篇由于篇幅过大，故手稿就不丢出来了。还是一些概念，类加载是经常会被面试问到的知识点，可见其重要性了。该啃还是要啃的，就点醋……","slug":"JVM-Class-Load","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh30009k9i1cqjz8idc","content":"<blockquote>\n<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>\n<p>与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java 里天生可以动态扩展的语言特性就是依赖 <strong>运行期动态加载</strong>和 <strong>动态连接</strong>这个特点实现的。</p>\n<h2 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Period.png\" alt=\"类的生命周期\"></p>\n<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>\n<p>对于初始化阶段，虚拟机规范是严格规定了 <strong>有且只有</strong> 5 中情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>\n<ul>\n<li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化</li>\n<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li>\n<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>\n</ul>\n<p><strong>这 5 中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</strong></p>\n<p>被动引用举例：</p>\n<ul>\n<li>通过子类引用父类的静态字段，不会导致子类初始化</li>\n<li>通过数组定义来引用类，不会触发此类的初始化</li>\n<li>常量在编译阶段存入常量池中，调用时不会触发定义常量的类的初始化</li>\n</ul>\n<p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊处理：接口也有初始化过程，虽然接口中不能使用 “static{}” 语句块，但编译器仍然会为接口生成 “<code>&lt;clinit&gt;()</code>” 类构造器，用于初始化接口中所定义的成员变量。</p>\n<p><strong>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</strong></p>\n<h2 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h2><p>类加载的全过程也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下 3 件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>\n<p>加载阶段与连接阶段的部分内容是交叉进行的，如一部分字节码文件格式验证动作。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>\n<p>从整体上看，验证阶段大致上会完成下面 4 个阶段的校验动作：</p>\n<h4 id=\"文件格式验证\"><a href=\"#文件格式验证\" class=\"headerlink\" title=\"文件格式验证\"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合 Class 文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内，并且能被当前版本的虚拟机处理。</p>\n<p>该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储。</p>\n<h4 id=\"元数据验证\"><a href=\"#元数据验证\" class=\"headerlink\" title=\"元数据验证\"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，对类的元数据信息进行语义校验，以保证其描述的信息符合 Java 语言规范的要求。</p>\n<h4 id=\"字节码验证\"><a href=\"#字节码验证\" class=\"headerlink\" title=\"字节码验证\"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>\n<p>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。<strong>即通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</strong></p>\n<h4 id=\"符号引用验证\"><a href=\"#符号引用验证\" class=\"headerlink\" title=\"符号引用验证\"></a>符号引用验证</h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p>\n<p>符号引用验证的目的是确保解析动作能正常执行。</p>\n<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要的阶段。</p>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>\n<p>这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p>\n<p><code>public static int value = 123;</code></p>\n<p>上述的 value 变量在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 <code>putstatic</code> 指令是程序被编译后，存放于类构造器 <code>&lt;clinit&gt;()</code> 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。</p>\n<p>如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，如：</p>\n<p><code>public static final int value = 123;</code></p>\n<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>\n<ul>\n<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>\n<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>\n</ul>\n<p>解析动作主要针对以下 7 类符号引用进行：</p>\n<ul>\n<li>类或接口的解析</li>\n<li>字段解析</li>\n<li>类方法解析</li>\n<li>接口方法解析</li>\n<li>方法类型解析</li>\n<li>方法句柄解析</li>\n<li>调用点限定符解析</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。</p>\n<p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程，在这执行过程中一些可能会影响程序运行行为的特点和细节：</p>\n<ul>\n<li><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</strong></li>\n<li><code>&lt;clinit&gt;()</code> 方法与类的构造函数（或者说实例构造器 <code>&lt;init&gt;()</code> 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。因此在虚拟机中第一个被执行的 <code>&lt;clinit&gt;()</code> 方法的类肯定是 java.lang.Object。</li>\n<li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li>\n<li><code>&lt;clinit&gt;()</code> 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</li>\n<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</li>\n<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>\n</ul>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>虚拟机设计团队把类加载器阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：</p>\n<ul>\n<li>启动类加载器，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分</li>\n<li>所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类 java.lang.ClassLoader</li>\n</ul>\n<p>类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到一下 3 种系统提供的类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 <code>&lt;JAVA_HOME&gt;\\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。</li>\n<li>扩展类加载器（Extension ClassLoader）：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 <code>&lt;JAVA_HOME&gt;\\lib\\ext</code> 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>\n</ul>\n<p>我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Loader.png\" alt=\"类加载器双亲委派模型\"></p>\n<p>上图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。</p>\n<p><strong>双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>\n<hr>\n<p>End.这一篇由于篇幅过大，故手稿就不丢出来了。还是一些概念，类加载是经常会被面试问到的知识点，可见其重要性了。该啃还是要啃的，就点醋……</p>\n","excerpt":"","more":"<blockquote>\n<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>\n<p>与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java 里天生可以动态扩展的语言特性就是依赖 <strong>运行期动态加载</strong>和 <strong>动态连接</strong>这个特点实现的。</p>\n<h2 id=\"类加载的时机\"><a href=\"#类加载的时机\" class=\"headerlink\" title=\"类加载的时机\"></a>类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Period.png\" alt=\"类的生命周期\"></p>\n<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>\n<p>对于初始化阶段，虚拟机规范是严格规定了 <strong>有且只有</strong> 5 中情况必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>\n<ul>\n<li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化</li>\n<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li>\n<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li>\n</ul>\n<p><strong>这 5 中场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</strong></p>\n<p>被动引用举例：</p>\n<ul>\n<li>通过子类引用父类的静态字段，不会导致子类初始化</li>\n<li>通过数组定义来引用类，不会触发此类的初始化</li>\n<li>常量在编译阶段存入常量池中，调用时不会触发定义常量的类的初始化</li>\n</ul>\n<p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊处理：接口也有初始化过程，虽然接口中不能使用 “static{}” 语句块，但编译器仍然会为接口生成 “<code>&lt;clinit&gt;()</code>” 类构造器，用于初始化接口中所定义的成员变量。</p>\n<p><strong>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</strong></p>\n<h2 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h2><p>类加载的全过程也就是加载、验证、准备、解析和初始化这 5 个阶段所执行的具体动作。</p>\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下 3 件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>\n<p>加载阶段与连接阶段的部分内容是交叉进行的，如一部分字节码文件格式验证动作。</p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>\n<p>从整体上看，验证阶段大致上会完成下面 4 个阶段的校验动作：</p>\n<h4 id=\"文件格式验证\"><a href=\"#文件格式验证\" class=\"headerlink\" title=\"文件格式验证\"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合 Class 文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内，并且能被当前版本的虚拟机处理。</p>\n<p>该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储。</p>\n<h4 id=\"元数据验证\"><a href=\"#元数据验证\" class=\"headerlink\" title=\"元数据验证\"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，对类的元数据信息进行语义校验，以保证其描述的信息符合 Java 语言规范的要求。</p>\n<h4 id=\"字节码验证\"><a href=\"#字节码验证\" class=\"headerlink\" title=\"字节码验证\"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>\n<p>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。<strong>即通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</strong></p>\n<h4 id=\"符号引用验证\"><a href=\"#符号引用验证\" class=\"headerlink\" title=\"符号引用验证\"></a>符号引用验证</h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p>\n<p>符号引用验证的目的是确保解析动作能正常执行。</p>\n<p>对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要的阶段。</p>\n<h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>\n<p>这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p>\n<p><code>public static int value = 123;</code></p>\n<p>上述的 value 变量在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 <code>putstatic</code> 指令是程序被编译后，存放于类构造器 <code>&lt;clinit&gt;()</code> 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。</p>\n<p>如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，如：</p>\n<p><code>public static final int value = 123;</code></p>\n<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>\n<ul>\n<li>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>\n<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>\n</ul>\n<p>解析动作主要针对以下 7 类符号引用进行：</p>\n<ul>\n<li>类或接口的解析</li>\n<li>字段解析</li>\n<li>类方法解析</li>\n<li>接口方法解析</li>\n<li>方法类型解析</li>\n<li>方法句柄解析</li>\n<li>调用点限定符解析</li>\n</ul>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。</p>\n<p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程，在这执行过程中一些可能会影响程序运行行为的特点和细节：</p>\n<ul>\n<li><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</strong></li>\n<li><code>&lt;clinit&gt;()</code> 方法与类的构造函数（或者说实例构造器 <code>&lt;init&gt;()</code> 方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。因此在虚拟机中第一个被执行的 <code>&lt;clinit&gt;()</code> 方法的类肯定是 java.lang.Object。</li>\n<li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li>\n<li><code>&lt;clinit&gt;()</code> 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</li>\n<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。但接口与类不同的是，执行接口的 <code>&lt;clinit&gt;()</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;()</code> 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <code>&lt;clinit&gt;()</code> 方法。</li>\n<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>\n</ul>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>虚拟机设计团队把类加载器阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>\n<h3 id=\"类与类加载器\"><a href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：</p>\n<ul>\n<li>启动类加载器，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分</li>\n<li>所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类 java.lang.ClassLoader</li>\n</ul>\n<p>类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到一下 3 种系统提供的类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 <code>&lt;JAVA_HOME&gt;\\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。</li>\n<li>扩展类加载器（Extension ClassLoader）：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 <code>&lt;JAVA_HOME&gt;\\lib\\ext</code> 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>\n</ul>\n<p>我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Class-Loader.png\" alt=\"类加载器双亲委派模型\"></p>\n<p>上图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。</p>\n<p><strong>双亲委派模型的工作过程是：如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</strong></p>\n<hr>\n<p>End.这一篇由于篇幅过大，故手稿就不丢出来了。还是一些概念，类加载是经常会被面试问到的知识点，可见其重要性了。该啃还是要啃的，就点醋……</p>\n"},{"title":"JVM 之字节码执行引擎","date":"2018-12-01T07:47:43.000Z","_content":"\n> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。\n\n## 概述\n执行引擎是 Java 虚拟机最核心的组成部分之一。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。\n\n但从外观上看起来，所有的 Java 虚拟机的执行引擎都是一致的：**输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。**接下来将主要从 **概念模型**的角度来总结下虚拟机的 **方法调用**和 **字节码执行**。\n\n## 运行时栈帧结构\n栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。**每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。**\n\n每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此，**一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。**\n\n### 局部变量表\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。它的容量以变量槽（Variable Slot，下称 Slot）为最小单位。\n\n在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 `this` 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。\n\n**局部变量定义了但没有赋初始值，是不能使用的，切记！**\n\n### 操作数栈\n操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，它的最大深度也是在编译时就写入到 Code 属性的 max_stacks 数据项中。\n\n当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作。如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。\n\n### 动态连接\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。\n\n字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为 **静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为 **动态连接**。\n\n### 方法返回地址\n当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n- 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。\n- 在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常还是代码中使用 `athrow` 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。\n\n**一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。**\n\n方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。\n\n### 附加信息\n虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。\n\n**在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。**\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-09.jpg)\n\n## 方法调用\n方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。\n\n**一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。**\n\n### 解析\n调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。\n\n在 Java 虚拟机里面提供了 5 条方法调用字节码指令：\n\n- invokestatic：调用静态方法\n- invokespecial：调用实例构造器 `<init>` 方法、私有方法和父类方法\n- invokevirtual：调用所有的虚方法\n- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象\n- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的 4 条调用指令，分派逻辑是固化在 Java 虚拟机内部的，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的\n\n只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法 4 类。它们在类加载的时候就会把符号引用解析为该方法的直接引用，称为 **非虚方法**。其余的称为 **虚方法**。\n\n**final 方法是一种非虚方法。**\n\n### 分派\n\n#### 静态分派\n`Human man = new Man()`\n\n上面代码中的 `Human` 称为变量的静态类型，或是外观类型，`Man` 称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，但是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。\n\n**编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的，所以，两个静态类型相同但实际类型不同的变量，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪一个重载版本。**\n\n#### 动态分派\n我们先说说重写，重写与动态分派关系密切。invokevirtual 指令执行是在 **运行期**确定接收者的实际类型，所以调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质。\n\n我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-10.jpg)\n\n#### 单分派与多分派\n方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。\n\n单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。\n\n## 基于栈的字节码解释执行引擎\n探讨虚拟机是如何执行方法中的字节码指令的。\n\n### 解释执行\n![编译过程](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Compilation-Process.png)\n\nJava 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。\n\n### 基于栈的指令集与基于寄存器的指令集\n基于栈的指令集主要优点就是可移植，还可把一些访问频繁的数据放到寄存器中获取尽量好的性能，代码会相对更加紧凑，编译器实现更加简单等。\n\n栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需的指令数量较寄存器架构多，频繁的栈访问导致频繁的内存访问。\n\n---\nEnd.","source":"_posts/JVM-Code-Execution-Engine.md","raw":"---\ntitle: JVM 之字节码执行引擎\ndate: 2018-12-01 15:47:43\ncategories: [开发,JVM]\ntags: [Java,JVM]\n---\n\n> 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。\n\n## 概述\n执行引擎是 Java 虚拟机最核心的组成部分之一。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。\n\n但从外观上看起来，所有的 Java 虚拟机的执行引擎都是一致的：**输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。**接下来将主要从 **概念模型**的角度来总结下虚拟机的 **方法调用**和 **字节码执行**。\n\n## 运行时栈帧结构\n栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。**每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。**\n\n每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此，**一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。**\n\n### 局部变量表\n局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。它的容量以变量槽（Variable Slot，下称 Slot）为最小单位。\n\n在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 `this` 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。\n\n**局部变量定义了但没有赋初始值，是不能使用的，切记！**\n\n### 操作数栈\n操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，它的最大深度也是在编译时就写入到 Code 属性的 max_stacks 数据项中。\n\n当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作。如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。\n\n### 动态连接\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。\n\n字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为 **静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为 **动态连接**。\n\n### 方法返回地址\n当一个方法开始执行后，只有两种方式可以退出这个方法：\n\n- 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。\n- 在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常还是代码中使用 `athrow` 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。\n\n**一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。**\n\n方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。\n\n### 附加信息\n虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。\n\n**在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。**\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-09.jpg)\n\n## 方法调用\n方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。\n\n**一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。**\n\n### 解析\n调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。\n\n在 Java 虚拟机里面提供了 5 条方法调用字节码指令：\n\n- invokestatic：调用静态方法\n- invokespecial：调用实例构造器 `<init>` 方法、私有方法和父类方法\n- invokevirtual：调用所有的虚方法\n- invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象\n- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的 4 条调用指令，分派逻辑是固化在 Java 虚拟机内部的，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的\n\n只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法 4 类。它们在类加载的时候就会把符号引用解析为该方法的直接引用，称为 **非虚方法**。其余的称为 **虚方法**。\n\n**final 方法是一种非虚方法。**\n\n### 分派\n\n#### 静态分派\n`Human man = new Man()`\n\n上面代码中的 `Human` 称为变量的静态类型，或是外观类型，`Man` 称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，但是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。\n\n**编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的，所以，两个静态类型相同但实际类型不同的变量，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪一个重载版本。**\n\n#### 动态分派\n我们先说说重写，重写与动态分派关系密切。invokevirtual 指令执行是在 **运行期**确定接收者的实际类型，所以调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质。\n\n我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-10.jpg)\n\n#### 单分派与多分派\n方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。\n\n单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。\n\n## 基于栈的字节码解释执行引擎\n探讨虚拟机是如何执行方法中的字节码指令的。\n\n### 解释执行\n![编译过程](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Compilation-Process.png)\n\nJava 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。\n\n### 基于栈的指令集与基于寄存器的指令集\n基于栈的指令集主要优点就是可移植，还可把一些访问频繁的数据放到寄存器中获取尽量好的性能，代码会相对更加紧凑，编译器实现更加简单等。\n\n栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需的指令数量较寄存器架构多，频繁的栈访问导致频繁的内存访问。\n\n---\nEnd.","slug":"JVM-Code-Execution-Engine","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh4000bk9i16m02bqq4","content":"<blockquote>\n<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>执行引擎是 Java 虚拟机最核心的组成部分之一。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。</p>\n<p>但从外观上看起来，所有的 Java 虚拟机的执行引擎都是一致的：<strong>输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</strong>接下来将主要从 <strong>概念模型</strong>的角度来总结下虚拟机的 <strong>方法调用</strong>和 <strong>字节码执行</strong>。</p>\n<h2 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<strong>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</strong></p>\n<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此，<strong>一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</strong></p>\n<h3 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。它的容量以变量槽（Variable Slot，下称 Slot）为最小单位。</p>\n<p>在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 <code>this</code> 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。</p>\n<p><strong>局部变量定义了但没有赋初始值，是不能使用的，切记！</strong></p>\n<h3 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h3><p>操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，它的最大深度也是在编译时就写入到 Code 属性的 max_stacks 数据项中。</p>\n<p>当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 &#x2F; 入栈操作。如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p>\n<h3 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>\n<p>字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为 <strong>静态解析</strong>。另外一部分将在每一次运行期间转化为直接引用，这部分称为 <strong>动态连接</strong>。</p>\n<h3 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>\n<ul>\n<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li>\n<li>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常还是代码中使用 <code>athrow</code> 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。</li>\n</ul>\n<p><strong>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</strong></p>\n<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p>\n<h3 id=\"附加信息\"><a href=\"#附加信息\" class=\"headerlink\" title=\"附加信息\"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>\n<p><strong>在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-09.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p>\n<p><strong>一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。</strong></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。</p>\n<p>在 Java 虚拟机里面提供了 5 条方法调用字节码指令：</p>\n<ul>\n<li>invokestatic：调用静态方法</li>\n<li>invokespecial：调用实例构造器 <code>&lt;init&gt;</code> 方法、私有方法和父类方法</li>\n<li>invokevirtual：调用所有的虚方法</li>\n<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>\n<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的 4 条调用指令，分派逻辑是固化在 Java 虚拟机内部的，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的</li>\n</ul>\n<p>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法 4 类。它们在类加载的时候就会把符号引用解析为该方法的直接引用，称为 <strong>非虚方法</strong>。其余的称为 <strong>虚方法</strong>。</p>\n<p><strong>final 方法是一种非虚方法。</strong></p>\n<h3 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h3><h4 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h4><p><code>Human man = new Man()</code></p>\n<p>上面代码中的 <code>Human</code> 称为变量的静态类型，或是外观类型，<code>Man</code> 称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，但是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。</p>\n<p><strong>编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的，所以，两个静态类型相同但实际类型不同的变量，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪一个重载版本。</strong></p>\n<h4 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h4><p>我们先说说重写，重写与动态分派关系密切。invokevirtual 指令执行是在 <strong>运行期</strong>确定接收者的实际类型，所以调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质。</p>\n<p>我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-10.jpg\" alt=\"附上手稿\"></p>\n<h4 id=\"单分派与多分派\"><a href=\"#单分派与多分派\" class=\"headerlink\" title=\"单分派与多分派\"></a>单分派与多分派</h4><p>方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</p>\n<p>单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</p>\n<h2 id=\"基于栈的字节码解释执行引擎\"><a href=\"#基于栈的字节码解释执行引擎\" class=\"headerlink\" title=\"基于栈的字节码解释执行引擎\"></a>基于栈的字节码解释执行引擎</h2><p>探讨虚拟机是如何执行方法中的字节码指令的。</p>\n<h3 id=\"解释执行\"><a href=\"#解释执行\" class=\"headerlink\" title=\"解释执行\"></a>解释执行</h3><p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Compilation-Process.png\" alt=\"编译过程\"></p>\n<p>Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。</p>\n<h3 id=\"基于栈的指令集与基于寄存器的指令集\"><a href=\"#基于栈的指令集与基于寄存器的指令集\" class=\"headerlink\" title=\"基于栈的指令集与基于寄存器的指令集\"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集主要优点就是可移植，还可把一些访问频繁的数据放到寄存器中获取尽量好的性能，代码会相对更加紧凑，编译器实现更加简单等。</p>\n<p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需的指令数量较寄存器架构多，频繁的栈访问导致频繁的内存访问。</p>\n<hr>\n<p>End.</p>\n","excerpt":"","more":"<blockquote>\n<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>执行引擎是 Java 虚拟机最核心的组成部分之一。在不同的虚拟机实现里面，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。</p>\n<p>但从外观上看起来，所有的 Java 虚拟机的执行引擎都是一致的：<strong>输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</strong>接下来将主要从 <strong>概念模型</strong>的角度来总结下虚拟机的 <strong>方法调用</strong>和 <strong>字节码执行</strong>。</p>\n<h2 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h2><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。<strong>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</strong></p>\n<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此，<strong>一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</strong></p>\n<h3 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。它的容量以变量槽（Variable Slot，下称 Slot）为最小单位。</p>\n<p>在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非 static 的方法），那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字 <code>this</code> 来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从 1 开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。</p>\n<p><strong>局部变量定义了但没有赋初始值，是不能使用的，切记！</strong></p>\n<h3 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h3><p>操作数栈也常称为操作栈，它是一个后入先出栈。同局部变量表一样，它的最大深度也是在编译时就写入到 Code 属性的 max_stacks 数据项中。</p>\n<p>当一个方法刚刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 &#x2F; 入栈操作。如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p>\n<h3 id=\"动态连接\"><a href=\"#动态连接\" class=\"headerlink\" title=\"动态连接\"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>\n<p>字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为 <strong>静态解析</strong>。另外一部分将在每一次运行期间转化为直接引用，这部分称为 <strong>动态连接</strong>。</p>\n<h3 id=\"方法返回地址\"><a href=\"#方法返回地址\" class=\"headerlink\" title=\"方法返回地址\"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>\n<ul>\n<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li>\n<li>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常还是代码中使用 <code>athrow</code> 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。</li>\n</ul>\n<p><strong>一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</strong></p>\n<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p>\n<h3 id=\"附加信息\"><a href=\"#附加信息\" class=\"headerlink\" title=\"附加信息\"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>\n<p><strong>在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-09.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p>\n<p><strong>一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。</strong></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。</p>\n<p>在 Java 虚拟机里面提供了 5 条方法调用字节码指令：</p>\n<ul>\n<li>invokestatic：调用静态方法</li>\n<li>invokespecial：调用实例构造器 <code>&lt;init&gt;</code> 方法、私有方法和父类方法</li>\n<li>invokevirtual：调用所有的虚方法</li>\n<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>\n<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的 4 条调用指令，分派逻辑是固化在 Java 虚拟机内部的，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的</li>\n</ul>\n<p>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法 4 类。它们在类加载的时候就会把符号引用解析为该方法的直接引用，称为 <strong>非虚方法</strong>。其余的称为 <strong>虚方法</strong>。</p>\n<p><strong>final 方法是一种非虚方法。</strong></p>\n<h3 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h3><h4 id=\"静态分派\"><a href=\"#静态分派\" class=\"headerlink\" title=\"静态分派\"></a>静态分派</h4><p><code>Human man = new Man()</code></p>\n<p>上面代码中的 <code>Human</code> 称为变量的静态类型，或是外观类型，<code>Man</code> 称为变量的实际类型。静态类型和实际类型在程序中都可以发生一些变化，但是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序时并不知道一个对象的实际类型是什么。</p>\n<p><strong>编译器在重载时是通过参数的静态类型而不是实际类型作为判断依据的，所以，两个静态类型相同但实际类型不同的变量，在编译阶段，Javac 编译器会根据参数的静态类型决定使用哪一个重载版本。</strong></p>\n<h4 id=\"动态分派\"><a href=\"#动态分派\" class=\"headerlink\" title=\"动态分派\"></a>动态分派</h4><p>我们先说说重写，重写与动态分派关系密切。invokevirtual 指令执行是在 <strong>运行期</strong>确定接收者的实际类型，所以调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是 Java 语言中方法重写的本质。</p>\n<p>我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-10.jpg\" alt=\"附上手稿\"></p>\n<h4 id=\"单分派与多分派\"><a href=\"#单分派与多分派\" class=\"headerlink\" title=\"单分派与多分派\"></a>单分派与多分派</h4><p>方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</p>\n<p>单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。</p>\n<h2 id=\"基于栈的字节码解释执行引擎\"><a href=\"#基于栈的字节码解释执行引擎\" class=\"headerlink\" title=\"基于栈的字节码解释执行引擎\"></a>基于栈的字节码解释执行引擎</h2><p>探讨虚拟机是如何执行方法中的字节码指令的。</p>\n<h3 id=\"解释执行\"><a href=\"#解释执行\" class=\"headerlink\" title=\"解释执行\"></a>解释执行</h3><p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/JVM-Compilation-Process.png\" alt=\"编译过程\"></p>\n<p>Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。</p>\n<h3 id=\"基于栈的指令集与基于寄存器的指令集\"><a href=\"#基于栈的指令集与基于寄存器的指令集\" class=\"headerlink\" title=\"基于栈的指令集与基于寄存器的指令集\"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集主要优点就是可移植，还可把一些访问频繁的数据放到寄存器中获取尽量好的性能，代码会相对更加紧凑，编译器实现更加简单等。</p>\n<p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些，完成相同功能所需的指令数量较寄存器架构多，频繁的栈访问导致频繁的内存访问。</p>\n<hr>\n<p>End.</p>\n"},{"title":"JVM 之垃圾收集器与内存分配策略","date":"2018-11-19T13:33:59.000Z","_content":"\n> Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n\n## 对象死活\n垃圾收集器在对堆进行回收前，第一件事就是要确认这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）\n\n### 引用计数法\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。这就是引用计数法。\n\n**但是，主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。**\n\n### 可达性分析算法\n这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 **引用链**，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。\n\n![可达性分析算法判定对象是否可回收](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/Reachability-Analysis.png)\n\n上图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会判定为是可回收的对象。\n\n在 Java 语言中，可作为 GC Roots 的对象包括下面几种：\n\n- 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n- 方法区中类静态属性引用的对象。\n- 方法区中常量引用的对象。\n- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。\n\n### 引用\n在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。\n\n在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用 4 种，这 4 种引用强度依次逐渐减弱。\n\n- 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。\n- 软引用是用来描述一些 **还有用但并非必需的对象**。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中 **进行第二次回收**。如果这次回收还没有足够的内存，才会抛出内存溢出异常。**在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。**\n- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。**\n- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。**\n\n### 生存 Or 死亡\n即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n- 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。**当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。**\n- 如果这个对象被判定为有必要执行 finalize() 方法，那这个对象将会放置在一个叫做 **F-Queue** 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalize 线程去执行它。\n\nfinalize() 方法是对象逃脱死亡命运的最后一次机会，GC 将会对 F-Queue 中的对象进行第二次小规模的标记，对象只要重新与引用链上的任何一个对象建立关联才能拯救自己。\n\n**注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次。**\n\n### 回收方法区\n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。\n\n类需要同时满足下面 3 个条件才能算是“无用的类”：\n\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 ClassLoader 已经被回收。\n- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-03.jpg)\n\n## 垃圾收集算法\n### 标记-清除算法\n算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n\n它的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n### 复制算法\n为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。**当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。**\n\n### 标记-整理算法\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。\n\n根据老年代的特点，有人提出了这种算法，标记过程还是一样，后续则让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n## HotSpot 的算法实现\n### 枚举根节点\n可达性分析从 GC Roots 节点找引用链这个操作，如果逐个检查这里面的引用必然会消耗很多时间，且此分析工作必须在一个能确保一致性的快照中进行，即不可以出现分析过程中对象引用关系还在不断变化的情况。**所以 GC 进行时必须停顿所有 Java 执行线程。**\n\n在 HotSpot 的实现中使用一组称为 OopMap 的数据结构来得知哪些地方存放着对象引用。\n\n### 安全点\nHotSpot 没有为每条指令都生成 OopMap,只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。\n\n### 安全区域\n若是程序没有分配 CPU 时间，这时候线程就无法响应 JVM 的中断请求。如线程处于 Sleep 状态或者 Blocked 状态。这种情况下就需要安全区域来解决。\n\n## 垃圾收集器\n### Serial 收集器\nSerial 收集器是最基本、发展历史最悠久的收集器。**它是一个单线程的收集器，进行垃圾收集时必须暂停其他所有的工作线程，直到它收集结束。**\n\n### ParNew 收集器\nParNew 收集器其实就是 Serial 收集器的多线程版本。\n\n### Parallel Scavenge 收集器\nParallel Scavenge 收集器的目的是达到一个可控制的吞吐量。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n\n### Serial Old 收集器\nSerial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器。\n\n### Parallel Old 收集器\nParallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。\n\n### CMS 收集器\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\n\nCMS 收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤：\n\n- 初始标记（CMS initial mark）\n- 并发标记（CMS concurrent mark）\n- 重新标记（CMS remark）\n- 并发清除（CMS concurrent sweep）\n\nCMS 有以下 3 个明显的缺点：\n\n- CMS 收集器对 CPU 资源非常敏感。\n- CMS 收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。\n- CMS 是基于“标记-清除”算法实现的，收集结束时会产生大量空间碎片。\n\n### G1 收集器\nG1 是一款面向服务端应用的垃圾收集器。与其他 GC 收集器相比，特点如下：\n\n- 并行与并发\n- 分代收集\n- 空间整合\n- 可预测的停顿\n\nG1 收集器的运作大致可划分为以下几个步骤：\n\n- 初始标记（Initial Marking）\n- 并发标记（Concurrent Marking）\n- 最终标记（Final Marking）\n- 筛选回收（Live Data Counting and Evacuation）\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-04.jpg)\n\n## 内存分配与回收策略\nJava 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配给对象的内存。\n\n### 对象优先在 Eden 分配\n大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。\n\n### 大对象直接进入老年代\n所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的就是很长的字符串以及数组。\n\n### 长期存活的对象将进入老年代\n虚拟机给每个对象定义了一个对象年龄计数器。**如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程序（默认为 15 岁），就将会被晋升到老年代中。**\n\n### 动态对象年龄判定\n如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代。\n\n### 空间分配担保\n新生代使用复制收集算法，为了内存利用率之使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-05.jpg)\n\n---\n好困啊……2018-11-20 00:37:02","source":"_posts/JVM-GC.md","raw":"---\ntitle: JVM 之垃圾收集器与内存分配策略\ndate: 2018-11-19 21:33:59\ncategories: [开发,JVM]\ntags: [Java,JVM]\n---\n\n> Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n\n## 对象死活\n垃圾收集器在对堆进行回收前，第一件事就是要确认这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）\n\n### 引用计数法\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。这就是引用计数法。\n\n**但是，主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。**\n\n### 可达性分析算法\n这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 **引用链**，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。\n\n![可达性分析算法判定对象是否可回收](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/Reachability-Analysis.png)\n\n上图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会判定为是可回收的对象。\n\n在 Java 语言中，可作为 GC Roots 的对象包括下面几种：\n\n- 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n- 方法区中类静态属性引用的对象。\n- 方法区中常量引用的对象。\n- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。\n\n### 引用\n在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。\n\n在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用 4 种，这 4 种引用强度依次逐渐减弱。\n\n- 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。\n- 软引用是用来描述一些 **还有用但并非必需的对象**。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中 **进行第二次回收**。如果这次回收还没有足够的内存，才会抛出内存溢出异常。**在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。**\n- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，**被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。**\n- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。**为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。**\n\n### 生存 Or 死亡\n即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n- 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。**当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。**\n- 如果这个对象被判定为有必要执行 finalize() 方法，那这个对象将会放置在一个叫做 **F-Queue** 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalize 线程去执行它。\n\nfinalize() 方法是对象逃脱死亡命运的最后一次机会，GC 将会对 F-Queue 中的对象进行第二次小规模的标记，对象只要重新与引用链上的任何一个对象建立关联才能拯救自己。\n\n**注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次。**\n\n### 回收方法区\n永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。\n\n类需要同时满足下面 3 个条件才能算是“无用的类”：\n\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 ClassLoader 已经被回收。\n- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-03.jpg)\n\n## 垃圾收集算法\n### 标记-清除算法\n算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n\n它的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n### 复制算法\n为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。**当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。**\n\n### 标记-整理算法\n复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。\n\n根据老年代的特点，有人提出了这种算法，标记过程还是一样，后续则让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n## HotSpot 的算法实现\n### 枚举根节点\n可达性分析从 GC Roots 节点找引用链这个操作，如果逐个检查这里面的引用必然会消耗很多时间，且此分析工作必须在一个能确保一致性的快照中进行，即不可以出现分析过程中对象引用关系还在不断变化的情况。**所以 GC 进行时必须停顿所有 Java 执行线程。**\n\n在 HotSpot 的实现中使用一组称为 OopMap 的数据结构来得知哪些地方存放着对象引用。\n\n### 安全点\nHotSpot 没有为每条指令都生成 OopMap,只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。\n\n### 安全区域\n若是程序没有分配 CPU 时间，这时候线程就无法响应 JVM 的中断请求。如线程处于 Sleep 状态或者 Blocked 状态。这种情况下就需要安全区域来解决。\n\n## 垃圾收集器\n### Serial 收集器\nSerial 收集器是最基本、发展历史最悠久的收集器。**它是一个单线程的收集器，进行垃圾收集时必须暂停其他所有的工作线程，直到它收集结束。**\n\n### ParNew 收集器\nParNew 收集器其实就是 Serial 收集器的多线程版本。\n\n### Parallel Scavenge 收集器\nParallel Scavenge 收集器的目的是达到一个可控制的吞吐量。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n\n### Serial Old 收集器\nSerial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器。\n\n### Parallel Old 收集器\nParallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。\n\n### CMS 收集器\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。\n\nCMS 收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤：\n\n- 初始标记（CMS initial mark）\n- 并发标记（CMS concurrent mark）\n- 重新标记（CMS remark）\n- 并发清除（CMS concurrent sweep）\n\nCMS 有以下 3 个明显的缺点：\n\n- CMS 收集器对 CPU 资源非常敏感。\n- CMS 收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。\n- CMS 是基于“标记-清除”算法实现的，收集结束时会产生大量空间碎片。\n\n### G1 收集器\nG1 是一款面向服务端应用的垃圾收集器。与其他 GC 收集器相比，特点如下：\n\n- 并行与并发\n- 分代收集\n- 空间整合\n- 可预测的停顿\n\nG1 收集器的运作大致可划分为以下几个步骤：\n\n- 初始标记（Initial Marking）\n- 并发标记（Concurrent Marking）\n- 最终标记（Final Marking）\n- 筛选回收（Live Data Counting and Evacuation）\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-04.jpg)\n\n## 内存分配与回收策略\nJava 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配给对象的内存。\n\n### 对象优先在 Eden 分配\n大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。\n\n### 大对象直接进入老年代\n所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的就是很长的字符串以及数组。\n\n### 长期存活的对象将进入老年代\n虚拟机给每个对象定义了一个对象年龄计数器。**如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程序（默认为 15 岁），就将会被晋升到老年代中。**\n\n### 动态对象年龄判定\n如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代。\n\n### 空间分配担保\n新生代使用复制收集算法，为了内存利用率之使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-05.jpg)\n\n---\n好困啊……2018-11-20 00:37:02","slug":"JVM-GC","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh4000ek9i1gotb7l6p","content":"<blockquote>\n<p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>\n</blockquote>\n<h2 id=\"对象死活\"><a href=\"#对象死活\" class=\"headerlink\" title=\"对象死活\"></a>对象死活</h2><p>垃圾收集器在对堆进行回收前，第一件事就是要确认这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。这就是引用计数法。</p>\n<p><strong>但是，主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p>\n<h3 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h3><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 <strong>引用链</strong>，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/Reachability-Analysis.png\" alt=\"可达性分析算法判定对象是否可回收\"></p>\n<p>上图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会判定为是可回收的对象。</p>\n<p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>\n<li>方法区中类静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>\n</ul>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p>\n<p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用 4 种，这 4 种引用强度依次逐渐减弱。</p>\n<ul>\n<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj &#x3D; new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>\n<li>软引用是用来描述一些 <strong>还有用但并非必需的对象</strong>。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中 <strong>进行第二次回收</strong>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<strong>在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。</strong></li>\n<li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<strong>在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</strong></li>\n<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</strong></li>\n</ul>\n<h3 id=\"生存-Or-死亡\"><a href=\"#生存-Or-死亡\" class=\"headerlink\" title=\"生存 Or 死亡\"></a>生存 Or 死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ul>\n<li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。<strong>当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</strong></li>\n<li>如果这个对象被判定为有必要执行 finalize() 方法，那这个对象将会放置在一个叫做 <strong>F-Queue</strong> 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalize 线程去执行它。</li>\n</ul>\n<p>finalize() 方法是对象逃脱死亡命运的最后一次机会，GC 将会对 F-Queue 中的对象进行第二次小规模的标记，对象只要重新与引用链上的任何一个对象建立关联才能拯救自己。</p>\n<p><strong>注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次。</strong></p>\n<h3 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>\n<p>类需要同时满足下面 3 个条件才能算是“无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 ClassLoader 已经被回收。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-03.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>\n<p>它的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。<strong>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong></p>\n<h3 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</p>\n<p>根据老年代的特点，有人提出了这种算法，标记过程还是一样，后续则让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<h2 id=\"HotSpot-的算法实现\"><a href=\"#HotSpot-的算法实现\" class=\"headerlink\" title=\"HotSpot 的算法实现\"></a>HotSpot 的算法实现</h2><h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>可达性分析从 GC Roots 节点找引用链这个操作，如果逐个检查这里面的引用必然会消耗很多时间，且此分析工作必须在一个能确保一致性的快照中进行，即不可以出现分析过程中对象引用关系还在不断变化的情况。<strong>所以 GC 进行时必须停顿所有 Java 执行线程。</strong></p>\n<p>在 HotSpot 的实现中使用一组称为 OopMap 的数据结构来得知哪些地方存放着对象引用。</p>\n<h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>HotSpot 没有为每条指令都生成 OopMap,只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。</p>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>若是程序没有分配 CPU 时间，这时候线程就无法响应 JVM 的中断请求。如线程处于 Sleep 状态或者 Blocked 状态。这种情况下就需要安全区域来解决。</p>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><h3 id=\"Serial-收集器\"><a href=\"#Serial-收集器\" class=\"headerlink\" title=\"Serial 收集器\"></a>Serial 收集器</h3><p>Serial 收集器是最基本、发展历史最悠久的收集器。<strong>它是一个单线程的收集器，进行垃圾收集时必须暂停其他所有的工作线程，直到它收集结束。</strong></p>\n<h3 id=\"ParNew-收集器\"><a href=\"#ParNew-收集器\" class=\"headerlink\" title=\"ParNew 收集器\"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本。</p>\n<h3 id=\"Parallel-Scavenge-收集器\"><a href=\"#Parallel-Scavenge-收集器\" class=\"headerlink\" title=\"Parallel Scavenge 收集器\"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）。</p>\n<h3 id=\"Serial-Old-收集器\"><a href=\"#Serial-Old-收集器\" class=\"headerlink\" title=\"Serial Old 收集器\"></a>Serial Old 收集器</h3><p>Serial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器。</p>\n<h3 id=\"Parallel-Old-收集器\"><a href=\"#Parallel-Old-收集器\" class=\"headerlink\" title=\"Parallel Old 收集器\"></a>Parallel Old 收集器</h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。</p>\n<h3 id=\"CMS-收集器\"><a href=\"#CMS-收集器\" class=\"headerlink\" title=\"CMS 收集器\"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>\n<p>CMS 收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤：</p>\n<ul>\n<li>初始标记（CMS initial mark）</li>\n<li>并发标记（CMS concurrent mark）</li>\n<li>重新标记（CMS remark）</li>\n<li>并发清除（CMS concurrent sweep）</li>\n</ul>\n<p>CMS 有以下 3 个明显的缺点：</p>\n<ul>\n<li>CMS 收集器对 CPU 资源非常敏感。</li>\n<li>CMS 收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。</li>\n<li>CMS 是基于“标记-清除”算法实现的，收集结束时会产生大量空间碎片。</li>\n</ul>\n<h3 id=\"G1-收集器\"><a href=\"#G1-收集器\" class=\"headerlink\" title=\"G1 收集器\"></a>G1 收集器</h3><p>G1 是一款面向服务端应用的垃圾收集器。与其他 GC 收集器相比，特点如下：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测的停顿</li>\n</ul>\n<p>G1 收集器的运作大致可划分为以下几个步骤：</p>\n<ul>\n<li>初始标记（Initial Marking）</li>\n<li>并发标记（Concurrent Marking）</li>\n<li>最终标记（Final Marking）</li>\n<li>筛选回收（Live Data Counting and Evacuation）</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-04.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h2><p>Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配给对象的内存。</p>\n<h3 id=\"对象优先在-Eden-分配\"><a href=\"#对象优先在-Eden-分配\" class=\"headerlink\" title=\"对象优先在 Eden 分配\"></a>对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>\n<h3 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的就是很长的字符串以及数组。</p>\n<h3 id=\"长期存活的对象将进入老年代\"><a href=\"#长期存活的对象将进入老年代\" class=\"headerlink\" title=\"长期存活的对象将进入老年代\"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄计数器。<strong>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程序（默认为 15 岁），就将会被晋升到老年代中。</strong></p>\n<h3 id=\"动态对象年龄判定\"><a href=\"#动态对象年龄判定\" class=\"headerlink\" title=\"动态对象年龄判定\"></a>动态对象年龄判定</h3><p>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代。</p>\n<h3 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h3><p>新生代使用复制收集算法，为了内存利用率之使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-05.jpg\" alt=\"附上手稿\"></p>\n<hr>\n<p>好困啊……2018-11-20 00:37:02</p>\n","excerpt":"","more":"<blockquote>\n<p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>\n</blockquote>\n<h2 id=\"对象死活\"><a href=\"#对象死活\" class=\"headerlink\" title=\"对象死活\"></a>对象死活</h2><p>垃圾收集器在对堆进行回收前，第一件事就是要确认这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）</p>\n<h3 id=\"引用计数法\"><a href=\"#引用计数法\" class=\"headerlink\" title=\"引用计数法\"></a>引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。这就是引用计数法。</p>\n<p><strong>但是，主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p>\n<h3 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h3><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 <strong>引用链</strong>，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/Reachability-Analysis.png\" alt=\"可达性分析算法判定对象是否可回收\"></p>\n<p>上图所示，对象 object 5、object 6、object 7 虽然互相有关联，但是它们到 GC Roots 是不可达的，所以它们将会判定为是可回收的对象。</p>\n<p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>\n<li>方法区中类静态属性引用的对象。</li>\n<li>方法区中常量引用的对象。</li>\n<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>\n</ul>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>在 JDK 1.2 以前，Java 中的引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</p>\n<p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用 4 种，这 4 种引用强度依次逐渐减弱。</p>\n<ul>\n<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj &#x3D; new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>\n<li>软引用是用来描述一些 <strong>还有用但并非必需的对象</strong>。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中 <strong>进行第二次回收</strong>。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<strong>在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。</strong></li>\n<li>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生之前。</strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<strong>在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。</strong></li>\n<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了 PhantomReference 类来实现虚引用。</strong></li>\n</ul>\n<h3 id=\"生存-Or-死亡\"><a href=\"#生存-Or-死亡\" class=\"headerlink\" title=\"生存 Or 死亡\"></a>生存 Or 死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ul>\n<li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。<strong>当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</strong></li>\n<li>如果这个对象被判定为有必要执行 finalize() 方法，那这个对象将会放置在一个叫做 <strong>F-Queue</strong> 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalize 线程去执行它。</li>\n</ul>\n<p>finalize() 方法是对象逃脱死亡命运的最后一次机会，GC 将会对 F-Queue 中的对象进行第二次小规模的标记，对象只要重新与引用链上的任何一个对象建立关联才能拯救自己。</p>\n<p><strong>注意：任何一个对象的 finalize() 方法都只会被系统自动调用一次。</strong></p>\n<h3 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>\n<p>类需要同时满足下面 3 个条件才能算是“无用的类”：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 ClassLoader 已经被回收。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-03.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>\n<p>它的不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>为了解决效率问题，一种称为“复制”的收集算法出现了，它将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。<strong>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong></p>\n<h3 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</p>\n<p>根据老年代的特点，有人提出了这种算法，标记过程还是一样，后续则让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<h2 id=\"HotSpot-的算法实现\"><a href=\"#HotSpot-的算法实现\" class=\"headerlink\" title=\"HotSpot 的算法实现\"></a>HotSpot 的算法实现</h2><h3 id=\"枚举根节点\"><a href=\"#枚举根节点\" class=\"headerlink\" title=\"枚举根节点\"></a>枚举根节点</h3><p>可达性分析从 GC Roots 节点找引用链这个操作，如果逐个检查这里面的引用必然会消耗很多时间，且此分析工作必须在一个能确保一致性的快照中进行，即不可以出现分析过程中对象引用关系还在不断变化的情况。<strong>所以 GC 进行时必须停顿所有 Java 执行线程。</strong></p>\n<p>在 HotSpot 的实现中使用一组称为 OopMap 的数据结构来得知哪些地方存放着对象引用。</p>\n<h3 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h3><p>HotSpot 没有为每条指令都生成 OopMap,只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。</p>\n<h3 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h3><p>若是程序没有分配 CPU 时间，这时候线程就无法响应 JVM 的中断请求。如线程处于 Sleep 状态或者 Blocked 状态。这种情况下就需要安全区域来解决。</p>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><h3 id=\"Serial-收集器\"><a href=\"#Serial-收集器\" class=\"headerlink\" title=\"Serial 收集器\"></a>Serial 收集器</h3><p>Serial 收集器是最基本、发展历史最悠久的收集器。<strong>它是一个单线程的收集器，进行垃圾收集时必须暂停其他所有的工作线程，直到它收集结束。</strong></p>\n<h3 id=\"ParNew-收集器\"><a href=\"#ParNew-收集器\" class=\"headerlink\" title=\"ParNew 收集器\"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本。</p>\n<h3 id=\"Parallel-Scavenge-收集器\"><a href=\"#Parallel-Scavenge-收集器\" class=\"headerlink\" title=\"Parallel Scavenge 收集器\"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）。</p>\n<h3 id=\"Serial-Old-收集器\"><a href=\"#Serial-Old-收集器\" class=\"headerlink\" title=\"Serial Old 收集器\"></a>Serial Old 收集器</h3><p>Serial Old 是 Serial 收集器的老年代版本，同样是一个单线程收集器。</p>\n<h3 id=\"Parallel-Old-收集器\"><a href=\"#Parallel-Old-收集器\" class=\"headerlink\" title=\"Parallel Old 收集器\"></a>Parallel Old 收集器</h3><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。</p>\n<h3 id=\"CMS-收集器\"><a href=\"#CMS-收集器\" class=\"headerlink\" title=\"CMS 收集器\"></a>CMS 收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>\n<p>CMS 收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为 4 个步骤：</p>\n<ul>\n<li>初始标记（CMS initial mark）</li>\n<li>并发标记（CMS concurrent mark）</li>\n<li>重新标记（CMS remark）</li>\n<li>并发清除（CMS concurrent sweep）</li>\n</ul>\n<p>CMS 有以下 3 个明显的缺点：</p>\n<ul>\n<li>CMS 收集器对 CPU 资源非常敏感。</li>\n<li>CMS 收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。</li>\n<li>CMS 是基于“标记-清除”算法实现的，收集结束时会产生大量空间碎片。</li>\n</ul>\n<h3 id=\"G1-收集器\"><a href=\"#G1-收集器\" class=\"headerlink\" title=\"G1 收集器\"></a>G1 收集器</h3><p>G1 是一款面向服务端应用的垃圾收集器。与其他 GC 收集器相比，特点如下：</p>\n<ul>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合</li>\n<li>可预测的停顿</li>\n</ul>\n<p>G1 收集器的运作大致可划分为以下几个步骤：</p>\n<ul>\n<li>初始标记（Initial Marking）</li>\n<li>并发标记（Concurrent Marking）</li>\n<li>最终标记（Final Marking）</li>\n<li>筛选回收（Live Data Counting and Evacuation）</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-04.jpg\" alt=\"附上手稿\"></p>\n<h2 id=\"内存分配与回收策略\"><a href=\"#内存分配与回收策略\" class=\"headerlink\" title=\"内存分配与回收策略\"></a>内存分配与回收策略</h2><p>Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配给对象的内存。</p>\n<h3 id=\"对象优先在-Eden-分配\"><a href=\"#对象优先在-Eden-分配\" class=\"headerlink\" title=\"对象优先在 Eden 分配\"></a>对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>\n<h3 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的就是很长的字符串以及数组。</p>\n<h3 id=\"长期存活的对象将进入老年代\"><a href=\"#长期存活的对象将进入老年代\" class=\"headerlink\" title=\"长期存活的对象将进入老年代\"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄计数器。<strong>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程序（默认为 15 岁），就将会被晋升到老年代中。</strong></p>\n<h3 id=\"动态对象年龄判定\"><a href=\"#动态对象年龄判定\" class=\"headerlink\" title=\"动态对象年龄判定\"></a>动态对象年龄判定</h3><p>如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代。</p>\n<h3 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h3><p>新生代使用复制收集算法，为了内存利用率之使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接进入老年代。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-05.jpg\" alt=\"附上手稿\"></p>\n<hr>\n<p>好困啊……2018-11-20 00:37:02</p>\n"},{"title":"JVM 之 Java 内存区域与内存溢出异常","date":"2018-11-18T17:16:24.000Z","_content":"\n> Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n\n## 运行时数据区域\nJava 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java 虚拟机规范（Java SE 7 版）》的规定，包括如下几个运行时数据区域，如图：\n![Java 虚拟机运行时数据区](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-runtime-dataarea.png)\n\n### 程序计数器\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。\n\n由于 Java 虚拟机的多线程是通过 **线程轮流切换并分配处理器执行时间的方式**来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。**因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，**这类内存区域称为“线程私有”的内存。\n\n- 线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；\n- 线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。\n\n**此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。**\n\n### Java 虚拟机栈\n与程序计数器一样它也是线程私有的，它的生命周期与线程相同。**虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。**\n\n在 Java 虚拟机规范中，对这个区域规定了两种异常状况：\n\n- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；\n- 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。\n\n### 本地方法栈\n本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是 **虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**\n\n### Java 堆\nJava 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。\n\n此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。\n\n**但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。**\n\nJava 堆是垃圾收集器管理的主要区域，所以有时也称之为“GC 堆”。\n\n- 内存回收角度看，它可以细分为新生代和老年代，细致一点可以分为 Eden 空间、From Survivor 空间、To Survivor 空间等。\n- 内存分配角度看，它可能划分出多个线程私有的分配缓冲区。\n\n### 方法区\n方法区与 Java 堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**\n\nJava 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。\n\n根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。\n\n### 运行时常量池\n运行时常量池是方法区的一部分。它相对于 Class 文件常量池的一个重要特征是 **具备动态性**，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。\n\n当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。\n\n### 直接内存\n直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。\n\n在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库 **直接分配堆外内存**，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n\n## HotSpot 虚拟机对象探秘\n以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，博主也在此简短总结下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。\n\n### 对象的创建\n虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（类加载过程之后的博文会有相关总结）\n\n在类加载检查通过后，接下来虚拟机将为新生对象分配内存。内存分配有两种方式：\n\n- 假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞**”。\n- 如果 Java 堆中内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个 **列表**，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“**空闲列表**”。\n\n选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有 **压缩整理功能**决定。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-01.jpg)\n\n### 对象的内存布局\n在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据和对齐填充。\n\n对象头包括两部分信息：\n\n- 第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等；\n- 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n**并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说查找对象的元数据信息并不一定要经过对象本身。**\n\n**如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。**\n\n实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。\n\n对其填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。\n\n### 对象的访问定位\n对象访问方式取决于虚拟机实现而定的，目前主流的访问方式有 **使用句柄**和 **直接指针**两种。\n\n- 如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n- 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。\n\n这两种对象访问方式各有优势。\n\n使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改；\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。\n\n![对象的内存布局](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-02.jpg)\n","source":"_posts/JVM-MemoryArea.md","raw":"---\ntitle: JVM 之 Java 内存区域与内存溢出异常\ndate: 2018-11-19 01:16:24\ncategories: [开发,JVM]\ntags: [Java,JVM]\n---\n\n> Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n\n## 运行时数据区域\nJava 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java 虚拟机规范（Java SE 7 版）》的规定，包括如下几个运行时数据区域，如图：\n![Java 虚拟机运行时数据区](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-runtime-dataarea.png)\n\n### 程序计数器\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。\n\n由于 Java 虚拟机的多线程是通过 **线程轮流切换并分配处理器执行时间的方式**来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。**因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，**这类内存区域称为“线程私有”的内存。\n\n- 线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；\n- 线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。\n\n**此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。**\n\n### Java 虚拟机栈\n与程序计数器一样它也是线程私有的，它的生命周期与线程相同。**虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。**\n\n在 Java 虚拟机规范中，对这个区域规定了两种异常状况：\n\n- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；\n- 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。\n\n### 本地方法栈\n本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是 **虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**\n\n### Java 堆\nJava 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。\n\n此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。\n\n**但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。**\n\nJava 堆是垃圾收集器管理的主要区域，所以有时也称之为“GC 堆”。\n\n- 内存回收角度看，它可以细分为新生代和老年代，细致一点可以分为 Eden 空间、From Survivor 空间、To Survivor 空间等。\n- 内存分配角度看，它可能划分出多个线程私有的分配缓冲区。\n\n### 方法区\n方法区与 Java 堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**\n\nJava 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。\n\n根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。\n\n### 运行时常量池\n运行时常量池是方法区的一部分。它相对于 Class 文件常量池的一个重要特征是 **具备动态性**，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。\n\n当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。\n\n### 直接内存\n直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。\n\n在 JDK 1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库 **直接分配堆外内存**，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n\n## HotSpot 虚拟机对象探秘\n以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，博主也在此简短总结下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。\n\n### 对象的创建\n虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（类加载过程之后的博文会有相关总结）\n\n在类加载检查通过后，接下来虚拟机将为新生对象分配内存。内存分配有两种方式：\n\n- 假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“**指针碰撞**”。\n- 如果 Java 堆中内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个 **列表**，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“**空闲列表**”。\n\n选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有 **压缩整理功能**决定。\n\n![附上手稿](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-01.jpg)\n\n### 对象的内存布局\n在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据和对齐填充。\n\n对象头包括两部分信息：\n\n- 第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等；\n- 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n**并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说查找对象的元数据信息并不一定要经过对象本身。**\n\n**如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。**\n\n实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。\n\n对其填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。\n\n### 对象的访问定位\n对象访问方式取决于虚拟机实现而定的，目前主流的访问方式有 **使用句柄**和 **直接指针**两种。\n\n- 如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n- 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。\n\n这两种对象访问方式各有优势。\n\n使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改；\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。\n\n![对象的内存布局](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-02.jpg)\n","slug":"JVM-MemoryArea","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh4000fk9i1c189azei","content":"<blockquote>\n<p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>\n</blockquote>\n<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java 虚拟机规范（Java SE 7 版）》的规定，包括如下几个运行时数据区域，如图：<br><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-runtime-dataarea.png\" alt=\"Java 虚拟机运行时数据区\"></p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>\n<p>由于 Java 虚拟机的多线程是通过 <strong>线程轮流切换并分配处理器执行时间的方式</strong>来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。<strong>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，</strong>这类内存区域称为“线程私有”的内存。</p>\n<ul>\n<li>线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</li>\n<li>线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。</li>\n</ul>\n<p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p>\n<h3 id=\"Java-虚拟机栈\"><a href=\"#Java-虚拟机栈\" class=\"headerlink\" title=\"Java 虚拟机栈\"></a>Java 虚拟机栈</h3><p>与程序计数器一样它也是线程私有的，它的生命周期与线程相同。<strong>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p>\n<p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况：</p>\n<ul>\n<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；</li>\n<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是 <strong>虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p>\n<h3 id=\"Java-堆\"><a href=\"#Java-堆\" class=\"headerlink\" title=\"Java 堆\"></a>Java 堆</h3><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>\n<p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>\n<p><strong>但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</strong></p>\n<p>Java 堆是垃圾收集器管理的主要区域，所以有时也称之为“GC 堆”。</p>\n<ul>\n<li>内存回收角度看，它可以细分为新生代和老年代，细致一点可以分为 Eden 空间、From Survivor 空间、To Survivor 空间等。</li>\n<li>内存分配角度看，它可能划分出多个线程私有的分配缓冲区。</li>\n</ul>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>\n<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。</p>\n<p>根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。它相对于 Class 文件常量池的一个重要特征是 <strong>具备动态性</strong>，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p>\n<p>当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>\n<h3 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。</p>\n<p>在 JDK 1.4 中新加入了 NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I&#x2F;O 方式，它可以使用 Native 函数库 <strong>直接分配堆外内存</strong>，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>\n<h2 id=\"HotSpot-虚拟机对象探秘\"><a href=\"#HotSpot-虚拟机对象探秘\" class=\"headerlink\" title=\"HotSpot 虚拟机对象探秘\"></a>HotSpot 虚拟机对象探秘</h2><p>以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，博主也在此简短总结下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>\n<h3 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（类加载过程之后的博文会有相关总结）</p>\n<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。内存分配有两种方式：</p>\n<ul>\n<li>假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</li>\n<li>如果 Java 堆中内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个 <strong>列表</strong>，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”。</li>\n</ul>\n<p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有 <strong>压缩整理功能</strong>决定。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-01.jpg\" alt=\"附上手稿\"></p>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>\n<p>对象头包括两部分信息：</p>\n<ul>\n<li>第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等；</li>\n<li>另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n</ul>\n<p><strong>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说查找对象的元数据信息并不一定要经过对象本身。</strong></p>\n<p><strong>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</strong></p>\n<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>\n<p>对其填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>对象访问方式取决于虚拟机实现而定的，目前主流的访问方式有 <strong>使用句柄</strong>和 <strong>直接指针</strong>两种。</p>\n<ul>\n<li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>\n<li>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li>\n</ul>\n<p>这两种对象访问方式各有优势。</p>\n<p>使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改；</p>\n<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-02.jpg\" alt=\"对象的内存布局\"></p>\n","excerpt":"","more":"<blockquote>\n<p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>\n</blockquote>\n<h2 id=\"运行时数据区域\"><a href=\"#运行时数据区域\" class=\"headerlink\" title=\"运行时数据区域\"></a>运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java 虚拟机规范（Java SE 7 版）》的规定，包括如下几个运行时数据区域，如图：<br><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-runtime-dataarea.png\" alt=\"Java 虚拟机运行时数据区\"></p>\n<h3 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>\n<p>由于 Java 虚拟机的多线程是通过 <strong>线程轮流切换并分配处理器执行时间的方式</strong>来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。<strong>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，</strong>这类内存区域称为“线程私有”的内存。</p>\n<ul>\n<li>线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</li>\n<li>线程正在执行的是一个 Native 方法，这个计数器值则为空（Undefined）。</li>\n</ul>\n<p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p>\n<h3 id=\"Java-虚拟机栈\"><a href=\"#Java-虚拟机栈\" class=\"headerlink\" title=\"Java 虚拟机栈\"></a>Java 虚拟机栈</h3><p>与程序计数器一样它也是线程私有的，它的生命周期与线程相同。<strong>虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p>\n<p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况：</p>\n<ul>\n<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；</li>\n<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</li>\n</ul>\n<h3 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是 <strong>虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></p>\n<h3 id=\"Java-堆\"><a href=\"#Java-堆\" class=\"headerlink\" title=\"Java 堆\"></a>Java 堆</h3><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>\n<p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>\n<p><strong>但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</strong></p>\n<p>Java 堆是垃圾收集器管理的主要区域，所以有时也称之为“GC 堆”。</p>\n<ul>\n<li>内存回收角度看，它可以细分为新生代和老年代，细致一点可以分为 Eden 空间、From Survivor 空间、To Survivor 空间等。</li>\n<li>内存分配角度看，它可能划分出多个线程私有的分配缓冲区。</li>\n</ul>\n<h3 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>\n<p>Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。</p>\n<p>根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p>\n<h3 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。它相对于 Class 文件常量池的一个重要特征是 <strong>具备动态性</strong>，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p>\n<p>当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>\n<h3 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。</p>\n<p>在 JDK 1.4 中新加入了 NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I&#x2F;O 方式，它可以使用 Native 函数库 <strong>直接分配堆外内存</strong>，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>\n<h2 id=\"HotSpot-虚拟机对象探秘\"><a href=\"#HotSpot-虚拟机对象探秘\" class=\"headerlink\" title=\"HotSpot 虚拟机对象探秘\"></a>HotSpot 虚拟机对象探秘</h2><p>以常用的虚拟机 HotSpot 和常用的内存区域 Java 堆为例，博主也在此简短总结下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>\n<h3 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h3><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（类加载过程之后的博文会有相关总结）</p>\n<p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。内存分配有两种方式：</p>\n<ul>\n<li>假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</li>\n<li>如果 Java 堆中内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个 <strong>列表</strong>，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”。</li>\n</ul>\n<p>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有 <strong>压缩整理功能</strong>决定。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-01.jpg\" alt=\"附上手稿\"></p>\n<h3 id=\"对象的内存布局\"><a href=\"#对象的内存布局\" class=\"headerlink\" title=\"对象的内存布局\"></a>对象的内存布局</h3><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据和对齐填充。</p>\n<p>对象头包括两部分信息：</p>\n<ul>\n<li>第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等；</li>\n<li>另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n</ul>\n<p><strong>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，也就是说查找对象的元数据信息并不一定要经过对象本身。</strong></p>\n<p><strong>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</strong></p>\n<p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>\n<p>对其填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>\n<h3 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h3><p>对象访问方式取决于虚拟机实现而定的，目前主流的访问方式有 <strong>使用句柄</strong>和 <strong>直接指针</strong>两种。</p>\n<ul>\n<li>如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>\n<li>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</li>\n</ul>\n<p>这两种对象访问方式各有优势。</p>\n<p>使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改；</p>\n<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/JVM/VM-02.jpg\" alt=\"对象的内存布局\"></p>\n"},{"title":"JVM 常用调优参数","date":"2019-02-21T06:20:12.000Z","_content":"\n> 记录下 JVM 常用的一些调优参数。\n\n\n```\n// 常见参数\n-Xms1024m 初始堆大小 \n-Xmx1024m 最大堆大小  一般将 Xms 和 Xmx 设置为相同大小，防止堆扩展，影响性能。\n-XX:NewSize=n:设置年轻代大小 \n-XX:NewRatio=n:设置年轻代和年老代的比值.如:为 3,表示年轻代与年老代比值为 1:3,年轻代占整个年轻代年老代和的 1/4 \n-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值.注意 Survivor 区有两个.如: 3,表示 Eden:Survivor=3:2,一个 Survivor 区占整个年轻代的 1/5 \n-XX:MaxPermSize=n:设置持久代大小\n-XX:+HeapDumpOnOutOfMemoryError OOM 时自动保存堆文件，可以用 visualvm 分析堆文件\n\n// 收集器设置 \n-XX:+UseSerialGC:设置串行收集器\n-XX:+UseParallelGC:设置并行收集器\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n-XX:+UseConcMarkSweepGC:设置并发收集器\n\n// 垃圾回收统计信息\n-XX:+PrintGC \n-XX:+PrintGCDetails \n-XX:+PrintGCTimeStamps \n-Xloggc:filename\n\n// 并行收集器设置 \n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数 \n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 \n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为 1/(1+n)\n\n// 并发收集器设置 \n-XX:+CMSIncrementalMode:设置为增量模式.适用于单 CPU 情况. \n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的 CPU 数.并行收集线程数.\n```","source":"_posts/JVM-Parameter.md","raw":"---\ntitle: JVM 常用调优参数\ndate: 2019-2-21 14:20:12\ncategories: [开发,JVM]\ntags: [Java,JVM]\n---\n\n> 记录下 JVM 常用的一些调优参数。\n\n\n```\n// 常见参数\n-Xms1024m 初始堆大小 \n-Xmx1024m 最大堆大小  一般将 Xms 和 Xmx 设置为相同大小，防止堆扩展，影响性能。\n-XX:NewSize=n:设置年轻代大小 \n-XX:NewRatio=n:设置年轻代和年老代的比值.如:为 3,表示年轻代与年老代比值为 1:3,年轻代占整个年轻代年老代和的 1/4 \n-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值.注意 Survivor 区有两个.如: 3,表示 Eden:Survivor=3:2,一个 Survivor 区占整个年轻代的 1/5 \n-XX:MaxPermSize=n:设置持久代大小\n-XX:+HeapDumpOnOutOfMemoryError OOM 时自动保存堆文件，可以用 visualvm 分析堆文件\n\n// 收集器设置 \n-XX:+UseSerialGC:设置串行收集器\n-XX:+UseParallelGC:设置并行收集器\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n-XX:+UseConcMarkSweepGC:设置并发收集器\n\n// 垃圾回收统计信息\n-XX:+PrintGC \n-XX:+PrintGCDetails \n-XX:+PrintGCTimeStamps \n-Xloggc:filename\n\n// 并行收集器设置 \n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数 \n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 \n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为 1/(1+n)\n\n// 并发收集器设置 \n-XX:+CMSIncrementalMode:设置为增量模式.适用于单 CPU 情况. \n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的 CPU 数.并行收集线程数.\n```","slug":"JVM-Parameter","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh5000ik9i17zcmhplk","content":"<blockquote>\n<p>记录下 JVM 常用的一些调优参数。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 常见参数</span><br><span class=\"line\">-Xms1024m 初始堆大小 </span><br><span class=\"line\">-Xmx1024m 最大堆大小  一般将 Xms 和 Xmx 设置为相同大小，防止堆扩展，影响性能。</span><br><span class=\"line\">-XX:NewSize=n:设置年轻代大小 </span><br><span class=\"line\">-XX:NewRatio=n:设置年轻代和年老代的比值.如:为 3,表示年轻代与年老代比值为 1:3,年轻代占整个年轻代年老代和的 1/4 </span><br><span class=\"line\">-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值.注意 Survivor 区有两个.如: 3,表示 Eden:Survivor=3:2,一个 Survivor 区占整个年轻代的 1/5 </span><br><span class=\"line\">-XX:MaxPermSize=n:设置持久代大小</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError OOM 时自动保存堆文件，可以用 visualvm 分析堆文件</span><br><span class=\"line\"></span><br><span class=\"line\">// 收集器设置 </span><br><span class=\"line\">-XX:+UseSerialGC:设置串行收集器</span><br><span class=\"line\">-XX:+UseParallelGC:设置并行收集器</span><br><span class=\"line\">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br><span class=\"line\"></span><br><span class=\"line\">// 垃圾回收统计信息</span><br><span class=\"line\">-XX:+PrintGC </span><br><span class=\"line\">-XX:+PrintGCDetails </span><br><span class=\"line\">-XX:+PrintGCTimeStamps </span><br><span class=\"line\">-Xloggc:filename</span><br><span class=\"line\"></span><br><span class=\"line\">// 并行收集器设置 </span><br><span class=\"line\">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数 </span><br><span class=\"line\">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 </span><br><span class=\"line\">-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为 1/(1+n)</span><br><span class=\"line\"></span><br><span class=\"line\">// 并发收集器设置 </span><br><span class=\"line\">-XX:+CMSIncrementalMode:设置为增量模式.适用于单 CPU 情况. </span><br><span class=\"line\">-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的 CPU 数.并行收集线程数.</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>记录下 JVM 常用的一些调优参数。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 常见参数</span><br><span class=\"line\">-Xms1024m 初始堆大小 </span><br><span class=\"line\">-Xmx1024m 最大堆大小  一般将 Xms 和 Xmx 设置为相同大小，防止堆扩展，影响性能。</span><br><span class=\"line\">-XX:NewSize=n:设置年轻代大小 </span><br><span class=\"line\">-XX:NewRatio=n:设置年轻代和年老代的比值.如:为 3,表示年轻代与年老代比值为 1:3,年轻代占整个年轻代年老代和的 1/4 </span><br><span class=\"line\">-XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值.注意 Survivor 区有两个.如: 3,表示 Eden:Survivor=3:2,一个 Survivor 区占整个年轻代的 1/5 </span><br><span class=\"line\">-XX:MaxPermSize=n:设置持久代大小</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError OOM 时自动保存堆文件，可以用 visualvm 分析堆文件</span><br><span class=\"line\"></span><br><span class=\"line\">// 收集器设置 </span><br><span class=\"line\">-XX:+UseSerialGC:设置串行收集器</span><br><span class=\"line\">-XX:+UseParallelGC:设置并行收集器</span><br><span class=\"line\">-XX:+UseParalledlOldGC:设置并行年老代收集器</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br><span class=\"line\"></span><br><span class=\"line\">// 垃圾回收统计信息</span><br><span class=\"line\">-XX:+PrintGC </span><br><span class=\"line\">-XX:+PrintGCDetails </span><br><span class=\"line\">-XX:+PrintGCTimeStamps </span><br><span class=\"line\">-Xloggc:filename</span><br><span class=\"line\"></span><br><span class=\"line\">// 并行收集器设置 </span><br><span class=\"line\">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数 </span><br><span class=\"line\">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 </span><br><span class=\"line\">-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比.公式为 1/(1+n)</span><br><span class=\"line\"></span><br><span class=\"line\">// 并发收集器设置 </span><br><span class=\"line\">-XX:+CMSIncrementalMode:设置为增量模式.适用于单 CPU 情况. </span><br><span class=\"line\">-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时,使用的 CPU 数.并行收集线程数.</span><br></pre></td></tr></table></figure>"},{"title":"线程管理","date":"2019-09-01T14:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第八章小结\n\n**本章介绍了如何将线程管控起来以便高效/可靠地利用线程这种有限地资源。**\n\n---\n\n&emsp;&emsp;线程组是 Thread.UncaughtExceptionHandler 的一个实现类，它可以帮助我们检测线程的异常终止。多数情况下，我们可以忽略线程组这一概念以及线程组的存在。\n\n&emsp;&emsp;Thread.UncaughtExceptionHandler 接口使得我们能够侦测到线程运行过程中抛出的未捕获的异常，以便做出相应的补救措施，例如创建并启动相应的替代线程。**一个线程在其抛出未捕获的异常而终止前，总有一个 UncaughtExceptionHandler 实例会被选中。被选中的 UncaughtExceptionHandler 实例的 uncaughtException 方法会被该线程在其终止前执行。**UncaughtExceptionHandler 实例 > 线程所在线程组 > 默认 UncaughtExceptionHandler。\n\n&emsp;&emsp;线程工厂 ThreadFactory 能够封装线程的创建与配置的逻辑，这使得我们能够对线程的创建与配置进行统一的控制。\n\n&emsp;&emsp;利用条件变量我们能实现线程的暂挂与恢复，用于替代 Thread.suspend()/resume() 这两个废弃的方法。\n\n&emsp;&emsp;**线程池是生产者——消费者模式的一个具体例子，它能够摊销线程的创建/启动与销毁的开销，并在一定程度上有利于减少线程调度的开销。**线程池使得我们能够充分利用有限的线程资源。ThreadPoolExecutor 支持核心线程大小以及最大线程池大小这两种阈值来控制线程池中的工作者线程总数。ThreadPoolExecutor 支持对核心线程以外的空闲了指定时间的工作者线程进行清理，以减少不必要的资源消耗。RejectedExecutionHandler 接口使得我们能够对被线程池拒绝的任务进行重试以提高系统的可靠性。Future 接口使得我们可以获取提交给线程池执行的任务的处理结果/侦测任务处理异常以及取消任务的执行。当一个线程池实例不再被需要的时候，我们需要主动将其关闭以节约资源。ThreadPoolExecutor 提供了一组能够对线程池进行监控的方法，通过这些方法我们能够了解线程池的当前线程池大小/工作队列的情况等数据。同一个线程池只能用于执行相互独立的任务，彼此有依赖关系的任务需要提交给不同的线程池执行以避免死锁。**我们可以通过线程工厂为线程池中的工作者线程关联 UncaughtExceptionHandler，但是这些 UncaughtExceptionHandler 只会对通过 ThreadPoolExecutor.execute 方法提交给线程池的任务起作用。**\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eight.png) ","source":"_posts/Multithreading-Chapter-Eight.md","raw":"---\ntitle: 线程管理\ndate: 2019-09-01 22:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第八章小结\n\n**本章介绍了如何将线程管控起来以便高效/可靠地利用线程这种有限地资源。**\n\n---\n\n&emsp;&emsp;线程组是 Thread.UncaughtExceptionHandler 的一个实现类，它可以帮助我们检测线程的异常终止。多数情况下，我们可以忽略线程组这一概念以及线程组的存在。\n\n&emsp;&emsp;Thread.UncaughtExceptionHandler 接口使得我们能够侦测到线程运行过程中抛出的未捕获的异常，以便做出相应的补救措施，例如创建并启动相应的替代线程。**一个线程在其抛出未捕获的异常而终止前，总有一个 UncaughtExceptionHandler 实例会被选中。被选中的 UncaughtExceptionHandler 实例的 uncaughtException 方法会被该线程在其终止前执行。**UncaughtExceptionHandler 实例 > 线程所在线程组 > 默认 UncaughtExceptionHandler。\n\n&emsp;&emsp;线程工厂 ThreadFactory 能够封装线程的创建与配置的逻辑，这使得我们能够对线程的创建与配置进行统一的控制。\n\n&emsp;&emsp;利用条件变量我们能实现线程的暂挂与恢复，用于替代 Thread.suspend()/resume() 这两个废弃的方法。\n\n&emsp;&emsp;**线程池是生产者——消费者模式的一个具体例子，它能够摊销线程的创建/启动与销毁的开销，并在一定程度上有利于减少线程调度的开销。**线程池使得我们能够充分利用有限的线程资源。ThreadPoolExecutor 支持核心线程大小以及最大线程池大小这两种阈值来控制线程池中的工作者线程总数。ThreadPoolExecutor 支持对核心线程以外的空闲了指定时间的工作者线程进行清理，以减少不必要的资源消耗。RejectedExecutionHandler 接口使得我们能够对被线程池拒绝的任务进行重试以提高系统的可靠性。Future 接口使得我们可以获取提交给线程池执行的任务的处理结果/侦测任务处理异常以及取消任务的执行。当一个线程池实例不再被需要的时候，我们需要主动将其关闭以节约资源。ThreadPoolExecutor 提供了一组能够对线程池进行监控的方法，通过这些方法我们能够了解线程池的当前线程池大小/工作队列的情况等数据。同一个线程池只能用于执行相互独立的任务，彼此有依赖关系的任务需要提交给不同的线程池执行以避免死锁。**我们可以通过线程工厂为线程池中的工作者线程关联 UncaughtExceptionHandler，但是这些 UncaughtExceptionHandler 只会对通过 ThreadPoolExecutor.execute 方法提交给线程池的任务起作用。**\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eight.png) ","slug":"Multithreading-Chapter-Eight","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh5000jk9i1dq6m53b5","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第八章小结</p>\n</blockquote>\n<p><strong>本章介绍了如何将线程管控起来以便高效&#x2F;可靠地利用线程这种有限地资源。</strong></p>\n<hr>\n<p>&emsp;&emsp;线程组是 Thread.UncaughtExceptionHandler 的一个实现类，它可以帮助我们检测线程的异常终止。多数情况下，我们可以忽略线程组这一概念以及线程组的存在。</p>\n<p>&emsp;&emsp;Thread.UncaughtExceptionHandler 接口使得我们能够侦测到线程运行过程中抛出的未捕获的异常，以便做出相应的补救措施，例如创建并启动相应的替代线程。<strong>一个线程在其抛出未捕获的异常而终止前，总有一个 UncaughtExceptionHandler 实例会被选中。被选中的 UncaughtExceptionHandler 实例的 uncaughtException 方法会被该线程在其终止前执行。</strong>UncaughtExceptionHandler 实例 &gt; 线程所在线程组 &gt; 默认 UncaughtExceptionHandler。</p>\n<p>&emsp;&emsp;线程工厂 ThreadFactory 能够封装线程的创建与配置的逻辑，这使得我们能够对线程的创建与配置进行统一的控制。</p>\n<p>&emsp;&emsp;利用条件变量我们能实现线程的暂挂与恢复，用于替代 Thread.suspend()&#x2F;resume() 这两个废弃的方法。</p>\n<p>&emsp;&emsp;<strong>线程池是生产者——消费者模式的一个具体例子，它能够摊销线程的创建&#x2F;启动与销毁的开销，并在一定程度上有利于减少线程调度的开销。</strong>线程池使得我们能够充分利用有限的线程资源。ThreadPoolExecutor 支持核心线程大小以及最大线程池大小这两种阈值来控制线程池中的工作者线程总数。ThreadPoolExecutor 支持对核心线程以外的空闲了指定时间的工作者线程进行清理，以减少不必要的资源消耗。RejectedExecutionHandler 接口使得我们能够对被线程池拒绝的任务进行重试以提高系统的可靠性。Future 接口使得我们可以获取提交给线程池执行的任务的处理结果&#x2F;侦测任务处理异常以及取消任务的执行。当一个线程池实例不再被需要的时候，我们需要主动将其关闭以节约资源。ThreadPoolExecutor 提供了一组能够对线程池进行监控的方法，通过这些方法我们能够了解线程池的当前线程池大小&#x2F;工作队列的情况等数据。同一个线程池只能用于执行相互独立的任务，彼此有依赖关系的任务需要提交给不同的线程池执行以避免死锁。<strong>我们可以通过线程工厂为线程池中的工作者线程关联 UncaughtExceptionHandler，但是这些 UncaughtExceptionHandler 只会对通过 ThreadPoolExecutor.execute 方法提交给线程池的任务起作用。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eight.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第八章小结</p>\n</blockquote>\n<p><strong>本章介绍了如何将线程管控起来以便高效&#x2F;可靠地利用线程这种有限地资源。</strong></p>\n<hr>\n<p>&emsp;&emsp;线程组是 Thread.UncaughtExceptionHandler 的一个实现类，它可以帮助我们检测线程的异常终止。多数情况下，我们可以忽略线程组这一概念以及线程组的存在。</p>\n<p>&emsp;&emsp;Thread.UncaughtExceptionHandler 接口使得我们能够侦测到线程运行过程中抛出的未捕获的异常，以便做出相应的补救措施，例如创建并启动相应的替代线程。<strong>一个线程在其抛出未捕获的异常而终止前，总有一个 UncaughtExceptionHandler 实例会被选中。被选中的 UncaughtExceptionHandler 实例的 uncaughtException 方法会被该线程在其终止前执行。</strong>UncaughtExceptionHandler 实例 &gt; 线程所在线程组 &gt; 默认 UncaughtExceptionHandler。</p>\n<p>&emsp;&emsp;线程工厂 ThreadFactory 能够封装线程的创建与配置的逻辑，这使得我们能够对线程的创建与配置进行统一的控制。</p>\n<p>&emsp;&emsp;利用条件变量我们能实现线程的暂挂与恢复，用于替代 Thread.suspend()&#x2F;resume() 这两个废弃的方法。</p>\n<p>&emsp;&emsp;<strong>线程池是生产者——消费者模式的一个具体例子，它能够摊销线程的创建&#x2F;启动与销毁的开销，并在一定程度上有利于减少线程调度的开销。</strong>线程池使得我们能够充分利用有限的线程资源。ThreadPoolExecutor 支持核心线程大小以及最大线程池大小这两种阈值来控制线程池中的工作者线程总数。ThreadPoolExecutor 支持对核心线程以外的空闲了指定时间的工作者线程进行清理，以减少不必要的资源消耗。RejectedExecutionHandler 接口使得我们能够对被线程池拒绝的任务进行重试以提高系统的可靠性。Future 接口使得我们可以获取提交给线程池执行的任务的处理结果&#x2F;侦测任务处理异常以及取消任务的执行。当一个线程池实例不再被需要的时候，我们需要主动将其关闭以节约资源。ThreadPoolExecutor 提供了一组能够对线程池进行监控的方法，通过这些方法我们能够了解线程池的当前线程池大小&#x2F;工作队列的情况等数据。同一个线程池只能用于执行相互独立的任务，彼此有依赖关系的任务需要提交给不同的线程池执行以避免死锁。<strong>我们可以通过线程工厂为线程池中的工作者线程关联 UncaughtExceptionHandler，但是这些 UncaughtExceptionHandler 只会对通过 ThreadPoolExecutor.execute 方法提交给线程池的任务起作用。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eight.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"多线程编程的硬件基础与 Java 内存模型","date":"2019-09-08T15:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第十一章小结\n\n**本章介绍了多线程编程的硬件基础以及 Java 内存模型的基础知识。**\n\n---\n\n&emsp;&emsp;高速缓存是一个存取速率远比主内存大而容量远比主内存小的存储部件，其引入弥补了处理器与主内存处理能力之间的鸿沟。**高速缓存相当于一个由硬件实现的散列表，其键为内存地址，其值为从内存读取或者准备写入内存的数据。**高速缓存中的每个桶可包含若干缓存条目。缓存条目中的 Tag 部分包含了内存地址的高位部分比特；Flag 部分指示了缓存条目的有效性；缓存行用于存储从内存读取或者准备写入内存的数据，其容量在 16~256 字节之间不等，一个缓存行可用于存储多个变量。缓存命中意味着待读取或者写入内存的数据在高速缓存中存在相应的副本，这可以提升内存访问效率。缓存未命中包括读未命中和写未命中，它不利于性能，但是由于高速缓存容量的限制又往往是不可避免的。Linux 内核工具 perf 可用来查看缓存未命中情况。现代处理器多采用多级高速缓存，典型的高速缓存层级包括 L1 Cache/L2 Cache 和 L3 Cache。\n\n&emsp;&emsp;缓存一致性协议保障了多个处理器上高速缓存中的数据副本的数据一致性，避免了一个处理器读取到共享变量的旧值以及避免了一个处理器对共享变量所做的更新丢失。MESI 协议是一个广为使用的缓存一致性协议，在该协议下缓存条目的 Flag 可能值包括：M/E/S/I。内存读/写操作是通过处理器发送与接收相关消息并更新缓存条目的 Flag 实现的。这些消息包括：Read/Read Response、Invalidate/Invalidate Acknowledge、Read Invalidate、Writeback。\n\n&emsp;&emsp;写缓冲器与无效化队列的引入弥补了 MESI 协议的性能弱点。\n\n&emsp;&emsp;写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储部件。其引入使得内存写操作的执行处理器无须等待其他处理器回复 Invalidate Acknowledge/Read Response 消息便可以执行其他指令，从而减小内存写操作的延迟。写缓冲器能导致写线程对共享变量所做的更新无法被其他处理器同步过去。**存储转发技术使得一个处理器可以直接从写缓冲器中读取该处理器先前执行的写操作的结果，但是它也可能导致可见性问题。**另外，写缓冲器还会导致 StoreLoad 重排序和 StoreStore 重排序。\n\n&emsp;&emsp;无效化队列的引入使得处理器在接收到 Invalidate 消息之后可以立即回复 Invalidate Acknowledge 消息，这减少了发送 Invalidate 消息的处理器的等待时间。无效化队列可能使写线程对共享变量所做的共享无法反映到读线程执行处理器的高速缓存中，即导致可见性问题。无效化队列可以导致 LoadLoad 重排序。\n\n&emsp;&emsp;**从硬件的角度来看，可见性的保障是通过写线程和读线程配对使用存储屏障和加载屏障实现的。**存储屏障能够冲刷写缓冲器使得写线程对共享变量所做的更新能够被其他处理器同步，加载屏障能够清空无效化队列，使得写线程对共享变量所做的更新能够反映在读线程执行处理器的高速缓存之中。\n\n&emsp;&emsp;获取屏障相当于 LoadLoad 屏障和 LoadStore 屏障的组合，释放屏障相当于 StoreStore 屏障和 StoreLoad 屏障的组合。LoadLoad 屏障相当于加载屏障；而 StoreLoad 屏障是“全能型”屏障，它既可以充当存储屏障，也可以充当加载屏障。\n\n&emsp;&emsp;Java 虚拟机（JIT 编译器）为了确保 final 关键字的语义，会在 final 字段初始化与构造器返回之前插入一个 StoreStore 屏障，这使得 final 字段初始化操作无法被重排序到构造器之外，从而确保了构造器返回之后相应对象的 final 字段总是初始化完毕的。**有序性的保障是通过写线程与读线程配对执行释放屏障和获取屏障实现的，同样这些屏障也是 Java 虚拟机（JIT 编译器）替我们的应用程序插入的。**Java 虚拟机（JIT 编译器）会在 volatile 变量写操作之后插入一个 StoreLoad 屏障，该屏障不仅充当了存储屏障以冲刷写缓冲器，它还充当了加载屏障以清空无效化队列从而消除了存储转发技术的副作用。Java 虚拟机（JIT 编译器）会在 volatile 变量读操作前插入一个 LoadLoad 屏障，该屏障充当了加载屏障，用于清空无效化队列。\n\n&emsp;&emsp;Java 内存模型从“什么”（What）的角度来回答线程安全有关问题，JSR 133 对 Java 内存模型进行了增强和修复。**Java 内存模型规定，long/double 型变量以外的任何变量的读/写操作具有原子性；volatile 变量修饰的 long/double 型变量的读/写操作也具有原子性。long/double 型普通变量的读/写操作的原子性取决于具体的 Java 虚拟机。**happens-before 从可见性的角度对有序性进行描述。happens-before 关系具有传递性和累积效果。Java 内存模型定义的 happens-before 规则包括：程序顺序规则/内部锁规则/volatile 变量规则/线程启动规则和线程终止规则。Java 标准库本身也定义了一些 happens-before 规则。从语言的层面来看，这些规则是通过使用 Java 的同步机制实现的；从底层的角度来看，这些规则是由 Java 虚拟机/编译器以及处理器一同协作来落实的，内存屏障则是 Java 虚拟机/编译器和处理器之间的“沟通”纽带。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eleven.png) ","source":"_posts/Multithreading-Chapter-Eleven.md","raw":"---\ntitle: 多线程编程的硬件基础与 Java 内存模型\ndate: 2019-09-08 23:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第十一章小结\n\n**本章介绍了多线程编程的硬件基础以及 Java 内存模型的基础知识。**\n\n---\n\n&emsp;&emsp;高速缓存是一个存取速率远比主内存大而容量远比主内存小的存储部件，其引入弥补了处理器与主内存处理能力之间的鸿沟。**高速缓存相当于一个由硬件实现的散列表，其键为内存地址，其值为从内存读取或者准备写入内存的数据。**高速缓存中的每个桶可包含若干缓存条目。缓存条目中的 Tag 部分包含了内存地址的高位部分比特；Flag 部分指示了缓存条目的有效性；缓存行用于存储从内存读取或者准备写入内存的数据，其容量在 16~256 字节之间不等，一个缓存行可用于存储多个变量。缓存命中意味着待读取或者写入内存的数据在高速缓存中存在相应的副本，这可以提升内存访问效率。缓存未命中包括读未命中和写未命中，它不利于性能，但是由于高速缓存容量的限制又往往是不可避免的。Linux 内核工具 perf 可用来查看缓存未命中情况。现代处理器多采用多级高速缓存，典型的高速缓存层级包括 L1 Cache/L2 Cache 和 L3 Cache。\n\n&emsp;&emsp;缓存一致性协议保障了多个处理器上高速缓存中的数据副本的数据一致性，避免了一个处理器读取到共享变量的旧值以及避免了一个处理器对共享变量所做的更新丢失。MESI 协议是一个广为使用的缓存一致性协议，在该协议下缓存条目的 Flag 可能值包括：M/E/S/I。内存读/写操作是通过处理器发送与接收相关消息并更新缓存条目的 Flag 实现的。这些消息包括：Read/Read Response、Invalidate/Invalidate Acknowledge、Read Invalidate、Writeback。\n\n&emsp;&emsp;写缓冲器与无效化队列的引入弥补了 MESI 协议的性能弱点。\n\n&emsp;&emsp;写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储部件。其引入使得内存写操作的执行处理器无须等待其他处理器回复 Invalidate Acknowledge/Read Response 消息便可以执行其他指令，从而减小内存写操作的延迟。写缓冲器能导致写线程对共享变量所做的更新无法被其他处理器同步过去。**存储转发技术使得一个处理器可以直接从写缓冲器中读取该处理器先前执行的写操作的结果，但是它也可能导致可见性问题。**另外，写缓冲器还会导致 StoreLoad 重排序和 StoreStore 重排序。\n\n&emsp;&emsp;无效化队列的引入使得处理器在接收到 Invalidate 消息之后可以立即回复 Invalidate Acknowledge 消息，这减少了发送 Invalidate 消息的处理器的等待时间。无效化队列可能使写线程对共享变量所做的共享无法反映到读线程执行处理器的高速缓存中，即导致可见性问题。无效化队列可以导致 LoadLoad 重排序。\n\n&emsp;&emsp;**从硬件的角度来看，可见性的保障是通过写线程和读线程配对使用存储屏障和加载屏障实现的。**存储屏障能够冲刷写缓冲器使得写线程对共享变量所做的更新能够被其他处理器同步，加载屏障能够清空无效化队列，使得写线程对共享变量所做的更新能够反映在读线程执行处理器的高速缓存之中。\n\n&emsp;&emsp;获取屏障相当于 LoadLoad 屏障和 LoadStore 屏障的组合，释放屏障相当于 StoreStore 屏障和 StoreLoad 屏障的组合。LoadLoad 屏障相当于加载屏障；而 StoreLoad 屏障是“全能型”屏障，它既可以充当存储屏障，也可以充当加载屏障。\n\n&emsp;&emsp;Java 虚拟机（JIT 编译器）为了确保 final 关键字的语义，会在 final 字段初始化与构造器返回之前插入一个 StoreStore 屏障，这使得 final 字段初始化操作无法被重排序到构造器之外，从而确保了构造器返回之后相应对象的 final 字段总是初始化完毕的。**有序性的保障是通过写线程与读线程配对执行释放屏障和获取屏障实现的，同样这些屏障也是 Java 虚拟机（JIT 编译器）替我们的应用程序插入的。**Java 虚拟机（JIT 编译器）会在 volatile 变量写操作之后插入一个 StoreLoad 屏障，该屏障不仅充当了存储屏障以冲刷写缓冲器，它还充当了加载屏障以清空无效化队列从而消除了存储转发技术的副作用。Java 虚拟机（JIT 编译器）会在 volatile 变量读操作前插入一个 LoadLoad 屏障，该屏障充当了加载屏障，用于清空无效化队列。\n\n&emsp;&emsp;Java 内存模型从“什么”（What）的角度来回答线程安全有关问题，JSR 133 对 Java 内存模型进行了增强和修复。**Java 内存模型规定，long/double 型变量以外的任何变量的读/写操作具有原子性；volatile 变量修饰的 long/double 型变量的读/写操作也具有原子性。long/double 型普通变量的读/写操作的原子性取决于具体的 Java 虚拟机。**happens-before 从可见性的角度对有序性进行描述。happens-before 关系具有传递性和累积效果。Java 内存模型定义的 happens-before 规则包括：程序顺序规则/内部锁规则/volatile 变量规则/线程启动规则和线程终止规则。Java 标准库本身也定义了一些 happens-before 规则。从语言的层面来看，这些规则是通过使用 Java 的同步机制实现的；从底层的角度来看，这些规则是由 Java 虚拟机/编译器以及处理器一同协作来落实的，内存屏障则是 Java 虚拟机/编译器和处理器之间的“沟通”纽带。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eleven.png) ","slug":"Multithreading-Chapter-Eleven","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh5000mk9i1ad2neh25","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第十一章小结</p>\n</blockquote>\n<p><strong>本章介绍了多线程编程的硬件基础以及 Java 内存模型的基础知识。</strong></p>\n<hr>\n<p>&emsp;&emsp;高速缓存是一个存取速率远比主内存大而容量远比主内存小的存储部件，其引入弥补了处理器与主内存处理能力之间的鸿沟。<strong>高速缓存相当于一个由硬件实现的散列表，其键为内存地址，其值为从内存读取或者准备写入内存的数据。</strong>高速缓存中的每个桶可包含若干缓存条目。缓存条目中的 Tag 部分包含了内存地址的高位部分比特；Flag 部分指示了缓存条目的有效性；缓存行用于存储从内存读取或者准备写入内存的数据，其容量在 16~256 字节之间不等，一个缓存行可用于存储多个变量。缓存命中意味着待读取或者写入内存的数据在高速缓存中存在相应的副本，这可以提升内存访问效率。缓存未命中包括读未命中和写未命中，它不利于性能，但是由于高速缓存容量的限制又往往是不可避免的。Linux 内核工具 perf 可用来查看缓存未命中情况。现代处理器多采用多级高速缓存，典型的高速缓存层级包括 L1 Cache&#x2F;L2 Cache 和 L3 Cache。</p>\n<p>&emsp;&emsp;缓存一致性协议保障了多个处理器上高速缓存中的数据副本的数据一致性，避免了一个处理器读取到共享变量的旧值以及避免了一个处理器对共享变量所做的更新丢失。MESI 协议是一个广为使用的缓存一致性协议，在该协议下缓存条目的 Flag 可能值包括：M&#x2F;E&#x2F;S&#x2F;I。内存读&#x2F;写操作是通过处理器发送与接收相关消息并更新缓存条目的 Flag 实现的。这些消息包括：Read&#x2F;Read Response、Invalidate&#x2F;Invalidate Acknowledge、Read Invalidate、Writeback。</p>\n<p>&emsp;&emsp;写缓冲器与无效化队列的引入弥补了 MESI 协议的性能弱点。</p>\n<p>&emsp;&emsp;写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储部件。其引入使得内存写操作的执行处理器无须等待其他处理器回复 Invalidate Acknowledge&#x2F;Read Response 消息便可以执行其他指令，从而减小内存写操作的延迟。写缓冲器能导致写线程对共享变量所做的更新无法被其他处理器同步过去。<strong>存储转发技术使得一个处理器可以直接从写缓冲器中读取该处理器先前执行的写操作的结果，但是它也可能导致可见性问题。</strong>另外，写缓冲器还会导致 StoreLoad 重排序和 StoreStore 重排序。</p>\n<p>&emsp;&emsp;无效化队列的引入使得处理器在接收到 Invalidate 消息之后可以立即回复 Invalidate Acknowledge 消息，这减少了发送 Invalidate 消息的处理器的等待时间。无效化队列可能使写线程对共享变量所做的共享无法反映到读线程执行处理器的高速缓存中，即导致可见性问题。无效化队列可以导致 LoadLoad 重排序。</p>\n<p>&emsp;&emsp;<strong>从硬件的角度来看，可见性的保障是通过写线程和读线程配对使用存储屏障和加载屏障实现的。</strong>存储屏障能够冲刷写缓冲器使得写线程对共享变量所做的更新能够被其他处理器同步，加载屏障能够清空无效化队列，使得写线程对共享变量所做的更新能够反映在读线程执行处理器的高速缓存之中。</p>\n<p>&emsp;&emsp;获取屏障相当于 LoadLoad 屏障和 LoadStore 屏障的组合，释放屏障相当于 StoreStore 屏障和 StoreLoad 屏障的组合。LoadLoad 屏障相当于加载屏障；而 StoreLoad 屏障是“全能型”屏障，它既可以充当存储屏障，也可以充当加载屏障。</p>\n<p>&emsp;&emsp;Java 虚拟机（JIT 编译器）为了确保 final 关键字的语义，会在 final 字段初始化与构造器返回之前插入一个 StoreStore 屏障，这使得 final 字段初始化操作无法被重排序到构造器之外，从而确保了构造器返回之后相应对象的 final 字段总是初始化完毕的。<strong>有序性的保障是通过写线程与读线程配对执行释放屏障和获取屏障实现的，同样这些屏障也是 Java 虚拟机（JIT 编译器）替我们的应用程序插入的。</strong>Java 虚拟机（JIT 编译器）会在 volatile 变量写操作之后插入一个 StoreLoad 屏障，该屏障不仅充当了存储屏障以冲刷写缓冲器，它还充当了加载屏障以清空无效化队列从而消除了存储转发技术的副作用。Java 虚拟机（JIT 编译器）会在 volatile 变量读操作前插入一个 LoadLoad 屏障，该屏障充当了加载屏障，用于清空无效化队列。</p>\n<p>&emsp;&emsp;Java 内存模型从“什么”（What）的角度来回答线程安全有关问题，JSR 133 对 Java 内存模型进行了增强和修复。<strong>Java 内存模型规定，long&#x2F;double 型变量以外的任何变量的读&#x2F;写操作具有原子性；volatile 变量修饰的 long&#x2F;double 型变量的读&#x2F;写操作也具有原子性。long&#x2F;double 型普通变量的读&#x2F;写操作的原子性取决于具体的 Java 虚拟机。</strong>happens-before 从可见性的角度对有序性进行描述。happens-before 关系具有传递性和累积效果。Java 内存模型定义的 happens-before 规则包括：程序顺序规则&#x2F;内部锁规则&#x2F;volatile 变量规则&#x2F;线程启动规则和线程终止规则。Java 标准库本身也定义了一些 happens-before 规则。从语言的层面来看，这些规则是通过使用 Java 的同步机制实现的；从底层的角度来看，这些规则是由 Java 虚拟机&#x2F;编译器以及处理器一同协作来落实的，内存屏障则是 Java 虚拟机&#x2F;编译器和处理器之间的“沟通”纽带。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eleven.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第十一章小结</p>\n</blockquote>\n<p><strong>本章介绍了多线程编程的硬件基础以及 Java 内存模型的基础知识。</strong></p>\n<hr>\n<p>&emsp;&emsp;高速缓存是一个存取速率远比主内存大而容量远比主内存小的存储部件，其引入弥补了处理器与主内存处理能力之间的鸿沟。<strong>高速缓存相当于一个由硬件实现的散列表，其键为内存地址，其值为从内存读取或者准备写入内存的数据。</strong>高速缓存中的每个桶可包含若干缓存条目。缓存条目中的 Tag 部分包含了内存地址的高位部分比特；Flag 部分指示了缓存条目的有效性；缓存行用于存储从内存读取或者准备写入内存的数据，其容量在 16~256 字节之间不等，一个缓存行可用于存储多个变量。缓存命中意味着待读取或者写入内存的数据在高速缓存中存在相应的副本，这可以提升内存访问效率。缓存未命中包括读未命中和写未命中，它不利于性能，但是由于高速缓存容量的限制又往往是不可避免的。Linux 内核工具 perf 可用来查看缓存未命中情况。现代处理器多采用多级高速缓存，典型的高速缓存层级包括 L1 Cache&#x2F;L2 Cache 和 L3 Cache。</p>\n<p>&emsp;&emsp;缓存一致性协议保障了多个处理器上高速缓存中的数据副本的数据一致性，避免了一个处理器读取到共享变量的旧值以及避免了一个处理器对共享变量所做的更新丢失。MESI 协议是一个广为使用的缓存一致性协议，在该协议下缓存条目的 Flag 可能值包括：M&#x2F;E&#x2F;S&#x2F;I。内存读&#x2F;写操作是通过处理器发送与接收相关消息并更新缓存条目的 Flag 实现的。这些消息包括：Read&#x2F;Read Response、Invalidate&#x2F;Invalidate Acknowledge、Read Invalidate、Writeback。</p>\n<p>&emsp;&emsp;写缓冲器与无效化队列的引入弥补了 MESI 协议的性能弱点。</p>\n<p>&emsp;&emsp;写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储部件。其引入使得内存写操作的执行处理器无须等待其他处理器回复 Invalidate Acknowledge&#x2F;Read Response 消息便可以执行其他指令，从而减小内存写操作的延迟。写缓冲器能导致写线程对共享变量所做的更新无法被其他处理器同步过去。<strong>存储转发技术使得一个处理器可以直接从写缓冲器中读取该处理器先前执行的写操作的结果，但是它也可能导致可见性问题。</strong>另外，写缓冲器还会导致 StoreLoad 重排序和 StoreStore 重排序。</p>\n<p>&emsp;&emsp;无效化队列的引入使得处理器在接收到 Invalidate 消息之后可以立即回复 Invalidate Acknowledge 消息，这减少了发送 Invalidate 消息的处理器的等待时间。无效化队列可能使写线程对共享变量所做的共享无法反映到读线程执行处理器的高速缓存中，即导致可见性问题。无效化队列可以导致 LoadLoad 重排序。</p>\n<p>&emsp;&emsp;<strong>从硬件的角度来看，可见性的保障是通过写线程和读线程配对使用存储屏障和加载屏障实现的。</strong>存储屏障能够冲刷写缓冲器使得写线程对共享变量所做的更新能够被其他处理器同步，加载屏障能够清空无效化队列，使得写线程对共享变量所做的更新能够反映在读线程执行处理器的高速缓存之中。</p>\n<p>&emsp;&emsp;获取屏障相当于 LoadLoad 屏障和 LoadStore 屏障的组合，释放屏障相当于 StoreStore 屏障和 StoreLoad 屏障的组合。LoadLoad 屏障相当于加载屏障；而 StoreLoad 屏障是“全能型”屏障，它既可以充当存储屏障，也可以充当加载屏障。</p>\n<p>&emsp;&emsp;Java 虚拟机（JIT 编译器）为了确保 final 关键字的语义，会在 final 字段初始化与构造器返回之前插入一个 StoreStore 屏障，这使得 final 字段初始化操作无法被重排序到构造器之外，从而确保了构造器返回之后相应对象的 final 字段总是初始化完毕的。<strong>有序性的保障是通过写线程与读线程配对执行释放屏障和获取屏障实现的，同样这些屏障也是 Java 虚拟机（JIT 编译器）替我们的应用程序插入的。</strong>Java 虚拟机（JIT 编译器）会在 volatile 变量写操作之后插入一个 StoreLoad 屏障，该屏障不仅充当了存储屏障以冲刷写缓冲器，它还充当了加载屏障以清空无效化队列从而消除了存储转发技术的副作用。Java 虚拟机（JIT 编译器）会在 volatile 变量读操作前插入一个 LoadLoad 屏障，该屏障充当了加载屏障，用于清空无效化队列。</p>\n<p>&emsp;&emsp;Java 内存模型从“什么”（What）的角度来回答线程安全有关问题，JSR 133 对 Java 内存模型进行了增强和修复。<strong>Java 内存模型规定，long&#x2F;double 型变量以外的任何变量的读&#x2F;写操作具有原子性；volatile 变量修饰的 long&#x2F;double 型变量的读&#x2F;写操作也具有原子性。long&#x2F;double 型普通变量的读&#x2F;写操作的原子性取决于具体的 Java 虚拟机。</strong>happens-before 从可见性的角度对有序性进行描述。happens-before 关系具有传递性和累积效果。Java 内存模型定义的 happens-before 规则包括：程序顺序规则&#x2F;内部锁规则&#x2F;volatile 变量规则&#x2F;线程启动规则和线程终止规则。Java 标准库本身也定义了一些 happens-before 规则。从语言的层面来看，这些规则是通过使用 Java 的同步机制实现的；从底层的角度来看，这些规则是由 Java 虚拟机&#x2F;编译器以及处理器一同协作来落实的，内存屏障则是 Java 虚拟机&#x2F;编译器和处理器之间的“沟通”纽带。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Eleven.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"线程间协作","date":"2019-07-28T14:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第五章小结\n\n**本章介绍了多线程编程中线程间常见的协作形式以及 Java 平台对这些协作形式所提出的支持。**\n\n---\n\n&emsp;&emsp;等待线程可以通过执行 Object.wait()/wait(long) 来实现等待。通知线程可以通过执行 Object.notify()/notifyAll() 来实现通知。等待线程/通知线程在执行 Object.wait()/wait(long)/Object.notify()/notifyAll() 时必须持有相应对象对应的内部锁。为了避免信号丢失问题以及欺骗性唤醒问题，等待线程将等待线程对保护条件的判断/Object.wait()/wait(long) 的调用必须放在相应对象所引导的临界区中的一个循环语句之中。\n\n&emsp;&emsp;使用 notify() 替代 notifyAll() 必须使以下两个条件同时得以满足：\n\n- 一次通知仅需要唤醒至多一个线程；\n- 相应对象上的所有等待线程都是同质等待线程。\n\n&emsp;&emsp;使用 notify() 替代 notifyAll() 可以减少等待/通知中产生的上下文切换。通知线程在执行完 Object.notify()/notifyAll() 后尽快释放相应对象的内部锁也有助于减少上下文切换。\n\n&emsp;&emsp;条件变量（Condition 接口）是 wait/notify 的替代品。Condition 接口的 API 与 wait/notify 类似：Condition.await()/awaitUtil(Date) 相当于 Object.wait()/wait(long);Condition.signal()/signalAll() 相当于 Object.notify()/notifyAll()。Condition.awaitUtil(Date) 解决了 Object.wait(long) 存在的问题——无法区分其返回是否是由等待超时而导致的。\n\n&emsp;&emsp;Condition 接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量之间的对应关系，即使用不同保护条件的等待线程需要调用不同的条件变量的 await 方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的 signal/signalAll 方法来实现通知。\n\n&emsp;&emsp;CountDownLatch 能够用来实现一个线程等待其他线程执行的特定操作的结束。等待线程执行 CountDownLatch.await()，通知线程执行 CountDownLatch.countDown()。为避免等待线程永远处于暂停状态而无法被唤醒，CountDownLatch.countDown() 调用通常需要被放在 finally 块中。一个 CountDownLatch 实例只能实现一次等待/通知。对于同一个 CountDownLatch 实例 latch，latch.countDown() 的执行线程在执行该方法之前所执行的任何内存操作，对等待线程在 latch.await() 调用返回之后的代码是可见的且有序。\n\n&emsp;&emsp;CyclicBarrier 能够用于实现多个线程间的相互等待。CyclicBarrier.await() 既是等待方法又是通知方法。CyclicBarrier 实例的所有参与方除最后一个线程外都相当于等待线程，最后一个线程则相当于通知线程。与 CountDownLatch 不同的是，CyclicBarrier 实例是可以复用的——一个 CyclicBarrier 实例可以实现多次等待/通知。在使用 CountDownLatch 足以满足要求的情况下，我们应该避免使用 CyclicBarrier。CyclicBarrier 的典型应用场景包括：使迭代（Iterative）算法并发化，在测试代码中模拟高并发。\n\n&emsp;&emsp;在生产者——消费者模式中，生产者负责生产产品并通过传输通道将产品以线程安全的方式发布到消费者线程。消费者线程仅负责从传输通道中取出产品进行“消费”。产品既可以是数据，也可以是待处理的任务。BlockingQueue 的实现类 ArrayBlockingQueue/LinkedBlockingQueue 和 SynchronousQueue 等以及 Exchanger 类可作为传输通道。\n\n&emsp;&emsp;生产者与消费者所执行的处理，即产品的生产与“消费”是并发的。这使得我们能够平衡生产者/消费者处理能力的差异，即避免了一方处理过慢对另一方产生影响。另外，生产者——消费者模式使得一个线程（消费者线程）可以处理多个任务，提高了线程的利用率。\n\n&emsp;&emsp;使用无界队列作为传输通道时往往需要借助 Semaphore 控制生产者的生产速率。Semaphore 相当于能够对程序访问虚拟资源的并发程度进行控制的配额调度器。Semaphore.acquire() 用于申请配额，Semaphore.release() 用于返还配额，Semaphore.release() 调用总是放在 finally 块中。Semaphore.acquire() 和 Semaphore.release() 总是配对使用的，这点需要由应用代码来确保。Semaphore 对配额的调度既支持非公平策略（默认策略），也支持公平策略。\n\n&emsp;&emsp;PipedOutputStream/PipedInputStream 是 Java 标准库类中生产者——消费者模式的一个具体例子。PipedOutputStream/PipedInputStream 适合在单生产者——单消费者模式中使用，应避免在单线程程序中使用 PipedOutputStream/PipedInputStream。生产者线程发生异常而导致其无法继续提供新的数据时，生产者线程必须主动提前关闭相应的 PipedOutputStream 实例（调用 PipedOutputStream.close()）。\n\n&emsp;&emsp;Exchanger 类也可作为传输通道，它对双缓冲技术提供了支持：生产者与消费者各自维护一个缓冲区，双方通过执行 Exchanger.exchange(V) 来交换各自持有的缓冲区。当消费者在“消费”一个已填充完毕的缓冲区时，生产者可以对待填充的缓冲区进行填充（生产产品），从而实现了产品的“消费”与生成的并发。Exchanger 类便于我们能够对产品的粒度进行优化。\n\n&emsp;&emsp;Java 线程中断机制相当于 Java 线程与线程间协作的一套协议框架：发起线程通过 Thread.interrupt() 调用给目标线程发送中断，这相当于将目标线程的线程中断标记置为 true；目标线程则通过 Thread.currentThread().isInterrupted()/Thread.interrupted() 来获取或者获取并重置线程中断的响应方式。给目标线程发送中断还能够产生唤醒目标线程的效果。目标线程可以通过对 InterruptedException 进行处理的方式或者直接通过判断线程中断标记并执行相应的处理逻辑的方式来响应中断。对 InterruptedException 进行处理的正确方式包括：不捕获InterruptedException/捕获 InterruptedException 后重新将该异常抛出，以及捕获 InterruptedException 并在捕获该异常后中断当前线程。\n\n&emsp;&emsp;需要主动停止线程的典型场景包括：服务或者系统关闭/错误处理以及用户取消任务。通用的线程优雅停止办法：发起线程更新目标线程的线程停止标记并给其发送中断，目标线程仅在当前无待处理任务且不会产生新的待处理任务情况下才能使 run 方法返回。Web 应用自身启动的工作者线程需要由应用自身在 Web 应用停止时主动停止。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Five.png) ","source":"_posts/Multithreading-Chapter-Five.md","raw":"---\ntitle: 线程间协作\ndate: 2019-07-28 22:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第五章小结\n\n**本章介绍了多线程编程中线程间常见的协作形式以及 Java 平台对这些协作形式所提出的支持。**\n\n---\n\n&emsp;&emsp;等待线程可以通过执行 Object.wait()/wait(long) 来实现等待。通知线程可以通过执行 Object.notify()/notifyAll() 来实现通知。等待线程/通知线程在执行 Object.wait()/wait(long)/Object.notify()/notifyAll() 时必须持有相应对象对应的内部锁。为了避免信号丢失问题以及欺骗性唤醒问题，等待线程将等待线程对保护条件的判断/Object.wait()/wait(long) 的调用必须放在相应对象所引导的临界区中的一个循环语句之中。\n\n&emsp;&emsp;使用 notify() 替代 notifyAll() 必须使以下两个条件同时得以满足：\n\n- 一次通知仅需要唤醒至多一个线程；\n- 相应对象上的所有等待线程都是同质等待线程。\n\n&emsp;&emsp;使用 notify() 替代 notifyAll() 可以减少等待/通知中产生的上下文切换。通知线程在执行完 Object.notify()/notifyAll() 后尽快释放相应对象的内部锁也有助于减少上下文切换。\n\n&emsp;&emsp;条件变量（Condition 接口）是 wait/notify 的替代品。Condition 接口的 API 与 wait/notify 类似：Condition.await()/awaitUtil(Date) 相当于 Object.wait()/wait(long);Condition.signal()/signalAll() 相当于 Object.notify()/notifyAll()。Condition.awaitUtil(Date) 解决了 Object.wait(long) 存在的问题——无法区分其返回是否是由等待超时而导致的。\n\n&emsp;&emsp;Condition 接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量之间的对应关系，即使用不同保护条件的等待线程需要调用不同的条件变量的 await 方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的 signal/signalAll 方法来实现通知。\n\n&emsp;&emsp;CountDownLatch 能够用来实现一个线程等待其他线程执行的特定操作的结束。等待线程执行 CountDownLatch.await()，通知线程执行 CountDownLatch.countDown()。为避免等待线程永远处于暂停状态而无法被唤醒，CountDownLatch.countDown() 调用通常需要被放在 finally 块中。一个 CountDownLatch 实例只能实现一次等待/通知。对于同一个 CountDownLatch 实例 latch，latch.countDown() 的执行线程在执行该方法之前所执行的任何内存操作，对等待线程在 latch.await() 调用返回之后的代码是可见的且有序。\n\n&emsp;&emsp;CyclicBarrier 能够用于实现多个线程间的相互等待。CyclicBarrier.await() 既是等待方法又是通知方法。CyclicBarrier 实例的所有参与方除最后一个线程外都相当于等待线程，最后一个线程则相当于通知线程。与 CountDownLatch 不同的是，CyclicBarrier 实例是可以复用的——一个 CyclicBarrier 实例可以实现多次等待/通知。在使用 CountDownLatch 足以满足要求的情况下，我们应该避免使用 CyclicBarrier。CyclicBarrier 的典型应用场景包括：使迭代（Iterative）算法并发化，在测试代码中模拟高并发。\n\n&emsp;&emsp;在生产者——消费者模式中，生产者负责生产产品并通过传输通道将产品以线程安全的方式发布到消费者线程。消费者线程仅负责从传输通道中取出产品进行“消费”。产品既可以是数据，也可以是待处理的任务。BlockingQueue 的实现类 ArrayBlockingQueue/LinkedBlockingQueue 和 SynchronousQueue 等以及 Exchanger 类可作为传输通道。\n\n&emsp;&emsp;生产者与消费者所执行的处理，即产品的生产与“消费”是并发的。这使得我们能够平衡生产者/消费者处理能力的差异，即避免了一方处理过慢对另一方产生影响。另外，生产者——消费者模式使得一个线程（消费者线程）可以处理多个任务，提高了线程的利用率。\n\n&emsp;&emsp;使用无界队列作为传输通道时往往需要借助 Semaphore 控制生产者的生产速率。Semaphore 相当于能够对程序访问虚拟资源的并发程度进行控制的配额调度器。Semaphore.acquire() 用于申请配额，Semaphore.release() 用于返还配额，Semaphore.release() 调用总是放在 finally 块中。Semaphore.acquire() 和 Semaphore.release() 总是配对使用的，这点需要由应用代码来确保。Semaphore 对配额的调度既支持非公平策略（默认策略），也支持公平策略。\n\n&emsp;&emsp;PipedOutputStream/PipedInputStream 是 Java 标准库类中生产者——消费者模式的一个具体例子。PipedOutputStream/PipedInputStream 适合在单生产者——单消费者模式中使用，应避免在单线程程序中使用 PipedOutputStream/PipedInputStream。生产者线程发生异常而导致其无法继续提供新的数据时，生产者线程必须主动提前关闭相应的 PipedOutputStream 实例（调用 PipedOutputStream.close()）。\n\n&emsp;&emsp;Exchanger 类也可作为传输通道，它对双缓冲技术提供了支持：生产者与消费者各自维护一个缓冲区，双方通过执行 Exchanger.exchange(V) 来交换各自持有的缓冲区。当消费者在“消费”一个已填充完毕的缓冲区时，生产者可以对待填充的缓冲区进行填充（生产产品），从而实现了产品的“消费”与生成的并发。Exchanger 类便于我们能够对产品的粒度进行优化。\n\n&emsp;&emsp;Java 线程中断机制相当于 Java 线程与线程间协作的一套协议框架：发起线程通过 Thread.interrupt() 调用给目标线程发送中断，这相当于将目标线程的线程中断标记置为 true；目标线程则通过 Thread.currentThread().isInterrupted()/Thread.interrupted() 来获取或者获取并重置线程中断的响应方式。给目标线程发送中断还能够产生唤醒目标线程的效果。目标线程可以通过对 InterruptedException 进行处理的方式或者直接通过判断线程中断标记并执行相应的处理逻辑的方式来响应中断。对 InterruptedException 进行处理的正确方式包括：不捕获InterruptedException/捕获 InterruptedException 后重新将该异常抛出，以及捕获 InterruptedException 并在捕获该异常后中断当前线程。\n\n&emsp;&emsp;需要主动停止线程的典型场景包括：服务或者系统关闭/错误处理以及用户取消任务。通用的线程优雅停止办法：发起线程更新目标线程的线程停止标记并给其发送中断，目标线程仅在当前无待处理任务且不会产生新的待处理任务情况下才能使 run 方法返回。Web 应用自身启动的工作者线程需要由应用自身在 Web 应用停止时主动停止。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Five.png) ","slug":"Multithreading-Chapter-Five","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh5000ok9i17ssobc8p","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第五章小结</p>\n</blockquote>\n<p><strong>本章介绍了多线程编程中线程间常见的协作形式以及 Java 平台对这些协作形式所提出的支持。</strong></p>\n<hr>\n<p>&emsp;&emsp;等待线程可以通过执行 Object.wait()&#x2F;wait(long) 来实现等待。通知线程可以通过执行 Object.notify()&#x2F;notifyAll() 来实现通知。等待线程&#x2F;通知线程在执行 Object.wait()&#x2F;wait(long)&#x2F;Object.notify()&#x2F;notifyAll() 时必须持有相应对象对应的内部锁。为了避免信号丢失问题以及欺骗性唤醒问题，等待线程将等待线程对保护条件的判断&#x2F;Object.wait()&#x2F;wait(long) 的调用必须放在相应对象所引导的临界区中的一个循环语句之中。</p>\n<p>&emsp;&emsp;使用 notify() 替代 notifyAll() 必须使以下两个条件同时得以满足：</p>\n<ul>\n<li>一次通知仅需要唤醒至多一个线程；</li>\n<li>相应对象上的所有等待线程都是同质等待线程。</li>\n</ul>\n<p>&emsp;&emsp;使用 notify() 替代 notifyAll() 可以减少等待&#x2F;通知中产生的上下文切换。通知线程在执行完 Object.notify()&#x2F;notifyAll() 后尽快释放相应对象的内部锁也有助于减少上下文切换。</p>\n<p>&emsp;&emsp;条件变量（Condition 接口）是 wait&#x2F;notify 的替代品。Condition 接口的 API 与 wait&#x2F;notify 类似：Condition.await()&#x2F;awaitUtil(Date) 相当于 Object.wait()&#x2F;wait(long);Condition.signal()&#x2F;signalAll() 相当于 Object.notify()&#x2F;notifyAll()。Condition.awaitUtil(Date) 解决了 Object.wait(long) 存在的问题——无法区分其返回是否是由等待超时而导致的。</p>\n<p>&emsp;&emsp;Condition 接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量之间的对应关系，即使用不同保护条件的等待线程需要调用不同的条件变量的 await 方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的 signal&#x2F;signalAll 方法来实现通知。</p>\n<p>&emsp;&emsp;CountDownLatch 能够用来实现一个线程等待其他线程执行的特定操作的结束。等待线程执行 CountDownLatch.await()，通知线程执行 CountDownLatch.countDown()。为避免等待线程永远处于暂停状态而无法被唤醒，CountDownLatch.countDown() 调用通常需要被放在 finally 块中。一个 CountDownLatch 实例只能实现一次等待&#x2F;通知。对于同一个 CountDownLatch 实例 latch，latch.countDown() 的执行线程在执行该方法之前所执行的任何内存操作，对等待线程在 latch.await() 调用返回之后的代码是可见的且有序。</p>\n<p>&emsp;&emsp;CyclicBarrier 能够用于实现多个线程间的相互等待。CyclicBarrier.await() 既是等待方法又是通知方法。CyclicBarrier 实例的所有参与方除最后一个线程外都相当于等待线程，最后一个线程则相当于通知线程。与 CountDownLatch 不同的是，CyclicBarrier 实例是可以复用的——一个 CyclicBarrier 实例可以实现多次等待&#x2F;通知。在使用 CountDownLatch 足以满足要求的情况下，我们应该避免使用 CyclicBarrier。CyclicBarrier 的典型应用场景包括：使迭代（Iterative）算法并发化，在测试代码中模拟高并发。</p>\n<p>&emsp;&emsp;在生产者——消费者模式中，生产者负责生产产品并通过传输通道将产品以线程安全的方式发布到消费者线程。消费者线程仅负责从传输通道中取出产品进行“消费”。产品既可以是数据，也可以是待处理的任务。BlockingQueue 的实现类 ArrayBlockingQueue&#x2F;LinkedBlockingQueue 和 SynchronousQueue 等以及 Exchanger 类可作为传输通道。</p>\n<p>&emsp;&emsp;生产者与消费者所执行的处理，即产品的生产与“消费”是并发的。这使得我们能够平衡生产者&#x2F;消费者处理能力的差异，即避免了一方处理过慢对另一方产生影响。另外，生产者——消费者模式使得一个线程（消费者线程）可以处理多个任务，提高了线程的利用率。</p>\n<p>&emsp;&emsp;使用无界队列作为传输通道时往往需要借助 Semaphore 控制生产者的生产速率。Semaphore 相当于能够对程序访问虚拟资源的并发程度进行控制的配额调度器。Semaphore.acquire() 用于申请配额，Semaphore.release() 用于返还配额，Semaphore.release() 调用总是放在 finally 块中。Semaphore.acquire() 和 Semaphore.release() 总是配对使用的，这点需要由应用代码来确保。Semaphore 对配额的调度既支持非公平策略（默认策略），也支持公平策略。</p>\n<p>&emsp;&emsp;PipedOutputStream&#x2F;PipedInputStream 是 Java 标准库类中生产者——消费者模式的一个具体例子。PipedOutputStream&#x2F;PipedInputStream 适合在单生产者——单消费者模式中使用，应避免在单线程程序中使用 PipedOutputStream&#x2F;PipedInputStream。生产者线程发生异常而导致其无法继续提供新的数据时，生产者线程必须主动提前关闭相应的 PipedOutputStream 实例（调用 PipedOutputStream.close()）。</p>\n<p>&emsp;&emsp;Exchanger 类也可作为传输通道，它对双缓冲技术提供了支持：生产者与消费者各自维护一个缓冲区，双方通过执行 Exchanger.exchange(V) 来交换各自持有的缓冲区。当消费者在“消费”一个已填充完毕的缓冲区时，生产者可以对待填充的缓冲区进行填充（生产产品），从而实现了产品的“消费”与生成的并发。Exchanger 类便于我们能够对产品的粒度进行优化。</p>\n<p>&emsp;&emsp;Java 线程中断机制相当于 Java 线程与线程间协作的一套协议框架：发起线程通过 Thread.interrupt() 调用给目标线程发送中断，这相当于将目标线程的线程中断标记置为 true；目标线程则通过 Thread.currentThread().isInterrupted()&#x2F;Thread.interrupted() 来获取或者获取并重置线程中断的响应方式。给目标线程发送中断还能够产生唤醒目标线程的效果。目标线程可以通过对 InterruptedException 进行处理的方式或者直接通过判断线程中断标记并执行相应的处理逻辑的方式来响应中断。对 InterruptedException 进行处理的正确方式包括：不捕获InterruptedException&#x2F;捕获 InterruptedException 后重新将该异常抛出，以及捕获 InterruptedException 并在捕获该异常后中断当前线程。</p>\n<p>&emsp;&emsp;需要主动停止线程的典型场景包括：服务或者系统关闭&#x2F;错误处理以及用户取消任务。通用的线程优雅停止办法：发起线程更新目标线程的线程停止标记并给其发送中断，目标线程仅在当前无待处理任务且不会产生新的待处理任务情况下才能使 run 方法返回。Web 应用自身启动的工作者线程需要由应用自身在 Web 应用停止时主动停止。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Five.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第五章小结</p>\n</blockquote>\n<p><strong>本章介绍了多线程编程中线程间常见的协作形式以及 Java 平台对这些协作形式所提出的支持。</strong></p>\n<hr>\n<p>&emsp;&emsp;等待线程可以通过执行 Object.wait()&#x2F;wait(long) 来实现等待。通知线程可以通过执行 Object.notify()&#x2F;notifyAll() 来实现通知。等待线程&#x2F;通知线程在执行 Object.wait()&#x2F;wait(long)&#x2F;Object.notify()&#x2F;notifyAll() 时必须持有相应对象对应的内部锁。为了避免信号丢失问题以及欺骗性唤醒问题，等待线程将等待线程对保护条件的判断&#x2F;Object.wait()&#x2F;wait(long) 的调用必须放在相应对象所引导的临界区中的一个循环语句之中。</p>\n<p>&emsp;&emsp;使用 notify() 替代 notifyAll() 必须使以下两个条件同时得以满足：</p>\n<ul>\n<li>一次通知仅需要唤醒至多一个线程；</li>\n<li>相应对象上的所有等待线程都是同质等待线程。</li>\n</ul>\n<p>&emsp;&emsp;使用 notify() 替代 notifyAll() 可以减少等待&#x2F;通知中产生的上下文切换。通知线程在执行完 Object.notify()&#x2F;notifyAll() 后尽快释放相应对象的内部锁也有助于减少上下文切换。</p>\n<p>&emsp;&emsp;条件变量（Condition 接口）是 wait&#x2F;notify 的替代品。Condition 接口的 API 与 wait&#x2F;notify 类似：Condition.await()&#x2F;awaitUtil(Date) 相当于 Object.wait()&#x2F;wait(long);Condition.signal()&#x2F;signalAll() 相当于 Object.notify()&#x2F;notifyAll()。Condition.awaitUtil(Date) 解决了 Object.wait(long) 存在的问题——无法区分其返回是否是由等待超时而导致的。</p>\n<p>&emsp;&emsp;Condition 接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们需要通过应用代码维护保护条件与条件变量之间的对应关系，即使用不同保护条件的等待线程需要调用不同的条件变量的 await 方法来实现其等待，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的 signal&#x2F;signalAll 方法来实现通知。</p>\n<p>&emsp;&emsp;CountDownLatch 能够用来实现一个线程等待其他线程执行的特定操作的结束。等待线程执行 CountDownLatch.await()，通知线程执行 CountDownLatch.countDown()。为避免等待线程永远处于暂停状态而无法被唤醒，CountDownLatch.countDown() 调用通常需要被放在 finally 块中。一个 CountDownLatch 实例只能实现一次等待&#x2F;通知。对于同一个 CountDownLatch 实例 latch，latch.countDown() 的执行线程在执行该方法之前所执行的任何内存操作，对等待线程在 latch.await() 调用返回之后的代码是可见的且有序。</p>\n<p>&emsp;&emsp;CyclicBarrier 能够用于实现多个线程间的相互等待。CyclicBarrier.await() 既是等待方法又是通知方法。CyclicBarrier 实例的所有参与方除最后一个线程外都相当于等待线程，最后一个线程则相当于通知线程。与 CountDownLatch 不同的是，CyclicBarrier 实例是可以复用的——一个 CyclicBarrier 实例可以实现多次等待&#x2F;通知。在使用 CountDownLatch 足以满足要求的情况下，我们应该避免使用 CyclicBarrier。CyclicBarrier 的典型应用场景包括：使迭代（Iterative）算法并发化，在测试代码中模拟高并发。</p>\n<p>&emsp;&emsp;在生产者——消费者模式中，生产者负责生产产品并通过传输通道将产品以线程安全的方式发布到消费者线程。消费者线程仅负责从传输通道中取出产品进行“消费”。产品既可以是数据，也可以是待处理的任务。BlockingQueue 的实现类 ArrayBlockingQueue&#x2F;LinkedBlockingQueue 和 SynchronousQueue 等以及 Exchanger 类可作为传输通道。</p>\n<p>&emsp;&emsp;生产者与消费者所执行的处理，即产品的生产与“消费”是并发的。这使得我们能够平衡生产者&#x2F;消费者处理能力的差异，即避免了一方处理过慢对另一方产生影响。另外，生产者——消费者模式使得一个线程（消费者线程）可以处理多个任务，提高了线程的利用率。</p>\n<p>&emsp;&emsp;使用无界队列作为传输通道时往往需要借助 Semaphore 控制生产者的生产速率。Semaphore 相当于能够对程序访问虚拟资源的并发程度进行控制的配额调度器。Semaphore.acquire() 用于申请配额，Semaphore.release() 用于返还配额，Semaphore.release() 调用总是放在 finally 块中。Semaphore.acquire() 和 Semaphore.release() 总是配对使用的，这点需要由应用代码来确保。Semaphore 对配额的调度既支持非公平策略（默认策略），也支持公平策略。</p>\n<p>&emsp;&emsp;PipedOutputStream&#x2F;PipedInputStream 是 Java 标准库类中生产者——消费者模式的一个具体例子。PipedOutputStream&#x2F;PipedInputStream 适合在单生产者——单消费者模式中使用，应避免在单线程程序中使用 PipedOutputStream&#x2F;PipedInputStream。生产者线程发生异常而导致其无法继续提供新的数据时，生产者线程必须主动提前关闭相应的 PipedOutputStream 实例（调用 PipedOutputStream.close()）。</p>\n<p>&emsp;&emsp;Exchanger 类也可作为传输通道，它对双缓冲技术提供了支持：生产者与消费者各自维护一个缓冲区，双方通过执行 Exchanger.exchange(V) 来交换各自持有的缓冲区。当消费者在“消费”一个已填充完毕的缓冲区时，生产者可以对待填充的缓冲区进行填充（生产产品），从而实现了产品的“消费”与生成的并发。Exchanger 类便于我们能够对产品的粒度进行优化。</p>\n<p>&emsp;&emsp;Java 线程中断机制相当于 Java 线程与线程间协作的一套协议框架：发起线程通过 Thread.interrupt() 调用给目标线程发送中断，这相当于将目标线程的线程中断标记置为 true；目标线程则通过 Thread.currentThread().isInterrupted()&#x2F;Thread.interrupted() 来获取或者获取并重置线程中断的响应方式。给目标线程发送中断还能够产生唤醒目标线程的效果。目标线程可以通过对 InterruptedException 进行处理的方式或者直接通过判断线程中断标记并执行相应的处理逻辑的方式来响应中断。对 InterruptedException 进行处理的正确方式包括：不捕获InterruptedException&#x2F;捕获 InterruptedException 后重新将该异常抛出，以及捕获 InterruptedException 并在捕获该异常后中断当前线程。</p>\n<p>&emsp;&emsp;需要主动停止线程的典型场景包括：服务或者系统关闭&#x2F;错误处理以及用户取消任务。通用的线程优雅停止办法：发起线程更新目标线程的线程停止标记并给其发送中断，目标线程仅在当前无待处理任务且不会产生新的待处理任务情况下才能使 run 方法返回。Web 应用自身启动的工作者线程需要由应用自身在 Web 应用停止时主动停止。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Five.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"在实践中运用多线程","date":"2019-07-21T14:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第四章小结\n\n**本章介绍了利用多线程实现并发计算的基本方法以及多线程编程实践中的注意事项及应对措施。**\n\n---\n\n&emsp;&emsp;挖掘出程序中的可并发点是实现多线程编程的目标——并发计算的前提。\n\n&emsp;&emsp;实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。前者从程序处理的数据角度入手，将原始输入分解为若干规模更小的子输入，并将这些子输入指派给专门的工作者线程处理。其结果是产生若干同质的工作者线程。后者从程序的处理逻辑角度入手，将原始任务处理逻辑依照任务的资源消耗属性或者处理步骤分解为若干个子任务，并创建专门的工作者线程来执行这些子任务。其结果是产生多个相互协作的异质工作者线程。\n\n&emsp;&emsp;多线程编程实践中需要注意以下几下问题。\n\n- 考虑到多线程程序往往比相应的单线程程序要复杂，且未必比相应的单线程程序快，因此多线程编程的一个实施策略是考虑从单线程程序向多线程程序“进化”，而不是直接迈向“多线程”。\n\n- 线程数的合理设置。设置线程数的基本原则就是避免随意设置/使线程数可配置或者可以动态计算得来。设置合理的线程数需要考虑系统的资源状况（处理器数目/内存大小等）/线程所执行的任务的特性（CPU 密集型任务/I/O 密集型任务）/资源使用情况规划（CPU 使用率上限）以及程序运行过程中使用到的其他稀缺资源情况（如数据库连接/文件句柄数）等因素。\n\n- 多线程程序往往比相应的单线程程序产生更多的开销，且需要注意工作者线程的异常处理以及原始任务规模未知问题的应对。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Four.png) ","source":"_posts/Multithreading-Chapter-Four.md","raw":"---\ntitle: 在实践中运用多线程\ndate: 2019-07-21 22:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第四章小结\n\n**本章介绍了利用多线程实现并发计算的基本方法以及多线程编程实践中的注意事项及应对措施。**\n\n---\n\n&emsp;&emsp;挖掘出程序中的可并发点是实现多线程编程的目标——并发计算的前提。\n\n&emsp;&emsp;实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。前者从程序处理的数据角度入手，将原始输入分解为若干规模更小的子输入，并将这些子输入指派给专门的工作者线程处理。其结果是产生若干同质的工作者线程。后者从程序的处理逻辑角度入手，将原始任务处理逻辑依照任务的资源消耗属性或者处理步骤分解为若干个子任务，并创建专门的工作者线程来执行这些子任务。其结果是产生多个相互协作的异质工作者线程。\n\n&emsp;&emsp;多线程编程实践中需要注意以下几下问题。\n\n- 考虑到多线程程序往往比相应的单线程程序要复杂，且未必比相应的单线程程序快，因此多线程编程的一个实施策略是考虑从单线程程序向多线程程序“进化”，而不是直接迈向“多线程”。\n\n- 线程数的合理设置。设置线程数的基本原则就是避免随意设置/使线程数可配置或者可以动态计算得来。设置合理的线程数需要考虑系统的资源状况（处理器数目/内存大小等）/线程所执行的任务的特性（CPU 密集型任务/I/O 密集型任务）/资源使用情况规划（CPU 使用率上限）以及程序运行过程中使用到的其他稀缺资源情况（如数据库连接/文件句柄数）等因素。\n\n- 多线程程序往往比相应的单线程程序产生更多的开销，且需要注意工作者线程的异常处理以及原始任务规模未知问题的应对。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Four.png) ","slug":"Multithreading-Chapter-Four","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh6000sk9i1cztk50rf","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第四章小结</p>\n</blockquote>\n<p><strong>本章介绍了利用多线程实现并发计算的基本方法以及多线程编程实践中的注意事项及应对措施。</strong></p>\n<hr>\n<p>&emsp;&emsp;挖掘出程序中的可并发点是实现多线程编程的目标——并发计算的前提。</p>\n<p>&emsp;&emsp;实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。前者从程序处理的数据角度入手，将原始输入分解为若干规模更小的子输入，并将这些子输入指派给专门的工作者线程处理。其结果是产生若干同质的工作者线程。后者从程序的处理逻辑角度入手，将原始任务处理逻辑依照任务的资源消耗属性或者处理步骤分解为若干个子任务，并创建专门的工作者线程来执行这些子任务。其结果是产生多个相互协作的异质工作者线程。</p>\n<p>&emsp;&emsp;多线程编程实践中需要注意以下几下问题。</p>\n<ul>\n<li><p>考虑到多线程程序往往比相应的单线程程序要复杂，且未必比相应的单线程程序快，因此多线程编程的一个实施策略是考虑从单线程程序向多线程程序“进化”，而不是直接迈向“多线程”。</p>\n</li>\n<li><p>线程数的合理设置。设置线程数的基本原则就是避免随意设置&#x2F;使线程数可配置或者可以动态计算得来。设置合理的线程数需要考虑系统的资源状况（处理器数目&#x2F;内存大小等）&#x2F;线程所执行的任务的特性（CPU 密集型任务&#x2F;I&#x2F;O 密集型任务）&#x2F;资源使用情况规划（CPU 使用率上限）以及程序运行过程中使用到的其他稀缺资源情况（如数据库连接&#x2F;文件句柄数）等因素。</p>\n</li>\n<li><p>多线程程序往往比相应的单线程程序产生更多的开销，且需要注意工作者线程的异常处理以及原始任务规模未知问题的应对。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Four.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第四章小结</p>\n</blockquote>\n<p><strong>本章介绍了利用多线程实现并发计算的基本方法以及多线程编程实践中的注意事项及应对措施。</strong></p>\n<hr>\n<p>&emsp;&emsp;挖掘出程序中的可并发点是实现多线程编程的目标——并发计算的前提。</p>\n<p>&emsp;&emsp;实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。前者从程序处理的数据角度入手，将原始输入分解为若干规模更小的子输入，并将这些子输入指派给专门的工作者线程处理。其结果是产生若干同质的工作者线程。后者从程序的处理逻辑角度入手，将原始任务处理逻辑依照任务的资源消耗属性或者处理步骤分解为若干个子任务，并创建专门的工作者线程来执行这些子任务。其结果是产生多个相互协作的异质工作者线程。</p>\n<p>&emsp;&emsp;多线程编程实践中需要注意以下几下问题。</p>\n<ul>\n<li><p>考虑到多线程程序往往比相应的单线程程序要复杂，且未必比相应的单线程程序快，因此多线程编程的一个实施策略是考虑从单线程程序向多线程程序“进化”，而不是直接迈向“多线程”。</p>\n</li>\n<li><p>线程数的合理设置。设置线程数的基本原则就是避免随意设置&#x2F;使线程数可配置或者可以动态计算得来。设置合理的线程数需要考虑系统的资源状况（处理器数目&#x2F;内存大小等）&#x2F;线程所执行的任务的特性（CPU 密集型任务&#x2F;I&#x2F;O 密集型任务）&#x2F;资源使用情况规划（CPU 使用率上限）以及程序运行过程中使用到的其他稀缺资源情况（如数据库连接&#x2F;文件句柄数）等因素。</p>\n</li>\n<li><p>多线程程序往往比相应的单线程程序产生更多的开销，且需要注意工作者线程的异常处理以及原始任务规模未知问题的应对。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Four.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"Java 异步编程","date":"2019-09-01T15:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第九章小结\n\n**本章介绍了同步计算与异步计算的概念，并介绍了 Java 平台对异步计算所提供的相关 API。**\n\n---\n\n&emsp;&emsp;从单个任务的角度来看，任务的执行方式可以是同步的，也可以是异步的。**同步方式的优点是代码简单/直观，缺点是它往往意味着阻塞，因此不利于系统的吞吐率。异步方式的优点则是它往往意味着非阻塞，因此有利于系统的吞吐率，其代价是相对复杂的代码和额外的开销。**阻塞/非阻塞是任务执行方式的属性，它们与任务执行方式没有必然的联系：同步任务既可能是阻塞的，也可能是非阻塞的；异步任务既可能是非阻塞的，也可能是阻塞的。**对于同一个任务，我们既可以说它是同步任务也可以说它是异步任务，这取决于任务的执行方式以及我们的观察角度。**\n\n&emsp;&emsp;Runnable/Callable 接口是对任务处理逻辑进行的抽象，而 Executor 接口是对任务的执行进行的抽象。Executor 接口使得我们能够对任务的提交与任务的具体执行细节进行解耦，这为更改任务的具体执行细节提供了灵活性与便利。ExecutorService 接口是对 Executor 接口的增强：它支持返回异步任务的处理结果/支持资源的管理接口/支持批量任务提交等。ThreadPoolExecutor 是 Executor/ExecutorService 接口的一个实现类。实用工具类 Executors 为线程池的创建提供了快捷方法。Completion Service 接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利，其默认实现类为 ExecutorCompletionService。\n\n&emsp;&emsp;FutureTask 是 Java 标准库提供的 Future 接口实现类，它还实现了 Runnable 接口。因此，FutureTask 可直接用来获取异步任务的处理结果，它可以交给专门的工作者线程执行，也可以交给 Executor 实例执行，甚至由当前线程直接执行（同步）。**一般来说，FutureTask 是一次性使用的，一个 FutureTask 实例代表的任务只能够被执行一次。如果需要多次执行同一个任务，那么可以考虑 AsyncTask 类。**\n\n&emsp;&emsp;计划任务的执行方式包括延迟执行和周期性执行。ScheduledThreadPoolExecutor 是 ScheduledExecutorService 接口的默认实现类，它可以用于执行计划任务。ScheduledFuture 接口可用来获取延迟执行的计划任务的处理结果。如果要获取周期性执行的计划任务的处理结果，可以使用自定义的 AsyncTask 类。**周期性执行的计划任务，其执行周期并不是固定的，而是受任务单次执行耗时的影响：提交给 scheAtFixedRate 方法执行的计划任务，其执行周期为 max（Execution Time,period）；提交给 scheduleWithFixedDelay 方法执行的计划任务，其执行周期为 Execution Time + delay。计划任务在其执行过程中如果抛出未捕获的异常，那么该任务将不会再被执行。**\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Nine.png) ","source":"_posts/Multithreading-Chapter-Nine.md","raw":"---\ntitle: Java 异步编程\ndate: 2019-09-01 23:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第九章小结\n\n**本章介绍了同步计算与异步计算的概念，并介绍了 Java 平台对异步计算所提供的相关 API。**\n\n---\n\n&emsp;&emsp;从单个任务的角度来看，任务的执行方式可以是同步的，也可以是异步的。**同步方式的优点是代码简单/直观，缺点是它往往意味着阻塞，因此不利于系统的吞吐率。异步方式的优点则是它往往意味着非阻塞，因此有利于系统的吞吐率，其代价是相对复杂的代码和额外的开销。**阻塞/非阻塞是任务执行方式的属性，它们与任务执行方式没有必然的联系：同步任务既可能是阻塞的，也可能是非阻塞的；异步任务既可能是非阻塞的，也可能是阻塞的。**对于同一个任务，我们既可以说它是同步任务也可以说它是异步任务，这取决于任务的执行方式以及我们的观察角度。**\n\n&emsp;&emsp;Runnable/Callable 接口是对任务处理逻辑进行的抽象，而 Executor 接口是对任务的执行进行的抽象。Executor 接口使得我们能够对任务的提交与任务的具体执行细节进行解耦，这为更改任务的具体执行细节提供了灵活性与便利。ExecutorService 接口是对 Executor 接口的增强：它支持返回异步任务的处理结果/支持资源的管理接口/支持批量任务提交等。ThreadPoolExecutor 是 Executor/ExecutorService 接口的一个实现类。实用工具类 Executors 为线程池的创建提供了快捷方法。Completion Service 接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利，其默认实现类为 ExecutorCompletionService。\n\n&emsp;&emsp;FutureTask 是 Java 标准库提供的 Future 接口实现类，它还实现了 Runnable 接口。因此，FutureTask 可直接用来获取异步任务的处理结果，它可以交给专门的工作者线程执行，也可以交给 Executor 实例执行，甚至由当前线程直接执行（同步）。**一般来说，FutureTask 是一次性使用的，一个 FutureTask 实例代表的任务只能够被执行一次。如果需要多次执行同一个任务，那么可以考虑 AsyncTask 类。**\n\n&emsp;&emsp;计划任务的执行方式包括延迟执行和周期性执行。ScheduledThreadPoolExecutor 是 ScheduledExecutorService 接口的默认实现类，它可以用于执行计划任务。ScheduledFuture 接口可用来获取延迟执行的计划任务的处理结果。如果要获取周期性执行的计划任务的处理结果，可以使用自定义的 AsyncTask 类。**周期性执行的计划任务，其执行周期并不是固定的，而是受任务单次执行耗时的影响：提交给 scheAtFixedRate 方法执行的计划任务，其执行周期为 max（Execution Time,period）；提交给 scheduleWithFixedDelay 方法执行的计划任务，其执行周期为 Execution Time + delay。计划任务在其执行过程中如果抛出未捕获的异常，那么该任务将不会再被执行。**\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Nine.png) ","slug":"Multithreading-Chapter-Nine","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh6000uk9i1boo76p2e","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第九章小结</p>\n</blockquote>\n<p><strong>本章介绍了同步计算与异步计算的概念，并介绍了 Java 平台对异步计算所提供的相关 API。</strong></p>\n<hr>\n<p>&emsp;&emsp;从单个任务的角度来看，任务的执行方式可以是同步的，也可以是异步的。<strong>同步方式的优点是代码简单&#x2F;直观，缺点是它往往意味着阻塞，因此不利于系统的吞吐率。异步方式的优点则是它往往意味着非阻塞，因此有利于系统的吞吐率，其代价是相对复杂的代码和额外的开销。</strong>阻塞&#x2F;非阻塞是任务执行方式的属性，它们与任务执行方式没有必然的联系：同步任务既可能是阻塞的，也可能是非阻塞的；异步任务既可能是非阻塞的，也可能是阻塞的。<strong>对于同一个任务，我们既可以说它是同步任务也可以说它是异步任务，这取决于任务的执行方式以及我们的观察角度。</strong></p>\n<p>&emsp;&emsp;Runnable&#x2F;Callable 接口是对任务处理逻辑进行的抽象，而 Executor 接口是对任务的执行进行的抽象。Executor 接口使得我们能够对任务的提交与任务的具体执行细节进行解耦，这为更改任务的具体执行细节提供了灵活性与便利。ExecutorService 接口是对 Executor 接口的增强：它支持返回异步任务的处理结果&#x2F;支持资源的管理接口&#x2F;支持批量任务提交等。ThreadPoolExecutor 是 Executor&#x2F;ExecutorService 接口的一个实现类。实用工具类 Executors 为线程池的创建提供了快捷方法。Completion Service 接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利，其默认实现类为 ExecutorCompletionService。</p>\n<p>&emsp;&emsp;FutureTask 是 Java 标准库提供的 Future 接口实现类，它还实现了 Runnable 接口。因此，FutureTask 可直接用来获取异步任务的处理结果，它可以交给专门的工作者线程执行，也可以交给 Executor 实例执行，甚至由当前线程直接执行（同步）。<strong>一般来说，FutureTask 是一次性使用的，一个 FutureTask 实例代表的任务只能够被执行一次。如果需要多次执行同一个任务，那么可以考虑 AsyncTask 类。</strong></p>\n<p>&emsp;&emsp;计划任务的执行方式包括延迟执行和周期性执行。ScheduledThreadPoolExecutor 是 ScheduledExecutorService 接口的默认实现类，它可以用于执行计划任务。ScheduledFuture 接口可用来获取延迟执行的计划任务的处理结果。如果要获取周期性执行的计划任务的处理结果，可以使用自定义的 AsyncTask 类。<strong>周期性执行的计划任务，其执行周期并不是固定的，而是受任务单次执行耗时的影响：提交给 scheAtFixedRate 方法执行的计划任务，其执行周期为 max（Execution Time,period）；提交给 scheduleWithFixedDelay 方法执行的计划任务，其执行周期为 Execution Time + delay。计划任务在其执行过程中如果抛出未捕获的异常，那么该任务将不会再被执行。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Nine.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第九章小结</p>\n</blockquote>\n<p><strong>本章介绍了同步计算与异步计算的概念，并介绍了 Java 平台对异步计算所提供的相关 API。</strong></p>\n<hr>\n<p>&emsp;&emsp;从单个任务的角度来看，任务的执行方式可以是同步的，也可以是异步的。<strong>同步方式的优点是代码简单&#x2F;直观，缺点是它往往意味着阻塞，因此不利于系统的吞吐率。异步方式的优点则是它往往意味着非阻塞，因此有利于系统的吞吐率，其代价是相对复杂的代码和额外的开销。</strong>阻塞&#x2F;非阻塞是任务执行方式的属性，它们与任务执行方式没有必然的联系：同步任务既可能是阻塞的，也可能是非阻塞的；异步任务既可能是非阻塞的，也可能是阻塞的。<strong>对于同一个任务，我们既可以说它是同步任务也可以说它是异步任务，这取决于任务的执行方式以及我们的观察角度。</strong></p>\n<p>&emsp;&emsp;Runnable&#x2F;Callable 接口是对任务处理逻辑进行的抽象，而 Executor 接口是对任务的执行进行的抽象。Executor 接口使得我们能够对任务的提交与任务的具体执行细节进行解耦，这为更改任务的具体执行细节提供了灵活性与便利。ExecutorService 接口是对 Executor 接口的增强：它支持返回异步任务的处理结果&#x2F;支持资源的管理接口&#x2F;支持批量任务提交等。ThreadPoolExecutor 是 Executor&#x2F;ExecutorService 接口的一个实现类。实用工具类 Executors 为线程池的创建提供了快捷方法。Completion Service 接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利，其默认实现类为 ExecutorCompletionService。</p>\n<p>&emsp;&emsp;FutureTask 是 Java 标准库提供的 Future 接口实现类，它还实现了 Runnable 接口。因此，FutureTask 可直接用来获取异步任务的处理结果，它可以交给专门的工作者线程执行，也可以交给 Executor 实例执行，甚至由当前线程直接执行（同步）。<strong>一般来说，FutureTask 是一次性使用的，一个 FutureTask 实例代表的任务只能够被执行一次。如果需要多次执行同一个任务，那么可以考虑 AsyncTask 类。</strong></p>\n<p>&emsp;&emsp;计划任务的执行方式包括延迟执行和周期性执行。ScheduledThreadPoolExecutor 是 ScheduledExecutorService 接口的默认实现类，它可以用于执行计划任务。ScheduledFuture 接口可用来获取延迟执行的计划任务的处理结果。如果要获取周期性执行的计划任务的处理结果，可以使用自定义的 AsyncTask 类。<strong>周期性执行的计划任务，其执行周期并不是固定的，而是受任务单次执行耗时的影响：提交给 scheAtFixedRate 方法执行的计划任务，其执行周期为 max（Execution Time,period）；提交给 scheduleWithFixedDelay 方法执行的计划任务，其执行周期为 Execution Time + delay。计划任务在其执行过程中如果抛出未捕获的异常，那么该任务将不会再被执行。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Nine.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"走近 Java 世界中的线程","date":"2019-06-15T05:47:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第一章小结\n\n**本章介绍了线程、多线程编程这两个基本概念以及 Java 平台对线程的实现。**\n\n---\n\n- 进程是程序的运行实例，一个进程可以包含多个线程，这些线程共享其所在进程的资源。\n\n- **线程是进程中可独立执行的最小单位。**Java 标准库类 `java.lang.Thread` 就是 Java 平台对线程的实现。特定线程总是在执行特定的任务，线程的 `run` 方法就是线程所要执行任务的处理逻辑的入口方法，该方法由 Java 虚拟机直接调用执行。Java 标准库接口 `java.lang.Runnable` 就是对任务的抽象，**Thread 类就是 Runnable 接口的一个实现类**。\n\n- **应用程序负责线程的创建与启动，而线程调度器负责线程的调度和执行。**Java 平台中有两种方式创建线程：创建 Thread 的子类和以 Runnable 接口实例为构造器参数直接通过 new 创建 Thread 实例。\n\n- 在 Java 平台中，任何一段代码总是执行在确定的代码中的。同一段代码可以被不同的线程执行。代码可以通过 `Thread.currentThread()` 调用来获取其当前执行线程。\n\n- 为每个线程设置一个简短而含义明确的名称属性有助于多线程程序的调试和问题定位。\n\n- 一个线程从其创建到运行结束的整个生命周期会经历若干状态。线程执行过程中调用一些对象的方法（如 `Thread.sleep(long millis)`）或者执行特定的操作（如 I/O 操作）往往导致其状态的变更。线程转储是对线程进行监视的重要媒介。操作系统以及 JDK 都提供了一些工具（jvisualvm、jstack 和 Java Mission Control），可以用来获取线程转储。\n\n- Java 平台是一个多线程的平台，线程的身影在 Java 平台中无处不在。按照线程间的创建关系，我们可以将多个线程间的关系理解为一个层次关系。**Java 并无相关 API 用于获取一个线程的父线程或子线程，父线程和子线程之间的生命周期并无必然联系。**\n\n- **线程是多线程编程的基本单位。多线程编程一方面有助于提高系统的吞吐率、提高软件的响应性、充分利用多核处理器资源、最小化对系统资源的使用和简化程序的结构，另一方面面临线程安全问题、线程活性问题、上下文切换和可靠性等问题。**因此，多线程编程绝不仅仅是使用多个线程进行编程那么简单，多线程编程有其自身需要解决的问题，而这正是后续章节的主要内容。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-One.png)\n","source":"_posts/Multithreading-Chapter-One.md","raw":"---\ntitle: 走近 Java 世界中的线程\ndate: 2019-06-15 13:47:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第一章小结\n\n**本章介绍了线程、多线程编程这两个基本概念以及 Java 平台对线程的实现。**\n\n---\n\n- 进程是程序的运行实例，一个进程可以包含多个线程，这些线程共享其所在进程的资源。\n\n- **线程是进程中可独立执行的最小单位。**Java 标准库类 `java.lang.Thread` 就是 Java 平台对线程的实现。特定线程总是在执行特定的任务，线程的 `run` 方法就是线程所要执行任务的处理逻辑的入口方法，该方法由 Java 虚拟机直接调用执行。Java 标准库接口 `java.lang.Runnable` 就是对任务的抽象，**Thread 类就是 Runnable 接口的一个实现类**。\n\n- **应用程序负责线程的创建与启动，而线程调度器负责线程的调度和执行。**Java 平台中有两种方式创建线程：创建 Thread 的子类和以 Runnable 接口实例为构造器参数直接通过 new 创建 Thread 实例。\n\n- 在 Java 平台中，任何一段代码总是执行在确定的代码中的。同一段代码可以被不同的线程执行。代码可以通过 `Thread.currentThread()` 调用来获取其当前执行线程。\n\n- 为每个线程设置一个简短而含义明确的名称属性有助于多线程程序的调试和问题定位。\n\n- 一个线程从其创建到运行结束的整个生命周期会经历若干状态。线程执行过程中调用一些对象的方法（如 `Thread.sleep(long millis)`）或者执行特定的操作（如 I/O 操作）往往导致其状态的变更。线程转储是对线程进行监视的重要媒介。操作系统以及 JDK 都提供了一些工具（jvisualvm、jstack 和 Java Mission Control），可以用来获取线程转储。\n\n- Java 平台是一个多线程的平台，线程的身影在 Java 平台中无处不在。按照线程间的创建关系，我们可以将多个线程间的关系理解为一个层次关系。**Java 并无相关 API 用于获取一个线程的父线程或子线程，父线程和子线程之间的生命周期并无必然联系。**\n\n- **线程是多线程编程的基本单位。多线程编程一方面有助于提高系统的吞吐率、提高软件的响应性、充分利用多核处理器资源、最小化对系统资源的使用和简化程序的结构，另一方面面临线程安全问题、线程活性问题、上下文切换和可靠性等问题。**因此，多线程编程绝不仅仅是使用多个线程进行编程那么简单，多线程编程有其自身需要解决的问题，而这正是后续章节的主要内容。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-One.png)\n","slug":"Multithreading-Chapter-One","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh6000zk9i1f97ag6bb","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第一章小结</p>\n</blockquote>\n<p><strong>本章介绍了线程、多线程编程这两个基本概念以及 Java 平台对线程的实现。</strong></p>\n<hr>\n<ul>\n<li><p>进程是程序的运行实例，一个进程可以包含多个线程，这些线程共享其所在进程的资源。</p>\n</li>\n<li><p><strong>线程是进程中可独立执行的最小单位。</strong>Java 标准库类 <code>java.lang.Thread</code> 就是 Java 平台对线程的实现。特定线程总是在执行特定的任务，线程的 <code>run</code> 方法就是线程所要执行任务的处理逻辑的入口方法，该方法由 Java 虚拟机直接调用执行。Java 标准库接口 <code>java.lang.Runnable</code> 就是对任务的抽象，<strong>Thread 类就是 Runnable 接口的一个实现类</strong>。</p>\n</li>\n<li><p><strong>应用程序负责线程的创建与启动，而线程调度器负责线程的调度和执行。</strong>Java 平台中有两种方式创建线程：创建 Thread 的子类和以 Runnable 接口实例为构造器参数直接通过 new 创建 Thread 实例。</p>\n</li>\n<li><p>在 Java 平台中，任何一段代码总是执行在确定的代码中的。同一段代码可以被不同的线程执行。代码可以通过 <code>Thread.currentThread()</code> 调用来获取其当前执行线程。</p>\n</li>\n<li><p>为每个线程设置一个简短而含义明确的名称属性有助于多线程程序的调试和问题定位。</p>\n</li>\n<li><p>一个线程从其创建到运行结束的整个生命周期会经历若干状态。线程执行过程中调用一些对象的方法（如 <code>Thread.sleep(long millis)</code>）或者执行特定的操作（如 I&#x2F;O 操作）往往导致其状态的变更。线程转储是对线程进行监视的重要媒介。操作系统以及 JDK 都提供了一些工具（jvisualvm、jstack 和 Java Mission Control），可以用来获取线程转储。</p>\n</li>\n<li><p>Java 平台是一个多线程的平台，线程的身影在 Java 平台中无处不在。按照线程间的创建关系，我们可以将多个线程间的关系理解为一个层次关系。<strong>Java 并无相关 API 用于获取一个线程的父线程或子线程，父线程和子线程之间的生命周期并无必然联系。</strong></p>\n</li>\n<li><p><strong>线程是多线程编程的基本单位。多线程编程一方面有助于提高系统的吞吐率、提高软件的响应性、充分利用多核处理器资源、最小化对系统资源的使用和简化程序的结构，另一方面面临线程安全问题、线程活性问题、上下文切换和可靠性等问题。</strong>因此，多线程编程绝不仅仅是使用多个线程进行编程那么简单，多线程编程有其自身需要解决的问题，而这正是后续章节的主要内容。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-One.png\" alt=\"本章知识结构图\"></p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第一章小结</p>\n</blockquote>\n<p><strong>本章介绍了线程、多线程编程这两个基本概念以及 Java 平台对线程的实现。</strong></p>\n<hr>\n<ul>\n<li><p>进程是程序的运行实例，一个进程可以包含多个线程，这些线程共享其所在进程的资源。</p>\n</li>\n<li><p><strong>线程是进程中可独立执行的最小单位。</strong>Java 标准库类 <code>java.lang.Thread</code> 就是 Java 平台对线程的实现。特定线程总是在执行特定的任务，线程的 <code>run</code> 方法就是线程所要执行任务的处理逻辑的入口方法，该方法由 Java 虚拟机直接调用执行。Java 标准库接口 <code>java.lang.Runnable</code> 就是对任务的抽象，<strong>Thread 类就是 Runnable 接口的一个实现类</strong>。</p>\n</li>\n<li><p><strong>应用程序负责线程的创建与启动，而线程调度器负责线程的调度和执行。</strong>Java 平台中有两种方式创建线程：创建 Thread 的子类和以 Runnable 接口实例为构造器参数直接通过 new 创建 Thread 实例。</p>\n</li>\n<li><p>在 Java 平台中，任何一段代码总是执行在确定的代码中的。同一段代码可以被不同的线程执行。代码可以通过 <code>Thread.currentThread()</code> 调用来获取其当前执行线程。</p>\n</li>\n<li><p>为每个线程设置一个简短而含义明确的名称属性有助于多线程程序的调试和问题定位。</p>\n</li>\n<li><p>一个线程从其创建到运行结束的整个生命周期会经历若干状态。线程执行过程中调用一些对象的方法（如 <code>Thread.sleep(long millis)</code>）或者执行特定的操作（如 I&#x2F;O 操作）往往导致其状态的变更。线程转储是对线程进行监视的重要媒介。操作系统以及 JDK 都提供了一些工具（jvisualvm、jstack 和 Java Mission Control），可以用来获取线程转储。</p>\n</li>\n<li><p>Java 平台是一个多线程的平台，线程的身影在 Java 平台中无处不在。按照线程间的创建关系，我们可以将多个线程间的关系理解为一个层次关系。<strong>Java 并无相关 API 用于获取一个线程的父线程或子线程，父线程和子线程之间的生命周期并无必然联系。</strong></p>\n</li>\n<li><p><strong>线程是多线程编程的基本单位。多线程编程一方面有助于提高系统的吞吐率、提高软件的响应性、充分利用多核处理器资源、最小化对系统资源的使用和简化程序的结构，另一方面面临线程安全问题、线程活性问题、上下文切换和可靠性等问题。</strong>因此，多线程编程绝不仅仅是使用多个线程进行编程那么简单，多线程编程有其自身需要解决的问题，而这正是后续章节的主要内容。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-One.png\" alt=\"本章知识结构图\"></p>\n"},{"title":"线程的活性故障","date":"2019-08-25T14:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第七章小结\n\n**本章介绍了常见的线程活性故障以及相应的规避措施。**\n\n---\n\n&emsp;&emsp;死锁会导致相关线程一直被暂停使得其任务无法进展。**产生死锁的必要条件包括：资源互斥/资源不可抢夺/占用并等待资源以及循环等待资源。**我们可以通过查看线程转储手工检测死锁，也可以利用 ThreadMXBean.findDeadlockedThreads() 方法进行死锁的自动检测。死锁的规避方法包括：粗锁法（使用一个粗粒度的锁代替多个锁）/锁排序法（相关线程使用全局统一的顺序申请锁）/使用 ReentrantLock.tryLock(long,TimeUnit)来申请锁/使用开放调用（在调用外部方法时不加锁）以及使用锁的替代品。**使用内部锁或者使用 lock.lock() 申请的显式锁导致的死锁是无法恢复的；使用 lock.lockInterruptibly()申请的显式锁导致的死锁理论上是可恢复的，但实际可操作性不强——自动恢复的尝试可能是徒劳且有害的（导致活锁）。**\n\n&emsp;&emsp;**锁死是等待线程由于某种原因一直无法被唤醒而导致其任务无法进展的一种活性故障。**信号丢失锁死是由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态的一种活性故障。嵌套监视器锁死是嵌套锁导致通知线程无法获得其为唤醒等待线程所需的锁从而使其无法唤醒等待线程，最终使得通知线程与等待线程都一直处于等待状态的一种活性故障。嵌套监视器锁死可以通过查看线程转储进行检测。为规避嵌套监视器锁死，我们应该避免在嵌套锁的内层临界区内实现等待/通知。\n\n&emsp;&emsp;**线程饥饿指线程一直无法获得其所需的资源而导致其任务一直无法进展的一种活性故障。**把锁看成一种资源，那么死锁可被看作一种线程饥饿。饥饿可能演变成活锁。\n\n&emsp;&emsp;**活锁是线程一直在做无用功而使其任务一直无法进展的一种活性故障。**试图进行死锁故障恢复可能导致活锁。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Seven.png) ","source":"_posts/Multithreading-Chapter-Seven.md","raw":"---\ntitle: 线程的活性故障\ndate: 2019-08-25 22:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第七章小结\n\n**本章介绍了常见的线程活性故障以及相应的规避措施。**\n\n---\n\n&emsp;&emsp;死锁会导致相关线程一直被暂停使得其任务无法进展。**产生死锁的必要条件包括：资源互斥/资源不可抢夺/占用并等待资源以及循环等待资源。**我们可以通过查看线程转储手工检测死锁，也可以利用 ThreadMXBean.findDeadlockedThreads() 方法进行死锁的自动检测。死锁的规避方法包括：粗锁法（使用一个粗粒度的锁代替多个锁）/锁排序法（相关线程使用全局统一的顺序申请锁）/使用 ReentrantLock.tryLock(long,TimeUnit)来申请锁/使用开放调用（在调用外部方法时不加锁）以及使用锁的替代品。**使用内部锁或者使用 lock.lock() 申请的显式锁导致的死锁是无法恢复的；使用 lock.lockInterruptibly()申请的显式锁导致的死锁理论上是可恢复的，但实际可操作性不强——自动恢复的尝试可能是徒劳且有害的（导致活锁）。**\n\n&emsp;&emsp;**锁死是等待线程由于某种原因一直无法被唤醒而导致其任务无法进展的一种活性故障。**信号丢失锁死是由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态的一种活性故障。嵌套监视器锁死是嵌套锁导致通知线程无法获得其为唤醒等待线程所需的锁从而使其无法唤醒等待线程，最终使得通知线程与等待线程都一直处于等待状态的一种活性故障。嵌套监视器锁死可以通过查看线程转储进行检测。为规避嵌套监视器锁死，我们应该避免在嵌套锁的内层临界区内实现等待/通知。\n\n&emsp;&emsp;**线程饥饿指线程一直无法获得其所需的资源而导致其任务一直无法进展的一种活性故障。**把锁看成一种资源，那么死锁可被看作一种线程饥饿。饥饿可能演变成活锁。\n\n&emsp;&emsp;**活锁是线程一直在做无用功而使其任务一直无法进展的一种活性故障。**试图进行死锁故障恢复可能导致活锁。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Seven.png) ","slug":"Multithreading-Chapter-Seven","published":1,"updated":"2023-12-23T15:35:23.827Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh60011k9i1dir1dpru","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第七章小结</p>\n</blockquote>\n<p><strong>本章介绍了常见的线程活性故障以及相应的规避措施。</strong></p>\n<hr>\n<p>&emsp;&emsp;死锁会导致相关线程一直被暂停使得其任务无法进展。<strong>产生死锁的必要条件包括：资源互斥&#x2F;资源不可抢夺&#x2F;占用并等待资源以及循环等待资源。</strong>我们可以通过查看线程转储手工检测死锁，也可以利用 ThreadMXBean.findDeadlockedThreads() 方法进行死锁的自动检测。死锁的规避方法包括：粗锁法（使用一个粗粒度的锁代替多个锁）&#x2F;锁排序法（相关线程使用全局统一的顺序申请锁）&#x2F;使用 ReentrantLock.tryLock(long,TimeUnit)来申请锁&#x2F;使用开放调用（在调用外部方法时不加锁）以及使用锁的替代品。<strong>使用内部锁或者使用 lock.lock() 申请的显式锁导致的死锁是无法恢复的；使用 lock.lockInterruptibly()申请的显式锁导致的死锁理论上是可恢复的，但实际可操作性不强——自动恢复的尝试可能是徒劳且有害的（导致活锁）。</strong></p>\n<p>&emsp;&emsp;<strong>锁死是等待线程由于某种原因一直无法被唤醒而导致其任务无法进展的一种活性故障。</strong>信号丢失锁死是由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态的一种活性故障。嵌套监视器锁死是嵌套锁导致通知线程无法获得其为唤醒等待线程所需的锁从而使其无法唤醒等待线程，最终使得通知线程与等待线程都一直处于等待状态的一种活性故障。嵌套监视器锁死可以通过查看线程转储进行检测。为规避嵌套监视器锁死，我们应该避免在嵌套锁的内层临界区内实现等待&#x2F;通知。</p>\n<p>&emsp;&emsp;<strong>线程饥饿指线程一直无法获得其所需的资源而导致其任务一直无法进展的一种活性故障。</strong>把锁看成一种资源，那么死锁可被看作一种线程饥饿。饥饿可能演变成活锁。</p>\n<p>&emsp;&emsp;<strong>活锁是线程一直在做无用功而使其任务一直无法进展的一种活性故障。</strong>试图进行死锁故障恢复可能导致活锁。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Seven.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第七章小结</p>\n</blockquote>\n<p><strong>本章介绍了常见的线程活性故障以及相应的规避措施。</strong></p>\n<hr>\n<p>&emsp;&emsp;死锁会导致相关线程一直被暂停使得其任务无法进展。<strong>产生死锁的必要条件包括：资源互斥&#x2F;资源不可抢夺&#x2F;占用并等待资源以及循环等待资源。</strong>我们可以通过查看线程转储手工检测死锁，也可以利用 ThreadMXBean.findDeadlockedThreads() 方法进行死锁的自动检测。死锁的规避方法包括：粗锁法（使用一个粗粒度的锁代替多个锁）&#x2F;锁排序法（相关线程使用全局统一的顺序申请锁）&#x2F;使用 ReentrantLock.tryLock(long,TimeUnit)来申请锁&#x2F;使用开放调用（在调用外部方法时不加锁）以及使用锁的替代品。<strong>使用内部锁或者使用 lock.lock() 申请的显式锁导致的死锁是无法恢复的；使用 lock.lockInterruptibly()申请的显式锁导致的死锁理论上是可恢复的，但实际可操作性不强——自动恢复的尝试可能是徒劳且有害的（导致活锁）。</strong></p>\n<p>&emsp;&emsp;<strong>锁死是等待线程由于某种原因一直无法被唤醒而导致其任务无法进展的一种活性故障。</strong>信号丢失锁死是由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态的一种活性故障。嵌套监视器锁死是嵌套锁导致通知线程无法获得其为唤醒等待线程所需的锁从而使其无法唤醒等待线程，最终使得通知线程与等待线程都一直处于等待状态的一种活性故障。嵌套监视器锁死可以通过查看线程转储进行检测。为规避嵌套监视器锁死，我们应该避免在嵌套锁的内层临界区内实现等待&#x2F;通知。</p>\n<p>&emsp;&emsp;<strong>线程饥饿指线程一直无法获得其所需的资源而导致其任务一直无法进展的一种活性故障。</strong>把锁看成一种资源，那么死锁可被看作一种线程饥饿。饥饿可能演变成活锁。</p>\n<p>&emsp;&emsp;<strong>活锁是线程一直在做无用功而使其任务一直无法进展的一种活性故障。</strong>试图进行死锁故障恢复可能导致活锁。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Seven.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"保障线程安全的设计技术","date":"2019-08-18T14:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第六章小结\n\n**本章从面向对象编程的角度出发讲解了实现线程安全的几种常用技术。这些技术的运用通常可以产生具有固有线程安全性的对象，即这些对象本身无须借助锁就可以保障线程安全，从而有利于提高系统的并发性。本章还介绍了同步集合和并发集合。**\n\n---\n\n&emsp;&emsp;**Java 运行时空间可分为堆空间/非堆空间以及栈空间。**栈空间是线程的私有空间，而堆空间和非堆空间都是线程的共享空间。堆空间用于存储对象以及类的实例变量，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。非堆空间用于存储类的静态变量以及其他元数据，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。栈空间用于存储线程所执行的方法的局部变量/返回值等私有数据，**它是线程创建时分配的容量固定不可变的存储空间。**\n\n&emsp;&emsp;**无状态对象不包含任何实例变量以及可更新的变量，它具有固有的线程安全性。**无状态对象的客户端代码在调用该对象的任何方法时都无须加锁，而无状态对象自身的方法实现可能仍然需要借助锁。仅包含静态方法的类并不能取代无状态对象。Servlet 类通常需要被设计为无状态对象。\n\n&emsp;&emsp;**不可变对象也具有固有的线程安全性。**严格意义上的不可变对象需要同时满足这几个条件：类本身采用 final 修饰，所有字段都是 final 字段，在对象初始化过程中 this 代表的当前对象没有逸出，引用了状态可变的对象的字段不能直接暴露给其他对象。**如果需要将引用了状态可变的对象的字段暴露给其他对象，那么需要在返回该对象前进行防御性复制，或者返回一个不支持 remove() 的 Iterator 实例。**使用不可变对象建模时，系统状态的变化是通过创建新的不可变对象实现的。这种方式可能有利于提高垃圾回收效率，但也可能由于系统状态频繁变更/无状态对象占用较多内存空间等因素增加了垃圾回收的负担。不可变对象的典型应用场景包括：被建模对象的状态变化不频繁/同时对一组相关的数据进行写操作，因此需要保证原子性/使用不可变对象作为安全可靠的 Map 键。当被建模对象的状态变更比较频繁时，不可变对象也不见得就不能使用。此时，我们需要综合考虑被建模对象的规模/代码目标运行环境的 Java 虚拟机堆内存容量/系统对吞吐率和响应性的要求这几个因素。\n\n&emsp;&emsp;线程特有对象也具有固有的线程安全性。ThreadLocal 是线程访问其线程特有对象的代理。ThreadLocal 也被称为线程局部变量，一个线程可以通过使用不同的线程局部变量来访问不同的线程特有对象实例。多个线程即使是使用同一个线程局部变量，其访问到的对象也是各自的线程特有对象。**线程局部变量通常作为一个类的静态字段来使用。为避免线程局部变量的使用导致内存泄露和伪内存泄露，我们需要确保在线程特有对象不再被需要的时候将其“删除”（即调用 ThreadLocal.remove()）。**线程特有对象的典型应用场景包括：需要使用非线程安全对象，但又不希望因此而引入锁；使用线程安全对象，但希望避免其使用的锁的开销和相关问题；实现方法间的隐式参数传递；实现特定于线程的单例模式。\n\n&emsp;&emsp;装饰器模式也能够用于实现线程安全。在使用装饰器模式的情况下，实现同一组功能的对象有非线程安全版和线程安全版两种。这两种对象具有相同的接口，其中非线程安全版对象仅关注功能的实现，而外包装对象（线程安全版）主要关注线程安全的保障。外包装对象在功能方面则是通过委托给相应的非线程安全对象来实现的。**Java 并发集合就是使用装饰器模式来保障线程安全的。使用装饰器模式实现线程安全的优点是它支持关注点分离，并有利于降低开发难度和提高代码的可测试性，也有利于提高使用的灵活性。其缺点是并发性不高，并可能导致遍历操作是非线程安全的。**\n\n&emsp;&emsp;并发集合一般可用于替代同步集合。其内部实现往往借助于 CAS 操作或者细粒度锁。并发集合支持线程安全的遍历操作，即对集合的遍历操作与更新操作是可以由不同线程并发执行的。**并发集合实现线程安全的遍历操作由两种方式：快照和准实时。**前者无法在遍历过程中反映其他线程对被遍历集合所做的更新，而后者在遍历过程中可能反映其他线程对被遍历集合所做的更新。CopyOnWriteArrayList 相当于 ArrayList 的线程安全版，它适用于遍历操作远比更新操作频繁或者不希望在遍历的时候加锁的场景，在其他场景下我们仍然要考虑使用相应的同步集合。CopyOnWriteArraySet 相当于 HashSet 的线程安全版，内部实现是基于 CopyOnWriteArrayList 的。因此，CopyOnWriteArraySet 适用场景与 CopyOnWriteArrayList 类似。ConcurrentLinkedQueue 相当于 LinkedList 的线程安全版，与 BlockingQueue 的实现类相比，ConcurrentLinkedQueue 适用于更新操作和遍历操作并发的场景。**BlockingQueue 的实现类更适合于多个线程并发更新同一队列的场景，如生产者——消费者模式中。**ConcurrentSkipListMap 相当于 TreeMap 的线程安全版。ConcurrentSkipListSet 相当于 TreeSet 的线程安全版。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Six.png) ","source":"_posts/Multithreading-Chapter-Six.md","raw":"---\ntitle: 保障线程安全的设计技术\ndate: 2019-08-18 22:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第六章小结\n\n**本章从面向对象编程的角度出发讲解了实现线程安全的几种常用技术。这些技术的运用通常可以产生具有固有线程安全性的对象，即这些对象本身无须借助锁就可以保障线程安全，从而有利于提高系统的并发性。本章还介绍了同步集合和并发集合。**\n\n---\n\n&emsp;&emsp;**Java 运行时空间可分为堆空间/非堆空间以及栈空间。**栈空间是线程的私有空间，而堆空间和非堆空间都是线程的共享空间。堆空间用于存储对象以及类的实例变量，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。非堆空间用于存储类的静态变量以及其他元数据，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。栈空间用于存储线程所执行的方法的局部变量/返回值等私有数据，**它是线程创建时分配的容量固定不可变的存储空间。**\n\n&emsp;&emsp;**无状态对象不包含任何实例变量以及可更新的变量，它具有固有的线程安全性。**无状态对象的客户端代码在调用该对象的任何方法时都无须加锁，而无状态对象自身的方法实现可能仍然需要借助锁。仅包含静态方法的类并不能取代无状态对象。Servlet 类通常需要被设计为无状态对象。\n\n&emsp;&emsp;**不可变对象也具有固有的线程安全性。**严格意义上的不可变对象需要同时满足这几个条件：类本身采用 final 修饰，所有字段都是 final 字段，在对象初始化过程中 this 代表的当前对象没有逸出，引用了状态可变的对象的字段不能直接暴露给其他对象。**如果需要将引用了状态可变的对象的字段暴露给其他对象，那么需要在返回该对象前进行防御性复制，或者返回一个不支持 remove() 的 Iterator 实例。**使用不可变对象建模时，系统状态的变化是通过创建新的不可变对象实现的。这种方式可能有利于提高垃圾回收效率，但也可能由于系统状态频繁变更/无状态对象占用较多内存空间等因素增加了垃圾回收的负担。不可变对象的典型应用场景包括：被建模对象的状态变化不频繁/同时对一组相关的数据进行写操作，因此需要保证原子性/使用不可变对象作为安全可靠的 Map 键。当被建模对象的状态变更比较频繁时，不可变对象也不见得就不能使用。此时，我们需要综合考虑被建模对象的规模/代码目标运行环境的 Java 虚拟机堆内存容量/系统对吞吐率和响应性的要求这几个因素。\n\n&emsp;&emsp;线程特有对象也具有固有的线程安全性。ThreadLocal 是线程访问其线程特有对象的代理。ThreadLocal 也被称为线程局部变量，一个线程可以通过使用不同的线程局部变量来访问不同的线程特有对象实例。多个线程即使是使用同一个线程局部变量，其访问到的对象也是各自的线程特有对象。**线程局部变量通常作为一个类的静态字段来使用。为避免线程局部变量的使用导致内存泄露和伪内存泄露，我们需要确保在线程特有对象不再被需要的时候将其“删除”（即调用 ThreadLocal.remove()）。**线程特有对象的典型应用场景包括：需要使用非线程安全对象，但又不希望因此而引入锁；使用线程安全对象，但希望避免其使用的锁的开销和相关问题；实现方法间的隐式参数传递；实现特定于线程的单例模式。\n\n&emsp;&emsp;装饰器模式也能够用于实现线程安全。在使用装饰器模式的情况下，实现同一组功能的对象有非线程安全版和线程安全版两种。这两种对象具有相同的接口，其中非线程安全版对象仅关注功能的实现，而外包装对象（线程安全版）主要关注线程安全的保障。外包装对象在功能方面则是通过委托给相应的非线程安全对象来实现的。**Java 并发集合就是使用装饰器模式来保障线程安全的。使用装饰器模式实现线程安全的优点是它支持关注点分离，并有利于降低开发难度和提高代码的可测试性，也有利于提高使用的灵活性。其缺点是并发性不高，并可能导致遍历操作是非线程安全的。**\n\n&emsp;&emsp;并发集合一般可用于替代同步集合。其内部实现往往借助于 CAS 操作或者细粒度锁。并发集合支持线程安全的遍历操作，即对集合的遍历操作与更新操作是可以由不同线程并发执行的。**并发集合实现线程安全的遍历操作由两种方式：快照和准实时。**前者无法在遍历过程中反映其他线程对被遍历集合所做的更新，而后者在遍历过程中可能反映其他线程对被遍历集合所做的更新。CopyOnWriteArrayList 相当于 ArrayList 的线程安全版，它适用于遍历操作远比更新操作频繁或者不希望在遍历的时候加锁的场景，在其他场景下我们仍然要考虑使用相应的同步集合。CopyOnWriteArraySet 相当于 HashSet 的线程安全版，内部实现是基于 CopyOnWriteArrayList 的。因此，CopyOnWriteArraySet 适用场景与 CopyOnWriteArrayList 类似。ConcurrentLinkedQueue 相当于 LinkedList 的线程安全版，与 BlockingQueue 的实现类相比，ConcurrentLinkedQueue 适用于更新操作和遍历操作并发的场景。**BlockingQueue 的实现类更适合于多个线程并发更新同一队列的场景，如生产者——消费者模式中。**ConcurrentSkipListMap 相当于 TreeMap 的线程安全版。ConcurrentSkipListSet 相当于 TreeSet 的线程安全版。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Six.png) ","slug":"Multithreading-Chapter-Six","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh70015k9i11z5jd2iz","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第六章小结</p>\n</blockquote>\n<p><strong>本章从面向对象编程的角度出发讲解了实现线程安全的几种常用技术。这些技术的运用通常可以产生具有固有线程安全性的对象，即这些对象本身无须借助锁就可以保障线程安全，从而有利于提高系统的并发性。本章还介绍了同步集合和并发集合。</strong></p>\n<hr>\n<p>&emsp;&emsp;<strong>Java 运行时空间可分为堆空间&#x2F;非堆空间以及栈空间。</strong>栈空间是线程的私有空间，而堆空间和非堆空间都是线程的共享空间。堆空间用于存储对象以及类的实例变量，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。非堆空间用于存储类的静态变量以及其他元数据，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。栈空间用于存储线程所执行的方法的局部变量&#x2F;返回值等私有数据，<strong>它是线程创建时分配的容量固定不可变的存储空间。</strong></p>\n<p>&emsp;&emsp;<strong>无状态对象不包含任何实例变量以及可更新的变量，它具有固有的线程安全性。</strong>无状态对象的客户端代码在调用该对象的任何方法时都无须加锁，而无状态对象自身的方法实现可能仍然需要借助锁。仅包含静态方法的类并不能取代无状态对象。Servlet 类通常需要被设计为无状态对象。</p>\n<p>&emsp;&emsp;<strong>不可变对象也具有固有的线程安全性。</strong>严格意义上的不可变对象需要同时满足这几个条件：类本身采用 final 修饰，所有字段都是 final 字段，在对象初始化过程中 this 代表的当前对象没有逸出，引用了状态可变的对象的字段不能直接暴露给其他对象。<strong>如果需要将引用了状态可变的对象的字段暴露给其他对象，那么需要在返回该对象前进行防御性复制，或者返回一个不支持 remove() 的 Iterator 实例。</strong>使用不可变对象建模时，系统状态的变化是通过创建新的不可变对象实现的。这种方式可能有利于提高垃圾回收效率，但也可能由于系统状态频繁变更&#x2F;无状态对象占用较多内存空间等因素增加了垃圾回收的负担。不可变对象的典型应用场景包括：被建模对象的状态变化不频繁&#x2F;同时对一组相关的数据进行写操作，因此需要保证原子性&#x2F;使用不可变对象作为安全可靠的 Map 键。当被建模对象的状态变更比较频繁时，不可变对象也不见得就不能使用。此时，我们需要综合考虑被建模对象的规模&#x2F;代码目标运行环境的 Java 虚拟机堆内存容量&#x2F;系统对吞吐率和响应性的要求这几个因素。</p>\n<p>&emsp;&emsp;线程特有对象也具有固有的线程安全性。ThreadLocal 是线程访问其线程特有对象的代理。ThreadLocal 也被称为线程局部变量，一个线程可以通过使用不同的线程局部变量来访问不同的线程特有对象实例。多个线程即使是使用同一个线程局部变量，其访问到的对象也是各自的线程特有对象。<strong>线程局部变量通常作为一个类的静态字段来使用。为避免线程局部变量的使用导致内存泄露和伪内存泄露，我们需要确保在线程特有对象不再被需要的时候将其“删除”（即调用 ThreadLocal.remove()）。</strong>线程特有对象的典型应用场景包括：需要使用非线程安全对象，但又不希望因此而引入锁；使用线程安全对象，但希望避免其使用的锁的开销和相关问题；实现方法间的隐式参数传递；实现特定于线程的单例模式。</p>\n<p>&emsp;&emsp;装饰器模式也能够用于实现线程安全。在使用装饰器模式的情况下，实现同一组功能的对象有非线程安全版和线程安全版两种。这两种对象具有相同的接口，其中非线程安全版对象仅关注功能的实现，而外包装对象（线程安全版）主要关注线程安全的保障。外包装对象在功能方面则是通过委托给相应的非线程安全对象来实现的。<strong>Java 并发集合就是使用装饰器模式来保障线程安全的。使用装饰器模式实现线程安全的优点是它支持关注点分离，并有利于降低开发难度和提高代码的可测试性，也有利于提高使用的灵活性。其缺点是并发性不高，并可能导致遍历操作是非线程安全的。</strong></p>\n<p>&emsp;&emsp;并发集合一般可用于替代同步集合。其内部实现往往借助于 CAS 操作或者细粒度锁。并发集合支持线程安全的遍历操作，即对集合的遍历操作与更新操作是可以由不同线程并发执行的。<strong>并发集合实现线程安全的遍历操作由两种方式：快照和准实时。</strong>前者无法在遍历过程中反映其他线程对被遍历集合所做的更新，而后者在遍历过程中可能反映其他线程对被遍历集合所做的更新。CopyOnWriteArrayList 相当于 ArrayList 的线程安全版，它适用于遍历操作远比更新操作频繁或者不希望在遍历的时候加锁的场景，在其他场景下我们仍然要考虑使用相应的同步集合。CopyOnWriteArraySet 相当于 HashSet 的线程安全版，内部实现是基于 CopyOnWriteArrayList 的。因此，CopyOnWriteArraySet 适用场景与 CopyOnWriteArrayList 类似。ConcurrentLinkedQueue 相当于 LinkedList 的线程安全版，与 BlockingQueue 的实现类相比，ConcurrentLinkedQueue 适用于更新操作和遍历操作并发的场景。<strong>BlockingQueue 的实现类更适合于多个线程并发更新同一队列的场景，如生产者——消费者模式中。</strong>ConcurrentSkipListMap 相当于 TreeMap 的线程安全版。ConcurrentSkipListSet 相当于 TreeSet 的线程安全版。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Six.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第六章小结</p>\n</blockquote>\n<p><strong>本章从面向对象编程的角度出发讲解了实现线程安全的几种常用技术。这些技术的运用通常可以产生具有固有线程安全性的对象，即这些对象本身无须借助锁就可以保障线程安全，从而有利于提高系统的并发性。本章还介绍了同步集合和并发集合。</strong></p>\n<hr>\n<p>&emsp;&emsp;<strong>Java 运行时空间可分为堆空间&#x2F;非堆空间以及栈空间。</strong>栈空间是线程的私有空间，而堆空间和非堆空间都是线程的共享空间。堆空间用于存储对象以及类的实例变量，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。非堆空间用于存储类的静态变量以及其他元数据，它是 Java 虚拟机启动时分配的可以动态扩容的存储空间。栈空间用于存储线程所执行的方法的局部变量&#x2F;返回值等私有数据，<strong>它是线程创建时分配的容量固定不可变的存储空间。</strong></p>\n<p>&emsp;&emsp;<strong>无状态对象不包含任何实例变量以及可更新的变量，它具有固有的线程安全性。</strong>无状态对象的客户端代码在调用该对象的任何方法时都无须加锁，而无状态对象自身的方法实现可能仍然需要借助锁。仅包含静态方法的类并不能取代无状态对象。Servlet 类通常需要被设计为无状态对象。</p>\n<p>&emsp;&emsp;<strong>不可变对象也具有固有的线程安全性。</strong>严格意义上的不可变对象需要同时满足这几个条件：类本身采用 final 修饰，所有字段都是 final 字段，在对象初始化过程中 this 代表的当前对象没有逸出，引用了状态可变的对象的字段不能直接暴露给其他对象。<strong>如果需要将引用了状态可变的对象的字段暴露给其他对象，那么需要在返回该对象前进行防御性复制，或者返回一个不支持 remove() 的 Iterator 实例。</strong>使用不可变对象建模时，系统状态的变化是通过创建新的不可变对象实现的。这种方式可能有利于提高垃圾回收效率，但也可能由于系统状态频繁变更&#x2F;无状态对象占用较多内存空间等因素增加了垃圾回收的负担。不可变对象的典型应用场景包括：被建模对象的状态变化不频繁&#x2F;同时对一组相关的数据进行写操作，因此需要保证原子性&#x2F;使用不可变对象作为安全可靠的 Map 键。当被建模对象的状态变更比较频繁时，不可变对象也不见得就不能使用。此时，我们需要综合考虑被建模对象的规模&#x2F;代码目标运行环境的 Java 虚拟机堆内存容量&#x2F;系统对吞吐率和响应性的要求这几个因素。</p>\n<p>&emsp;&emsp;线程特有对象也具有固有的线程安全性。ThreadLocal 是线程访问其线程特有对象的代理。ThreadLocal 也被称为线程局部变量，一个线程可以通过使用不同的线程局部变量来访问不同的线程特有对象实例。多个线程即使是使用同一个线程局部变量，其访问到的对象也是各自的线程特有对象。<strong>线程局部变量通常作为一个类的静态字段来使用。为避免线程局部变量的使用导致内存泄露和伪内存泄露，我们需要确保在线程特有对象不再被需要的时候将其“删除”（即调用 ThreadLocal.remove()）。</strong>线程特有对象的典型应用场景包括：需要使用非线程安全对象，但又不希望因此而引入锁；使用线程安全对象，但希望避免其使用的锁的开销和相关问题；实现方法间的隐式参数传递；实现特定于线程的单例模式。</p>\n<p>&emsp;&emsp;装饰器模式也能够用于实现线程安全。在使用装饰器模式的情况下，实现同一组功能的对象有非线程安全版和线程安全版两种。这两种对象具有相同的接口，其中非线程安全版对象仅关注功能的实现，而外包装对象（线程安全版）主要关注线程安全的保障。外包装对象在功能方面则是通过委托给相应的非线程安全对象来实现的。<strong>Java 并发集合就是使用装饰器模式来保障线程安全的。使用装饰器模式实现线程安全的优点是它支持关注点分离，并有利于降低开发难度和提高代码的可测试性，也有利于提高使用的灵活性。其缺点是并发性不高，并可能导致遍历操作是非线程安全的。</strong></p>\n<p>&emsp;&emsp;并发集合一般可用于替代同步集合。其内部实现往往借助于 CAS 操作或者细粒度锁。并发集合支持线程安全的遍历操作，即对集合的遍历操作与更新操作是可以由不同线程并发执行的。<strong>并发集合实现线程安全的遍历操作由两种方式：快照和准实时。</strong>前者无法在遍历过程中反映其他线程对被遍历集合所做的更新，而后者在遍历过程中可能反映其他线程对被遍历集合所做的更新。CopyOnWriteArrayList 相当于 ArrayList 的线程安全版，它适用于遍历操作远比更新操作频繁或者不希望在遍历的时候加锁的场景，在其他场景下我们仍然要考虑使用相应的同步集合。CopyOnWriteArraySet 相当于 HashSet 的线程安全版，内部实现是基于 CopyOnWriteArrayList 的。因此，CopyOnWriteArraySet 适用场景与 CopyOnWriteArrayList 类似。ConcurrentLinkedQueue 相当于 LinkedList 的线程安全版，与 BlockingQueue 的实现类相比，ConcurrentLinkedQueue 适用于更新操作和遍历操作并发的场景。<strong>BlockingQueue 的实现类更适合于多个线程并发更新同一队列的场景，如生产者——消费者模式中。</strong>ConcurrentSkipListMap 相当于 TreeMap 的线程安全版。ConcurrentSkipListSet 相当于 TreeSet 的线程安全版。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Six.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"Java 线程同步机制","date":"2019-07-13T12:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第三章小结\n\n**本章介绍了 Java 平台提供的各种线程同步机制。**\n\n---\n\n&emsp;&emsp;Java 线程同步机制的幕后助手是内存屏障。不同同步机制的功能强弱不同，相应的开销以及可能导致的问题也不同，如下表所示。因此，我们需要根据实际情况选择一个功能适用且开销较小的同步机制。\n\n**Java 线程同步机制的功能与开销/问题**\n\n||锁|volatile|CAS|final|static|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|原子性保障|具备|具备②|具备|不涉及|不涉及|\n|可见性保障|具备|具备|不具备|不具备|具备③|\n|有序性保障|具备|具备|不涉及|具备|具备④|\n|上下文切换？|可能①|不会|不会|不会|可能⑤|\n|备注|①被争用的锁可能导致上下文切换|②仅能够保障对 volatile 变量读/写操作本身的原子性|||③④仅在一个线程初次读取一个类的静态变量时起作用<br>⑤静态变量所属类的初始化可能导致上下文切换|\n\n&emsp;&emsp;锁是 Java 平台中功能最强大的一种线程同步机制，同时其开销也最大，可能导致的问题也最多。被争用的锁会导致上下文切换，锁还可能导致死锁/锁死等线程活性故障。锁适用于存在多个线程对多个共享数据进行更新/check-then-act 操作或者 read-modify-write 操作这样的场景。\n\n&emsp;&emsp;锁的排他性以及 Java 虚拟机在临界区前后插入的内存屏障使得临界区中的操作具有原子性。由此，锁还保障了写线程在临界区中执行操作在读线程看来是有序的，即保障了有序性。Java 虚拟机在 MonitorExit 对应的机器码后插入的内存屏障则保障了可见性。锁能够保障线程安全的前提是访问同一组共享数据的多个线程必须同步在同一个锁之上，否则原子性/可见性和有序性均无法得以保障。在满足貌似串行语义的前提下，临界区内以及临界区外的操作可以在各自范围内重排序。**临界区外的操作可能会被 JIT 编译器重排到临界区内，但是临界区内的操作不会被编译器/处理器重排到临界区之外。**\n\n&emsp;&emsp;Java 中的所有锁都是可重入锁。内部锁（synchronized）仅支持非公平锁，因此它可能导致饥饿。而显式锁（ReentrantLock）既支持非公平锁又支持公平锁，显式锁可能导致锁泄露。内部锁和显式锁各有所长，各有所短。读写锁（ReadWriteLock）由于其内部实现的复杂性，仅适用于只读操作比更新操作要频繁得多且读线程持有锁的时间比较长的场景。**读写锁（ReadWriteLock）中的读锁和写锁是一个锁实例所充当的两个角色，并不是两个独立的锁。**\n\n&emsp;&emsp;线程转储中可以包含锁的相关信息——线程在等待哪些锁，这些锁又是被哪些线程持有的。\n\n&emsp;&emsp;volatile 相当于轻量级锁。在线程安全保障方面与锁相同的是，volatile 能够保障可见性/有序性；与锁不同的是 volatile 不具有排他性，也不会导致上下文切换。与锁类似，Java 虚拟机实现 volatile 对有序性和可见性的保障也是借助于内存屏障。从这个角度来看，volatile 变量写操作相当于释放锁，volatile 变量读操作相当于获得锁——Java 虚拟机通过在 volatile 变量写操作之前插入一个释放屏障，在 volatile 读操作之后插入一个获取屏障这种成对的释放屏障和获取屏障的使用实现了 volatile 对有序性的保障。类似地，Java 虚拟机在 volatile 变量写操作之后插入一个存储屏障，在 volatile 变量读操作之前插入一个加载屏障这种成对的存储屏障与加载屏障的使用实现了 volatile 对可见性的保障。\n\n&emsp;&emsp;在原子性方面，volatile 仅能够保障 long/double 型变量写操作的原子性。**如果要保障对 volatile 变量的赋值操作的线程安全，那么赋值操作右边的表达式不能涉及任何共享变量（包括被赋值的变量本身）。**volatile 关键字在可见性/有序性和原子性方面的保障并不会对其修饰的数组元素的读/写起作用。\n\n&emsp;&emsp;volatile 变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。读取一个 volatile 变量总是意味着（通过高速缓存进行的）读内存操作，而不是从寄存器中读取。因此，volatile 变量读操作的成本比读取普通变量要略高一些，但比在临界区中读取变量要低。\n\n&emsp;&emsp;volatile 的典型运用场景包括：一，使用 volatile 变量作为状态标志；二，使用 volatile 保障可见性；三，使用 volatile 变量替代锁；四，使用 volatile 实现简易版读写锁。\n\n&emsp;&emsp;CAS 使得我们可以在不借助锁的情况下保障 read-modify-write 操作/check-then-act 操作的原子性，但是它并不保障可见性。原子变量类相当于基于 CAS 实现的增强型 volatile 变量（保障 volatile 无法保障的那一部分操作的原子性）。常用的原子变量类包括 AtomicInteger/AtomicLong/AtomicBoolean 等。AtomicStampedReference 则可以用于规避 CAS 的 ABA 问题。\n\n&emsp;&emsp;**static 关键字能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值（而不是默认值）**。对于引用型静态变量，static 还确保了该变量引用的对象已经初始化完毕。但是，static 的这种可见性和有序性保障仅在一个线程初次读取静态变量的时候起作用。\n\n&emsp;&emsp;final 关键字在多线程环境下也有其特殊作用：**当一个对象被发布到其他线程的时候，该对象的所有 final 字段（实例变量）都是初始化完毕的。而非 final 字段没有这种保障，即这些线程读取该对象的非 final 字段时所读取到的值可能仍然是相应字段的默认值。**对于引用型 final 字段，final 关键字还进一步确保该字段所引用的对象已经初始化完毕。\n\n&emsp;&emsp;实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。\n\n- 使用 static 关键字修饰引用该对象的变量。\n- 使用 final 关键字修饰引用该对象的变量。\n- 使用 volatile 关键字修饰引用该对象的变量。\n- 使用 AtomicReference 来引用该对象。\n- 对访问该对象的代码进行加锁。\n\n&emsp;&emsp;为避免将 this 代表的当前对象逸出到其他线程，我们应该避免在构造器中启动工作者线程。通常我们可以定义一个 init 方法，在该方法中启动工作者线程。在此基础上，定义一个工厂方法来创建（并返回）相应的实例，并在该方法中调用该实例的 init 方法。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Three.png)\n","source":"_posts/Multithreading-Chapter-Three.md","raw":"---\ntitle: Java 线程同步机制\ndate: 2019-07-13 20:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第三章小结\n\n**本章介绍了 Java 平台提供的各种线程同步机制。**\n\n---\n\n&emsp;&emsp;Java 线程同步机制的幕后助手是内存屏障。不同同步机制的功能强弱不同，相应的开销以及可能导致的问题也不同，如下表所示。因此，我们需要根据实际情况选择一个功能适用且开销较小的同步机制。\n\n**Java 线程同步机制的功能与开销/问题**\n\n||锁|volatile|CAS|final|static|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|原子性保障|具备|具备②|具备|不涉及|不涉及|\n|可见性保障|具备|具备|不具备|不具备|具备③|\n|有序性保障|具备|具备|不涉及|具备|具备④|\n|上下文切换？|可能①|不会|不会|不会|可能⑤|\n|备注|①被争用的锁可能导致上下文切换|②仅能够保障对 volatile 变量读/写操作本身的原子性|||③④仅在一个线程初次读取一个类的静态变量时起作用<br>⑤静态变量所属类的初始化可能导致上下文切换|\n\n&emsp;&emsp;锁是 Java 平台中功能最强大的一种线程同步机制，同时其开销也最大，可能导致的问题也最多。被争用的锁会导致上下文切换，锁还可能导致死锁/锁死等线程活性故障。锁适用于存在多个线程对多个共享数据进行更新/check-then-act 操作或者 read-modify-write 操作这样的场景。\n\n&emsp;&emsp;锁的排他性以及 Java 虚拟机在临界区前后插入的内存屏障使得临界区中的操作具有原子性。由此，锁还保障了写线程在临界区中执行操作在读线程看来是有序的，即保障了有序性。Java 虚拟机在 MonitorExit 对应的机器码后插入的内存屏障则保障了可见性。锁能够保障线程安全的前提是访问同一组共享数据的多个线程必须同步在同一个锁之上，否则原子性/可见性和有序性均无法得以保障。在满足貌似串行语义的前提下，临界区内以及临界区外的操作可以在各自范围内重排序。**临界区外的操作可能会被 JIT 编译器重排到临界区内，但是临界区内的操作不会被编译器/处理器重排到临界区之外。**\n\n&emsp;&emsp;Java 中的所有锁都是可重入锁。内部锁（synchronized）仅支持非公平锁，因此它可能导致饥饿。而显式锁（ReentrantLock）既支持非公平锁又支持公平锁，显式锁可能导致锁泄露。内部锁和显式锁各有所长，各有所短。读写锁（ReadWriteLock）由于其内部实现的复杂性，仅适用于只读操作比更新操作要频繁得多且读线程持有锁的时间比较长的场景。**读写锁（ReadWriteLock）中的读锁和写锁是一个锁实例所充当的两个角色，并不是两个独立的锁。**\n\n&emsp;&emsp;线程转储中可以包含锁的相关信息——线程在等待哪些锁，这些锁又是被哪些线程持有的。\n\n&emsp;&emsp;volatile 相当于轻量级锁。在线程安全保障方面与锁相同的是，volatile 能够保障可见性/有序性；与锁不同的是 volatile 不具有排他性，也不会导致上下文切换。与锁类似，Java 虚拟机实现 volatile 对有序性和可见性的保障也是借助于内存屏障。从这个角度来看，volatile 变量写操作相当于释放锁，volatile 变量读操作相当于获得锁——Java 虚拟机通过在 volatile 变量写操作之前插入一个释放屏障，在 volatile 读操作之后插入一个获取屏障这种成对的释放屏障和获取屏障的使用实现了 volatile 对有序性的保障。类似地，Java 虚拟机在 volatile 变量写操作之后插入一个存储屏障，在 volatile 变量读操作之前插入一个加载屏障这种成对的存储屏障与加载屏障的使用实现了 volatile 对可见性的保障。\n\n&emsp;&emsp;在原子性方面，volatile 仅能够保障 long/double 型变量写操作的原子性。**如果要保障对 volatile 变量的赋值操作的线程安全，那么赋值操作右边的表达式不能涉及任何共享变量（包括被赋值的变量本身）。**volatile 关键字在可见性/有序性和原子性方面的保障并不会对其修饰的数组元素的读/写起作用。\n\n&emsp;&emsp;volatile 变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。读取一个 volatile 变量总是意味着（通过高速缓存进行的）读内存操作，而不是从寄存器中读取。因此，volatile 变量读操作的成本比读取普通变量要略高一些，但比在临界区中读取变量要低。\n\n&emsp;&emsp;volatile 的典型运用场景包括：一，使用 volatile 变量作为状态标志；二，使用 volatile 保障可见性；三，使用 volatile 变量替代锁；四，使用 volatile 实现简易版读写锁。\n\n&emsp;&emsp;CAS 使得我们可以在不借助锁的情况下保障 read-modify-write 操作/check-then-act 操作的原子性，但是它并不保障可见性。原子变量类相当于基于 CAS 实现的增强型 volatile 变量（保障 volatile 无法保障的那一部分操作的原子性）。常用的原子变量类包括 AtomicInteger/AtomicLong/AtomicBoolean 等。AtomicStampedReference 则可以用于规避 CAS 的 ABA 问题。\n\n&emsp;&emsp;**static 关键字能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值（而不是默认值）**。对于引用型静态变量，static 还确保了该变量引用的对象已经初始化完毕。但是，static 的这种可见性和有序性保障仅在一个线程初次读取静态变量的时候起作用。\n\n&emsp;&emsp;final 关键字在多线程环境下也有其特殊作用：**当一个对象被发布到其他线程的时候，该对象的所有 final 字段（实例变量）都是初始化完毕的。而非 final 字段没有这种保障，即这些线程读取该对象的非 final 字段时所读取到的值可能仍然是相应字段的默认值。**对于引用型 final 字段，final 关键字还进一步确保该字段所引用的对象已经初始化完毕。\n\n&emsp;&emsp;实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。\n\n- 使用 static 关键字修饰引用该对象的变量。\n- 使用 final 关键字修饰引用该对象的变量。\n- 使用 volatile 关键字修饰引用该对象的变量。\n- 使用 AtomicReference 来引用该对象。\n- 对访问该对象的代码进行加锁。\n\n&emsp;&emsp;为避免将 this 代表的当前对象逸出到其他线程，我们应该避免在构造器中启动工作者线程。通常我们可以定义一个 init 方法，在该方法中启动工作者线程。在此基础上，定义一个工厂方法来创建（并返回）相应的实例，并在该方法中调用该实例的 init 方法。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Three.png)\n","slug":"Multithreading-Chapter-Three","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh70018k9i19syfgsht","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第三章小结</p>\n</blockquote>\n<p><strong>本章介绍了 Java 平台提供的各种线程同步机制。</strong></p>\n<hr>\n<p>&emsp;&emsp;Java 线程同步机制的幕后助手是内存屏障。不同同步机制的功能强弱不同，相应的开销以及可能导致的问题也不同，如下表所示。因此，我们需要根据实际情况选择一个功能适用且开销较小的同步机制。</p>\n<p><strong>Java 线程同步机制的功能与开销&#x2F;问题</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">锁</th>\n<th align=\"center\">volatile</th>\n<th align=\"center\">CAS</th>\n<th align=\"center\">final</th>\n<th align=\"center\">static</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">原子性保障</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备②</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">不涉及</td>\n<td align=\"center\">不涉及</td>\n</tr>\n<tr>\n<td align=\"center\">可见性保障</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">不具备</td>\n<td align=\"center\">不具备</td>\n<td align=\"center\">具备③</td>\n</tr>\n<tr>\n<td align=\"center\">有序性保障</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">不涉及</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备④</td>\n</tr>\n<tr>\n<td align=\"center\">上下文切换？</td>\n<td align=\"center\">可能①</td>\n<td align=\"center\">不会</td>\n<td align=\"center\">不会</td>\n<td align=\"center\">不会</td>\n<td align=\"center\">可能⑤</td>\n</tr>\n<tr>\n<td align=\"center\">备注</td>\n<td align=\"center\">①被争用的锁可能导致上下文切换</td>\n<td align=\"center\">②仅能够保障对 volatile 变量读&#x2F;写操作本身的原子性</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">③④仅在一个线程初次读取一个类的静态变量时起作用<br>⑤静态变量所属类的初始化可能导致上下文切换</td>\n</tr>\n</tbody></table>\n<p>&emsp;&emsp;锁是 Java 平台中功能最强大的一种线程同步机制，同时其开销也最大，可能导致的问题也最多。被争用的锁会导致上下文切换，锁还可能导致死锁&#x2F;锁死等线程活性故障。锁适用于存在多个线程对多个共享数据进行更新&#x2F;check-then-act 操作或者 read-modify-write 操作这样的场景。</p>\n<p>&emsp;&emsp;锁的排他性以及 Java 虚拟机在临界区前后插入的内存屏障使得临界区中的操作具有原子性。由此，锁还保障了写线程在临界区中执行操作在读线程看来是有序的，即保障了有序性。Java 虚拟机在 MonitorExit 对应的机器码后插入的内存屏障则保障了可见性。锁能够保障线程安全的前提是访问同一组共享数据的多个线程必须同步在同一个锁之上，否则原子性&#x2F;可见性和有序性均无法得以保障。在满足貌似串行语义的前提下，临界区内以及临界区外的操作可以在各自范围内重排序。<strong>临界区外的操作可能会被 JIT 编译器重排到临界区内，但是临界区内的操作不会被编译器&#x2F;处理器重排到临界区之外。</strong></p>\n<p>&emsp;&emsp;Java 中的所有锁都是可重入锁。内部锁（synchronized）仅支持非公平锁，因此它可能导致饥饿。而显式锁（ReentrantLock）既支持非公平锁又支持公平锁，显式锁可能导致锁泄露。内部锁和显式锁各有所长，各有所短。读写锁（ReadWriteLock）由于其内部实现的复杂性，仅适用于只读操作比更新操作要频繁得多且读线程持有锁的时间比较长的场景。<strong>读写锁（ReadWriteLock）中的读锁和写锁是一个锁实例所充当的两个角色，并不是两个独立的锁。</strong></p>\n<p>&emsp;&emsp;线程转储中可以包含锁的相关信息——线程在等待哪些锁，这些锁又是被哪些线程持有的。</p>\n<p>&emsp;&emsp;volatile 相当于轻量级锁。在线程安全保障方面与锁相同的是，volatile 能够保障可见性&#x2F;有序性；与锁不同的是 volatile 不具有排他性，也不会导致上下文切换。与锁类似，Java 虚拟机实现 volatile 对有序性和可见性的保障也是借助于内存屏障。从这个角度来看，volatile 变量写操作相当于释放锁，volatile 变量读操作相当于获得锁——Java 虚拟机通过在 volatile 变量写操作之前插入一个释放屏障，在 volatile 读操作之后插入一个获取屏障这种成对的释放屏障和获取屏障的使用实现了 volatile 对有序性的保障。类似地，Java 虚拟机在 volatile 变量写操作之后插入一个存储屏障，在 volatile 变量读操作之前插入一个加载屏障这种成对的存储屏障与加载屏障的使用实现了 volatile 对可见性的保障。</p>\n<p>&emsp;&emsp;在原子性方面，volatile 仅能够保障 long&#x2F;double 型变量写操作的原子性。<strong>如果要保障对 volatile 变量的赋值操作的线程安全，那么赋值操作右边的表达式不能涉及任何共享变量（包括被赋值的变量本身）。</strong>volatile 关键字在可见性&#x2F;有序性和原子性方面的保障并不会对其修饰的数组元素的读&#x2F;写起作用。</p>\n<p>&emsp;&emsp;volatile 变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。读取一个 volatile 变量总是意味着（通过高速缓存进行的）读内存操作，而不是从寄存器中读取。因此，volatile 变量读操作的成本比读取普通变量要略高一些，但比在临界区中读取变量要低。</p>\n<p>&emsp;&emsp;volatile 的典型运用场景包括：一，使用 volatile 变量作为状态标志；二，使用 volatile 保障可见性；三，使用 volatile 变量替代锁；四，使用 volatile 实现简易版读写锁。</p>\n<p>&emsp;&emsp;CAS 使得我们可以在不借助锁的情况下保障 read-modify-write 操作&#x2F;check-then-act 操作的原子性，但是它并不保障可见性。原子变量类相当于基于 CAS 实现的增强型 volatile 变量（保障 volatile 无法保障的那一部分操作的原子性）。常用的原子变量类包括 AtomicInteger&#x2F;AtomicLong&#x2F;AtomicBoolean 等。AtomicStampedReference 则可以用于规避 CAS 的 ABA 问题。</p>\n<p>&emsp;&emsp;<strong>static 关键字能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值（而不是默认值）</strong>。对于引用型静态变量，static 还确保了该变量引用的对象已经初始化完毕。但是，static 的这种可见性和有序性保障仅在一个线程初次读取静态变量的时候起作用。</p>\n<p>&emsp;&emsp;final 关键字在多线程环境下也有其特殊作用：<strong>当一个对象被发布到其他线程的时候，该对象的所有 final 字段（实例变量）都是初始化完毕的。而非 final 字段没有这种保障，即这些线程读取该对象的非 final 字段时所读取到的值可能仍然是相应字段的默认值。</strong>对于引用型 final 字段，final 关键字还进一步确保该字段所引用的对象已经初始化完毕。</p>\n<p>&emsp;&emsp;实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。</p>\n<ul>\n<li>使用 static 关键字修饰引用该对象的变量。</li>\n<li>使用 final 关键字修饰引用该对象的变量。</li>\n<li>使用 volatile 关键字修饰引用该对象的变量。</li>\n<li>使用 AtomicReference 来引用该对象。</li>\n<li>对访问该对象的代码进行加锁。</li>\n</ul>\n<p>&emsp;&emsp;为避免将 this 代表的当前对象逸出到其他线程，我们应该避免在构造器中启动工作者线程。通常我们可以定义一个 init 方法，在该方法中启动工作者线程。在此基础上，定义一个工厂方法来创建（并返回）相应的实例，并在该方法中调用该实例的 init 方法。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Three.png\" alt=\"本章知识结构图\"></p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第三章小结</p>\n</blockquote>\n<p><strong>本章介绍了 Java 平台提供的各种线程同步机制。</strong></p>\n<hr>\n<p>&emsp;&emsp;Java 线程同步机制的幕后助手是内存屏障。不同同步机制的功能强弱不同，相应的开销以及可能导致的问题也不同，如下表所示。因此，我们需要根据实际情况选择一个功能适用且开销较小的同步机制。</p>\n<p><strong>Java 线程同步机制的功能与开销&#x2F;问题</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">锁</th>\n<th align=\"center\">volatile</th>\n<th align=\"center\">CAS</th>\n<th align=\"center\">final</th>\n<th align=\"center\">static</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">原子性保障</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备②</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">不涉及</td>\n<td align=\"center\">不涉及</td>\n</tr>\n<tr>\n<td align=\"center\">可见性保障</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">不具备</td>\n<td align=\"center\">不具备</td>\n<td align=\"center\">具备③</td>\n</tr>\n<tr>\n<td align=\"center\">有序性保障</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">不涉及</td>\n<td align=\"center\">具备</td>\n<td align=\"center\">具备④</td>\n</tr>\n<tr>\n<td align=\"center\">上下文切换？</td>\n<td align=\"center\">可能①</td>\n<td align=\"center\">不会</td>\n<td align=\"center\">不会</td>\n<td align=\"center\">不会</td>\n<td align=\"center\">可能⑤</td>\n</tr>\n<tr>\n<td align=\"center\">备注</td>\n<td align=\"center\">①被争用的锁可能导致上下文切换</td>\n<td align=\"center\">②仅能够保障对 volatile 变量读&#x2F;写操作本身的原子性</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">③④仅在一个线程初次读取一个类的静态变量时起作用<br>⑤静态变量所属类的初始化可能导致上下文切换</td>\n</tr>\n</tbody></table>\n<p>&emsp;&emsp;锁是 Java 平台中功能最强大的一种线程同步机制，同时其开销也最大，可能导致的问题也最多。被争用的锁会导致上下文切换，锁还可能导致死锁&#x2F;锁死等线程活性故障。锁适用于存在多个线程对多个共享数据进行更新&#x2F;check-then-act 操作或者 read-modify-write 操作这样的场景。</p>\n<p>&emsp;&emsp;锁的排他性以及 Java 虚拟机在临界区前后插入的内存屏障使得临界区中的操作具有原子性。由此，锁还保障了写线程在临界区中执行操作在读线程看来是有序的，即保障了有序性。Java 虚拟机在 MonitorExit 对应的机器码后插入的内存屏障则保障了可见性。锁能够保障线程安全的前提是访问同一组共享数据的多个线程必须同步在同一个锁之上，否则原子性&#x2F;可见性和有序性均无法得以保障。在满足貌似串行语义的前提下，临界区内以及临界区外的操作可以在各自范围内重排序。<strong>临界区外的操作可能会被 JIT 编译器重排到临界区内，但是临界区内的操作不会被编译器&#x2F;处理器重排到临界区之外。</strong></p>\n<p>&emsp;&emsp;Java 中的所有锁都是可重入锁。内部锁（synchronized）仅支持非公平锁，因此它可能导致饥饿。而显式锁（ReentrantLock）既支持非公平锁又支持公平锁，显式锁可能导致锁泄露。内部锁和显式锁各有所长，各有所短。读写锁（ReadWriteLock）由于其内部实现的复杂性，仅适用于只读操作比更新操作要频繁得多且读线程持有锁的时间比较长的场景。<strong>读写锁（ReadWriteLock）中的读锁和写锁是一个锁实例所充当的两个角色，并不是两个独立的锁。</strong></p>\n<p>&emsp;&emsp;线程转储中可以包含锁的相关信息——线程在等待哪些锁，这些锁又是被哪些线程持有的。</p>\n<p>&emsp;&emsp;volatile 相当于轻量级锁。在线程安全保障方面与锁相同的是，volatile 能够保障可见性&#x2F;有序性；与锁不同的是 volatile 不具有排他性，也不会导致上下文切换。与锁类似，Java 虚拟机实现 volatile 对有序性和可见性的保障也是借助于内存屏障。从这个角度来看，volatile 变量写操作相当于释放锁，volatile 变量读操作相当于获得锁——Java 虚拟机通过在 volatile 变量写操作之前插入一个释放屏障，在 volatile 读操作之后插入一个获取屏障这种成对的释放屏障和获取屏障的使用实现了 volatile 对有序性的保障。类似地，Java 虚拟机在 volatile 变量写操作之后插入一个存储屏障，在 volatile 变量读操作之前插入一个加载屏障这种成对的存储屏障与加载屏障的使用实现了 volatile 对可见性的保障。</p>\n<p>&emsp;&emsp;在原子性方面，volatile 仅能够保障 long&#x2F;double 型变量写操作的原子性。<strong>如果要保障对 volatile 变量的赋值操作的线程安全，那么赋值操作右边的表达式不能涉及任何共享变量（包括被赋值的变量本身）。</strong>volatile 关键字在可见性&#x2F;有序性和原子性方面的保障并不会对其修饰的数组元素的读&#x2F;写起作用。</p>\n<p>&emsp;&emsp;volatile 变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。读取一个 volatile 变量总是意味着（通过高速缓存进行的）读内存操作，而不是从寄存器中读取。因此，volatile 变量读操作的成本比读取普通变量要略高一些，但比在临界区中读取变量要低。</p>\n<p>&emsp;&emsp;volatile 的典型运用场景包括：一，使用 volatile 变量作为状态标志；二，使用 volatile 保障可见性；三，使用 volatile 变量替代锁；四，使用 volatile 实现简易版读写锁。</p>\n<p>&emsp;&emsp;CAS 使得我们可以在不借助锁的情况下保障 read-modify-write 操作&#x2F;check-then-act 操作的原子性，但是它并不保障可见性。原子变量类相当于基于 CAS 实现的增强型 volatile 变量（保障 volatile 无法保障的那一部分操作的原子性）。常用的原子变量类包括 AtomicInteger&#x2F;AtomicLong&#x2F;AtomicBoolean 等。AtomicStampedReference 则可以用于规避 CAS 的 ABA 问题。</p>\n<p>&emsp;&emsp;<strong>static 关键字能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值（而不是默认值）</strong>。对于引用型静态变量，static 还确保了该变量引用的对象已经初始化完毕。但是，static 的这种可见性和有序性保障仅在一个线程初次读取静态变量的时候起作用。</p>\n<p>&emsp;&emsp;final 关键字在多线程环境下也有其特殊作用：<strong>当一个对象被发布到其他线程的时候，该对象的所有 final 字段（实例变量）都是初始化完毕的。而非 final 字段没有这种保障，即这些线程读取该对象的非 final 字段时所读取到的值可能仍然是相应字段的默认值。</strong>对于引用型 final 字段，final 关键字还进一步确保该字段所引用的对象已经初始化完毕。</p>\n<p>&emsp;&emsp;实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。</p>\n<ul>\n<li>使用 static 关键字修饰引用该对象的变量。</li>\n<li>使用 final 关键字修饰引用该对象的变量。</li>\n<li>使用 volatile 关键字修饰引用该对象的变量。</li>\n<li>使用 AtomicReference 来引用该对象。</li>\n<li>对访问该对象的代码进行加锁。</li>\n</ul>\n<p>&emsp;&emsp;为避免将 this 代表的当前对象逸出到其他线程，我们应该避免在构造器中启动工作者线程。通常我们可以定义一个 init 方法，在该方法中启动工作者线程。在此基础上，定义一个工厂方法来创建（并返回）相应的实例，并在该方法中调用该实例的 init 方法。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Three.png\" alt=\"本章知识结构图\"></p>\n"},{"title":"Java 多线程程序的性能调校","date":"2019-09-13T15:25:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第十二章小结\n\n**本章介绍了与 Java 多线程程序紧密相关的性能调校常用技术。**\n\n---\n\n&emsp;&emsp;Java 虚拟机自 Java 6 开始对内部锁进行了若干优化：锁消除、锁粗化、偏向锁以及适应性锁。除锁消除是 Java 7 开始引入的，其他优化均是在 Java 6 开始引入的，**这些优化仅在 Java 虚拟机的 server 模式下起作用。这些优化默认都是开启的，且多数优化都可能依赖于 JIT 的内联优化，并且其本身也可能是通过 JIT 编译实现的。**因此，这些优化都有其开销。锁消除优化能够彻底消除锁的开销，它依赖于逃逸分析技术。锁粗化优化能够减少线程申请/释放锁的频率，其代价是使临界区长度变大，从而可能导致线程在申请锁时的等待时间变长。偏向锁优化可以减小锁的申请/释放的开销，它不适用于争用程度较高的锁。适应性锁优化可以减小锁申请的开销，有利于减少上下文切换。\n\n&emsp;&emsp;**锁的开销主要是由争用锁引起的。**这些开销主要包括：上下文切换与线程调度开销、内存同步、编译器优化受限的开销以及限制可伸缩性。降低锁的开销可以从使用锁的替代品、降低锁的争用程度以及减少线程所需申请的锁的数量这几个方面入手。\n\n&emsp;&emsp;使用可参数化锁可以减少线程所需申请的锁的数量从而降低锁的开销，但是它在一定程度上破坏了封装性。\n\n&emsp;&emsp;减小临界区的长度可以减少锁的持有时间，从而降低锁的争用程度。减小临界区的长度有利于适用性锁优化发挥作用。在不影响线程安全的前提下，将临界区中的阻塞式 I/O 等阻塞操作以及较耗时的操作挪动到临界区之外可以减小临界区的长度。\n\n&emsp;&emsp;减小锁的粒度可以降低锁的申请频率从而降低锁的争用程度。减小锁的粒度常用技术包括锁拆分技术和锁分段技术。锁拆分技术在高争用情况下的效果可能并不明显；锁分段技术会使得对整个对象进行加锁比较困难乃至不可能。\n\n&emsp;&emsp;减少上下文切换可以从这几个方面入手：控制线程数量、避免在临界区中执行阻塞式 I/O 等阻塞操作、避免在临界区中执行比较耗时的操作和减少 Java 虚拟机垃圾回收。\n\n&emsp;&emsp;运用多线程设计模式也有助于提升多线程程序的性能，但是程序的复杂性也可能相应增加。\n\n&emsp;&emsp;**伪共享产生的前提是多个线程访问被缓存到同一个缓存中的不同变量，它会导致大量的缓存未命中，从而增加内存访问操作的开销。**了解 Java 对象的内存布局有助于分析与消除伪共享。Java 对象内存布局的规则包括：对象是以 8 字节为粒度进行对齐的、对象中的实例字段并非依照其源代码声明顺序排列以及继承自父类的实例字段不会与类本身定义的实例字段混杂在一起进行存储等。使用 jol 工具可以查看具体对象的内存布局情况。判断伪共享是否存在可以从分析多个线程是否存在共同的共享变量入手，并通过 jol 以及 Linux 内核工具 perf 来进一步分析与确认。**伪共享可通过手工填充、自动填充以及降低共享变量的访问频率这几个方面来消除与规避。**手工填充和自动填充可以在无须调整程序算法的前提下消除伪共享。手工填充的缺点比较多，使用该方法我们必须知道缓存行的宽度、Java 对象的具体内存布局，这使得该方法存在硬件、软件层面的可移植性问题，并对人员的要求比较高。并且，我们还需要避免手工填充的字段被 Java 虚拟机优化掉，自动填充依赖于 `@Contented` 注解，它避免了手工填充的缺点，但是其消耗的额外空间更多。Java 虚拟机对自动填充的支持需要通过 Java 虚拟机的开关 \"-XX:-RestrictContended\" 开启。虽然减少共享变量的访问频率所带来的效果可能比较明显，但是由于它可能涉及程序算法的调整，因此其适用范围比较有限。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Twelve.png) ","source":"_posts/Multithreading-Chapter-Twelve.md","raw":"---\ntitle: Java 多线程程序的性能调校\ndate: 2019-09-13 23:25:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第十二章小结\n\n**本章介绍了与 Java 多线程程序紧密相关的性能调校常用技术。**\n\n---\n\n&emsp;&emsp;Java 虚拟机自 Java 6 开始对内部锁进行了若干优化：锁消除、锁粗化、偏向锁以及适应性锁。除锁消除是 Java 7 开始引入的，其他优化均是在 Java 6 开始引入的，**这些优化仅在 Java 虚拟机的 server 模式下起作用。这些优化默认都是开启的，且多数优化都可能依赖于 JIT 的内联优化，并且其本身也可能是通过 JIT 编译实现的。**因此，这些优化都有其开销。锁消除优化能够彻底消除锁的开销，它依赖于逃逸分析技术。锁粗化优化能够减少线程申请/释放锁的频率，其代价是使临界区长度变大，从而可能导致线程在申请锁时的等待时间变长。偏向锁优化可以减小锁的申请/释放的开销，它不适用于争用程度较高的锁。适应性锁优化可以减小锁申请的开销，有利于减少上下文切换。\n\n&emsp;&emsp;**锁的开销主要是由争用锁引起的。**这些开销主要包括：上下文切换与线程调度开销、内存同步、编译器优化受限的开销以及限制可伸缩性。降低锁的开销可以从使用锁的替代品、降低锁的争用程度以及减少线程所需申请的锁的数量这几个方面入手。\n\n&emsp;&emsp;使用可参数化锁可以减少线程所需申请的锁的数量从而降低锁的开销，但是它在一定程度上破坏了封装性。\n\n&emsp;&emsp;减小临界区的长度可以减少锁的持有时间，从而降低锁的争用程度。减小临界区的长度有利于适用性锁优化发挥作用。在不影响线程安全的前提下，将临界区中的阻塞式 I/O 等阻塞操作以及较耗时的操作挪动到临界区之外可以减小临界区的长度。\n\n&emsp;&emsp;减小锁的粒度可以降低锁的申请频率从而降低锁的争用程度。减小锁的粒度常用技术包括锁拆分技术和锁分段技术。锁拆分技术在高争用情况下的效果可能并不明显；锁分段技术会使得对整个对象进行加锁比较困难乃至不可能。\n\n&emsp;&emsp;减少上下文切换可以从这几个方面入手：控制线程数量、避免在临界区中执行阻塞式 I/O 等阻塞操作、避免在临界区中执行比较耗时的操作和减少 Java 虚拟机垃圾回收。\n\n&emsp;&emsp;运用多线程设计模式也有助于提升多线程程序的性能，但是程序的复杂性也可能相应增加。\n\n&emsp;&emsp;**伪共享产生的前提是多个线程访问被缓存到同一个缓存中的不同变量，它会导致大量的缓存未命中，从而增加内存访问操作的开销。**了解 Java 对象的内存布局有助于分析与消除伪共享。Java 对象内存布局的规则包括：对象是以 8 字节为粒度进行对齐的、对象中的实例字段并非依照其源代码声明顺序排列以及继承自父类的实例字段不会与类本身定义的实例字段混杂在一起进行存储等。使用 jol 工具可以查看具体对象的内存布局情况。判断伪共享是否存在可以从分析多个线程是否存在共同的共享变量入手，并通过 jol 以及 Linux 内核工具 perf 来进一步分析与确认。**伪共享可通过手工填充、自动填充以及降低共享变量的访问频率这几个方面来消除与规避。**手工填充和自动填充可以在无须调整程序算法的前提下消除伪共享。手工填充的缺点比较多，使用该方法我们必须知道缓存行的宽度、Java 对象的具体内存布局，这使得该方法存在硬件、软件层面的可移植性问题，并对人员的要求比较高。并且，我们还需要避免手工填充的字段被 Java 虚拟机优化掉，自动填充依赖于 `@Contented` 注解，它避免了手工填充的缺点，但是其消耗的额外空间更多。Java 虚拟机对自动填充的支持需要通过 Java 虚拟机的开关 \"-XX:-RestrictContended\" 开启。虽然减少共享变量的访问频率所带来的效果可能比较明显，但是由于它可能涉及程序算法的调整，因此其适用范围比较有限。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Twelve.png) ","slug":"Multithreading-Chapter-Twelve","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh7001dk9i1g95t5zr9","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第十二章小结</p>\n</blockquote>\n<p><strong>本章介绍了与 Java 多线程程序紧密相关的性能调校常用技术。</strong></p>\n<hr>\n<p>&emsp;&emsp;Java 虚拟机自 Java 6 开始对内部锁进行了若干优化：锁消除、锁粗化、偏向锁以及适应性锁。除锁消除是 Java 7 开始引入的，其他优化均是在 Java 6 开始引入的，<strong>这些优化仅在 Java 虚拟机的 server 模式下起作用。这些优化默认都是开启的，且多数优化都可能依赖于 JIT 的内联优化，并且其本身也可能是通过 JIT 编译实现的。</strong>因此，这些优化都有其开销。锁消除优化能够彻底消除锁的开销，它依赖于逃逸分析技术。锁粗化优化能够减少线程申请&#x2F;释放锁的频率，其代价是使临界区长度变大，从而可能导致线程在申请锁时的等待时间变长。偏向锁优化可以减小锁的申请&#x2F;释放的开销，它不适用于争用程度较高的锁。适应性锁优化可以减小锁申请的开销，有利于减少上下文切换。</p>\n<p>&emsp;&emsp;<strong>锁的开销主要是由争用锁引起的。</strong>这些开销主要包括：上下文切换与线程调度开销、内存同步、编译器优化受限的开销以及限制可伸缩性。降低锁的开销可以从使用锁的替代品、降低锁的争用程度以及减少线程所需申请的锁的数量这几个方面入手。</p>\n<p>&emsp;&emsp;使用可参数化锁可以减少线程所需申请的锁的数量从而降低锁的开销，但是它在一定程度上破坏了封装性。</p>\n<p>&emsp;&emsp;减小临界区的长度可以减少锁的持有时间，从而降低锁的争用程度。减小临界区的长度有利于适用性锁优化发挥作用。在不影响线程安全的前提下，将临界区中的阻塞式 I&#x2F;O 等阻塞操作以及较耗时的操作挪动到临界区之外可以减小临界区的长度。</p>\n<p>&emsp;&emsp;减小锁的粒度可以降低锁的申请频率从而降低锁的争用程度。减小锁的粒度常用技术包括锁拆分技术和锁分段技术。锁拆分技术在高争用情况下的效果可能并不明显；锁分段技术会使得对整个对象进行加锁比较困难乃至不可能。</p>\n<p>&emsp;&emsp;减少上下文切换可以从这几个方面入手：控制线程数量、避免在临界区中执行阻塞式 I&#x2F;O 等阻塞操作、避免在临界区中执行比较耗时的操作和减少 Java 虚拟机垃圾回收。</p>\n<p>&emsp;&emsp;运用多线程设计模式也有助于提升多线程程序的性能，但是程序的复杂性也可能相应增加。</p>\n<p>&emsp;&emsp;<strong>伪共享产生的前提是多个线程访问被缓存到同一个缓存中的不同变量，它会导致大量的缓存未命中，从而增加内存访问操作的开销。</strong>了解 Java 对象的内存布局有助于分析与消除伪共享。Java 对象内存布局的规则包括：对象是以 8 字节为粒度进行对齐的、对象中的实例字段并非依照其源代码声明顺序排列以及继承自父类的实例字段不会与类本身定义的实例字段混杂在一起进行存储等。使用 jol 工具可以查看具体对象的内存布局情况。判断伪共享是否存在可以从分析多个线程是否存在共同的共享变量入手，并通过 jol 以及 Linux 内核工具 perf 来进一步分析与确认。<strong>伪共享可通过手工填充、自动填充以及降低共享变量的访问频率这几个方面来消除与规避。</strong>手工填充和自动填充可以在无须调整程序算法的前提下消除伪共享。手工填充的缺点比较多，使用该方法我们必须知道缓存行的宽度、Java 对象的具体内存布局，这使得该方法存在硬件、软件层面的可移植性问题，并对人员的要求比较高。并且，我们还需要避免手工填充的字段被 Java 虚拟机优化掉，自动填充依赖于 <code>@Contented</code> 注解，它避免了手工填充的缺点，但是其消耗的额外空间更多。Java 虚拟机对自动填充的支持需要通过 Java 虚拟机的开关 “-XX:-RestrictContended” 开启。虽然减少共享变量的访问频率所带来的效果可能比较明显，但是由于它可能涉及程序算法的调整，因此其适用范围比较有限。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Twelve.png\" alt=\"本章知识结构图\"> </p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第十二章小结</p>\n</blockquote>\n<p><strong>本章介绍了与 Java 多线程程序紧密相关的性能调校常用技术。</strong></p>\n<hr>\n<p>&emsp;&emsp;Java 虚拟机自 Java 6 开始对内部锁进行了若干优化：锁消除、锁粗化、偏向锁以及适应性锁。除锁消除是 Java 7 开始引入的，其他优化均是在 Java 6 开始引入的，<strong>这些优化仅在 Java 虚拟机的 server 模式下起作用。这些优化默认都是开启的，且多数优化都可能依赖于 JIT 的内联优化，并且其本身也可能是通过 JIT 编译实现的。</strong>因此，这些优化都有其开销。锁消除优化能够彻底消除锁的开销，它依赖于逃逸分析技术。锁粗化优化能够减少线程申请&#x2F;释放锁的频率，其代价是使临界区长度变大，从而可能导致线程在申请锁时的等待时间变长。偏向锁优化可以减小锁的申请&#x2F;释放的开销，它不适用于争用程度较高的锁。适应性锁优化可以减小锁申请的开销，有利于减少上下文切换。</p>\n<p>&emsp;&emsp;<strong>锁的开销主要是由争用锁引起的。</strong>这些开销主要包括：上下文切换与线程调度开销、内存同步、编译器优化受限的开销以及限制可伸缩性。降低锁的开销可以从使用锁的替代品、降低锁的争用程度以及减少线程所需申请的锁的数量这几个方面入手。</p>\n<p>&emsp;&emsp;使用可参数化锁可以减少线程所需申请的锁的数量从而降低锁的开销，但是它在一定程度上破坏了封装性。</p>\n<p>&emsp;&emsp;减小临界区的长度可以减少锁的持有时间，从而降低锁的争用程度。减小临界区的长度有利于适用性锁优化发挥作用。在不影响线程安全的前提下，将临界区中的阻塞式 I&#x2F;O 等阻塞操作以及较耗时的操作挪动到临界区之外可以减小临界区的长度。</p>\n<p>&emsp;&emsp;减小锁的粒度可以降低锁的申请频率从而降低锁的争用程度。减小锁的粒度常用技术包括锁拆分技术和锁分段技术。锁拆分技术在高争用情况下的效果可能并不明显；锁分段技术会使得对整个对象进行加锁比较困难乃至不可能。</p>\n<p>&emsp;&emsp;减少上下文切换可以从这几个方面入手：控制线程数量、避免在临界区中执行阻塞式 I&#x2F;O 等阻塞操作、避免在临界区中执行比较耗时的操作和减少 Java 虚拟机垃圾回收。</p>\n<p>&emsp;&emsp;运用多线程设计模式也有助于提升多线程程序的性能，但是程序的复杂性也可能相应增加。</p>\n<p>&emsp;&emsp;<strong>伪共享产生的前提是多个线程访问被缓存到同一个缓存中的不同变量，它会导致大量的缓存未命中，从而增加内存访问操作的开销。</strong>了解 Java 对象的内存布局有助于分析与消除伪共享。Java 对象内存布局的规则包括：对象是以 8 字节为粒度进行对齐的、对象中的实例字段并非依照其源代码声明顺序排列以及继承自父类的实例字段不会与类本身定义的实例字段混杂在一起进行存储等。使用 jol 工具可以查看具体对象的内存布局情况。判断伪共享是否存在可以从分析多个线程是否存在共同的共享变量入手，并通过 jol 以及 Linux 内核工具 perf 来进一步分析与确认。<strong>伪共享可通过手工填充、自动填充以及降低共享变量的访问频率这几个方面来消除与规避。</strong>手工填充和自动填充可以在无须调整程序算法的前提下消除伪共享。手工填充的缺点比较多，使用该方法我们必须知道缓存行的宽度、Java 对象的具体内存布局，这使得该方法存在硬件、软件层面的可移植性问题，并对人员的要求比较高。并且，我们还需要避免手工填充的字段被 Java 虚拟机优化掉，自动填充依赖于 <code>@Contented</code> 注解，它避免了手工填充的缺点，但是其消耗的额外空间更多。Java 虚拟机对自动填充的支持需要通过 Java 虚拟机的开关 “-XX:-RestrictContended” 开启。虽然减少共享变量的访问频率所带来的效果可能比较明显，但是由于它可能涉及程序算法的调整，因此其适用范围比较有限。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Twelve.png\" alt=\"本章知识结构图\"> </p>\n"},{"title":"多线程编程的目标与挑战","date":"2019-07-08T14:07:54.000Z","_content":"\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第二章小结\n\n**本章通过一些具体概念介绍了多线程编程的目标及其面临的挑战。**\n\n- 单线程程序所进行的计算本质上是串行。多线程编程的目标是将原本串行的计算改为并发乃至并行。\n\n- 竞态（Race Condition）是指计算的正确性依赖于相对时间顺序（Relative Timing）或者线程的交错（Interleaving）。竞态表现为计算的结果时而正确时而错误，它并不意味着计算的结果一定是错误的，其往往伴随着读脏数据/丢失更新的问题。**竞态是访问（读取/更新）同一组共享变量的多个线程所执行的操作相互交错（Interleave）而导致的干扰（读取脏数据）或者冲突（丢失更新）的结果。**二维表分析法是分析和解释竞态的有效和常用工具。一个类能够导致竞态，那么它就不是线程安全的。线程安全意味着不存在竞态，但是不存在竞态却未必意味着线程安全。\n\n- **线程安全问题表现为原子性/可见性和有序性这三个方面。**这几个方面既相互区别，又相互联系。原子性的保障能够消除竞态。可见性描述了一个线程对共享变量的更新对于另外一个线程而言是否可见，或者说什么情况下可见的问题。原子性和可见性一同得以保障了一个线程能够共享变量的相对新值，而不是一个“半成品”的值。有序性描述了一个处理器上运行的一个线程对共享变量所做的更新，在另外一个处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。**可见性是有序性的基础，而有序性又可能影响可见性。**\n\n- 原子操作是“不可分割”的操作。所谓“不可分割”包括两层含义：其一，访问（读/写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果；其二，访问同一组共享变量的原子操作是不能够被交错的，这通常意味着互斥（Mutual Exclusion），即对于访问同一组共享变量的多个原子操作，一个线程执行其中一个操作的时候其他线程无法访问这组共享变量中的任意一个变量。将 read-modify-write 操作和 check-then-act 转换为原子操作能够消除竞态。**在 Java 语言中，对 long/double 型以外的任何变量的写操作都是原子的。volatile 关键字修饰的 long/double 型写操作也具有原子性。针对任何变量的读操作都是原子操作。**\n\n- 可见性问题不是必然出现的，而一旦出现则可能导致灾难性后果。导致可见性问题的因素既有软件因素（JIT 编译器）也有硬件因素（处理器和内存等存储设备）。可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障更新对这个子线程可见，子线程执行期间对共享变量所做的更新对该线程的 join() 执行线程可见（从 join() 返回处开始才是可见的）。\n\n- 编译器/处理器/存储子系统（写缓冲器和高速缓存等）和运行时（JIT 编译器）都可能导致重排序。重排序是出于性能的需要并在满足“貌似串行语义”的前提下进行的，它可能导致线程安全问题。于可见性问题类似，重排序也不是必然出现的。有序性的保障是通过部分地从逻辑上禁止重排序实现的。**可见性是有序性的基础，而有序性反过来又可能影响可见性。**\n\n- 上下文切换可以被看作多线程编程的必然产物，一方面它使得充分利用极其有限的处理器资源成为可能；另一方面它也增加了系统的开销。因此，多线程编程未必比单线程的计算效率要高。程序运行过程中发生的上下文切换既有自发性上下文切换，也有非自发性上下文切换。Linux 内核提供的 `perf` 命令可以帮助我们测量程序运行过程中发生的上下文切换的次数和频率。\n\n- 多线程程序可能由于资源稀缺性或者程序自身的错误和缺陷而一直处于非 RUNNABLE 状态，或者即使是处于 RUNNABLE 状态，但是其要执行的任务一直无法进展，即产生了活性故障。\n\n- 非公平调度策略是我们多数情况下的首选资源调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Two.png)\n","source":"_posts/Multithreading-Chapter-Two.md","raw":"---\ntitle: 多线程编程的目标与挑战\ndate: 2019-07-08 22:07:54\ncategories: [开发,多线程]\ntags: [Java,多线程]\n---\n\n> 本文摘抄自《Java 多线程编程实战指南》核心篇 第二章小结\n\n**本章通过一些具体概念介绍了多线程编程的目标及其面临的挑战。**\n\n- 单线程程序所进行的计算本质上是串行。多线程编程的目标是将原本串行的计算改为并发乃至并行。\n\n- 竞态（Race Condition）是指计算的正确性依赖于相对时间顺序（Relative Timing）或者线程的交错（Interleaving）。竞态表现为计算的结果时而正确时而错误，它并不意味着计算的结果一定是错误的，其往往伴随着读脏数据/丢失更新的问题。**竞态是访问（读取/更新）同一组共享变量的多个线程所执行的操作相互交错（Interleave）而导致的干扰（读取脏数据）或者冲突（丢失更新）的结果。**二维表分析法是分析和解释竞态的有效和常用工具。一个类能够导致竞态，那么它就不是线程安全的。线程安全意味着不存在竞态，但是不存在竞态却未必意味着线程安全。\n\n- **线程安全问题表现为原子性/可见性和有序性这三个方面。**这几个方面既相互区别，又相互联系。原子性的保障能够消除竞态。可见性描述了一个线程对共享变量的更新对于另外一个线程而言是否可见，或者说什么情况下可见的问题。原子性和可见性一同得以保障了一个线程能够共享变量的相对新值，而不是一个“半成品”的值。有序性描述了一个处理器上运行的一个线程对共享变量所做的更新，在另外一个处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。**可见性是有序性的基础，而有序性又可能影响可见性。**\n\n- 原子操作是“不可分割”的操作。所谓“不可分割”包括两层含义：其一，访问（读/写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果；其二，访问同一组共享变量的原子操作是不能够被交错的，这通常意味着互斥（Mutual Exclusion），即对于访问同一组共享变量的多个原子操作，一个线程执行其中一个操作的时候其他线程无法访问这组共享变量中的任意一个变量。将 read-modify-write 操作和 check-then-act 转换为原子操作能够消除竞态。**在 Java 语言中，对 long/double 型以外的任何变量的写操作都是原子的。volatile 关键字修饰的 long/double 型写操作也具有原子性。针对任何变量的读操作都是原子操作。**\n\n- 可见性问题不是必然出现的，而一旦出现则可能导致灾难性后果。导致可见性问题的因素既有软件因素（JIT 编译器）也有硬件因素（处理器和内存等存储设备）。可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障更新对这个子线程可见，子线程执行期间对共享变量所做的更新对该线程的 join() 执行线程可见（从 join() 返回处开始才是可见的）。\n\n- 编译器/处理器/存储子系统（写缓冲器和高速缓存等）和运行时（JIT 编译器）都可能导致重排序。重排序是出于性能的需要并在满足“貌似串行语义”的前提下进行的，它可能导致线程安全问题。于可见性问题类似，重排序也不是必然出现的。有序性的保障是通过部分地从逻辑上禁止重排序实现的。**可见性是有序性的基础，而有序性反过来又可能影响可见性。**\n\n- 上下文切换可以被看作多线程编程的必然产物，一方面它使得充分利用极其有限的处理器资源成为可能；另一方面它也增加了系统的开销。因此，多线程编程未必比单线程的计算效率要高。程序运行过程中发生的上下文切换既有自发性上下文切换，也有非自发性上下文切换。Linux 内核提供的 `perf` 命令可以帮助我们测量程序运行过程中发生的上下文切换的次数和频率。\n\n- 多线程程序可能由于资源稀缺性或者程序自身的错误和缺陷而一直处于非 RUNNABLE 状态，或者即使是处于 RUNNABLE 状态，但是其要执行的任务一直无法进展，即产生了活性故障。\n\n- 非公平调度策略是我们多数情况下的首选资源调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小。\n\n![本章知识结构图](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Two.png)\n","slug":"Multithreading-Chapter-Two","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh7001fk9i18z9v1qp3","content":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第二章小结</p>\n</blockquote>\n<p><strong>本章通过一些具体概念介绍了多线程编程的目标及其面临的挑战。</strong></p>\n<ul>\n<li><p>单线程程序所进行的计算本质上是串行。多线程编程的目标是将原本串行的计算改为并发乃至并行。</p>\n</li>\n<li><p>竞态（Race Condition）是指计算的正确性依赖于相对时间顺序（Relative Timing）或者线程的交错（Interleaving）。竞态表现为计算的结果时而正确时而错误，它并不意味着计算的结果一定是错误的，其往往伴随着读脏数据&#x2F;丢失更新的问题。<strong>竞态是访问（读取&#x2F;更新）同一组共享变量的多个线程所执行的操作相互交错（Interleave）而导致的干扰（读取脏数据）或者冲突（丢失更新）的结果。</strong>二维表分析法是分析和解释竞态的有效和常用工具。一个类能够导致竞态，那么它就不是线程安全的。线程安全意味着不存在竞态，但是不存在竞态却未必意味着线程安全。</p>\n</li>\n<li><p><strong>线程安全问题表现为原子性&#x2F;可见性和有序性这三个方面。</strong>这几个方面既相互区别，又相互联系。原子性的保障能够消除竞态。可见性描述了一个线程对共享变量的更新对于另外一个线程而言是否可见，或者说什么情况下可见的问题。原子性和可见性一同得以保障了一个线程能够共享变量的相对新值，而不是一个“半成品”的值。有序性描述了一个处理器上运行的一个线程对共享变量所做的更新，在另外一个处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。<strong>可见性是有序性的基础，而有序性又可能影响可见性。</strong></p>\n</li>\n<li><p>原子操作是“不可分割”的操作。所谓“不可分割”包括两层含义：其一，访问（读&#x2F;写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果；其二，访问同一组共享变量的原子操作是不能够被交错的，这通常意味着互斥（Mutual Exclusion），即对于访问同一组共享变量的多个原子操作，一个线程执行其中一个操作的时候其他线程无法访问这组共享变量中的任意一个变量。将 read-modify-write 操作和 check-then-act 转换为原子操作能够消除竞态。<strong>在 Java 语言中，对 long&#x2F;double 型以外的任何变量的写操作都是原子的。volatile 关键字修饰的 long&#x2F;double 型写操作也具有原子性。针对任何变量的读操作都是原子操作。</strong></p>\n</li>\n<li><p>可见性问题不是必然出现的，而一旦出现则可能导致灾难性后果。导致可见性问题的因素既有软件因素（JIT 编译器）也有硬件因素（处理器和内存等存储设备）。可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障更新对这个子线程可见，子线程执行期间对共享变量所做的更新对该线程的 join() 执行线程可见（从 join() 返回处开始才是可见的）。</p>\n</li>\n<li><p>编译器&#x2F;处理器&#x2F;存储子系统（写缓冲器和高速缓存等）和运行时（JIT 编译器）都可能导致重排序。重排序是出于性能的需要并在满足“貌似串行语义”的前提下进行的，它可能导致线程安全问题。于可见性问题类似，重排序也不是必然出现的。有序性的保障是通过部分地从逻辑上禁止重排序实现的。<strong>可见性是有序性的基础，而有序性反过来又可能影响可见性。</strong></p>\n</li>\n<li><p>上下文切换可以被看作多线程编程的必然产物，一方面它使得充分利用极其有限的处理器资源成为可能；另一方面它也增加了系统的开销。因此，多线程编程未必比单线程的计算效率要高。程序运行过程中发生的上下文切换既有自发性上下文切换，也有非自发性上下文切换。Linux 内核提供的 <code>perf</code> 命令可以帮助我们测量程序运行过程中发生的上下文切换的次数和频率。</p>\n</li>\n<li><p>多线程程序可能由于资源稀缺性或者程序自身的错误和缺陷而一直处于非 RUNNABLE 状态，或者即使是处于 RUNNABLE 状态，但是其要执行的任务一直无法进展，即产生了活性故障。</p>\n</li>\n<li><p>非公平调度策略是我们多数情况下的首选资源调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Two.png\" alt=\"本章知识结构图\"></p>\n","excerpt":"","more":"<blockquote>\n<p>本文摘抄自《Java 多线程编程实战指南》核心篇 第二章小结</p>\n</blockquote>\n<p><strong>本章通过一些具体概念介绍了多线程编程的目标及其面临的挑战。</strong></p>\n<ul>\n<li><p>单线程程序所进行的计算本质上是串行。多线程编程的目标是将原本串行的计算改为并发乃至并行。</p>\n</li>\n<li><p>竞态（Race Condition）是指计算的正确性依赖于相对时间顺序（Relative Timing）或者线程的交错（Interleaving）。竞态表现为计算的结果时而正确时而错误，它并不意味着计算的结果一定是错误的，其往往伴随着读脏数据&#x2F;丢失更新的问题。<strong>竞态是访问（读取&#x2F;更新）同一组共享变量的多个线程所执行的操作相互交错（Interleave）而导致的干扰（读取脏数据）或者冲突（丢失更新）的结果。</strong>二维表分析法是分析和解释竞态的有效和常用工具。一个类能够导致竞态，那么它就不是线程安全的。线程安全意味着不存在竞态，但是不存在竞态却未必意味着线程安全。</p>\n</li>\n<li><p><strong>线程安全问题表现为原子性&#x2F;可见性和有序性这三个方面。</strong>这几个方面既相互区别，又相互联系。原子性的保障能够消除竞态。可见性描述了一个线程对共享变量的更新对于另外一个线程而言是否可见，或者说什么情况下可见的问题。原子性和可见性一同得以保障了一个线程能够共享变量的相对新值，而不是一个“半成品”的值。有序性描述了一个处理器上运行的一个线程对共享变量所做的更新，在另外一个处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。<strong>可见性是有序性的基础，而有序性又可能影响可见性。</strong></p>\n</li>\n<li><p>原子操作是“不可分割”的操作。所谓“不可分割”包括两层含义：其一，访问（读&#x2F;写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果；其二，访问同一组共享变量的原子操作是不能够被交错的，这通常意味着互斥（Mutual Exclusion），即对于访问同一组共享变量的多个原子操作，一个线程执行其中一个操作的时候其他线程无法访问这组共享变量中的任意一个变量。将 read-modify-write 操作和 check-then-act 转换为原子操作能够消除竞态。<strong>在 Java 语言中，对 long&#x2F;double 型以外的任何变量的写操作都是原子的。volatile 关键字修饰的 long&#x2F;double 型写操作也具有原子性。针对任何变量的读操作都是原子操作。</strong></p>\n</li>\n<li><p>可见性问题不是必然出现的，而一旦出现则可能导致灾难性后果。导致可见性问题的因素既有软件因素（JIT 编译器）也有硬件因素（处理器和内存等存储设备）。可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障更新对这个子线程可见，子线程执行期间对共享变量所做的更新对该线程的 join() 执行线程可见（从 join() 返回处开始才是可见的）。</p>\n</li>\n<li><p>编译器&#x2F;处理器&#x2F;存储子系统（写缓冲器和高速缓存等）和运行时（JIT 编译器）都可能导致重排序。重排序是出于性能的需要并在满足“貌似串行语义”的前提下进行的，它可能导致线程安全问题。于可见性问题类似，重排序也不是必然出现的。有序性的保障是通过部分地从逻辑上禁止重排序实现的。<strong>可见性是有序性的基础，而有序性反过来又可能影响可见性。</strong></p>\n</li>\n<li><p>上下文切换可以被看作多线程编程的必然产物，一方面它使得充分利用极其有限的处理器资源成为可能；另一方面它也增加了系统的开销。因此，多线程编程未必比单线程的计算效率要高。程序运行过程中发生的上下文切换既有自发性上下文切换，也有非自发性上下文切换。Linux 内核提供的 <code>perf</code> 命令可以帮助我们测量程序运行过程中发生的上下文切换的次数和频率。</p>\n</li>\n<li><p>多线程程序可能由于资源稀缺性或者程序自身的错误和缺陷而一直处于非 RUNNABLE 状态，或者即使是处于 RUNNABLE 状态，但是其要执行的任务一直无法进展，即产生了活性故障。</p>\n</li>\n<li><p>非公平调度策略是我们多数情况下的首选资源调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小。</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Multithreading/Multithreading-Chapter-Two.png\" alt=\"本章知识结构图\"></p>\n"},{"title":"My97DatePicker时间日期插件使用示例","date":"2018-06-25T10:17:59.000Z","_content":"## 前言\n\n- My97DatePicker目录是一个整体,不可破坏里面的目录结构,也不可对里面的文件改名,可以改目录名\n- My97DatePicker.htm是必须文件,不可删除\n\n### 各目录及文件的用途\n\n- WdatePicker.js配置文件,在调用的地方仅需使用该文件,可多个共存,以xx_WdatePicker.js方式命名\n- config.js 语言和皮肤配置文件,无需引入\n- calendar.js 日期库主文件,无需引入\n- My97DatePicker.htm 临时页面文件,不可删除\n- 目录lang 存放语言文件,你可以根据需要清理或添加语言文件\n- 目录skin 存放皮肤的相关文件,你可以根据需要清理或添加皮肤文件包\n- 当WdatePicker.js里的属性:$wdate=true时,在input里加上class=\"Wdate\"就会在选择框右边出现日期图标,如果您不喜欢这个样式,可以把class=\"Wdate\"去掉,另外也可以通过修改skin目录下的WdatePicker.css文件来修改样式\n\n## 示例\n\n### 没有对控件进行设置\n`<input class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker()\"/>`\n\n### 限制日期的范围是 2006-09-10到2008-12-20\n```\n<input id=\"d411\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({skin:'whyGreen',minDate: '2006-09-10', maxDate: '2008-12-20' })\"/>\n```\n\n### 限制日期的范围是 2008-3-8 11:30:00 到 2008-3-10 20:59:30\n```\n<input type=\"text\" class=\"Wdate\" id=\"d412\"\nonfocus=\"WdatePicker({skin:'whyGreen',dateFmt: 'yyyy-MM-dd HH:mm:ss',\nminDate: '2008-03-08 11:30:00', maxDate: '2008-03-10 20:59:30' })\" value=\"2008-03-09 11:00:00\"/>\n```\n\n### 限制日期的范围是 2008年2月 到 2008年10月\n```\n<input type=\"text\" class=\"Wdate\" id=\"d413\" onfocus=\"WdatePicker({dateFmt: 'yyyy年M月', minDate: '2008-2', maxDate: '2008-10' })\"/>\n```\n\n### 限制日期的范围是 8:00:00 到 11:30:00\n```\n<input type=\"text\" class=\"Wdate\" id=\"d414\" onfocus=\"WdatePicker({dateFmt: 'H:mm:ss', minDate: '8:00:00', maxDate: '11:30:00' })\"/>\n```\n\n### 只能选择今天以前的日期(包括今天)\n```\n<input id=\"d421\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({skin:'whyGreen',maxDate: '%y-%M-%d' })\"/>\n```\n\n### 使用了运算表达式 只能选择今天以后的日期(不包括今天)\n```\n<input id=\"d422\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({minDate: '%y-%M-#{%d+1}' })\"/>\n```\n\n### 只能选择本月的日期1号至本月最后一天\n```\n<input id=\"d423\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({minDate: '%y-%M-01', maxDate: '%y-%M-%ld' })\"/>\n```\n\n### 只能选择今天7:00:00至明天21:00:00的日期\n```\n<input id=\"d424\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({dateFmt:'yyyy-M-d H:mm:ss',minDate: '%y-%M-%d 7:00:00', maxDate: '%y-%M-#{%d+1} 21:00:00' })\"/>\n```\n\n### 使用了运算表达式 只能选择 20小时前 至 30小时后 的日期\n```\n<input id=\"d425\" class=\"Wdate\" type=\"text\"\nonClick=\"WdatePicker({dateFmt:'yyyy-MM-dd HH:mm',minDate: '%y-%M-%d #{%H-20}:%m:%s' ,maxDate: '%y-%M-%d #{%H+30}:%m:%s' })\"/>\n```\n### 前面的日期不能大于后面的日期且两个日期都不能大于 2020-10-01\n> 合同有效期从 到 <br>\n[注意: 两个日期的日期格式必须相同.\ndp. 相当于 document.getElementByIdx_x 函数.\n那么为什么里面的 ’ 使用 \\’ 呢? 那是因为 ” 和 ’ 都被外围的函数使用了,故使用转义符 \\ ,否则会提示JS语法错误.所以您在其他地方使用时注意把 \\’ 改成 ” 或者 ’ 来使用。\n`#F{$dp.$D(\\'d4312\\')||\\'2020-10-01\\'} 表示当 d4312 为空时, 采用 2020-10-01 的值作为最大值`]\n\n```\n<input id=\"d4311\" class=\"Wdate\" type=\"text\" onFocus=\"WdatePicker({maxDate: '#F{$dp.$D(\\'d4312\\')||\\'2020-10-01\\'}' })\"/>\n<input id=\"d4312\" class=\"Wdate\" type=\"text\" onFocus=\"WdatePicker({minDate: '#F{$dp.$D(\\'d4311\\')}' ,maxDate:'2020-10-01' })\"/>\n```\n\n## 取值和赋值\n### html:\n```\n<input class=\"p-Wdate\" type=\"text\"   onfocus=\"WdatePicker()\"/>\n<p><button class=\"tijiaoBtn\">提交</button></p>\n```\n### js:\n```\n//赋值\n$(\".p-Wdate\").val(\"2019-01-01\");\n//取值\n$(\".tijiaoBtn\").on(\"click\",function(){\n  console.log($(\".p-Wdate\").val());\n});\n```\n\n## 参考\n- [WdatePicker.js时间日期插件](https://www.2cto.com/kf/201707/662183.html)\n- [My97DatePicker日历控件配置](https://www.cnblogs.com/weiqt/articles/2012169.html)\n- [My97官网](http://www.my97.net/)","source":"_posts/My97DatePicker.md","raw":"---\ntitle: My97DatePicker时间日期插件使用示例\ndate: 2018-6-25 18:17:59\ncategories: [开发,Web]\ntags: [js]\n---\n## 前言\n\n- My97DatePicker目录是一个整体,不可破坏里面的目录结构,也不可对里面的文件改名,可以改目录名\n- My97DatePicker.htm是必须文件,不可删除\n\n### 各目录及文件的用途\n\n- WdatePicker.js配置文件,在调用的地方仅需使用该文件,可多个共存,以xx_WdatePicker.js方式命名\n- config.js 语言和皮肤配置文件,无需引入\n- calendar.js 日期库主文件,无需引入\n- My97DatePicker.htm 临时页面文件,不可删除\n- 目录lang 存放语言文件,你可以根据需要清理或添加语言文件\n- 目录skin 存放皮肤的相关文件,你可以根据需要清理或添加皮肤文件包\n- 当WdatePicker.js里的属性:$wdate=true时,在input里加上class=\"Wdate\"就会在选择框右边出现日期图标,如果您不喜欢这个样式,可以把class=\"Wdate\"去掉,另外也可以通过修改skin目录下的WdatePicker.css文件来修改样式\n\n## 示例\n\n### 没有对控件进行设置\n`<input class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker()\"/>`\n\n### 限制日期的范围是 2006-09-10到2008-12-20\n```\n<input id=\"d411\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({skin:'whyGreen',minDate: '2006-09-10', maxDate: '2008-12-20' })\"/>\n```\n\n### 限制日期的范围是 2008-3-8 11:30:00 到 2008-3-10 20:59:30\n```\n<input type=\"text\" class=\"Wdate\" id=\"d412\"\nonfocus=\"WdatePicker({skin:'whyGreen',dateFmt: 'yyyy-MM-dd HH:mm:ss',\nminDate: '2008-03-08 11:30:00', maxDate: '2008-03-10 20:59:30' })\" value=\"2008-03-09 11:00:00\"/>\n```\n\n### 限制日期的范围是 2008年2月 到 2008年10月\n```\n<input type=\"text\" class=\"Wdate\" id=\"d413\" onfocus=\"WdatePicker({dateFmt: 'yyyy年M月', minDate: '2008-2', maxDate: '2008-10' })\"/>\n```\n\n### 限制日期的范围是 8:00:00 到 11:30:00\n```\n<input type=\"text\" class=\"Wdate\" id=\"d414\" onfocus=\"WdatePicker({dateFmt: 'H:mm:ss', minDate: '8:00:00', maxDate: '11:30:00' })\"/>\n```\n\n### 只能选择今天以前的日期(包括今天)\n```\n<input id=\"d421\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({skin:'whyGreen',maxDate: '%y-%M-%d' })\"/>\n```\n\n### 使用了运算表达式 只能选择今天以后的日期(不包括今天)\n```\n<input id=\"d422\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({minDate: '%y-%M-#{%d+1}' })\"/>\n```\n\n### 只能选择本月的日期1号至本月最后一天\n```\n<input id=\"d423\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({minDate: '%y-%M-01', maxDate: '%y-%M-%ld' })\"/>\n```\n\n### 只能选择今天7:00:00至明天21:00:00的日期\n```\n<input id=\"d424\" class=\"Wdate\" type=\"text\" onfocus=\"WdatePicker({dateFmt:'yyyy-M-d H:mm:ss',minDate: '%y-%M-%d 7:00:00', maxDate: '%y-%M-#{%d+1} 21:00:00' })\"/>\n```\n\n### 使用了运算表达式 只能选择 20小时前 至 30小时后 的日期\n```\n<input id=\"d425\" class=\"Wdate\" type=\"text\"\nonClick=\"WdatePicker({dateFmt:'yyyy-MM-dd HH:mm',minDate: '%y-%M-%d #{%H-20}:%m:%s' ,maxDate: '%y-%M-%d #{%H+30}:%m:%s' })\"/>\n```\n### 前面的日期不能大于后面的日期且两个日期都不能大于 2020-10-01\n> 合同有效期从 到 <br>\n[注意: 两个日期的日期格式必须相同.\ndp. 相当于 document.getElementByIdx_x 函数.\n那么为什么里面的 ’ 使用 \\’ 呢? 那是因为 ” 和 ’ 都被外围的函数使用了,故使用转义符 \\ ,否则会提示JS语法错误.所以您在其他地方使用时注意把 \\’ 改成 ” 或者 ’ 来使用。\n`#F{$dp.$D(\\'d4312\\')||\\'2020-10-01\\'} 表示当 d4312 为空时, 采用 2020-10-01 的值作为最大值`]\n\n```\n<input id=\"d4311\" class=\"Wdate\" type=\"text\" onFocus=\"WdatePicker({maxDate: '#F{$dp.$D(\\'d4312\\')||\\'2020-10-01\\'}' })\"/>\n<input id=\"d4312\" class=\"Wdate\" type=\"text\" onFocus=\"WdatePicker({minDate: '#F{$dp.$D(\\'d4311\\')}' ,maxDate:'2020-10-01' })\"/>\n```\n\n## 取值和赋值\n### html:\n```\n<input class=\"p-Wdate\" type=\"text\"   onfocus=\"WdatePicker()\"/>\n<p><button class=\"tijiaoBtn\">提交</button></p>\n```\n### js:\n```\n//赋值\n$(\".p-Wdate\").val(\"2019-01-01\");\n//取值\n$(\".tijiaoBtn\").on(\"click\",function(){\n  console.log($(\".p-Wdate\").val());\n});\n```\n\n## 参考\n- [WdatePicker.js时间日期插件](https://www.2cto.com/kf/201707/662183.html)\n- [My97DatePicker日历控件配置](https://www.cnblogs.com/weiqt/articles/2012169.html)\n- [My97官网](http://www.my97.net/)","slug":"My97DatePicker","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh7001jk9i186lgd5cm","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>My97DatePicker目录是一个整体,不可破坏里面的目录结构,也不可对里面的文件改名,可以改目录名</li>\n<li>My97DatePicker.htm是必须文件,不可删除</li>\n</ul>\n<h3 id=\"各目录及文件的用途\"><a href=\"#各目录及文件的用途\" class=\"headerlink\" title=\"各目录及文件的用途\"></a>各目录及文件的用途</h3><ul>\n<li>WdatePicker.js配置文件,在调用的地方仅需使用该文件,可多个共存,以xx_WdatePicker.js方式命名</li>\n<li>config.js 语言和皮肤配置文件,无需引入</li>\n<li>calendar.js 日期库主文件,无需引入</li>\n<li>My97DatePicker.htm 临时页面文件,不可删除</li>\n<li>目录lang 存放语言文件,你可以根据需要清理或添加语言文件</li>\n<li>目录skin 存放皮肤的相关文件,你可以根据需要清理或添加皮肤文件包</li>\n<li>当WdatePicker.js里的属性:$wdate&#x3D;true时,在input里加上class&#x3D;”Wdate”就会在选择框右边出现日期图标,如果您不喜欢这个样式,可以把class&#x3D;”Wdate”去掉,另外也可以通过修改skin目录下的WdatePicker.css文件来修改样式</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"没有对控件进行设置\"><a href=\"#没有对控件进行设置\" class=\"headerlink\" title=\"没有对控件进行设置\"></a>没有对控件进行设置</h3><p><code>&lt;input class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker()&quot;/&gt;</code></p>\n<h3 id=\"限制日期的范围是-2006-09-10到2008-12-20\"><a href=\"#限制日期的范围是-2006-09-10到2008-12-20\" class=\"headerlink\" title=\"限制日期的范围是 2006-09-10到2008-12-20\"></a>限制日期的范围是 2006-09-10到2008-12-20</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d411&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;skin:&#x27;whyGreen&#x27;,minDate: &#x27;2006-09-10&#x27;, maxDate: &#x27;2008-12-20&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制日期的范围是-2008-3-8-11-30-00-到-2008-3-10-20-59-30\"><a href=\"#限制日期的范围是-2008-3-8-11-30-00-到-2008-3-10-20-59-30\" class=\"headerlink\" title=\"限制日期的范围是 2008-3-8 11:30:00 到 2008-3-10 20:59:30\"></a>限制日期的范围是 2008-3-8 11:30:00 到 2008-3-10 20:59:30</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; class=&quot;Wdate&quot; id=&quot;d412&quot;</span><br><span class=\"line\">onfocus=&quot;WdatePicker(&#123;skin:&#x27;whyGreen&#x27;,dateFmt: &#x27;yyyy-MM-dd HH:mm:ss&#x27;,</span><br><span class=\"line\">minDate: &#x27;2008-03-08 11:30:00&#x27;, maxDate: &#x27;2008-03-10 20:59:30&#x27; &#125;)&quot; value=&quot;2008-03-09 11:00:00&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制日期的范围是-2008年2月-到-2008年10月\"><a href=\"#限制日期的范围是-2008年2月-到-2008年10月\" class=\"headerlink\" title=\"限制日期的范围是 2008年2月 到 2008年10月\"></a>限制日期的范围是 2008年2月 到 2008年10月</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; class=&quot;Wdate&quot; id=&quot;d413&quot; onfocus=&quot;WdatePicker(&#123;dateFmt: &#x27;yyyy年M月&#x27;, minDate: &#x27;2008-2&#x27;, maxDate: &#x27;2008-10&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制日期的范围是-8-00-00-到-11-30-00\"><a href=\"#限制日期的范围是-8-00-00-到-11-30-00\" class=\"headerlink\" title=\"限制日期的范围是 8:00:00 到 11:30:00\"></a>限制日期的范围是 8:00:00 到 11:30:00</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; class=&quot;Wdate&quot; id=&quot;d414&quot; onfocus=&quot;WdatePicker(&#123;dateFmt: &#x27;H:mm:ss&#x27;, minDate: &#x27;8:00:00&#x27;, maxDate: &#x27;11:30:00&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"只能选择今天以前的日期-包括今天\"><a href=\"#只能选择今天以前的日期-包括今天\" class=\"headerlink\" title=\"只能选择今天以前的日期(包括今天)\"></a>只能选择今天以前的日期(包括今天)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d421&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;skin:&#x27;whyGreen&#x27;,maxDate: &#x27;%y-%M-%d&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用了运算表达式-只能选择今天以后的日期-不包括今天\"><a href=\"#使用了运算表达式-只能选择今天以后的日期-不包括今天\" class=\"headerlink\" title=\"使用了运算表达式 只能选择今天以后的日期(不包括今天)\"></a>使用了运算表达式 只能选择今天以后的日期(不包括今天)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d422&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;minDate: &#x27;%y-%M-#&#123;%d+1&#125;&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"只能选择本月的日期1号至本月最后一天\"><a href=\"#只能选择本月的日期1号至本月最后一天\" class=\"headerlink\" title=\"只能选择本月的日期1号至本月最后一天\"></a>只能选择本月的日期1号至本月最后一天</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d423&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;minDate: &#x27;%y-%M-01&#x27;, maxDate: &#x27;%y-%M-%ld&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"只能选择今天7-00-00至明天21-00-00的日期\"><a href=\"#只能选择今天7-00-00至明天21-00-00的日期\" class=\"headerlink\" title=\"只能选择今天7:00:00至明天21:00:00的日期\"></a>只能选择今天7:00:00至明天21:00:00的日期</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d424&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;dateFmt:&#x27;yyyy-M-d H:mm:ss&#x27;,minDate: &#x27;%y-%M-%d 7:00:00&#x27;, maxDate: &#x27;%y-%M-#&#123;%d+1&#125; 21:00:00&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用了运算表达式-只能选择-20小时前-至-30小时后-的日期\"><a href=\"#使用了运算表达式-只能选择-20小时前-至-30小时后-的日期\" class=\"headerlink\" title=\"使用了运算表达式 只能选择 20小时前 至 30小时后 的日期\"></a>使用了运算表达式 只能选择 20小时前 至 30小时后 的日期</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d425&quot; class=&quot;Wdate&quot; type=&quot;text&quot;</span><br><span class=\"line\">onClick=&quot;WdatePicker(&#123;dateFmt:&#x27;yyyy-MM-dd HH:mm&#x27;,minDate: &#x27;%y-%M-%d #&#123;%H-20&#125;:%m:%s&#x27; ,maxDate: &#x27;%y-%M-%d #&#123;%H+30&#125;:%m:%s&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前面的日期不能大于后面的日期且两个日期都不能大于-2020-10-01\"><a href=\"#前面的日期不能大于后面的日期且两个日期都不能大于-2020-10-01\" class=\"headerlink\" title=\"前面的日期不能大于后面的日期且两个日期都不能大于 2020-10-01\"></a>前面的日期不能大于后面的日期且两个日期都不能大于 2020-10-01</h3><blockquote>\n<p>合同有效期从 到 <br><br>[注意: 两个日期的日期格式必须相同.<br>dp. 相当于 document.getElementByIdx_x 函数.<br>那么为什么里面的 ’ 使用 \\’ 呢? 那是因为 ” 和 ’ 都被外围的函数使用了,故使用转义符 \\ ,否则会提示JS语法错误.所以您在其他地方使用时注意把 \\’ 改成 ” 或者 ’ 来使用。<br><code>#F&#123;$dp.$D(\\&#39;d4312\\&#39;)||\\&#39;2020-10-01\\&#39;&#125; 表示当 d4312 为空时, 采用 2020-10-01 的值作为最大值</code>]</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d4311&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onFocus=&quot;WdatePicker(&#123;maxDate: &#x27;#F&#123;$dp.$D(\\&#x27;d4312\\&#x27;)||\\&#x27;2020-10-01\\&#x27;&#125;&#x27; &#125;)&quot;/&gt;</span><br><span class=\"line\">&lt;input id=&quot;d4312&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onFocus=&quot;WdatePicker(&#123;minDate: &#x27;#F&#123;$dp.$D(\\&#x27;d4311\\&#x27;)&#125;&#x27; ,maxDate:&#x27;2020-10-01&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取值和赋值\"><a href=\"#取值和赋值\" class=\"headerlink\" title=\"取值和赋值\"></a>取值和赋值</h2><h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html:\"></a>html:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input class=&quot;p-Wdate&quot; type=&quot;text&quot;   onfocus=&quot;WdatePicker()&quot;/&gt;</span><br><span class=\"line\">&lt;p&gt;&lt;button class=&quot;tijiaoBtn&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js:\"></a>js:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//赋值</span><br><span class=\"line\">$(&quot;.p-Wdate&quot;).val(&quot;2019-01-01&quot;);</span><br><span class=\"line\">//取值</span><br><span class=\"line\">$(&quot;.tijiaoBtn&quot;).on(&quot;click&quot;,function()&#123;</span><br><span class=\"line\">  console.log($(&quot;.p-Wdate&quot;).val());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.2cto.com/kf/201707/662183.html\">WdatePicker.js时间日期插件</a></li>\n<li><a href=\"https://www.cnblogs.com/weiqt/articles/2012169.html\">My97DatePicker日历控件配置</a></li>\n<li><a href=\"http://www.my97.net/\">My97官网</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>My97DatePicker目录是一个整体,不可破坏里面的目录结构,也不可对里面的文件改名,可以改目录名</li>\n<li>My97DatePicker.htm是必须文件,不可删除</li>\n</ul>\n<h3 id=\"各目录及文件的用途\"><a href=\"#各目录及文件的用途\" class=\"headerlink\" title=\"各目录及文件的用途\"></a>各目录及文件的用途</h3><ul>\n<li>WdatePicker.js配置文件,在调用的地方仅需使用该文件,可多个共存,以xx_WdatePicker.js方式命名</li>\n<li>config.js 语言和皮肤配置文件,无需引入</li>\n<li>calendar.js 日期库主文件,无需引入</li>\n<li>My97DatePicker.htm 临时页面文件,不可删除</li>\n<li>目录lang 存放语言文件,你可以根据需要清理或添加语言文件</li>\n<li>目录skin 存放皮肤的相关文件,你可以根据需要清理或添加皮肤文件包</li>\n<li>当WdatePicker.js里的属性:$wdate&#x3D;true时,在input里加上class&#x3D;”Wdate”就会在选择框右边出现日期图标,如果您不喜欢这个样式,可以把class&#x3D;”Wdate”去掉,另外也可以通过修改skin目录下的WdatePicker.css文件来修改样式</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"没有对控件进行设置\"><a href=\"#没有对控件进行设置\" class=\"headerlink\" title=\"没有对控件进行设置\"></a>没有对控件进行设置</h3><p><code>&lt;input class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker()&quot;/&gt;</code></p>\n<h3 id=\"限制日期的范围是-2006-09-10到2008-12-20\"><a href=\"#限制日期的范围是-2006-09-10到2008-12-20\" class=\"headerlink\" title=\"限制日期的范围是 2006-09-10到2008-12-20\"></a>限制日期的范围是 2006-09-10到2008-12-20</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d411&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;skin:&#x27;whyGreen&#x27;,minDate: &#x27;2006-09-10&#x27;, maxDate: &#x27;2008-12-20&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制日期的范围是-2008-3-8-11-30-00-到-2008-3-10-20-59-30\"><a href=\"#限制日期的范围是-2008-3-8-11-30-00-到-2008-3-10-20-59-30\" class=\"headerlink\" title=\"限制日期的范围是 2008-3-8 11:30:00 到 2008-3-10 20:59:30\"></a>限制日期的范围是 2008-3-8 11:30:00 到 2008-3-10 20:59:30</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; class=&quot;Wdate&quot; id=&quot;d412&quot;</span><br><span class=\"line\">onfocus=&quot;WdatePicker(&#123;skin:&#x27;whyGreen&#x27;,dateFmt: &#x27;yyyy-MM-dd HH:mm:ss&#x27;,</span><br><span class=\"line\">minDate: &#x27;2008-03-08 11:30:00&#x27;, maxDate: &#x27;2008-03-10 20:59:30&#x27; &#125;)&quot; value=&quot;2008-03-09 11:00:00&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制日期的范围是-2008年2月-到-2008年10月\"><a href=\"#限制日期的范围是-2008年2月-到-2008年10月\" class=\"headerlink\" title=\"限制日期的范围是 2008年2月 到 2008年10月\"></a>限制日期的范围是 2008年2月 到 2008年10月</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; class=&quot;Wdate&quot; id=&quot;d413&quot; onfocus=&quot;WdatePicker(&#123;dateFmt: &#x27;yyyy年M月&#x27;, minDate: &#x27;2008-2&#x27;, maxDate: &#x27;2008-10&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"限制日期的范围是-8-00-00-到-11-30-00\"><a href=\"#限制日期的范围是-8-00-00-到-11-30-00\" class=\"headerlink\" title=\"限制日期的范围是 8:00:00 到 11:30:00\"></a>限制日期的范围是 8:00:00 到 11:30:00</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;text&quot; class=&quot;Wdate&quot; id=&quot;d414&quot; onfocus=&quot;WdatePicker(&#123;dateFmt: &#x27;H:mm:ss&#x27;, minDate: &#x27;8:00:00&#x27;, maxDate: &#x27;11:30:00&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"只能选择今天以前的日期-包括今天\"><a href=\"#只能选择今天以前的日期-包括今天\" class=\"headerlink\" title=\"只能选择今天以前的日期(包括今天)\"></a>只能选择今天以前的日期(包括今天)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d421&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;skin:&#x27;whyGreen&#x27;,maxDate: &#x27;%y-%M-%d&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用了运算表达式-只能选择今天以后的日期-不包括今天\"><a href=\"#使用了运算表达式-只能选择今天以后的日期-不包括今天\" class=\"headerlink\" title=\"使用了运算表达式 只能选择今天以后的日期(不包括今天)\"></a>使用了运算表达式 只能选择今天以后的日期(不包括今天)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d422&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;minDate: &#x27;%y-%M-#&#123;%d+1&#125;&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"只能选择本月的日期1号至本月最后一天\"><a href=\"#只能选择本月的日期1号至本月最后一天\" class=\"headerlink\" title=\"只能选择本月的日期1号至本月最后一天\"></a>只能选择本月的日期1号至本月最后一天</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d423&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;minDate: &#x27;%y-%M-01&#x27;, maxDate: &#x27;%y-%M-%ld&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"只能选择今天7-00-00至明天21-00-00的日期\"><a href=\"#只能选择今天7-00-00至明天21-00-00的日期\" class=\"headerlink\" title=\"只能选择今天7:00:00至明天21:00:00的日期\"></a>只能选择今天7:00:00至明天21:00:00的日期</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d424&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onfocus=&quot;WdatePicker(&#123;dateFmt:&#x27;yyyy-M-d H:mm:ss&#x27;,minDate: &#x27;%y-%M-%d 7:00:00&#x27;, maxDate: &#x27;%y-%M-#&#123;%d+1&#125; 21:00:00&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用了运算表达式-只能选择-20小时前-至-30小时后-的日期\"><a href=\"#使用了运算表达式-只能选择-20小时前-至-30小时后-的日期\" class=\"headerlink\" title=\"使用了运算表达式 只能选择 20小时前 至 30小时后 的日期\"></a>使用了运算表达式 只能选择 20小时前 至 30小时后 的日期</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d425&quot; class=&quot;Wdate&quot; type=&quot;text&quot;</span><br><span class=\"line\">onClick=&quot;WdatePicker(&#123;dateFmt:&#x27;yyyy-MM-dd HH:mm&#x27;,minDate: &#x27;%y-%M-%d #&#123;%H-20&#125;:%m:%s&#x27; ,maxDate: &#x27;%y-%M-%d #&#123;%H+30&#125;:%m:%s&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"前面的日期不能大于后面的日期且两个日期都不能大于-2020-10-01\"><a href=\"#前面的日期不能大于后面的日期且两个日期都不能大于-2020-10-01\" class=\"headerlink\" title=\"前面的日期不能大于后面的日期且两个日期都不能大于 2020-10-01\"></a>前面的日期不能大于后面的日期且两个日期都不能大于 2020-10-01</h3><blockquote>\n<p>合同有效期从 到 <br><br>[注意: 两个日期的日期格式必须相同.<br>dp. 相当于 document.getElementByIdx_x 函数.<br>那么为什么里面的 ’ 使用 \\’ 呢? 那是因为 ” 和 ’ 都被外围的函数使用了,故使用转义符 \\ ,否则会提示JS语法错误.所以您在其他地方使用时注意把 \\’ 改成 ” 或者 ’ 来使用。<br><code>#F&#123;$dp.$D(\\&#39;d4312\\&#39;)||\\&#39;2020-10-01\\&#39;&#125; 表示当 d4312 为空时, 采用 2020-10-01 的值作为最大值</code>]</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input id=&quot;d4311&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onFocus=&quot;WdatePicker(&#123;maxDate: &#x27;#F&#123;$dp.$D(\\&#x27;d4312\\&#x27;)||\\&#x27;2020-10-01\\&#x27;&#125;&#x27; &#125;)&quot;/&gt;</span><br><span class=\"line\">&lt;input id=&quot;d4312&quot; class=&quot;Wdate&quot; type=&quot;text&quot; onFocus=&quot;WdatePicker(&#123;minDate: &#x27;#F&#123;$dp.$D(\\&#x27;d4311\\&#x27;)&#125;&#x27; ,maxDate:&#x27;2020-10-01&#x27; &#125;)&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取值和赋值\"><a href=\"#取值和赋值\" class=\"headerlink\" title=\"取值和赋值\"></a>取值和赋值</h2><h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html:\"></a>html:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input class=&quot;p-Wdate&quot; type=&quot;text&quot;   onfocus=&quot;WdatePicker()&quot;/&gt;</span><br><span class=\"line\">&lt;p&gt;&lt;button class=&quot;tijiaoBtn&quot;&gt;提交&lt;/button&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js:\"></a>js:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//赋值</span><br><span class=\"line\">$(&quot;.p-Wdate&quot;).val(&quot;2019-01-01&quot;);</span><br><span class=\"line\">//取值</span><br><span class=\"line\">$(&quot;.tijiaoBtn&quot;).on(&quot;click&quot;,function()&#123;</span><br><span class=\"line\">  console.log($(&quot;.p-Wdate&quot;).val());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.2cto.com/kf/201707/662183.html\">WdatePicker.js时间日期插件</a></li>\n<li><a href=\"https://www.cnblogs.com/weiqt/articles/2012169.html\">My97DatePicker日历控件配置</a></li>\n<li><a href=\"http://www.my97.net/\">My97官网</a></li>\n</ul>\n"},{"title":"Java 运行时（RUNTIME）注解详解","date":"2018-09-07T02:29:41.000Z","_content":"\n> 参考博文：[Java注解解析-运行时注解详解(RUNTIME)](https://blog.csdn.net/jsonChumpKlutz/article/details/81747839#commentBox)\n> \n> 个人博客：[DoubleFJ の Blog](http://putop.top/2018/09/07/annotation-java-runtime/)\n\n整理测试后并附上完整代码\n\n---\n\n## 注解定义 \n注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明 。如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，注解不会改变编译器的编译方式，也不会改变虚拟机指令执行的顺序，它更可以理解为是一种特殊的注释，本身不会起到任何作用，需要工具方法或者编译器本身读取注解的内容继而控制进行某种操作。大致可分为三类：\n\n- 编写文档：通过代码里标识的元数据生成文档。\n- 代码分析：通过代码里标识的元数据对代码进行分析。\n- 编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查。\n\n## 注解用途\n因为注解可以在代码编译期间帮我们完成一些复杂的准备工作，所以我们可以利用注解去完成我们的一些准备工作。可以在编译期间获取到注解中的内容以便之后的数据处理，完全可以写好逻辑代码就等着编译时将值传入。\n\n## 注解详解\nJava JDK 中包含了三个注解分别为 @Override（校验格式），@Deprecated：（标记过时的方法或者类），@SuppressWarnnings（注解主要用于抑制编译器警告）等等。JDK 1.8 之后有新增了一些注解像 @FunctionalInterface()这样的,对于每个注解的具体使用细节这里不再论述。我们来看一下 @Override 的源码。\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n通过源代码的阅读我们可以看出生命注解的方式为 @interface，每个注解都需要不少于一个的元注解的修饰，这里的元注解其实就是修饰注解的注解，可以理解成最小的注解单位吧。下面详细的看下每个注释注解的意义吧：\n\n### @Target\n说明了 Annotation 所修饰的对象范围,也就是我们这个注解是用在那个对象上面的：Annotation 可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在 Annotation 类型的声明中使用了target可更加明晰其修饰的目标。以下属性是多选状态，我们可以定义多个注解作用域，比如：\n```\n@Target({ElementType.METHOD,ElementType.FIELD})，单个的使用 @Target(ElementType.FIELD)。    \n（1）.CONSTRUCTOR：构造方法声明。\n（2）.FIELD：用于描述域也就是类属性之类的，字段声明（包括枚举常量）。\n（3）.LOCAL_VARIABLE：用于描述局部变量。\n（4）.METHOD：用于描述方法。\n（5）.PACKAGE：包声明。\n（6）.PARAMETER：参数声明。\n（7）.TYPE：类、接口（包括注释类型）或枚举声明 。\n（8）.ANNOTATION_TYPE：注释类型声明，只能用于注释注解。\n```\n**官方解释：指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。** 例如，此元注释指示该声明类型是其自身，即元注释类型。它只能用在注释类型声明上:\n```\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface MetaAnnotationType {\n}\n```\n此元注释指示该声明类型只可作为复杂注释类型声明中的成员类型使用。它不能直接用于注释：\n```\n@Target({}) \npublic @interface MemberType {\n             ...\n}\n```\n这是一个**编译时错误**，它表明一个 ElementType 常量在 Target 注释中出现了不只一次。例如，以下元注释是非法的：\n```\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD})\npublic @interface Bogus {\n             ...\n}\n```\n\n### @Retention\n定义了该 Annotation 被保留的时间长短：某些 Annotation 仅出现在源代码中，而被编译器丢弃；而另一些却被编译在 class 文件中；编译在 class 文件中的 Annotation 可能会被虚拟机忽略，而另一些在 class 被装载时将被读取（请注意并不影响 class 的执行，因为 Annotation 与 class 在使用上是被分离的）。使用这个 meta-Annotation 可以对 Annotation 的“生命周期”限制。来源于 java.lang.annotation.RetentionPolicy 的枚举类型值： \n```\n（1）.SOURCE:在源文件中有效（即源文件保留）编译成class文件将舍弃该注解。 \n（2）.CLASS:在class文件中有效（即class保留） 编译成dex文件将舍弃该注解。 \n（3）.RUNTIME:在运行时有效（即运行时保留） 运行时可见。 \n```\n**也就是说注解处理器能处理这三类的注解,我们通过反射的话只能处理 RUNTIME 类型的注解。**\n\n**官方解释：指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。**\n\n### @Documented\n指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 Documented 来注释的，则其注释将成为注释元素的公共 API 的一部。Documented 是一个标记注解，没有成员。\n\n### @Inherited\n元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是**被继承的**。如果一个使用了 @Inherited 修饰的 annotation 类型被用于一个 class ，则这个 annotation 将被用于该 class 的子类。 注意：@Inherited annotation 类型是被标注过的 class 的子类所继承。类并不从它所实现的接口继承 annotation，方法并不从它所重载的方法继承 annotation。当 @Inherited annotation 类型标注的 annotation 的 Retention 是 RetentionPolicy.RUNTIME，则反射 API 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @Inherited annotation 类型的 annotation 时，反射代码检查将展开工作：检查 class 和其父类，直到发现指定的 annotation 类型被发现，或者到达类继承结构的顶层。\n\n**官方解释：指示注释类型被自动继承。如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。** \n\n***注意，如果使用注释类型注释类以外的任何事物，此元注释类型都是无效的。还要注意，此元注释仅促成从超类继承注释；对已实现接口的注释无效。***\n\n### @Repeatable\nRepeatable可重复性，JDK 1.8 新特性，其实就是把标注的注解放到该元注解所属的注解容器里面。以下是一个完整 Demo ：\n\n**MyTag.java** ： 自定义注解\n```\n@Target({ ElementType.METHOD, ElementType.FIELD })\n@Retention(RetentionPolicy.CLASS)\n@Repeatable(MyCar.class) // 注解可重复使用 将 MyTag 作为 MyCar 中 value 的值，即放入了 MyCar 注解容器中\npublic @interface MyTag {\n\n    // default 后为其默认值\n    String name() default \"\";\n\n    int size() default 0;\n}\n```\n\n**MyCar.java** ： MyTag 的注解容器\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyCar {\n    MyTag[] value(); // 注解里面属性的返回值是 Tag 注解的数组，即 MyTag 注解容器\n}\n```\n\n**Car.java** ： 测试实体类\n```\npublic class Car {\n\n    private String name;\n\n    private int size;\n\n    public Car(String name, int size) {\n        this.name = name;\n        this.size = size;\n    }\n\n    // 省略了 set get\n\n    @Override\n    public String toString() {\n        return \"Car [name=\" + name + \", size=\" + size + \"]\";\n    }\n\n}\n```\n\n**AnnotationCar.java** ： 最关键的注解处理类\n```\n/**\n * Car 注解处理类\n * \n * @author ffj\n *\n */\npublic class AnnotationCar {\n\n    private AnnotationCar() {\n    }\n\n    private static volatile AnnotationCar annotationCar;\n\n    public static AnnotationCar instance() {\n        // 单例 双重检查\n        if (annotationCar == null) {\n            synchronized (AnnotationCar.class) {\n                if (annotationCar == null) {\n                    annotationCar = new AnnotationCar();\n                }\n            }\n        }\n        return annotationCar;\n    }\n\n    public void inject(Object o) {\n        Class<?> aClass = o.getClass();\n        Field[] declaredFields = aClass.getDeclaredFields(); // 获取所有声明的字段\n        for (Field field : declaredFields) {\n            if (field.getName().equals(\"car\")) {\n                Annotation[] annotations = field.getAnnotations();\n                for (Annotation annotation : annotations) { // 注解的对象类型\n                    Class<? extends Annotation> className = annotation.annotationType();\n                    System.out.println(\"className :\" + className);\n                }\n                MyCar annotation = field.getAnnotation(MyCar.class); // MyCar 类型输出\n                MyTag[] tags = annotation.value();\n                for (MyTag tag : tags) {\n                    System.out.println(\"name :\" + tag.name());\n                    System.out.println(\"size :\" + tag.size());\n                    try {\n                        field.setAccessible(true); // 类中的成员变量为 private,故必须进行此操作\n                        field.set(o, new Car(tag.name(), tag.size())); // 重新赋值对象\n                        System.out.println(\"注解对象为 ：\" + field.get(o).toString());\n                    } catch (IllegalArgumentException e) {\n                        e.printStackTrace();\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n**AnnotationTest.java** ： 测试运行类\n```\npublic class AnnotationTest {\n\n    @MyTag(name = \"野马\", size = 222)\n    @MyTag(name = \"兰博基尼\", size = 333)\n    Car car;\n\n    public void printAnno() {\n        AnnotationCar.instance().inject(this);\n    }\n\n    public static void main(String[] args) {\n        new AnnotationTest().printAnno();\n\n    }\n}\n```\n\n**最终运行结果便是：**\n```\nclassName :interface com.tonglei.test.MyCar\nname :野马\nsize :222\n注解对象为 ：Car [name=野马, size=222]\nname :兰博基尼\nsize :333\n注解对象为 ：Car [name=兰博基尼, size=333]\n```\n\n## 总结\n不知这样可否清晰。这里运行时注解就是在程序编译时扫描到类下的字段上的注解，就可以知道该字段上的元注解的类型，进而将注解中元素的值得到进行你自己的业务操作。这个 Demo 是利用了 @Repeatable 注解，不用该注解直接用元注解 RUNTIME 类型也是一样的，只要注解类逻辑稍微修改即可。结合这个可以更好地理解了反射和注解以及 class 的注入。","source":"_posts/annotation-java-runtime.md","raw":"---\ntitle: Java 运行时（RUNTIME）注解详解\ndate: 2018-9-7 10:29:41\ncategories: [开发,总结]\ntags: [Java,反射,注解]\n---\n\n> 参考博文：[Java注解解析-运行时注解详解(RUNTIME)](https://blog.csdn.net/jsonChumpKlutz/article/details/81747839#commentBox)\n> \n> 个人博客：[DoubleFJ の Blog](http://putop.top/2018/09/07/annotation-java-runtime/)\n\n整理测试后并附上完整代码\n\n---\n\n## 注解定义 \n注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明 。如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，注解不会改变编译器的编译方式，也不会改变虚拟机指令执行的顺序，它更可以理解为是一种特殊的注释，本身不会起到任何作用，需要工具方法或者编译器本身读取注解的内容继而控制进行某种操作。大致可分为三类：\n\n- 编写文档：通过代码里标识的元数据生成文档。\n- 代码分析：通过代码里标识的元数据对代码进行分析。\n- 编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查。\n\n## 注解用途\n因为注解可以在代码编译期间帮我们完成一些复杂的准备工作，所以我们可以利用注解去完成我们的一些准备工作。可以在编译期间获取到注解中的内容以便之后的数据处理，完全可以写好逻辑代码就等着编译时将值传入。\n\n## 注解详解\nJava JDK 中包含了三个注解分别为 @Override（校验格式），@Deprecated：（标记过时的方法或者类），@SuppressWarnnings（注解主要用于抑制编译器警告）等等。JDK 1.8 之后有新增了一些注解像 @FunctionalInterface()这样的,对于每个注解的具体使用细节这里不再论述。我们来看一下 @Override 的源码。\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n通过源代码的阅读我们可以看出生命注解的方式为 @interface，每个注解都需要不少于一个的元注解的修饰，这里的元注解其实就是修饰注解的注解，可以理解成最小的注解单位吧。下面详细的看下每个注释注解的意义吧：\n\n### @Target\n说明了 Annotation 所修饰的对象范围,也就是我们这个注解是用在那个对象上面的：Annotation 可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在 Annotation 类型的声明中使用了target可更加明晰其修饰的目标。以下属性是多选状态，我们可以定义多个注解作用域，比如：\n```\n@Target({ElementType.METHOD,ElementType.FIELD})，单个的使用 @Target(ElementType.FIELD)。    \n（1）.CONSTRUCTOR：构造方法声明。\n（2）.FIELD：用于描述域也就是类属性之类的，字段声明（包括枚举常量）。\n（3）.LOCAL_VARIABLE：用于描述局部变量。\n（4）.METHOD：用于描述方法。\n（5）.PACKAGE：包声明。\n（6）.PARAMETER：参数声明。\n（7）.TYPE：类、接口（包括注释类型）或枚举声明 。\n（8）.ANNOTATION_TYPE：注释类型声明，只能用于注释注解。\n```\n**官方解释：指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。** 例如，此元注释指示该声明类型是其自身，即元注释类型。它只能用在注释类型声明上:\n```\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface MetaAnnotationType {\n}\n```\n此元注释指示该声明类型只可作为复杂注释类型声明中的成员类型使用。它不能直接用于注释：\n```\n@Target({}) \npublic @interface MemberType {\n             ...\n}\n```\n这是一个**编译时错误**，它表明一个 ElementType 常量在 Target 注释中出现了不只一次。例如，以下元注释是非法的：\n```\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.FIELD})\npublic @interface Bogus {\n             ...\n}\n```\n\n### @Retention\n定义了该 Annotation 被保留的时间长短：某些 Annotation 仅出现在源代码中，而被编译器丢弃；而另一些却被编译在 class 文件中；编译在 class 文件中的 Annotation 可能会被虚拟机忽略，而另一些在 class 被装载时将被读取（请注意并不影响 class 的执行，因为 Annotation 与 class 在使用上是被分离的）。使用这个 meta-Annotation 可以对 Annotation 的“生命周期”限制。来源于 java.lang.annotation.RetentionPolicy 的枚举类型值： \n```\n（1）.SOURCE:在源文件中有效（即源文件保留）编译成class文件将舍弃该注解。 \n（2）.CLASS:在class文件中有效（即class保留） 编译成dex文件将舍弃该注解。 \n（3）.RUNTIME:在运行时有效（即运行时保留） 运行时可见。 \n```\n**也就是说注解处理器能处理这三类的注解,我们通过反射的话只能处理 RUNTIME 类型的注解。**\n\n**官方解释：指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。**\n\n### @Documented\n指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 Documented 来注释的，则其注释将成为注释元素的公共 API 的一部。Documented 是一个标记注解，没有成员。\n\n### @Inherited\n元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是**被继承的**。如果一个使用了 @Inherited 修饰的 annotation 类型被用于一个 class ，则这个 annotation 将被用于该 class 的子类。 注意：@Inherited annotation 类型是被标注过的 class 的子类所继承。类并不从它所实现的接口继承 annotation，方法并不从它所重载的方法继承 annotation。当 @Inherited annotation 类型标注的 annotation 的 Retention 是 RetentionPolicy.RUNTIME，则反射 API 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @Inherited annotation 类型的 annotation 时，反射代码检查将展开工作：检查 class 和其父类，直到发现指定的 annotation 类型被发现，或者到达类继承结构的顶层。\n\n**官方解释：指示注释类型被自动继承。如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。** \n\n***注意，如果使用注释类型注释类以外的任何事物，此元注释类型都是无效的。还要注意，此元注释仅促成从超类继承注释；对已实现接口的注释无效。***\n\n### @Repeatable\nRepeatable可重复性，JDK 1.8 新特性，其实就是把标注的注解放到该元注解所属的注解容器里面。以下是一个完整 Demo ：\n\n**MyTag.java** ： 自定义注解\n```\n@Target({ ElementType.METHOD, ElementType.FIELD })\n@Retention(RetentionPolicy.CLASS)\n@Repeatable(MyCar.class) // 注解可重复使用 将 MyTag 作为 MyCar 中 value 的值，即放入了 MyCar 注解容器中\npublic @interface MyTag {\n\n    // default 后为其默认值\n    String name() default \"\";\n\n    int size() default 0;\n}\n```\n\n**MyCar.java** ： MyTag 的注解容器\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyCar {\n    MyTag[] value(); // 注解里面属性的返回值是 Tag 注解的数组，即 MyTag 注解容器\n}\n```\n\n**Car.java** ： 测试实体类\n```\npublic class Car {\n\n    private String name;\n\n    private int size;\n\n    public Car(String name, int size) {\n        this.name = name;\n        this.size = size;\n    }\n\n    // 省略了 set get\n\n    @Override\n    public String toString() {\n        return \"Car [name=\" + name + \", size=\" + size + \"]\";\n    }\n\n}\n```\n\n**AnnotationCar.java** ： 最关键的注解处理类\n```\n/**\n * Car 注解处理类\n * \n * @author ffj\n *\n */\npublic class AnnotationCar {\n\n    private AnnotationCar() {\n    }\n\n    private static volatile AnnotationCar annotationCar;\n\n    public static AnnotationCar instance() {\n        // 单例 双重检查\n        if (annotationCar == null) {\n            synchronized (AnnotationCar.class) {\n                if (annotationCar == null) {\n                    annotationCar = new AnnotationCar();\n                }\n            }\n        }\n        return annotationCar;\n    }\n\n    public void inject(Object o) {\n        Class<?> aClass = o.getClass();\n        Field[] declaredFields = aClass.getDeclaredFields(); // 获取所有声明的字段\n        for (Field field : declaredFields) {\n            if (field.getName().equals(\"car\")) {\n                Annotation[] annotations = field.getAnnotations();\n                for (Annotation annotation : annotations) { // 注解的对象类型\n                    Class<? extends Annotation> className = annotation.annotationType();\n                    System.out.println(\"className :\" + className);\n                }\n                MyCar annotation = field.getAnnotation(MyCar.class); // MyCar 类型输出\n                MyTag[] tags = annotation.value();\n                for (MyTag tag : tags) {\n                    System.out.println(\"name :\" + tag.name());\n                    System.out.println(\"size :\" + tag.size());\n                    try {\n                        field.setAccessible(true); // 类中的成员变量为 private,故必须进行此操作\n                        field.set(o, new Car(tag.name(), tag.size())); // 重新赋值对象\n                        System.out.println(\"注解对象为 ：\" + field.get(o).toString());\n                    } catch (IllegalArgumentException e) {\n                        e.printStackTrace();\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n**AnnotationTest.java** ： 测试运行类\n```\npublic class AnnotationTest {\n\n    @MyTag(name = \"野马\", size = 222)\n    @MyTag(name = \"兰博基尼\", size = 333)\n    Car car;\n\n    public void printAnno() {\n        AnnotationCar.instance().inject(this);\n    }\n\n    public static void main(String[] args) {\n        new AnnotationTest().printAnno();\n\n    }\n}\n```\n\n**最终运行结果便是：**\n```\nclassName :interface com.tonglei.test.MyCar\nname :野马\nsize :222\n注解对象为 ：Car [name=野马, size=222]\nname :兰博基尼\nsize :333\n注解对象为 ：Car [name=兰博基尼, size=333]\n```\n\n## 总结\n不知这样可否清晰。这里运行时注解就是在程序编译时扫描到类下的字段上的注解，就可以知道该字段上的元注解的类型，进而将注解中元素的值得到进行你自己的业务操作。这个 Demo 是利用了 @Repeatable 注解，不用该注解直接用元注解 RUNTIME 类型也是一样的，只要注解类逻辑稍微修改即可。结合这个可以更好地理解了反射和注解以及 class 的注入。","slug":"annotation-java-runtime","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh8001mk9i1ann25ex1","content":"<blockquote>\n<p>参考博文：<a href=\"https://blog.csdn.net/jsonChumpKlutz/article/details/81747839#commentBox\">Java注解解析-运行时注解详解(RUNTIME)</a></p>\n<p>个人博客：<a href=\"http://putop.top/2018/09/07/annotation-java-runtime/\">DoubleFJ の Blog</a></p>\n</blockquote>\n<p>整理测试后并附上完整代码</p>\n<hr>\n<h2 id=\"注解定义\"><a href=\"#注解定义\" class=\"headerlink\" title=\"注解定义\"></a>注解定义</h2><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明 。如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，注解不会改变编译器的编译方式，也不会改变虚拟机指令执行的顺序，它更可以理解为是一种特殊的注释，本身不会起到任何作用，需要工具方法或者编译器本身读取注解的内容继而控制进行某种操作。大致可分为三类：</p>\n<ul>\n<li>编写文档：通过代码里标识的元数据生成文档。</li>\n<li>代码分析：通过代码里标识的元数据对代码进行分析。</li>\n<li>编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查。</li>\n</ul>\n<h2 id=\"注解用途\"><a href=\"#注解用途\" class=\"headerlink\" title=\"注解用途\"></a>注解用途</h2><p>因为注解可以在代码编译期间帮我们完成一些复杂的准备工作，所以我们可以利用注解去完成我们的一些准备工作。可以在编译期间获取到注解中的内容以便之后的数据处理，完全可以写好逻辑代码就等着编译时将值传入。</p>\n<h2 id=\"注解详解\"><a href=\"#注解详解\" class=\"headerlink\" title=\"注解详解\"></a>注解详解</h2><p>Java JDK 中包含了三个注解分别为 @Override（校验格式），@Deprecated：（标记过时的方法或者类），@SuppressWarnnings（注解主要用于抑制编译器警告）等等。JDK 1.8 之后有新增了一些注解像 @FunctionalInterface()这样的,对于每个注解的具体使用细节这里不再论述。我们来看一下 @Override 的源码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.METHOD)</span><br><span class=\"line\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"line\">public @interface Override &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过源代码的阅读我们可以看出生命注解的方式为 @interface，每个注解都需要不少于一个的元注解的修饰，这里的元注解其实就是修饰注解的注解，可以理解成最小的注解单位吧。下面详细的看下每个注释注解的意义吧：</p>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h3><p>说明了 Annotation 所修饰的对象范围,也就是我们这个注解是用在那个对象上面的：Annotation 可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在 Annotation 类型的声明中使用了target可更加明晰其修饰的目标。以下属性是多选状态，我们可以定义多个注解作用域，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)，单个的使用 @Target(ElementType.FIELD)。    </span><br><span class=\"line\">（1）.CONSTRUCTOR：构造方法声明。</span><br><span class=\"line\">（2）.FIELD：用于描述域也就是类属性之类的，字段声明（包括枚举常量）。</span><br><span class=\"line\">（3）.LOCAL_VARIABLE：用于描述局部变量。</span><br><span class=\"line\">（4）.METHOD：用于描述方法。</span><br><span class=\"line\">（5）.PACKAGE：包声明。</span><br><span class=\"line\">（6）.PARAMETER：参数声明。</span><br><span class=\"line\">（7）.TYPE：类、接口（包括注释类型）或枚举声明 。</span><br><span class=\"line\">（8）.ANNOTATION_TYPE：注释类型声明，只能用于注释注解。</span><br></pre></td></tr></table></figure>\n<p><strong>官方解释：指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。</strong> 例如，此元注释指示该声明类型是其自身，即元注释类型。它只能用在注释类型声明上:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface MetaAnnotationType &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此元注释指示该声明类型只可作为复杂注释类型声明中的成员类型使用。它不能直接用于注释：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;&#125;) </span><br><span class=\"line\">public @interface MemberType &#123;</span><br><span class=\"line\">             ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个<strong>编译时错误</strong>，它表明一个 ElementType 常量在 Target 注释中出现了不只一次。例如，以下元注释是非法的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class=\"line\">public @interface Bogus &#123;</span><br><span class=\"line\">             ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h3><p>定义了该 Annotation 被保留的时间长短：某些 Annotation 仅出现在源代码中，而被编译器丢弃；而另一些却被编译在 class 文件中；编译在 class 文件中的 Annotation 可能会被虚拟机忽略，而另一些在 class 被装载时将被读取（请注意并不影响 class 的执行，因为 Annotation 与 class 在使用上是被分离的）。使用这个 meta-Annotation 可以对 Annotation 的“生命周期”限制。来源于 java.lang.annotation.RetentionPolicy 的枚举类型值： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）.SOURCE:在源文件中有效（即源文件保留）编译成class文件将舍弃该注解。 </span><br><span class=\"line\">（2）.CLASS:在class文件中有效（即class保留） 编译成dex文件将舍弃该注解。 </span><br><span class=\"line\">（3）.RUNTIME:在运行时有效（即运行时保留） 运行时可见。 </span><br></pre></td></tr></table></figure>\n<p><strong>也就是说注解处理器能处理这三类的注解,我们通过反射的话只能处理 RUNTIME 类型的注解。</strong></p>\n<p><strong>官方解释：指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。</strong></p>\n<h3 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h3><p>指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 Documented 来注释的，则其注释将成为注释元素的公共 API 的一部。Documented 是一个标记注解，没有成员。</p>\n<h3 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h3><p>元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是<strong>被继承的</strong>。如果一个使用了 @Inherited 修饰的 annotation 类型被用于一个 class ，则这个 annotation 将被用于该 class 的子类。 注意：@Inherited annotation 类型是被标注过的 class 的子类所继承。类并不从它所实现的接口继承 annotation，方法并不从它所重载的方法继承 annotation。当 @Inherited annotation 类型标注的 annotation 的 Retention 是 RetentionPolicy.RUNTIME，则反射 API 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @Inherited annotation 类型的 annotation 时，反射代码检查将展开工作：检查 class 和其父类，直到发现指定的 annotation 类型被发现，或者到达类继承结构的顶层。</p>\n<p><strong>官方解释：指示注释类型被自动继承。如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。</strong> </p>\n<p><em><strong>注意，如果使用注释类型注释类以外的任何事物，此元注释类型都是无效的。还要注意，此元注释仅促成从超类继承注释；对已实现接口的注释无效。</strong></em></p>\n<h3 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h3><p>Repeatable可重复性，JDK 1.8 新特性，其实就是把标注的注解放到该元注解所属的注解容器里面。以下是一个完整 Demo ：</p>\n<p><strong>MyTag.java</strong> ： 自定义注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.CLASS)</span><br><span class=\"line\">@Repeatable(MyCar.class) // 注解可重复使用 将 MyTag 作为 MyCar 中 value 的值，即放入了 MyCar 注解容器中</span><br><span class=\"line\">public @interface MyTag &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // default 后为其默认值</span><br><span class=\"line\">    String name() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    int size() default 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>MyCar.java</strong> ： MyTag 的注解容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.FIELD)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface MyCar &#123;</span><br><span class=\"line\">    MyTag[] value(); // 注解里面属性的返回值是 Tag 注解的数组，即 MyTag 注解容器</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Car.java</strong> ： 测试实体类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int size;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Car(String name, int size) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略了 set get</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Car [name=&quot; + name + &quot;, size=&quot; + size + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AnnotationCar.java</strong> ： 最关键的注解处理类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Car 注解处理类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class AnnotationCar &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private AnnotationCar() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static volatile AnnotationCar annotationCar;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static AnnotationCar instance() &#123;</span><br><span class=\"line\">        // 单例 双重检查</span><br><span class=\"line\">        if (annotationCar == null) &#123;</span><br><span class=\"line\">            synchronized (AnnotationCar.class) &#123;</span><br><span class=\"line\">                if (annotationCar == null) &#123;</span><br><span class=\"line\">                    annotationCar = new AnnotationCar();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return annotationCar;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void inject(Object o) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; aClass = o.getClass();</span><br><span class=\"line\">        Field[] declaredFields = aClass.getDeclaredFields(); // 获取所有声明的字段</span><br><span class=\"line\">        for (Field field : declaredFields) &#123;</span><br><span class=\"line\">            if (field.getName().equals(&quot;car&quot;)) &#123;</span><br><span class=\"line\">                Annotation[] annotations = field.getAnnotations();</span><br><span class=\"line\">                for (Annotation annotation : annotations) &#123; // 注解的对象类型</span><br><span class=\"line\">                    Class&lt;? extends Annotation&gt; className = annotation.annotationType();</span><br><span class=\"line\">                    System.out.println(&quot;className :&quot; + className);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                MyCar annotation = field.getAnnotation(MyCar.class); // MyCar 类型输出</span><br><span class=\"line\">                MyTag[] tags = annotation.value();</span><br><span class=\"line\">                for (MyTag tag : tags) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;name :&quot; + tag.name());</span><br><span class=\"line\">                    System.out.println(&quot;size :&quot; + tag.size());</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        field.setAccessible(true); // 类中的成员变量为 private,故必须进行此操作</span><br><span class=\"line\">                        field.set(o, new Car(tag.name(), tag.size())); // 重新赋值对象</span><br><span class=\"line\">                        System.out.println(&quot;注解对象为 ：&quot; + field.get(o).toString());</span><br><span class=\"line\">                    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AnnotationTest.java</strong> ： 测试运行类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnnotationTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @MyTag(name = &quot;野马&quot;, size = 222)</span><br><span class=\"line\">    @MyTag(name = &quot;兰博基尼&quot;, size = 333)</span><br><span class=\"line\">    Car car;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void printAnno() &#123;</span><br><span class=\"line\">        AnnotationCar.instance().inject(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new AnnotationTest().printAnno();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>最终运行结果便是：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">className :interface com.tonglei.test.MyCar</span><br><span class=\"line\">name :野马</span><br><span class=\"line\">size :222</span><br><span class=\"line\">注解对象为 ：Car [name=野马, size=222]</span><br><span class=\"line\">name :兰博基尼</span><br><span class=\"line\">size :333</span><br><span class=\"line\">注解对象为 ：Car [name=兰博基尼, size=333]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不知这样可否清晰。这里运行时注解就是在程序编译时扫描到类下的字段上的注解，就可以知道该字段上的元注解的类型，进而将注解中元素的值得到进行你自己的业务操作。这个 Demo 是利用了 @Repeatable 注解，不用该注解直接用元注解 RUNTIME 类型也是一样的，只要注解类逻辑稍微修改即可。结合这个可以更好地理解了反射和注解以及 class 的注入。</p>\n","excerpt":"","more":"<blockquote>\n<p>参考博文：<a href=\"https://blog.csdn.net/jsonChumpKlutz/article/details/81747839#commentBox\">Java注解解析-运行时注解详解(RUNTIME)</a></p>\n<p>个人博客：<a href=\"http://putop.top/2018/09/07/annotation-java-runtime/\">DoubleFJ の Blog</a></p>\n</blockquote>\n<p>整理测试后并附上完整代码</p>\n<hr>\n<h2 id=\"注解定义\"><a href=\"#注解定义\" class=\"headerlink\" title=\"注解定义\"></a>注解定义</h2><p>注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明 。如果要对于元数据的作用进行分类，还没有明确的定义，不过我们可以根据它所起的作用，注解不会改变编译器的编译方式，也不会改变虚拟机指令执行的顺序，它更可以理解为是一种特殊的注释，本身不会起到任何作用，需要工具方法或者编译器本身读取注解的内容继而控制进行某种操作。大致可分为三类：</p>\n<ul>\n<li>编写文档：通过代码里标识的元数据生成文档。</li>\n<li>代码分析：通过代码里标识的元数据对代码进行分析。</li>\n<li>编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查。</li>\n</ul>\n<h2 id=\"注解用途\"><a href=\"#注解用途\" class=\"headerlink\" title=\"注解用途\"></a>注解用途</h2><p>因为注解可以在代码编译期间帮我们完成一些复杂的准备工作，所以我们可以利用注解去完成我们的一些准备工作。可以在编译期间获取到注解中的内容以便之后的数据处理，完全可以写好逻辑代码就等着编译时将值传入。</p>\n<h2 id=\"注解详解\"><a href=\"#注解详解\" class=\"headerlink\" title=\"注解详解\"></a>注解详解</h2><p>Java JDK 中包含了三个注解分别为 @Override（校验格式），@Deprecated：（标记过时的方法或者类），@SuppressWarnnings（注解主要用于抑制编译器警告）等等。JDK 1.8 之后有新增了一些注解像 @FunctionalInterface()这样的,对于每个注解的具体使用细节这里不再论述。我们来看一下 @Override 的源码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.METHOD)</span><br><span class=\"line\">@Retention(RetentionPolicy.SOURCE)</span><br><span class=\"line\">public @interface Override &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过源代码的阅读我们可以看出生命注解的方式为 @interface，每个注解都需要不少于一个的元注解的修饰，这里的元注解其实就是修饰注解的注解，可以理解成最小的注解单位吧。下面详细的看下每个注释注解的意义吧：</p>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h3><p>说明了 Annotation 所修饰的对象范围,也就是我们这个注解是用在那个对象上面的：Annotation 可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在 Annotation 类型的声明中使用了target可更加明晰其修饰的目标。以下属性是多选状态，我们可以定义多个注解作用域，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)，单个的使用 @Target(ElementType.FIELD)。    </span><br><span class=\"line\">（1）.CONSTRUCTOR：构造方法声明。</span><br><span class=\"line\">（2）.FIELD：用于描述域也就是类属性之类的，字段声明（包括枚举常量）。</span><br><span class=\"line\">（3）.LOCAL_VARIABLE：用于描述局部变量。</span><br><span class=\"line\">（4）.METHOD：用于描述方法。</span><br><span class=\"line\">（5）.PACKAGE：包声明。</span><br><span class=\"line\">（6）.PARAMETER：参数声明。</span><br><span class=\"line\">（7）.TYPE：类、接口（包括注释类型）或枚举声明 。</span><br><span class=\"line\">（8）.ANNOTATION_TYPE：注释类型声明，只能用于注释注解。</span><br></pre></td></tr></table></figure>\n<p><strong>官方解释：指示注释类型所适用的程序元素的种类。如果注释类型声明中不存在 Target 元注释，则声明的类型可以用在任一程序元素上。如果存在这样的元注释，则编译器强制实施指定的使用限制。</strong> 例如，此元注释指示该声明类型是其自身，即元注释类型。它只能用在注释类型声明上:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class=\"line\">public @interface MetaAnnotationType &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此元注释指示该声明类型只可作为复杂注释类型声明中的成员类型使用。它不能直接用于注释：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;&#125;) </span><br><span class=\"line\">public @interface MemberType &#123;</span><br><span class=\"line\">             ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个<strong>编译时错误</strong>，它表明一个 ElementType 常量在 Target 注释中出现了不只一次。例如，以下元注释是非法的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.FIELD&#125;)</span><br><span class=\"line\">public @interface Bogus &#123;</span><br><span class=\"line\">             ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h3><p>定义了该 Annotation 被保留的时间长短：某些 Annotation 仅出现在源代码中，而被编译器丢弃；而另一些却被编译在 class 文件中；编译在 class 文件中的 Annotation 可能会被虚拟机忽略，而另一些在 class 被装载时将被读取（请注意并不影响 class 的执行，因为 Annotation 与 class 在使用上是被分离的）。使用这个 meta-Annotation 可以对 Annotation 的“生命周期”限制。来源于 java.lang.annotation.RetentionPolicy 的枚举类型值： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）.SOURCE:在源文件中有效（即源文件保留）编译成class文件将舍弃该注解。 </span><br><span class=\"line\">（2）.CLASS:在class文件中有效（即class保留） 编译成dex文件将舍弃该注解。 </span><br><span class=\"line\">（3）.RUNTIME:在运行时有效（即运行时保留） 运行时可见。 </span><br></pre></td></tr></table></figure>\n<p><strong>也就是说注解处理器能处理这三类的注解,我们通过反射的话只能处理 RUNTIME 类型的注解。</strong></p>\n<p><strong>官方解释：指示注释类型的注释要保留多久。如果注释类型声明中不存在 Retention 注释，则保留策略默认为 RetentionPolicy.CLASS。只有元注释类型直接用于注释时，Target 元注释才有效。如果元注释类型用作另一种注释类型的成员，则无效。</strong></p>\n<h3 id=\"Documented\"><a href=\"#Documented\" class=\"headerlink\" title=\"@Documented\"></a>@Documented</h3><p>指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。应使用此类型来注释这些类型的声明：其注释会影响由其客户端注释的元素的使用。如果类型声明是用 Documented 来注释的，则其注释将成为注释元素的公共 API 的一部。Documented 是一个标记注解，没有成员。</p>\n<h3 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h3><p>元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是<strong>被继承的</strong>。如果一个使用了 @Inherited 修饰的 annotation 类型被用于一个 class ，则这个 annotation 将被用于该 class 的子类。 注意：@Inherited annotation 类型是被标注过的 class 的子类所继承。类并不从它所实现的接口继承 annotation，方法并不从它所重载的方法继承 annotation。当 @Inherited annotation 类型标注的 annotation 的 Retention 是 RetentionPolicy.RUNTIME，则反射 API 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @Inherited annotation 类型的 annotation 时，反射代码检查将展开工作：检查 class 和其父类，直到发现指定的 annotation 类型被发现，或者到达类继承结构的顶层。</p>\n<p><strong>官方解释：指示注释类型被自动继承。如果在注释类型声明中存在 Inherited 元注释，并且用户在某一类声明中查询该注释类型，同时该类声明中没有此类型的注释，则将在该类的超类中自动查询该注释类型。此过程会重复进行，直到找到此类型的注释或到达了该类层次结构的顶层 (Object) 为止。如果没有超类具有该类型的注释，则查询将指示当前类没有这样的注释。</strong> </p>\n<p><em><strong>注意，如果使用注释类型注释类以外的任何事物，此元注释类型都是无效的。还要注意，此元注释仅促成从超类继承注释；对已实现接口的注释无效。</strong></em></p>\n<h3 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h3><p>Repeatable可重复性，JDK 1.8 新特性，其实就是把标注的注解放到该元注解所属的注解容器里面。以下是一个完整 Demo ：</p>\n<p><strong>MyTag.java</strong> ： 自定义注解</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(&#123; ElementType.METHOD, ElementType.FIELD &#125;)</span><br><span class=\"line\">@Retention(RetentionPolicy.CLASS)</span><br><span class=\"line\">@Repeatable(MyCar.class) // 注解可重复使用 将 MyTag 作为 MyCar 中 value 的值，即放入了 MyCar 注解容器中</span><br><span class=\"line\">public @interface MyTag &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // default 后为其默认值</span><br><span class=\"line\">    String name() default &quot;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    int size() default 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>MyCar.java</strong> ： MyTag 的注解容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.FIELD)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface MyCar &#123;</span><br><span class=\"line\">    MyTag[] value(); // 注解里面属性的返回值是 Tag 注解的数组，即 MyTag 注解容器</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Car.java</strong> ： 测试实体类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Car &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int size;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Car(String name, int size) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.size = size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略了 set get</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\">        return &quot;Car [name=&quot; + name + &quot;, size=&quot; + size + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AnnotationCar.java</strong> ： 最关键的注解处理类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Car 注解处理类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class AnnotationCar &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private AnnotationCar() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static volatile AnnotationCar annotationCar;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static AnnotationCar instance() &#123;</span><br><span class=\"line\">        // 单例 双重检查</span><br><span class=\"line\">        if (annotationCar == null) &#123;</span><br><span class=\"line\">            synchronized (AnnotationCar.class) &#123;</span><br><span class=\"line\">                if (annotationCar == null) &#123;</span><br><span class=\"line\">                    annotationCar = new AnnotationCar();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return annotationCar;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void inject(Object o) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; aClass = o.getClass();</span><br><span class=\"line\">        Field[] declaredFields = aClass.getDeclaredFields(); // 获取所有声明的字段</span><br><span class=\"line\">        for (Field field : declaredFields) &#123;</span><br><span class=\"line\">            if (field.getName().equals(&quot;car&quot;)) &#123;</span><br><span class=\"line\">                Annotation[] annotations = field.getAnnotations();</span><br><span class=\"line\">                for (Annotation annotation : annotations) &#123; // 注解的对象类型</span><br><span class=\"line\">                    Class&lt;? extends Annotation&gt; className = annotation.annotationType();</span><br><span class=\"line\">                    System.out.println(&quot;className :&quot; + className);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                MyCar annotation = field.getAnnotation(MyCar.class); // MyCar 类型输出</span><br><span class=\"line\">                MyTag[] tags = annotation.value();</span><br><span class=\"line\">                for (MyTag tag : tags) &#123;</span><br><span class=\"line\">                    System.out.println(&quot;name :&quot; + tag.name());</span><br><span class=\"line\">                    System.out.println(&quot;size :&quot; + tag.size());</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        field.setAccessible(true); // 类中的成员变量为 private,故必须进行此操作</span><br><span class=\"line\">                        field.set(o, new Car(tag.name(), tag.size())); // 重新赋值对象</span><br><span class=\"line\">                        System.out.println(&quot;注解对象为 ：&quot; + field.get(o).toString());</span><br><span class=\"line\">                    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125; catch (IllegalAccessException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AnnotationTest.java</strong> ： 测试运行类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnnotationTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @MyTag(name = &quot;野马&quot;, size = 222)</span><br><span class=\"line\">    @MyTag(name = &quot;兰博基尼&quot;, size = 333)</span><br><span class=\"line\">    Car car;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void printAnno() &#123;</span><br><span class=\"line\">        AnnotationCar.instance().inject(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        new AnnotationTest().printAnno();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>最终运行结果便是：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">className :interface com.tonglei.test.MyCar</span><br><span class=\"line\">name :野马</span><br><span class=\"line\">size :222</span><br><span class=\"line\">注解对象为 ：Car [name=野马, size=222]</span><br><span class=\"line\">name :兰博基尼</span><br><span class=\"line\">size :333</span><br><span class=\"line\">注解对象为 ：Car [name=兰博基尼, size=333]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不知这样可否清晰。这里运行时注解就是在程序编译时扫描到类下的字段上的注解，就可以知道该字段上的元注解的类型，进而将注解中元素的值得到进行你自己的业务操作。这个 Demo 是利用了 @Repeatable 注解，不用该注解直接用元注解 RUNTIME 类型也是一样的，只要注解类逻辑稍微修改即可。结合这个可以更好地理解了反射和注解以及 class 的注入。</p>\n"},{"title":"焦躁六月（2019）","date":"2019-06-24T02:59:49.000Z","_content":"\n> 送走了愉快的五月，就来了令人焦躁不已的六月。\n\n不知道是不是温度高了天气热了，总是在这样的季节使得焦躁浑身难受然后发生各种事情。\n\n---\n\n\n## 租房\n在外漂没有自己的房子真的是很难受，换工作不在附近得搬，房东不续租说搬也就得搬。\n\n住的地是三室户，这不马上就到期了，一室友不续租了跟女朋友住去结果导致空一间房，找不到人接盘，房东也就不跟我们续租了。也罢，老房子什么设施都是坏的，是得要对自己好一点了，搬吧，那就找房子吧。\n\n找房也还算顺利，虽然是通过中介的，多付了好几千中介费，这也算是找了个新住处，无缝对接。这房子也是个三室，不过面积要稍微大点，环境也好一点，出门就是欧尚超市不远还有个生活广场。原来住的三小伙要搬去浦东刚好也要到期了，房子是真的贵，感觉还合适那就快刀斩乱麻，直接签了得。\n\n过几天得收拾东西准备搬了，其它的倒是还好，就我那个大鱼缸有点费事，也是我要搬之所以头疼的事。说到还是个三室，那还是要准备拉一个人来的，刚好有个新同事过来，先住着，后面就再说吧。也不知道搬过去还能住多久，沪漂什么时候是个头。事情真多，头疼。\n\n## 淄博\n公司以前的一个项目突然就把我派过去考察了，**山东淄博潭溪山景区**。地方是真的挺偏的，下了高铁，打了个出租一直开了将近两小时，其中山路开了近一个小时，还是盘山上去的。据了解来这的都是自驾的多，不然交通确实是不方便。\n\n在那边呆了差不多四天吧，他们吃粗粮的多。我就入乡随俗，跟着吃了几天的菜饼馒头，一天吃个两顿，还真管饱。\n\n家族企业自建的景区，项目确实是多，玻璃桥建得也很奇，十五根索支持，还是值得去一趟的，就是地方偏了点。有一天中午我从那边跟着人群走山路下来，八百多米啊，走得后来腿都打颤了。现在小腿还酸着呢。在这边我就不吐槽公司。\n\n回来路上开车师傅路边买了点油桃，才两块钱一斤，那边的水果确实是好吃点，跟气候环境关系很大吧。看看他们那边居民生活也挺自在的，景点工作人员早上七点集合一起去山上上班，平时没什么人没什么事就坐在那玩玩手机睡睡觉，等到下午五点就下班回去吃饭了。\n\n回来的火车不知道因为什么事还晚点了半小时左右，我是中转去济南西再到上海的，还好给自己留的时间够长，不然又得要费一番劲了。回到上海晚上八点多，回到住的地方晚上十点多，喝了点稀饭吃了两个家里带的粽子，澡就第二天洗了，弄弄就睡了。\n\n回来公司还有一堆事。\n\n## 搬搬搬\n回头再来说说搬家这个事。\n\n其它东西倒还好，搬的地方也不是很远，还是就那个缸是真的不好弄。思来想去还是叫了辆依维柯，一趟省事，六七十倒也不贵。\n\n周末大雨啊，必是一番雨淋淋。之前一直是直接用的投影，没用上显示器，这下那边房间虽然小但是有桌子，显示器也有地方可以放了，刚好家里有个闲置的显示器，这不得要叫我姐给我寄过来，顺丰21，我最喜欢的数字。家里电脑配置都是七八年前的了，看年底的时候要不要把这边的电脑给他们带回去，自己再重新配一台，要努力赚钱攒钱咯。\n\n这么一搬，房租肯定是上去了，不过还好，还能接受吧。独自在外无人关怀，也不知道这样还要再过上几年啊。\n\n---\n最近发现一个很好听的声音，小C英乐，学英语又有动力了！","source":"_posts/anxiety-june.md","raw":"---\ntitle: 焦躁六月（2019）\ndate: 2019-6-24 10:59:49\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 送走了愉快的五月，就来了令人焦躁不已的六月。\n\n不知道是不是温度高了天气热了，总是在这样的季节使得焦躁浑身难受然后发生各种事情。\n\n---\n\n\n## 租房\n在外漂没有自己的房子真的是很难受，换工作不在附近得搬，房东不续租说搬也就得搬。\n\n住的地是三室户，这不马上就到期了，一室友不续租了跟女朋友住去结果导致空一间房，找不到人接盘，房东也就不跟我们续租了。也罢，老房子什么设施都是坏的，是得要对自己好一点了，搬吧，那就找房子吧。\n\n找房也还算顺利，虽然是通过中介的，多付了好几千中介费，这也算是找了个新住处，无缝对接。这房子也是个三室，不过面积要稍微大点，环境也好一点，出门就是欧尚超市不远还有个生活广场。原来住的三小伙要搬去浦东刚好也要到期了，房子是真的贵，感觉还合适那就快刀斩乱麻，直接签了得。\n\n过几天得收拾东西准备搬了，其它的倒是还好，就我那个大鱼缸有点费事，也是我要搬之所以头疼的事。说到还是个三室，那还是要准备拉一个人来的，刚好有个新同事过来，先住着，后面就再说吧。也不知道搬过去还能住多久，沪漂什么时候是个头。事情真多，头疼。\n\n## 淄博\n公司以前的一个项目突然就把我派过去考察了，**山东淄博潭溪山景区**。地方是真的挺偏的，下了高铁，打了个出租一直开了将近两小时，其中山路开了近一个小时，还是盘山上去的。据了解来这的都是自驾的多，不然交通确实是不方便。\n\n在那边呆了差不多四天吧，他们吃粗粮的多。我就入乡随俗，跟着吃了几天的菜饼馒头，一天吃个两顿，还真管饱。\n\n家族企业自建的景区，项目确实是多，玻璃桥建得也很奇，十五根索支持，还是值得去一趟的，就是地方偏了点。有一天中午我从那边跟着人群走山路下来，八百多米啊，走得后来腿都打颤了。现在小腿还酸着呢。在这边我就不吐槽公司。\n\n回来路上开车师傅路边买了点油桃，才两块钱一斤，那边的水果确实是好吃点，跟气候环境关系很大吧。看看他们那边居民生活也挺自在的，景点工作人员早上七点集合一起去山上上班，平时没什么人没什么事就坐在那玩玩手机睡睡觉，等到下午五点就下班回去吃饭了。\n\n回来的火车不知道因为什么事还晚点了半小时左右，我是中转去济南西再到上海的，还好给自己留的时间够长，不然又得要费一番劲了。回到上海晚上八点多，回到住的地方晚上十点多，喝了点稀饭吃了两个家里带的粽子，澡就第二天洗了，弄弄就睡了。\n\n回来公司还有一堆事。\n\n## 搬搬搬\n回头再来说说搬家这个事。\n\n其它东西倒还好，搬的地方也不是很远，还是就那个缸是真的不好弄。思来想去还是叫了辆依维柯，一趟省事，六七十倒也不贵。\n\n周末大雨啊，必是一番雨淋淋。之前一直是直接用的投影，没用上显示器，这下那边房间虽然小但是有桌子，显示器也有地方可以放了，刚好家里有个闲置的显示器，这不得要叫我姐给我寄过来，顺丰21，我最喜欢的数字。家里电脑配置都是七八年前的了，看年底的时候要不要把这边的电脑给他们带回去，自己再重新配一台，要努力赚钱攒钱咯。\n\n这么一搬，房租肯定是上去了，不过还好，还能接受吧。独自在外无人关怀，也不知道这样还要再过上几年啊。\n\n---\n最近发现一个很好听的声音，小C英乐，学英语又有动力了！","slug":"anxiety-june","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh8001rk9i12st9gkfc","content":"<blockquote>\n<p>送走了愉快的五月，就来了令人焦躁不已的六月。</p>\n</blockquote>\n<p>不知道是不是温度高了天气热了，总是在这样的季节使得焦躁浑身难受然后发生各种事情。</p>\n<hr>\n<h2 id=\"租房\"><a href=\"#租房\" class=\"headerlink\" title=\"租房\"></a>租房</h2><p>在外漂没有自己的房子真的是很难受，换工作不在附近得搬，房东不续租说搬也就得搬。</p>\n<p>住的地是三室户，这不马上就到期了，一室友不续租了跟女朋友住去结果导致空一间房，找不到人接盘，房东也就不跟我们续租了。也罢，老房子什么设施都是坏的，是得要对自己好一点了，搬吧，那就找房子吧。</p>\n<p>找房也还算顺利，虽然是通过中介的，多付了好几千中介费，这也算是找了个新住处，无缝对接。这房子也是个三室，不过面积要稍微大点，环境也好一点，出门就是欧尚超市不远还有个生活广场。原来住的三小伙要搬去浦东刚好也要到期了，房子是真的贵，感觉还合适那就快刀斩乱麻，直接签了得。</p>\n<p>过几天得收拾东西准备搬了，其它的倒是还好，就我那个大鱼缸有点费事，也是我要搬之所以头疼的事。说到还是个三室，那还是要准备拉一个人来的，刚好有个新同事过来，先住着，后面就再说吧。也不知道搬过去还能住多久，沪漂什么时候是个头。事情真多，头疼。</p>\n<h2 id=\"淄博\"><a href=\"#淄博\" class=\"headerlink\" title=\"淄博\"></a>淄博</h2><p>公司以前的一个项目突然就把我派过去考察了，<strong>山东淄博潭溪山景区</strong>。地方是真的挺偏的，下了高铁，打了个出租一直开了将近两小时，其中山路开了近一个小时，还是盘山上去的。据了解来这的都是自驾的多，不然交通确实是不方便。</p>\n<p>在那边呆了差不多四天吧，他们吃粗粮的多。我就入乡随俗，跟着吃了几天的菜饼馒头，一天吃个两顿，还真管饱。</p>\n<p>家族企业自建的景区，项目确实是多，玻璃桥建得也很奇，十五根索支持，还是值得去一趟的，就是地方偏了点。有一天中午我从那边跟着人群走山路下来，八百多米啊，走得后来腿都打颤了。现在小腿还酸着呢。在这边我就不吐槽公司。</p>\n<p>回来路上开车师傅路边买了点油桃，才两块钱一斤，那边的水果确实是好吃点，跟气候环境关系很大吧。看看他们那边居民生活也挺自在的，景点工作人员早上七点集合一起去山上上班，平时没什么人没什么事就坐在那玩玩手机睡睡觉，等到下午五点就下班回去吃饭了。</p>\n<p>回来的火车不知道因为什么事还晚点了半小时左右，我是中转去济南西再到上海的，还好给自己留的时间够长，不然又得要费一番劲了。回到上海晚上八点多，回到住的地方晚上十点多，喝了点稀饭吃了两个家里带的粽子，澡就第二天洗了，弄弄就睡了。</p>\n<p>回来公司还有一堆事。</p>\n<h2 id=\"搬搬搬\"><a href=\"#搬搬搬\" class=\"headerlink\" title=\"搬搬搬\"></a>搬搬搬</h2><p>回头再来说说搬家这个事。</p>\n<p>其它东西倒还好，搬的地方也不是很远，还是就那个缸是真的不好弄。思来想去还是叫了辆依维柯，一趟省事，六七十倒也不贵。</p>\n<p>周末大雨啊，必是一番雨淋淋。之前一直是直接用的投影，没用上显示器，这下那边房间虽然小但是有桌子，显示器也有地方可以放了，刚好家里有个闲置的显示器，这不得要叫我姐给我寄过来，顺丰21，我最喜欢的数字。家里电脑配置都是七八年前的了，看年底的时候要不要把这边的电脑给他们带回去，自己再重新配一台，要努力赚钱攒钱咯。</p>\n<p>这么一搬，房租肯定是上去了，不过还好，还能接受吧。独自在外无人关怀，也不知道这样还要再过上几年啊。</p>\n<hr>\n<p>最近发现一个很好听的声音，小C英乐，学英语又有动力了！</p>\n","excerpt":"","more":"<blockquote>\n<p>送走了愉快的五月，就来了令人焦躁不已的六月。</p>\n</blockquote>\n<p>不知道是不是温度高了天气热了，总是在这样的季节使得焦躁浑身难受然后发生各种事情。</p>\n<hr>\n<h2 id=\"租房\"><a href=\"#租房\" class=\"headerlink\" title=\"租房\"></a>租房</h2><p>在外漂没有自己的房子真的是很难受，换工作不在附近得搬，房东不续租说搬也就得搬。</p>\n<p>住的地是三室户，这不马上就到期了，一室友不续租了跟女朋友住去结果导致空一间房，找不到人接盘，房东也就不跟我们续租了。也罢，老房子什么设施都是坏的，是得要对自己好一点了，搬吧，那就找房子吧。</p>\n<p>找房也还算顺利，虽然是通过中介的，多付了好几千中介费，这也算是找了个新住处，无缝对接。这房子也是个三室，不过面积要稍微大点，环境也好一点，出门就是欧尚超市不远还有个生活广场。原来住的三小伙要搬去浦东刚好也要到期了，房子是真的贵，感觉还合适那就快刀斩乱麻，直接签了得。</p>\n<p>过几天得收拾东西准备搬了，其它的倒是还好，就我那个大鱼缸有点费事，也是我要搬之所以头疼的事。说到还是个三室，那还是要准备拉一个人来的，刚好有个新同事过来，先住着，后面就再说吧。也不知道搬过去还能住多久，沪漂什么时候是个头。事情真多，头疼。</p>\n<h2 id=\"淄博\"><a href=\"#淄博\" class=\"headerlink\" title=\"淄博\"></a>淄博</h2><p>公司以前的一个项目突然就把我派过去考察了，<strong>山东淄博潭溪山景区</strong>。地方是真的挺偏的，下了高铁，打了个出租一直开了将近两小时，其中山路开了近一个小时，还是盘山上去的。据了解来这的都是自驾的多，不然交通确实是不方便。</p>\n<p>在那边呆了差不多四天吧，他们吃粗粮的多。我就入乡随俗，跟着吃了几天的菜饼馒头，一天吃个两顿，还真管饱。</p>\n<p>家族企业自建的景区，项目确实是多，玻璃桥建得也很奇，十五根索支持，还是值得去一趟的，就是地方偏了点。有一天中午我从那边跟着人群走山路下来，八百多米啊，走得后来腿都打颤了。现在小腿还酸着呢。在这边我就不吐槽公司。</p>\n<p>回来路上开车师傅路边买了点油桃，才两块钱一斤，那边的水果确实是好吃点，跟气候环境关系很大吧。看看他们那边居民生活也挺自在的，景点工作人员早上七点集合一起去山上上班，平时没什么人没什么事就坐在那玩玩手机睡睡觉，等到下午五点就下班回去吃饭了。</p>\n<p>回来的火车不知道因为什么事还晚点了半小时左右，我是中转去济南西再到上海的，还好给自己留的时间够长，不然又得要费一番劲了。回到上海晚上八点多，回到住的地方晚上十点多，喝了点稀饭吃了两个家里带的粽子，澡就第二天洗了，弄弄就睡了。</p>\n<p>回来公司还有一堆事。</p>\n<h2 id=\"搬搬搬\"><a href=\"#搬搬搬\" class=\"headerlink\" title=\"搬搬搬\"></a>搬搬搬</h2><p>回头再来说说搬家这个事。</p>\n<p>其它东西倒还好，搬的地方也不是很远，还是就那个缸是真的不好弄。思来想去还是叫了辆依维柯，一趟省事，六七十倒也不贵。</p>\n<p>周末大雨啊，必是一番雨淋淋。之前一直是直接用的投影，没用上显示器，这下那边房间虽然小但是有桌子，显示器也有地方可以放了，刚好家里有个闲置的显示器，这不得要叫我姐给我寄过来，顺丰21，我最喜欢的数字。家里电脑配置都是七八年前的了，看年底的时候要不要把这边的电脑给他们带回去，自己再重新配一台，要努力赚钱攒钱咯。</p>\n<p>这么一搬，房租肯定是上去了，不过还好，还能接受吧。独自在外无人关怀，也不知道这样还要再过上几年啊。</p>\n<hr>\n<p>最近发现一个很好听的声音，小C英乐，学英语又有动力了！</p>\n"},{"title":"Java中的数组拷贝以及对象Bean拷贝","date":"2018-08-24T06:12:26.000Z","_content":"\n## 数组拷贝方式\n直接先贴出测试代码：\n\n**Student ：**\n```\npackage com.tonglei.test;\n\n/**\n * 学生实体测试类\n * \n * @author ffj\n *\n */\npublic class Student {\n\n    private int age;\n    private int height;\n    private String sex;\n\n    public Student(int age, int height, String sex) {\n        this.age = age;\n        this.height = height;\n        this.sex = sex;\n    }\n\n    // 省略set、get方法\n\n    @Override\n    public String toString() {\n\n        return \"Student :[\" + this.age + \" ,\" + this.height + \" ,\" + this.sex + \"]\";\n    }\n}\n\n```\n\n**运行测试 ：**\n```\npublic static void main(String[] args) {\n\n        Student[] stu = new Student[3];\n        stu[0] = new Student(11, 110, \"男\");\n        stu[1] = new Student(12, 120, \"女\");\n        stu[2] = new Student(13, 130, \"嬲\");\n        System.out.println(\"stu length :\" + stu.length);\n        System.out.println(\"stu :\" + Arrays.toString(stu));\n        System.out.println(\"stu address :\" + stu);\n\n        System.out.println(\"<------------------------------------->\");\n\n        // Arrays.copyOf 原数组 新数组长度\n        Student[] arrayCopyStu = Arrays.copyOf(stu, stu.length + 1);\n        arrayCopyStu[stu.length] = new Student(14, 140, \"奻\");\n        System.out.println(\"arrayCopyStu length :\" + arrayCopyStu.length);\n        System.out.println(\"arrayCopyStu :\" + Arrays.toString(arrayCopyStu));\n        System.out.println(\"arrayCopyStu address :\" + arrayCopyStu);\n\n        System.out.println(\"<------------------------------------->\");\n\n        // System.arraycopy 原数组 原数组拷贝起始地址 目标数组 目标数组拷贝起始地址 拷贝长度\n        Student[] systemCopyStu = new Student[4];\n        System.arraycopy(stu, 0, systemCopyStu, 0, stu.length);\n        System.out.println(\"systemCopyStu length :\" + systemCopyStu.length);\n        System.out.println(\"systemCopyStu :\" + Arrays.toString(systemCopyStu));\n        System.out.println(\"systemCopyStu address :\" + systemCopyStu);\n\n        System.out.println(\"<------------------------------------->\");\n        System.out.println(\"<---------改变了原数组第一个对象的age------->\");\n        System.out.println(\"<------------------------------------->\");\n\n        // 改变原数组的数据\n        stu[0].setAge(99);\n        System.out.println(\"stu :\" + Arrays.toString(stu));\n        System.out.println(\"arrayCopyStu :\" + Arrays.toString(arrayCopyStu));\n        System.out.println(\"systemCopyStu :\" + Arrays.toString(systemCopyStu));\n\n        /**\n         * 总结：Arrays.copyOf 和 System.arraycopy 都可将结果生成一个新数组，\n         * 不过两者的区别在于，Arrays.copyOf()不仅仅只是拷贝数组中的元素，在拷贝元素时，会创建一个新的数组对象。而System.arrayCopy只拷贝已经存在数组元素。\n         * Arrays.copyOf()的源码中可知其底层还是调用了System.arrayCopyOf()方法\n         * 当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址\n         */\n    }\n\n```\n\n**测试运行结果 ：**\n```\nstu length :3\nstu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]\nstu address :[Lcom.tonglei.test.Student;@70dea4e\n<------------------------------------->\narrayCopyStu length :4\narrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\narrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05\n<------------------------------------->\nsystemCopyStu length :4\nsystemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\nsystemCopyStu address :[Lcom.tonglei.test.Student;@33909752\n<------------------------------------->\n<---------改变了原数组第一个对象的age------->\n<------------------------------------->\nstu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]\narrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\nsystemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\n```\n\n### Arrays.copyOf\n`Arrays.copyOf`方法返回一个新数组，不仅仅只是拷贝原数组中的元素会创建一个新的数组对象\n\n**上述测试结果 ：**\n```\n<------------------------------------->\narrayCopyStu length :4\narrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\narrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05\n<------------------------------------->\n```\n可以看出，copy原数组中元素并扩容了一长度，同时`arrayCopyStu[stu.length] = new Student(14, 140, \"奻\");`对新增元素赋值，从而打印出的便是上述内容。\n\n### System.arraycopy\n`System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`方法只拷贝已经存在数组元素，参数依次为原数组、原数组拷贝起始地址、目标数组、目标数组拷贝起始地址、拷贝长度。\n\n**上述测试结果 ：**\n```\n<------------------------------------->\nsystemCopyStu length :4\nsystemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\nsystemCopyStu address :[Lcom.tonglei.test.Student;@33909752\n<------------------------------------->\n```\n可见，新数组只从原数组中拷贝了存在的指定个数元素并可以指定拷贝到目标数组中。\n从`Arrays.copyOf()`的源码中可知其底层还是调用了`System.arrayCopyOf()`方法。\n\n### 进而探究\n两种均可对数组进行copy，但是`Arrays.copyOf()`和`System.arrayCopyOf()`两种方法所copy生成的新的数组对象中的元素对象到底是新的还是依旧指向原先的呢？**来一探究竟！**\n\n然而细心的同学已经心领神会..测试代码早早贴在了上面！\n```\nSystem.out.println(\"<------------------------------------->\");\nSystem.out.println(\"<---------改变了原数组第一个对象的age------->\");\nSystem.out.println(\"<------------------------------------->\");\n\n// 改变原数组的数据\nstu[0].setAge(99);\nSystem.out.println(\"stu :\" + Arrays.toString(stu));\nSystem.out.println(\"arrayCopyStu :\" + Arrays.toString(arrayCopyStu));\nSystem.out.println(\"systemCopyStu :\" + Arrays.toString(systemCopyStu));\n```\n这段代码我改变了原数组中第一个stu对象元素中的age属性值，我将其改为了99。\n\n**结果显示为 ：**\n```\n<------------------------------------->\n<---------改变了原数组第一个对象的age------->\n<------------------------------------->\nstu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]\narrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\nsystemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\n```\n显而易见了，不管是原数组还是两个copy的数组，其值均由原先的11变成了99。\n\n***总结：当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址。***\n\n## 对象拷贝方式\n测试类还是上面的`Student`，只不过我又新增了一个`Teacher`类来方便测试，其结构与`Student`一致。\n\n**Teacher :**\n```\npackage com.tonglei.test;\n\n/**\n * 教师实体测试类\n * \n * @author ffj\n *\n */\npublic class Teacher {\n\n    private int age;\n    private int height;\n    private String sex;\n\n    public Teacher() {\n    }\n\n    public Teacher(int age, int height, String sex) {\n        this.age = age;\n        this.height = height;\n        this.sex = sex;\n    }\n\n    // 省略了set、get方法\n\n    @Override\n    public String toString() {\n\n        return \"Teacher :[\" + this.age + \" ,\" + this.height + \" ,\" + this.sex + \"]\";\n    }\n}\n```\n\n**测试的初始代码 ：**\n```\nStudent stu = new Student(18, 180, \"男\");\nTeacher tea = new Teacher();\n```\n\n### SpringBeanUtils\n`BeanUtils.copyProperties(Object source, Object target) `该方法为spring中方法，故需要导入相应jar包。参数依次为：源数组、目标数组。（方法间参数有差异，需注意！）\n\n**测试代码 ：**\n```\nBeanUtils.copyProperties(stu, tea);\nSystem.out.println(tea);\n```\n在运行测试之前，我先将原先`Teacher`中的`age`字段属性类型稍稍修改了下。改为了`private String age`，结果为`Could not copy properties from source to target; nested exception is java.lang.IllegalArgumentException`，抛了个异常错误。而后我将其类型改回，输出`Teacher :[18 ,180 ,男]`。**故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错**\n\n### commonsBeanUtils\n该包下有两个copy方法：`BeanUtils.copyProperties(Object dest, Object orig)`和`PropertyUtils.copyProperties(Object dest, Object orig)`，同样使用其方法前需要导入对应`org.apache.commons`jar包。\n\n#### BeanUtils.copyProperties\n`BeanUtils.copyProperties(Object dest, Object orig)`其中参数分别为：目标数组、源数组。（对了，跟spring中方法参数顺序不一样）\n\n**测试代码 ：**\n```\nSystem.out.println(stu);\norg.apache.commons.beanutils.BeanUtils.copyProperties(tea, stu);\nSystem.out.println(tea);\n```\n还是老步骤：在运行测试之前，我先将原先`Teacher`中的`age`字段属性类型稍稍修改了下。改为了`private String age`，结果显示为：\n```\nStudent :[18 ,180 ,男]\nTeacher :[18 ,180 ,男]\n```\n我再将`Teacher`中的`sex`字段改为了`private int sex`，结果显示为：\n```\nStudent :[18 ,180 ,男]\nTeacher :[18 ,180 ,0]\n```\n**由此可知：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型不一致则会强转该值，若是强转不了就为初始值**\n\n#### PropertyUtils.copyProperties\n`PropertyUtils.copyProperties(Object dest, Object orig)`其中参数分别为：目标数组、源数组。\n\n**测试代码 ：**\n```\nSystem.out.println(stu);\nPropertyUtils.copyProperties(tea, stu);\nSystem.out.println(tea);\n```\n一样，在运行测试之前，我先将原先`Teacher`中的`age`字段属性类型稍稍修改了下。改为了`private String age`，结果显示为：`Cannot invoke com.tonglei.test.Teacher.setAge on bean class 'class com.tonglei.test.Teacher' - argument type mismatch - had objects of type \"java.lang.Integer\" but expected signature \"java.lang.String\"`，报错抛出类型不匹配异常信息，再将类型改回，输出：\n```\nStudent :[18 ,180 ,男]\nTeacher :[18 ,180 ,男]\n```\n**故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错（与SpringBeanUtils差不多不过报错信息更为详细，纯粹这次简单测试个人体会）**\n\n## 参考博文\n- [关于Java 拷贝数组方法 Arrays.copyOf() 是地址传递还是值传递](https://blog.csdn.net/qq_27093465/article/details/54970538)\n- [Java对象拷贝(BeanUtil.copyProperties 方法)](https://blog.csdn.net/weixin_38399962/article/details/79664598)\n- [Java开发中beancopy比较](https://www.cnblogs.com/fanguangdexiaoyuer/p/8358720.html)\n- [Java对象间属性值的复制-Spring的BeanUtil](https://blog.csdn.net/zsx157326/article/details/77693220)\n\n---\n具体方法具体场景各自选择。 END.","source":"_posts/arrcopy-beancopy.md","raw":"---\ntitle: Java中的数组拷贝以及对象Bean拷贝\ndate: 2018-8-24 14:12:26\ncategories: [开发,总结]\ntags: [Java]\n---\n\n## 数组拷贝方式\n直接先贴出测试代码：\n\n**Student ：**\n```\npackage com.tonglei.test;\n\n/**\n * 学生实体测试类\n * \n * @author ffj\n *\n */\npublic class Student {\n\n    private int age;\n    private int height;\n    private String sex;\n\n    public Student(int age, int height, String sex) {\n        this.age = age;\n        this.height = height;\n        this.sex = sex;\n    }\n\n    // 省略set、get方法\n\n    @Override\n    public String toString() {\n\n        return \"Student :[\" + this.age + \" ,\" + this.height + \" ,\" + this.sex + \"]\";\n    }\n}\n\n```\n\n**运行测试 ：**\n```\npublic static void main(String[] args) {\n\n        Student[] stu = new Student[3];\n        stu[0] = new Student(11, 110, \"男\");\n        stu[1] = new Student(12, 120, \"女\");\n        stu[2] = new Student(13, 130, \"嬲\");\n        System.out.println(\"stu length :\" + stu.length);\n        System.out.println(\"stu :\" + Arrays.toString(stu));\n        System.out.println(\"stu address :\" + stu);\n\n        System.out.println(\"<------------------------------------->\");\n\n        // Arrays.copyOf 原数组 新数组长度\n        Student[] arrayCopyStu = Arrays.copyOf(stu, stu.length + 1);\n        arrayCopyStu[stu.length] = new Student(14, 140, \"奻\");\n        System.out.println(\"arrayCopyStu length :\" + arrayCopyStu.length);\n        System.out.println(\"arrayCopyStu :\" + Arrays.toString(arrayCopyStu));\n        System.out.println(\"arrayCopyStu address :\" + arrayCopyStu);\n\n        System.out.println(\"<------------------------------------->\");\n\n        // System.arraycopy 原数组 原数组拷贝起始地址 目标数组 目标数组拷贝起始地址 拷贝长度\n        Student[] systemCopyStu = new Student[4];\n        System.arraycopy(stu, 0, systemCopyStu, 0, stu.length);\n        System.out.println(\"systemCopyStu length :\" + systemCopyStu.length);\n        System.out.println(\"systemCopyStu :\" + Arrays.toString(systemCopyStu));\n        System.out.println(\"systemCopyStu address :\" + systemCopyStu);\n\n        System.out.println(\"<------------------------------------->\");\n        System.out.println(\"<---------改变了原数组第一个对象的age------->\");\n        System.out.println(\"<------------------------------------->\");\n\n        // 改变原数组的数据\n        stu[0].setAge(99);\n        System.out.println(\"stu :\" + Arrays.toString(stu));\n        System.out.println(\"arrayCopyStu :\" + Arrays.toString(arrayCopyStu));\n        System.out.println(\"systemCopyStu :\" + Arrays.toString(systemCopyStu));\n\n        /**\n         * 总结：Arrays.copyOf 和 System.arraycopy 都可将结果生成一个新数组，\n         * 不过两者的区别在于，Arrays.copyOf()不仅仅只是拷贝数组中的元素，在拷贝元素时，会创建一个新的数组对象。而System.arrayCopy只拷贝已经存在数组元素。\n         * Arrays.copyOf()的源码中可知其底层还是调用了System.arrayCopyOf()方法\n         * 当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址\n         */\n    }\n\n```\n\n**测试运行结果 ：**\n```\nstu length :3\nstu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]\nstu address :[Lcom.tonglei.test.Student;@70dea4e\n<------------------------------------->\narrayCopyStu length :4\narrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\narrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05\n<------------------------------------->\nsystemCopyStu length :4\nsystemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\nsystemCopyStu address :[Lcom.tonglei.test.Student;@33909752\n<------------------------------------->\n<---------改变了原数组第一个对象的age------->\n<------------------------------------->\nstu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]\narrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\nsystemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\n```\n\n### Arrays.copyOf\n`Arrays.copyOf`方法返回一个新数组，不仅仅只是拷贝原数组中的元素会创建一个新的数组对象\n\n**上述测试结果 ：**\n```\n<------------------------------------->\narrayCopyStu length :4\narrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\narrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05\n<------------------------------------->\n```\n可以看出，copy原数组中元素并扩容了一长度，同时`arrayCopyStu[stu.length] = new Student(14, 140, \"奻\");`对新增元素赋值，从而打印出的便是上述内容。\n\n### System.arraycopy\n`System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`方法只拷贝已经存在数组元素，参数依次为原数组、原数组拷贝起始地址、目标数组、目标数组拷贝起始地址、拷贝长度。\n\n**上述测试结果 ：**\n```\n<------------------------------------->\nsystemCopyStu length :4\nsystemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\nsystemCopyStu address :[Lcom.tonglei.test.Student;@33909752\n<------------------------------------->\n```\n可见，新数组只从原数组中拷贝了存在的指定个数元素并可以指定拷贝到目标数组中。\n从`Arrays.copyOf()`的源码中可知其底层还是调用了`System.arrayCopyOf()`方法。\n\n### 进而探究\n两种均可对数组进行copy，但是`Arrays.copyOf()`和`System.arrayCopyOf()`两种方法所copy生成的新的数组对象中的元素对象到底是新的还是依旧指向原先的呢？**来一探究竟！**\n\n然而细心的同学已经心领神会..测试代码早早贴在了上面！\n```\nSystem.out.println(\"<------------------------------------->\");\nSystem.out.println(\"<---------改变了原数组第一个对象的age------->\");\nSystem.out.println(\"<------------------------------------->\");\n\n// 改变原数组的数据\nstu[0].setAge(99);\nSystem.out.println(\"stu :\" + Arrays.toString(stu));\nSystem.out.println(\"arrayCopyStu :\" + Arrays.toString(arrayCopyStu));\nSystem.out.println(\"systemCopyStu :\" + Arrays.toString(systemCopyStu));\n```\n这段代码我改变了原数组中第一个stu对象元素中的age属性值，我将其改为了99。\n\n**结果显示为 ：**\n```\n<------------------------------------->\n<---------改变了原数组第一个对象的age------->\n<------------------------------------->\nstu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]\narrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]\nsystemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]\n```\n显而易见了，不管是原数组还是两个copy的数组，其值均由原先的11变成了99。\n\n***总结：当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址。***\n\n## 对象拷贝方式\n测试类还是上面的`Student`，只不过我又新增了一个`Teacher`类来方便测试，其结构与`Student`一致。\n\n**Teacher :**\n```\npackage com.tonglei.test;\n\n/**\n * 教师实体测试类\n * \n * @author ffj\n *\n */\npublic class Teacher {\n\n    private int age;\n    private int height;\n    private String sex;\n\n    public Teacher() {\n    }\n\n    public Teacher(int age, int height, String sex) {\n        this.age = age;\n        this.height = height;\n        this.sex = sex;\n    }\n\n    // 省略了set、get方法\n\n    @Override\n    public String toString() {\n\n        return \"Teacher :[\" + this.age + \" ,\" + this.height + \" ,\" + this.sex + \"]\";\n    }\n}\n```\n\n**测试的初始代码 ：**\n```\nStudent stu = new Student(18, 180, \"男\");\nTeacher tea = new Teacher();\n```\n\n### SpringBeanUtils\n`BeanUtils.copyProperties(Object source, Object target) `该方法为spring中方法，故需要导入相应jar包。参数依次为：源数组、目标数组。（方法间参数有差异，需注意！）\n\n**测试代码 ：**\n```\nBeanUtils.copyProperties(stu, tea);\nSystem.out.println(tea);\n```\n在运行测试之前，我先将原先`Teacher`中的`age`字段属性类型稍稍修改了下。改为了`private String age`，结果为`Could not copy properties from source to target; nested exception is java.lang.IllegalArgumentException`，抛了个异常错误。而后我将其类型改回，输出`Teacher :[18 ,180 ,男]`。**故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错**\n\n### commonsBeanUtils\n该包下有两个copy方法：`BeanUtils.copyProperties(Object dest, Object orig)`和`PropertyUtils.copyProperties(Object dest, Object orig)`，同样使用其方法前需要导入对应`org.apache.commons`jar包。\n\n#### BeanUtils.copyProperties\n`BeanUtils.copyProperties(Object dest, Object orig)`其中参数分别为：目标数组、源数组。（对了，跟spring中方法参数顺序不一样）\n\n**测试代码 ：**\n```\nSystem.out.println(stu);\norg.apache.commons.beanutils.BeanUtils.copyProperties(tea, stu);\nSystem.out.println(tea);\n```\n还是老步骤：在运行测试之前，我先将原先`Teacher`中的`age`字段属性类型稍稍修改了下。改为了`private String age`，结果显示为：\n```\nStudent :[18 ,180 ,男]\nTeacher :[18 ,180 ,男]\n```\n我再将`Teacher`中的`sex`字段改为了`private int sex`，结果显示为：\n```\nStudent :[18 ,180 ,男]\nTeacher :[18 ,180 ,0]\n```\n**由此可知：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型不一致则会强转该值，若是强转不了就为初始值**\n\n#### PropertyUtils.copyProperties\n`PropertyUtils.copyProperties(Object dest, Object orig)`其中参数分别为：目标数组、源数组。\n\n**测试代码 ：**\n```\nSystem.out.println(stu);\nPropertyUtils.copyProperties(tea, stu);\nSystem.out.println(tea);\n```\n一样，在运行测试之前，我先将原先`Teacher`中的`age`字段属性类型稍稍修改了下。改为了`private String age`，结果显示为：`Cannot invoke com.tonglei.test.Teacher.setAge on bean class 'class com.tonglei.test.Teacher' - argument type mismatch - had objects of type \"java.lang.Integer\" but expected signature \"java.lang.String\"`，报错抛出类型不匹配异常信息，再将类型改回，输出：\n```\nStudent :[18 ,180 ,男]\nTeacher :[18 ,180 ,男]\n```\n**故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错（与SpringBeanUtils差不多不过报错信息更为详细，纯粹这次简单测试个人体会）**\n\n## 参考博文\n- [关于Java 拷贝数组方法 Arrays.copyOf() 是地址传递还是值传递](https://blog.csdn.net/qq_27093465/article/details/54970538)\n- [Java对象拷贝(BeanUtil.copyProperties 方法)](https://blog.csdn.net/weixin_38399962/article/details/79664598)\n- [Java开发中beancopy比较](https://www.cnblogs.com/fanguangdexiaoyuer/p/8358720.html)\n- [Java对象间属性值的复制-Spring的BeanUtil](https://blog.csdn.net/zsx157326/article/details/77693220)\n\n---\n具体方法具体场景各自选择。 END.","slug":"arrcopy-beancopy","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh8001tk9i1ats75pl0","content":"<h2 id=\"数组拷贝方式\"><a href=\"#数组拷贝方式\" class=\"headerlink\" title=\"数组拷贝方式\"></a>数组拷贝方式</h2><p>直接先贴出测试代码：</p>\n<p><strong>Student ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.test;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 学生实体测试类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private int height;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Student(int age, int height, String sex) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.height = height;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略set、get方法</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &quot;Student :[&quot; + this.age + &quot; ,&quot; + this.height + &quot; ,&quot; + this.sex + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>运行测试 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Student[] stu = new Student[3];</span><br><span class=\"line\">        stu[0] = new Student(11, 110, &quot;男&quot;);</span><br><span class=\"line\">        stu[1] = new Student(12, 120, &quot;女&quot;);</span><br><span class=\"line\">        stu[2] = new Student(13, 130, &quot;嬲&quot;);</span><br><span class=\"line\">        System.out.println(&quot;stu length :&quot; + stu.length);</span><br><span class=\"line\">        System.out.println(&quot;stu :&quot; + Arrays.toString(stu));</span><br><span class=\"line\">        System.out.println(&quot;stu address :&quot; + stu);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Arrays.copyOf 原数组 新数组长度</span><br><span class=\"line\">        Student[] arrayCopyStu = Arrays.copyOf(stu, stu.length + 1);</span><br><span class=\"line\">        arrayCopyStu[stu.length] = new Student(14, 140, &quot;奻&quot;);</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu length :&quot; + arrayCopyStu.length);</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu :&quot; + Arrays.toString(arrayCopyStu));</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu address :&quot; + arrayCopyStu);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // System.arraycopy 原数组 原数组拷贝起始地址 目标数组 目标数组拷贝起始地址 拷贝长度</span><br><span class=\"line\">        Student[] systemCopyStu = new Student[4];</span><br><span class=\"line\">        System.arraycopy(stu, 0, systemCopyStu, 0, stu.length);</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu length :&quot; + systemCopyStu.length);</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu :&quot; + Arrays.toString(systemCopyStu));</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu address :&quot; + systemCopyStu);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\">        System.out.println(&quot;&lt;---------改变了原数组第一个对象的age-------&gt;&quot;);</span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 改变原数组的数据</span><br><span class=\"line\">        stu[0].setAge(99);</span><br><span class=\"line\">        System.out.println(&quot;stu :&quot; + Arrays.toString(stu));</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu :&quot; + Arrays.toString(arrayCopyStu));</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu :&quot; + Arrays.toString(systemCopyStu));</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 总结：Arrays.copyOf 和 System.arraycopy 都可将结果生成一个新数组，</span><br><span class=\"line\">         * 不过两者的区别在于，Arrays.copyOf()不仅仅只是拷贝数组中的元素，在拷贝元素时，会创建一个新的数组对象。而System.arrayCopy只拷贝已经存在数组元素。</span><br><span class=\"line\">         * Arrays.copyOf()的源码中可知其底层还是调用了System.arrayCopyOf()方法</span><br><span class=\"line\">         * 当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址</span><br><span class=\"line\">         */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>测试运行结果 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stu length :3</span><br><span class=\"line\">stu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]</span><br><span class=\"line\">stu address :[Lcom.tonglei.test.Student;@70dea4e</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">arrayCopyStu length :4</span><br><span class=\"line\">arrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">arrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">systemCopyStu length :4</span><br><span class=\"line\">systemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br><span class=\"line\">systemCopyStu address :[Lcom.tonglei.test.Student;@33909752</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">&lt;---------改变了原数组第一个对象的age-------&gt;</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">stu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]</span><br><span class=\"line\">arrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">systemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arrays-copyOf\"><a href=\"#Arrays-copyOf\" class=\"headerlink\" title=\"Arrays.copyOf\"></a>Arrays.copyOf</h3><p><code>Arrays.copyOf</code>方法返回一个新数组，不仅仅只是拷贝原数组中的元素会创建一个新的数组对象</p>\n<p><strong>上述测试结果 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">arrayCopyStu length :4</span><br><span class=\"line\">arrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">arrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br></pre></td></tr></table></figure>\n<p>可以看出，copy原数组中元素并扩容了一长度，同时<code>arrayCopyStu[stu.length] = new Student(14, 140, &quot;奻&quot;);</code>对新增元素赋值，从而打印出的便是上述内容。</p>\n<h3 id=\"System-arraycopy\"><a href=\"#System-arraycopy\" class=\"headerlink\" title=\"System.arraycopy\"></a>System.arraycopy</h3><p><code>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>方法只拷贝已经存在数组元素，参数依次为原数组、原数组拷贝起始地址、目标数组、目标数组拷贝起始地址、拷贝长度。</p>\n<p><strong>上述测试结果 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">systemCopyStu length :4</span><br><span class=\"line\">systemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br><span class=\"line\">systemCopyStu address :[Lcom.tonglei.test.Student;@33909752</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br></pre></td></tr></table></figure>\n<p>可见，新数组只从原数组中拷贝了存在的指定个数元素并可以指定拷贝到目标数组中。<br>从<code>Arrays.copyOf()</code>的源码中可知其底层还是调用了<code>System.arrayCopyOf()</code>方法。</p>\n<h3 id=\"进而探究\"><a href=\"#进而探究\" class=\"headerlink\" title=\"进而探究\"></a>进而探究</h3><p>两种均可对数组进行copy，但是<code>Arrays.copyOf()</code>和<code>System.arrayCopyOf()</code>两种方法所copy生成的新的数组对象中的元素对象到底是新的还是依旧指向原先的呢？<strong>来一探究竟！</strong></p>\n<p>然而细心的同学已经心领神会..测试代码早早贴在了上面！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\">System.out.println(&quot;&lt;---------改变了原数组第一个对象的age-------&gt;&quot;);</span><br><span class=\"line\">System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 改变原数组的数据</span><br><span class=\"line\">stu[0].setAge(99);</span><br><span class=\"line\">System.out.println(&quot;stu :&quot; + Arrays.toString(stu));</span><br><span class=\"line\">System.out.println(&quot;arrayCopyStu :&quot; + Arrays.toString(arrayCopyStu));</span><br><span class=\"line\">System.out.println(&quot;systemCopyStu :&quot; + Arrays.toString(systemCopyStu));</span><br></pre></td></tr></table></figure>\n<p>这段代码我改变了原数组中第一个stu对象元素中的age属性值，我将其改为了99。</p>\n<p><strong>结果显示为 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">&lt;---------改变了原数组第一个对象的age-------&gt;</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">stu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]</span><br><span class=\"line\">arrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">systemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br></pre></td></tr></table></figure>\n<p>显而易见了，不管是原数组还是两个copy的数组，其值均由原先的11变成了99。</p>\n<p><em><strong>总结：当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址。</strong></em></p>\n<h2 id=\"对象拷贝方式\"><a href=\"#对象拷贝方式\" class=\"headerlink\" title=\"对象拷贝方式\"></a>对象拷贝方式</h2><p>测试类还是上面的<code>Student</code>，只不过我又新增了一个<code>Teacher</code>类来方便测试，其结构与<code>Student</code>一致。</p>\n<p><strong>Teacher :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.test;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 教师实体测试类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Teacher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private int height;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Teacher() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Teacher(int age, int height, String sex) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.height = height;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略了set、get方法</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &quot;Teacher :[&quot; + this.age + &quot; ,&quot; + this.height + &quot; ,&quot; + this.sex + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试的初始代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student stu = new Student(18, 180, &quot;男&quot;);</span><br><span class=\"line\">Teacher tea = new Teacher();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SpringBeanUtils\"><a href=\"#SpringBeanUtils\" class=\"headerlink\" title=\"SpringBeanUtils\"></a>SpringBeanUtils</h3><p><code>BeanUtils.copyProperties(Object source, Object target) </code>该方法为spring中方法，故需要导入相应jar包。参数依次为：源数组、目标数组。（方法间参数有差异，需注意！）</p>\n<p><strong>测试代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeanUtils.copyProperties(stu, tea);</span><br><span class=\"line\">System.out.println(tea);</span><br></pre></td></tr></table></figure>\n<p>在运行测试之前，我先将原先<code>Teacher</code>中的<code>age</code>字段属性类型稍稍修改了下。改为了<code>private String age</code>，结果为<code>Could not copy properties from source to target; nested exception is java.lang.IllegalArgumentException</code>，抛了个异常错误。而后我将其类型改回，输出<code>Teacher :[18 ,180 ,男]</code>。<strong>故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错</strong></p>\n<h3 id=\"commonsBeanUtils\"><a href=\"#commonsBeanUtils\" class=\"headerlink\" title=\"commonsBeanUtils\"></a>commonsBeanUtils</h3><p>该包下有两个copy方法：<code>BeanUtils.copyProperties(Object dest, Object orig)</code>和<code>PropertyUtils.copyProperties(Object dest, Object orig)</code>，同样使用其方法前需要导入对应<code>org.apache.commons</code>jar包。</p>\n<h4 id=\"BeanUtils-copyProperties\"><a href=\"#BeanUtils-copyProperties\" class=\"headerlink\" title=\"BeanUtils.copyProperties\"></a>BeanUtils.copyProperties</h4><p><code>BeanUtils.copyProperties(Object dest, Object orig)</code>其中参数分别为：目标数组、源数组。（对了，跟spring中方法参数顺序不一样）</p>\n<p><strong>测试代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(stu);</span><br><span class=\"line\">org.apache.commons.beanutils.BeanUtils.copyProperties(tea, stu);</span><br><span class=\"line\">System.out.println(tea);</span><br></pre></td></tr></table></figure>\n<p>还是老步骤：在运行测试之前，我先将原先<code>Teacher</code>中的<code>age</code>字段属性类型稍稍修改了下。改为了<code>private String age</code>，结果显示为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student :[18 ,180 ,男]</span><br><span class=\"line\">Teacher :[18 ,180 ,男]</span><br></pre></td></tr></table></figure>\n<p>我再将<code>Teacher</code>中的<code>sex</code>字段改为了<code>private int sex</code>，结果显示为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student :[18 ,180 ,男]</span><br><span class=\"line\">Teacher :[18 ,180 ,0]</span><br></pre></td></tr></table></figure>\n<p><strong>由此可知：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型不一致则会强转该值，若是强转不了就为初始值</strong></p>\n<h4 id=\"PropertyUtils-copyProperties\"><a href=\"#PropertyUtils-copyProperties\" class=\"headerlink\" title=\"PropertyUtils.copyProperties\"></a>PropertyUtils.copyProperties</h4><p><code>PropertyUtils.copyProperties(Object dest, Object orig)</code>其中参数分别为：目标数组、源数组。</p>\n<p><strong>测试代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(stu);</span><br><span class=\"line\">PropertyUtils.copyProperties(tea, stu);</span><br><span class=\"line\">System.out.println(tea);</span><br></pre></td></tr></table></figure>\n<p>一样，在运行测试之前，我先将原先<code>Teacher</code>中的<code>age</code>字段属性类型稍稍修改了下。改为了<code>private String age</code>，结果显示为：<code>Cannot invoke com.tonglei.test.Teacher.setAge on bean class &#39;class com.tonglei.test.Teacher&#39; - argument type mismatch - had objects of type &quot;java.lang.Integer&quot; but expected signature &quot;java.lang.String&quot;</code>，报错抛出类型不匹配异常信息，再将类型改回，输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student :[18 ,180 ,男]</span><br><span class=\"line\">Teacher :[18 ,180 ,男]</span><br></pre></td></tr></table></figure>\n<p><strong>故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错（与SpringBeanUtils差不多不过报错信息更为详细，纯粹这次简单测试个人体会）</strong></p>\n<h2 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_27093465/article/details/54970538\">关于Java 拷贝数组方法 Arrays.copyOf() 是地址传递还是值传递</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38399962/article/details/79664598\">Java对象拷贝(BeanUtil.copyProperties 方法)</a></li>\n<li><a href=\"https://www.cnblogs.com/fanguangdexiaoyuer/p/8358720.html\">Java开发中beancopy比较</a></li>\n<li><a href=\"https://blog.csdn.net/zsx157326/article/details/77693220\">Java对象间属性值的复制-Spring的BeanUtil</a></li>\n</ul>\n<hr>\n<p>具体方法具体场景各自选择。 END.</p>\n","excerpt":"","more":"<h2 id=\"数组拷贝方式\"><a href=\"#数组拷贝方式\" class=\"headerlink\" title=\"数组拷贝方式\"></a>数组拷贝方式</h2><p>直接先贴出测试代码：</p>\n<p><strong>Student ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.test;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 学生实体测试类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Student &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private int height;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Student(int age, int height, String sex) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.height = height;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略set、get方法</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &quot;Student :[&quot; + this.age + &quot; ,&quot; + this.height + &quot; ,&quot; + this.sex + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>运行测试 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Student[] stu = new Student[3];</span><br><span class=\"line\">        stu[0] = new Student(11, 110, &quot;男&quot;);</span><br><span class=\"line\">        stu[1] = new Student(12, 120, &quot;女&quot;);</span><br><span class=\"line\">        stu[2] = new Student(13, 130, &quot;嬲&quot;);</span><br><span class=\"line\">        System.out.println(&quot;stu length :&quot; + stu.length);</span><br><span class=\"line\">        System.out.println(&quot;stu :&quot; + Arrays.toString(stu));</span><br><span class=\"line\">        System.out.println(&quot;stu address :&quot; + stu);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // Arrays.copyOf 原数组 新数组长度</span><br><span class=\"line\">        Student[] arrayCopyStu = Arrays.copyOf(stu, stu.length + 1);</span><br><span class=\"line\">        arrayCopyStu[stu.length] = new Student(14, 140, &quot;奻&quot;);</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu length :&quot; + arrayCopyStu.length);</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu :&quot; + Arrays.toString(arrayCopyStu));</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu address :&quot; + arrayCopyStu);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // System.arraycopy 原数组 原数组拷贝起始地址 目标数组 目标数组拷贝起始地址 拷贝长度</span><br><span class=\"line\">        Student[] systemCopyStu = new Student[4];</span><br><span class=\"line\">        System.arraycopy(stu, 0, systemCopyStu, 0, stu.length);</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu length :&quot; + systemCopyStu.length);</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu :&quot; + Arrays.toString(systemCopyStu));</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu address :&quot; + systemCopyStu);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\">        System.out.println(&quot;&lt;---------改变了原数组第一个对象的age-------&gt;&quot;);</span><br><span class=\"line\">        System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 改变原数组的数据</span><br><span class=\"line\">        stu[0].setAge(99);</span><br><span class=\"line\">        System.out.println(&quot;stu :&quot; + Arrays.toString(stu));</span><br><span class=\"line\">        System.out.println(&quot;arrayCopyStu :&quot; + Arrays.toString(arrayCopyStu));</span><br><span class=\"line\">        System.out.println(&quot;systemCopyStu :&quot; + Arrays.toString(systemCopyStu));</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 总结：Arrays.copyOf 和 System.arraycopy 都可将结果生成一个新数组，</span><br><span class=\"line\">         * 不过两者的区别在于，Arrays.copyOf()不仅仅只是拷贝数组中的元素，在拷贝元素时，会创建一个新的数组对象。而System.arrayCopy只拷贝已经存在数组元素。</span><br><span class=\"line\">         * Arrays.copyOf()的源码中可知其底层还是调用了System.arrayCopyOf()方法</span><br><span class=\"line\">         * 当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址</span><br><span class=\"line\">         */</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>测试运行结果 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stu length :3</span><br><span class=\"line\">stu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]</span><br><span class=\"line\">stu address :[Lcom.tonglei.test.Student;@70dea4e</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">arrayCopyStu length :4</span><br><span class=\"line\">arrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">arrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">systemCopyStu length :4</span><br><span class=\"line\">systemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br><span class=\"line\">systemCopyStu address :[Lcom.tonglei.test.Student;@33909752</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">&lt;---------改变了原数组第一个对象的age-------&gt;</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">stu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]</span><br><span class=\"line\">arrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">systemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Arrays-copyOf\"><a href=\"#Arrays-copyOf\" class=\"headerlink\" title=\"Arrays.copyOf\"></a>Arrays.copyOf</h3><p><code>Arrays.copyOf</code>方法返回一个新数组，不仅仅只是拷贝原数组中的元素会创建一个新的数组对象</p>\n<p><strong>上述测试结果 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">arrayCopyStu length :4</span><br><span class=\"line\">arrayCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">arrayCopyStu address :[Lcom.tonglei.test.Student;@5c647e05</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br></pre></td></tr></table></figure>\n<p>可以看出，copy原数组中元素并扩容了一长度，同时<code>arrayCopyStu[stu.length] = new Student(14, 140, &quot;奻&quot;);</code>对新增元素赋值，从而打印出的便是上述内容。</p>\n<h3 id=\"System-arraycopy\"><a href=\"#System-arraycopy\" class=\"headerlink\" title=\"System.arraycopy\"></a>System.arraycopy</h3><p><code>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>方法只拷贝已经存在数组元素，参数依次为原数组、原数组拷贝起始地址、目标数组、目标数组拷贝起始地址、拷贝长度。</p>\n<p><strong>上述测试结果 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">systemCopyStu length :4</span><br><span class=\"line\">systemCopyStu :[Student :[11 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br><span class=\"line\">systemCopyStu address :[Lcom.tonglei.test.Student;@33909752</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br></pre></td></tr></table></figure>\n<p>可见，新数组只从原数组中拷贝了存在的指定个数元素并可以指定拷贝到目标数组中。<br>从<code>Arrays.copyOf()</code>的源码中可知其底层还是调用了<code>System.arrayCopyOf()</code>方法。</p>\n<h3 id=\"进而探究\"><a href=\"#进而探究\" class=\"headerlink\" title=\"进而探究\"></a>进而探究</h3><p>两种均可对数组进行copy，但是<code>Arrays.copyOf()</code>和<code>System.arrayCopyOf()</code>两种方法所copy生成的新的数组对象中的元素对象到底是新的还是依旧指向原先的呢？<strong>来一探究竟！</strong></p>\n<p>然而细心的同学已经心领神会..测试代码早早贴在了上面！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\">System.out.println(&quot;&lt;---------改变了原数组第一个对象的age-------&gt;&quot;);</span><br><span class=\"line\">System.out.println(&quot;&lt;-------------------------------------&gt;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 改变原数组的数据</span><br><span class=\"line\">stu[0].setAge(99);</span><br><span class=\"line\">System.out.println(&quot;stu :&quot; + Arrays.toString(stu));</span><br><span class=\"line\">System.out.println(&quot;arrayCopyStu :&quot; + Arrays.toString(arrayCopyStu));</span><br><span class=\"line\">System.out.println(&quot;systemCopyStu :&quot; + Arrays.toString(systemCopyStu));</span><br></pre></td></tr></table></figure>\n<p>这段代码我改变了原数组中第一个stu对象元素中的age属性值，我将其改为了99。</p>\n<p><strong>结果显示为 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">&lt;---------改变了原数组第一个对象的age-------&gt;</span><br><span class=\"line\">&lt;-------------------------------------&gt;</span><br><span class=\"line\">stu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲]]</span><br><span class=\"line\">arrayCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], Student :[14 ,140 ,奻]]</span><br><span class=\"line\">systemCopyStu :[Student :[99 ,110 ,男], Student :[12 ,120 ,女], Student :[13 ,130 ,嬲], null]</span><br></pre></td></tr></table></figure>\n<p>显而易见了，不管是原数组还是两个copy的数组，其值均由原先的11变成了99。</p>\n<p><em><strong>总结：当修改了原数组中对象的属性时目标数组中也随之改变，故两者都是地址引用，其中元素指向的还是原数组的地址。</strong></em></p>\n<h2 id=\"对象拷贝方式\"><a href=\"#对象拷贝方式\" class=\"headerlink\" title=\"对象拷贝方式\"></a>对象拷贝方式</h2><p>测试类还是上面的<code>Student</code>，只不过我又新增了一个<code>Teacher</code>类来方便测试，其结构与<code>Student</code>一致。</p>\n<p><strong>Teacher :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.test;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 教师实体测试类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Teacher &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private int height;</span><br><span class=\"line\">    private String sex;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Teacher() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Teacher(int age, int height, String sex) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.height = height;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 省略了set、get方法</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String toString() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        return &quot;Teacher :[&quot; + this.age + &quot; ,&quot; + this.height + &quot; ,&quot; + this.sex + &quot;]&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试的初始代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student stu = new Student(18, 180, &quot;男&quot;);</span><br><span class=\"line\">Teacher tea = new Teacher();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SpringBeanUtils\"><a href=\"#SpringBeanUtils\" class=\"headerlink\" title=\"SpringBeanUtils\"></a>SpringBeanUtils</h3><p><code>BeanUtils.copyProperties(Object source, Object target) </code>该方法为spring中方法，故需要导入相应jar包。参数依次为：源数组、目标数组。（方法间参数有差异，需注意！）</p>\n<p><strong>测试代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BeanUtils.copyProperties(stu, tea);</span><br><span class=\"line\">System.out.println(tea);</span><br></pre></td></tr></table></figure>\n<p>在运行测试之前，我先将原先<code>Teacher</code>中的<code>age</code>字段属性类型稍稍修改了下。改为了<code>private String age</code>，结果为<code>Could not copy properties from source to target; nested exception is java.lang.IllegalArgumentException</code>，抛了个异常错误。而后我将其类型改回，输出<code>Teacher :[18 ,180 ,男]</code>。<strong>故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错</strong></p>\n<h3 id=\"commonsBeanUtils\"><a href=\"#commonsBeanUtils\" class=\"headerlink\" title=\"commonsBeanUtils\"></a>commonsBeanUtils</h3><p>该包下有两个copy方法：<code>BeanUtils.copyProperties(Object dest, Object orig)</code>和<code>PropertyUtils.copyProperties(Object dest, Object orig)</code>，同样使用其方法前需要导入对应<code>org.apache.commons</code>jar包。</p>\n<h4 id=\"BeanUtils-copyProperties\"><a href=\"#BeanUtils-copyProperties\" class=\"headerlink\" title=\"BeanUtils.copyProperties\"></a>BeanUtils.copyProperties</h4><p><code>BeanUtils.copyProperties(Object dest, Object orig)</code>其中参数分别为：目标数组、源数组。（对了，跟spring中方法参数顺序不一样）</p>\n<p><strong>测试代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(stu);</span><br><span class=\"line\">org.apache.commons.beanutils.BeanUtils.copyProperties(tea, stu);</span><br><span class=\"line\">System.out.println(tea);</span><br></pre></td></tr></table></figure>\n<p>还是老步骤：在运行测试之前，我先将原先<code>Teacher</code>中的<code>age</code>字段属性类型稍稍修改了下。改为了<code>private String age</code>，结果显示为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student :[18 ,180 ,男]</span><br><span class=\"line\">Teacher :[18 ,180 ,男]</span><br></pre></td></tr></table></figure>\n<p>我再将<code>Teacher</code>中的<code>sex</code>字段改为了<code>private int sex</code>，结果显示为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student :[18 ,180 ,男]</span><br><span class=\"line\">Teacher :[18 ,180 ,0]</span><br></pre></td></tr></table></figure>\n<p><strong>由此可知：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型不一致则会强转该值，若是强转不了就为初始值</strong></p>\n<h4 id=\"PropertyUtils-copyProperties\"><a href=\"#PropertyUtils-copyProperties\" class=\"headerlink\" title=\"PropertyUtils.copyProperties\"></a>PropertyUtils.copyProperties</h4><p><code>PropertyUtils.copyProperties(Object dest, Object orig)</code>其中参数分别为：目标数组、源数组。</p>\n<p><strong>测试代码 ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(stu);</span><br><span class=\"line\">PropertyUtils.copyProperties(tea, stu);</span><br><span class=\"line\">System.out.println(tea);</span><br></pre></td></tr></table></figure>\n<p>一样，在运行测试之前，我先将原先<code>Teacher</code>中的<code>age</code>字段属性类型稍稍修改了下。改为了<code>private String age</code>，结果显示为：<code>Cannot invoke com.tonglei.test.Teacher.setAge on bean class &#39;class com.tonglei.test.Teacher&#39; - argument type mismatch - had objects of type &quot;java.lang.Integer&quot; but expected signature &quot;java.lang.String&quot;</code>，报错抛出类型不匹配异常信息，再将类型改回，输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student :[18 ,180 ,男]</span><br><span class=\"line\">Teacher :[18 ,180 ,男]</span><br></pre></td></tr></table></figure>\n<p><strong>故：拷贝的目标数组与源数组中的元素对象其属性名称一样，类型就必须一致，否则会报错（与SpringBeanUtils差不多不过报错信息更为详细，纯粹这次简单测试个人体会）</strong></p>\n<h2 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_27093465/article/details/54970538\">关于Java 拷贝数组方法 Arrays.copyOf() 是地址传递还是值传递</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_38399962/article/details/79664598\">Java对象拷贝(BeanUtil.copyProperties 方法)</a></li>\n<li><a href=\"https://www.cnblogs.com/fanguangdexiaoyuer/p/8358720.html\">Java开发中beancopy比较</a></li>\n<li><a href=\"https://blog.csdn.net/zsx157326/article/details/77693220\">Java对象间属性值的复制-Spring的BeanUtil</a></li>\n</ul>\n<hr>\n<p>具体方法具体场景各自选择。 END.</p>\n"},{"title":"入秋九月（2020）","date":"2020-09-29T08:10:55.000Z","_content":"\n> 上海没有春秋，只有夏冬。上周五三十五，这周一二十五，抖擞。\n\n## 运动篇\n\n今年不是换了家公司么，一天来回出勤都得花两个小时在地铁上，时间肯定没那么充裕，好几天回来就想倒头睡了。\n\n前几天去浙江余姚跑了今年第一场半马，今年第一跑果然不争气，路上走了小一半路段，成绩不忍直视。不知道是不是受疫情影响，主办方感觉也没怎么用心，不过本来也就是市区自个儿组织办的，规模也不大，报名费也便宜，权当体验。环了一圈四明湖，路段是没有上次嘉善那么舒服，不过当天天气也是还不错，跑到后面右大腿韧带感觉快要拉伤了，跑不动那就环湖走呗。\n\n去年还报了场横店的半马，到现在都没有消息，今年肯定是黄了。\n\n公司附近的无人健身房终于开始营业了，下次找个时间去瞧瞧，还没去过无人健身房体验呢。刚开业看价格也不贵，挺适合像我这种不定期偶尔练练的。\n\n## 宠物篇\n\n我不是有一只 17 年就养着的北美鳄么，最近看原先买的缸对他来说有点偏小了而且他的食量也越来越大，现在都有 27 公分了。于是我就想着看随缘给转了，也好比被室友天天折磨（居然拿五粮液往里倒，五粮液不要钱啊）。挂闲鱼上了，很便宜的价格，差不多就是半卖半送的，当然很快就有买家联系我了。本来我标的就是仅自提，我也没寄过活物也怕麻烦。后来跟湖南买家聊着感觉还不错，买回去也是真的自己要养的，我就答应了看看能不能寄。结果就是，跑了附近所有的快递站都不给寄，顺丰啊德邦啊邮政啊全都不给寄。这交易就黄了，关键我还在网上已经买了两只麝香苗准备替代这只“狠王”……这下好了，旧的没去新的还来了，只能这样了，入坑就难爬出来咯。\n\n经过这次事件，我应该不会再卖了，“狠王”就此逃过一劫，也是与我缘分未尽。\n\n不住在自己的房子里就是这种各样的麻烦事，东西也不敢置办，想买点大点的玩意儿就是令人头疼，也不能随心所欲倒腾。\n\n## 游戏篇\n\n今天重新下了 Steam，听同事说的古墓经典还不错，就花了六十几买了个古墓 9，玩了一下午。跟着剧情一点点走，沉浸式体验，很过瘾。虽然是 13 年出的，画面还是比较细腻的，我这破电脑烂显示器看着也都很舒服，值得体验。年底准备置换电脑，顺带把家里用了十来年的电脑给换了，还得换手机，这一下又得万把块咯。玩游戏虽然费时间，但是能偶尔空闲的时候体验下精美游戏也是种享受，就是有瘾玩了停不下来。等换电脑就把荒野 2 体验下，好评如潮，国内近十年怕是都出不了这种游戏。\n\n---\n\n明天就是中秋加国庆了，可以回家好好休息几天，这一年一下子又要过去咯。","source":"_posts/autumn-september.md","raw":"---\ntitle: 入秋九月（2020）\ndate: 2020-09-29 16:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 上海没有春秋，只有夏冬。上周五三十五，这周一二十五，抖擞。\n\n## 运动篇\n\n今年不是换了家公司么，一天来回出勤都得花两个小时在地铁上，时间肯定没那么充裕，好几天回来就想倒头睡了。\n\n前几天去浙江余姚跑了今年第一场半马，今年第一跑果然不争气，路上走了小一半路段，成绩不忍直视。不知道是不是受疫情影响，主办方感觉也没怎么用心，不过本来也就是市区自个儿组织办的，规模也不大，报名费也便宜，权当体验。环了一圈四明湖，路段是没有上次嘉善那么舒服，不过当天天气也是还不错，跑到后面右大腿韧带感觉快要拉伤了，跑不动那就环湖走呗。\n\n去年还报了场横店的半马，到现在都没有消息，今年肯定是黄了。\n\n公司附近的无人健身房终于开始营业了，下次找个时间去瞧瞧，还没去过无人健身房体验呢。刚开业看价格也不贵，挺适合像我这种不定期偶尔练练的。\n\n## 宠物篇\n\n我不是有一只 17 年就养着的北美鳄么，最近看原先买的缸对他来说有点偏小了而且他的食量也越来越大，现在都有 27 公分了。于是我就想着看随缘给转了，也好比被室友天天折磨（居然拿五粮液往里倒，五粮液不要钱啊）。挂闲鱼上了，很便宜的价格，差不多就是半卖半送的，当然很快就有买家联系我了。本来我标的就是仅自提，我也没寄过活物也怕麻烦。后来跟湖南买家聊着感觉还不错，买回去也是真的自己要养的，我就答应了看看能不能寄。结果就是，跑了附近所有的快递站都不给寄，顺丰啊德邦啊邮政啊全都不给寄。这交易就黄了，关键我还在网上已经买了两只麝香苗准备替代这只“狠王”……这下好了，旧的没去新的还来了，只能这样了，入坑就难爬出来咯。\n\n经过这次事件，我应该不会再卖了，“狠王”就此逃过一劫，也是与我缘分未尽。\n\n不住在自己的房子里就是这种各样的麻烦事，东西也不敢置办，想买点大点的玩意儿就是令人头疼，也不能随心所欲倒腾。\n\n## 游戏篇\n\n今天重新下了 Steam，听同事说的古墓经典还不错，就花了六十几买了个古墓 9，玩了一下午。跟着剧情一点点走，沉浸式体验，很过瘾。虽然是 13 年出的，画面还是比较细腻的，我这破电脑烂显示器看着也都很舒服，值得体验。年底准备置换电脑，顺带把家里用了十来年的电脑给换了，还得换手机，这一下又得万把块咯。玩游戏虽然费时间，但是能偶尔空闲的时候体验下精美游戏也是种享受，就是有瘾玩了停不下来。等换电脑就把荒野 2 体验下，好评如潮，国内近十年怕是都出不了这种游戏。\n\n---\n\n明天就是中秋加国庆了，可以回家好好休息几天，这一年一下子又要过去咯。","slug":"autumn-september","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh8001xk9i1823h29ea","content":"<blockquote>\n<p>上海没有春秋，只有夏冬。上周五三十五，这周一二十五，抖擞。</p>\n</blockquote>\n<h2 id=\"运动篇\"><a href=\"#运动篇\" class=\"headerlink\" title=\"运动篇\"></a>运动篇</h2><p>今年不是换了家公司么，一天来回出勤都得花两个小时在地铁上，时间肯定没那么充裕，好几天回来就想倒头睡了。</p>\n<p>前几天去浙江余姚跑了今年第一场半马，今年第一跑果然不争气，路上走了小一半路段，成绩不忍直视。不知道是不是受疫情影响，主办方感觉也没怎么用心，不过本来也就是市区自个儿组织办的，规模也不大，报名费也便宜，权当体验。环了一圈四明湖，路段是没有上次嘉善那么舒服，不过当天天气也是还不错，跑到后面右大腿韧带感觉快要拉伤了，跑不动那就环湖走呗。</p>\n<p>去年还报了场横店的半马，到现在都没有消息，今年肯定是黄了。</p>\n<p>公司附近的无人健身房终于开始营业了，下次找个时间去瞧瞧，还没去过无人健身房体验呢。刚开业看价格也不贵，挺适合像我这种不定期偶尔练练的。</p>\n<h2 id=\"宠物篇\"><a href=\"#宠物篇\" class=\"headerlink\" title=\"宠物篇\"></a>宠物篇</h2><p>我不是有一只 17 年就养着的北美鳄么，最近看原先买的缸对他来说有点偏小了而且他的食量也越来越大，现在都有 27 公分了。于是我就想着看随缘给转了，也好比被室友天天折磨（居然拿五粮液往里倒，五粮液不要钱啊）。挂闲鱼上了，很便宜的价格，差不多就是半卖半送的，当然很快就有买家联系我了。本来我标的就是仅自提，我也没寄过活物也怕麻烦。后来跟湖南买家聊着感觉还不错，买回去也是真的自己要养的，我就答应了看看能不能寄。结果就是，跑了附近所有的快递站都不给寄，顺丰啊德邦啊邮政啊全都不给寄。这交易就黄了，关键我还在网上已经买了两只麝香苗准备替代这只“狠王”……这下好了，旧的没去新的还来了，只能这样了，入坑就难爬出来咯。</p>\n<p>经过这次事件，我应该不会再卖了，“狠王”就此逃过一劫，也是与我缘分未尽。</p>\n<p>不住在自己的房子里就是这种各样的麻烦事，东西也不敢置办，想买点大点的玩意儿就是令人头疼，也不能随心所欲倒腾。</p>\n<h2 id=\"游戏篇\"><a href=\"#游戏篇\" class=\"headerlink\" title=\"游戏篇\"></a>游戏篇</h2><p>今天重新下了 Steam，听同事说的古墓经典还不错，就花了六十几买了个古墓 9，玩了一下午。跟着剧情一点点走，沉浸式体验，很过瘾。虽然是 13 年出的，画面还是比较细腻的，我这破电脑烂显示器看着也都很舒服，值得体验。年底准备置换电脑，顺带把家里用了十来年的电脑给换了，还得换手机，这一下又得万把块咯。玩游戏虽然费时间，但是能偶尔空闲的时候体验下精美游戏也是种享受，就是有瘾玩了停不下来。等换电脑就把荒野 2 体验下，好评如潮，国内近十年怕是都出不了这种游戏。</p>\n<hr>\n<p>明天就是中秋加国庆了，可以回家好好休息几天，这一年一下子又要过去咯。</p>\n","excerpt":"","more":"<blockquote>\n<p>上海没有春秋，只有夏冬。上周五三十五，这周一二十五，抖擞。</p>\n</blockquote>\n<h2 id=\"运动篇\"><a href=\"#运动篇\" class=\"headerlink\" title=\"运动篇\"></a>运动篇</h2><p>今年不是换了家公司么，一天来回出勤都得花两个小时在地铁上，时间肯定没那么充裕，好几天回来就想倒头睡了。</p>\n<p>前几天去浙江余姚跑了今年第一场半马，今年第一跑果然不争气，路上走了小一半路段，成绩不忍直视。不知道是不是受疫情影响，主办方感觉也没怎么用心，不过本来也就是市区自个儿组织办的，规模也不大，报名费也便宜，权当体验。环了一圈四明湖，路段是没有上次嘉善那么舒服，不过当天天气也是还不错，跑到后面右大腿韧带感觉快要拉伤了，跑不动那就环湖走呗。</p>\n<p>去年还报了场横店的半马，到现在都没有消息，今年肯定是黄了。</p>\n<p>公司附近的无人健身房终于开始营业了，下次找个时间去瞧瞧，还没去过无人健身房体验呢。刚开业看价格也不贵，挺适合像我这种不定期偶尔练练的。</p>\n<h2 id=\"宠物篇\"><a href=\"#宠物篇\" class=\"headerlink\" title=\"宠物篇\"></a>宠物篇</h2><p>我不是有一只 17 年就养着的北美鳄么，最近看原先买的缸对他来说有点偏小了而且他的食量也越来越大，现在都有 27 公分了。于是我就想着看随缘给转了，也好比被室友天天折磨（居然拿五粮液往里倒，五粮液不要钱啊）。挂闲鱼上了，很便宜的价格，差不多就是半卖半送的，当然很快就有买家联系我了。本来我标的就是仅自提，我也没寄过活物也怕麻烦。后来跟湖南买家聊着感觉还不错，买回去也是真的自己要养的，我就答应了看看能不能寄。结果就是，跑了附近所有的快递站都不给寄，顺丰啊德邦啊邮政啊全都不给寄。这交易就黄了，关键我还在网上已经买了两只麝香苗准备替代这只“狠王”……这下好了，旧的没去新的还来了，只能这样了，入坑就难爬出来咯。</p>\n<p>经过这次事件，我应该不会再卖了，“狠王”就此逃过一劫，也是与我缘分未尽。</p>\n<p>不住在自己的房子里就是这种各样的麻烦事，东西也不敢置办，想买点大点的玩意儿就是令人头疼，也不能随心所欲倒腾。</p>\n<h2 id=\"游戏篇\"><a href=\"#游戏篇\" class=\"headerlink\" title=\"游戏篇\"></a>游戏篇</h2><p>今天重新下了 Steam，听同事说的古墓经典还不错，就花了六十几买了个古墓 9，玩了一下午。跟着剧情一点点走，沉浸式体验，很过瘾。虽然是 13 年出的，画面还是比较细腻的，我这破电脑烂显示器看着也都很舒服，值得体验。年底准备置换电脑，顺带把家里用了十来年的电脑给换了，还得换手机，这一下又得万把块咯。玩游戏虽然费时间，但是能偶尔空闲的时候体验下精美游戏也是种享受，就是有瘾玩了停不下来。等换电脑就把荒野 2 体验下，好评如潮，国内近十年怕是都出不了这种游戏。</p>\n<hr>\n<p>明天就是中秋加国庆了，可以回家好好休息几天，这一年一下子又要过去咯。</p>\n"},{"title":"跳动一月（2019）","date":"2019-01-28T02:10:55.000Z","_content":"\n年前一个月，怎么能不跳动？\n\n各大厂爆料不断，裁员信号到处闪烁，人心惶惶。\n\n看到最多的一句话是：2019，保住饭碗！\n\n裁团风波此起彼伏，有赞年会公然宣布 996，便利蜂裁员新招层出不穷，新东方的释放自我，微信、陌陌的令人羡慕……\n\n据说 2018 是未来五年经济最好的一年，呜呼哀哉！\n\n这是一个危机四伏的时代，同样也是一个充满机遇的时代，市场的一番大清洗将会把未来带向何处呢？\n\n还是要保持自身的竞争力，技多不压身，仗技走天涯，学习思考不能断！\n\n另外，保持健康最重要！2019 还是要坚持锻炼，自律。\n\n---\n\n我是 2018 年 3 月底来到现在这家公司的，也快满一年了。\n\n很荣幸，被评为了 2018 年度最佳新人奖，也作为其中之一主持人主持了 2018 年的公司年会。\n\n想想距离之前在大学做主持，已经过去了 5 年了，真是好快啊！\n\n意料之中，抽奖无缘。一张来伊份购物卡，阳光普照。\n\n年会结束跟同事又聚了下，说了不少东西。赚钱真不容易啊！\n\n2019 年，毕业就快 2 年了，现在还是没有攒什么钱，对比别人真的感觉好失败。\n\n打工没什么激情，创业没那个勇气，好难啊。\n\n---\n\n前段时间去看了场直火帮的现场，都市的夜晚是年轻人的狂欢。\n\n白日里压抑的所有情绪都在夜晚爆发，肆意尖叫。\n\n现场还是很不一样的，音乐鼓点直击心脏，就像是个泵在血海中抽放。\n\n适当调节生活也是相当不错的。\n\n--- \n\n在这里我要说说《大江大河》这部电视剧，真的很不错！\n\n那几天一有空就看，晚上下班早早地就洗漱好躲被窝里看，本来被子就薄，还漏一个大口子，甚是好看甚是好看。\n\n短短的电视剧中反映了很多东西，我真的是喜欢这类的作品。\n\n例如：路遥《平凡的世界》，陈忠实《白鹿原》，余华《活着》、《兄弟》等作品。\n\n现在怕是出不了这类大作了，时代不同了。\n\n---\n\n再过几天就回家过春节了，说到过年也是不怎么提得起兴致啊。\n\n跟个国庆一样，回家呆一周就又得回来过上班日子了。\n\n“回家就跟回娘家一样”难怪我爸如是说道……\n\n谁想呢，我也不想啊，好难啊。\n\n长大了，好多事情就自然而然变了。\n\n小时候的过年总是伴着地上厚厚的积雪，一捆烟花棒，一盒火柴或是口袋里塞着个黑口打火机。\n\n不一样咯。\n\n---\n\n最后，一段《站在悬崖边的我》\n\n我站在悬崖边，视线慢慢下移\n只看见一片山，飘着那一层云\n都说居高思危，我却有点神往\n\n那是一张床垫，还是一张薄纸\n那下面是什么，是那汪洋大海\n还是坚硬的沙石，血肉模糊\n\n天色越来越暗，回去的路越来越糊\n我站在悬崖边，开始犹豫\n\n前方需要勇气，可能粉身碎骨\n后方道路平坦，也许一世平庸\n\n左右思索着，天却已经全黑了\n我伸手，看不清楚自己的手指\n一阵眩晕，脚下一滑，身体前倾\n\n我还没来得及惊呼\n眼睛就睁开了\n\n站在悬崖边的我","source":"_posts/beat-january.md","raw":"---\ntitle: 跳动一月（2019）\ndate: 2019-1-28 10:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n年前一个月，怎么能不跳动？\n\n各大厂爆料不断，裁员信号到处闪烁，人心惶惶。\n\n看到最多的一句话是：2019，保住饭碗！\n\n裁团风波此起彼伏，有赞年会公然宣布 996，便利蜂裁员新招层出不穷，新东方的释放自我，微信、陌陌的令人羡慕……\n\n据说 2018 是未来五年经济最好的一年，呜呼哀哉！\n\n这是一个危机四伏的时代，同样也是一个充满机遇的时代，市场的一番大清洗将会把未来带向何处呢？\n\n还是要保持自身的竞争力，技多不压身，仗技走天涯，学习思考不能断！\n\n另外，保持健康最重要！2019 还是要坚持锻炼，自律。\n\n---\n\n我是 2018 年 3 月底来到现在这家公司的，也快满一年了。\n\n很荣幸，被评为了 2018 年度最佳新人奖，也作为其中之一主持人主持了 2018 年的公司年会。\n\n想想距离之前在大学做主持，已经过去了 5 年了，真是好快啊！\n\n意料之中，抽奖无缘。一张来伊份购物卡，阳光普照。\n\n年会结束跟同事又聚了下，说了不少东西。赚钱真不容易啊！\n\n2019 年，毕业就快 2 年了，现在还是没有攒什么钱，对比别人真的感觉好失败。\n\n打工没什么激情，创业没那个勇气，好难啊。\n\n---\n\n前段时间去看了场直火帮的现场，都市的夜晚是年轻人的狂欢。\n\n白日里压抑的所有情绪都在夜晚爆发，肆意尖叫。\n\n现场还是很不一样的，音乐鼓点直击心脏，就像是个泵在血海中抽放。\n\n适当调节生活也是相当不错的。\n\n--- \n\n在这里我要说说《大江大河》这部电视剧，真的很不错！\n\n那几天一有空就看，晚上下班早早地就洗漱好躲被窝里看，本来被子就薄，还漏一个大口子，甚是好看甚是好看。\n\n短短的电视剧中反映了很多东西，我真的是喜欢这类的作品。\n\n例如：路遥《平凡的世界》，陈忠实《白鹿原》，余华《活着》、《兄弟》等作品。\n\n现在怕是出不了这类大作了，时代不同了。\n\n---\n\n再过几天就回家过春节了，说到过年也是不怎么提得起兴致啊。\n\n跟个国庆一样，回家呆一周就又得回来过上班日子了。\n\n“回家就跟回娘家一样”难怪我爸如是说道……\n\n谁想呢，我也不想啊，好难啊。\n\n长大了，好多事情就自然而然变了。\n\n小时候的过年总是伴着地上厚厚的积雪，一捆烟花棒，一盒火柴或是口袋里塞着个黑口打火机。\n\n不一样咯。\n\n---\n\n最后，一段《站在悬崖边的我》\n\n我站在悬崖边，视线慢慢下移\n只看见一片山，飘着那一层云\n都说居高思危，我却有点神往\n\n那是一张床垫，还是一张薄纸\n那下面是什么，是那汪洋大海\n还是坚硬的沙石，血肉模糊\n\n天色越来越暗，回去的路越来越糊\n我站在悬崖边，开始犹豫\n\n前方需要勇气，可能粉身碎骨\n后方道路平坦，也许一世平庸\n\n左右思索着，天却已经全黑了\n我伸手，看不清楚自己的手指\n一阵眩晕，脚下一滑，身体前倾\n\n我还没来得及惊呼\n眼睛就睁开了\n\n站在悬崖边的我","slug":"beat-january","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh80020k9i1c2ftdrok","content":"<p>年前一个月，怎么能不跳动？</p>\n<p>各大厂爆料不断，裁员信号到处闪烁，人心惶惶。</p>\n<p>看到最多的一句话是：2019，保住饭碗！</p>\n<p>裁团风波此起彼伏，有赞年会公然宣布 996，便利蜂裁员新招层出不穷，新东方的释放自我，微信、陌陌的令人羡慕……</p>\n<p>据说 2018 是未来五年经济最好的一年，呜呼哀哉！</p>\n<p>这是一个危机四伏的时代，同样也是一个充满机遇的时代，市场的一番大清洗将会把未来带向何处呢？</p>\n<p>还是要保持自身的竞争力，技多不压身，仗技走天涯，学习思考不能断！</p>\n<p>另外，保持健康最重要！2019 还是要坚持锻炼，自律。</p>\n<hr>\n<p>我是 2018 年 3 月底来到现在这家公司的，也快满一年了。</p>\n<p>很荣幸，被评为了 2018 年度最佳新人奖，也作为其中之一主持人主持了 2018 年的公司年会。</p>\n<p>想想距离之前在大学做主持，已经过去了 5 年了，真是好快啊！</p>\n<p>意料之中，抽奖无缘。一张来伊份购物卡，阳光普照。</p>\n<p>年会结束跟同事又聚了下，说了不少东西。赚钱真不容易啊！</p>\n<p>2019 年，毕业就快 2 年了，现在还是没有攒什么钱，对比别人真的感觉好失败。</p>\n<p>打工没什么激情，创业没那个勇气，好难啊。</p>\n<hr>\n<p>前段时间去看了场直火帮的现场，都市的夜晚是年轻人的狂欢。</p>\n<p>白日里压抑的所有情绪都在夜晚爆发，肆意尖叫。</p>\n<p>现场还是很不一样的，音乐鼓点直击心脏，就像是个泵在血海中抽放。</p>\n<p>适当调节生活也是相当不错的。</p>\n<hr>\n<p>在这里我要说说《大江大河》这部电视剧，真的很不错！</p>\n<p>那几天一有空就看，晚上下班早早地就洗漱好躲被窝里看，本来被子就薄，还漏一个大口子，甚是好看甚是好看。</p>\n<p>短短的电视剧中反映了很多东西，我真的是喜欢这类的作品。</p>\n<p>例如：路遥《平凡的世界》，陈忠实《白鹿原》，余华《活着》、《兄弟》等作品。</p>\n<p>现在怕是出不了这类大作了，时代不同了。</p>\n<hr>\n<p>再过几天就回家过春节了，说到过年也是不怎么提得起兴致啊。</p>\n<p>跟个国庆一样，回家呆一周就又得回来过上班日子了。</p>\n<p>“回家就跟回娘家一样”难怪我爸如是说道……</p>\n<p>谁想呢，我也不想啊，好难啊。</p>\n<p>长大了，好多事情就自然而然变了。</p>\n<p>小时候的过年总是伴着地上厚厚的积雪，一捆烟花棒，一盒火柴或是口袋里塞着个黑口打火机。</p>\n<p>不一样咯。</p>\n<hr>\n<p>最后，一段《站在悬崖边的我》</p>\n<p>我站在悬崖边，视线慢慢下移<br>只看见一片山，飘着那一层云<br>都说居高思危，我却有点神往</p>\n<p>那是一张床垫，还是一张薄纸<br>那下面是什么，是那汪洋大海<br>还是坚硬的沙石，血肉模糊</p>\n<p>天色越来越暗，回去的路越来越糊<br>我站在悬崖边，开始犹豫</p>\n<p>前方需要勇气，可能粉身碎骨<br>后方道路平坦，也许一世平庸</p>\n<p>左右思索着，天却已经全黑了<br>我伸手，看不清楚自己的手指<br>一阵眩晕，脚下一滑，身体前倾</p>\n<p>我还没来得及惊呼<br>眼睛就睁开了</p>\n<p>站在悬崖边的我</p>\n","excerpt":"","more":"<p>年前一个月，怎么能不跳动？</p>\n<p>各大厂爆料不断，裁员信号到处闪烁，人心惶惶。</p>\n<p>看到最多的一句话是：2019，保住饭碗！</p>\n<p>裁团风波此起彼伏，有赞年会公然宣布 996，便利蜂裁员新招层出不穷，新东方的释放自我，微信、陌陌的令人羡慕……</p>\n<p>据说 2018 是未来五年经济最好的一年，呜呼哀哉！</p>\n<p>这是一个危机四伏的时代，同样也是一个充满机遇的时代，市场的一番大清洗将会把未来带向何处呢？</p>\n<p>还是要保持自身的竞争力，技多不压身，仗技走天涯，学习思考不能断！</p>\n<p>另外，保持健康最重要！2019 还是要坚持锻炼，自律。</p>\n<hr>\n<p>我是 2018 年 3 月底来到现在这家公司的，也快满一年了。</p>\n<p>很荣幸，被评为了 2018 年度最佳新人奖，也作为其中之一主持人主持了 2018 年的公司年会。</p>\n<p>想想距离之前在大学做主持，已经过去了 5 年了，真是好快啊！</p>\n<p>意料之中，抽奖无缘。一张来伊份购物卡，阳光普照。</p>\n<p>年会结束跟同事又聚了下，说了不少东西。赚钱真不容易啊！</p>\n<p>2019 年，毕业就快 2 年了，现在还是没有攒什么钱，对比别人真的感觉好失败。</p>\n<p>打工没什么激情，创业没那个勇气，好难啊。</p>\n<hr>\n<p>前段时间去看了场直火帮的现场，都市的夜晚是年轻人的狂欢。</p>\n<p>白日里压抑的所有情绪都在夜晚爆发，肆意尖叫。</p>\n<p>现场还是很不一样的，音乐鼓点直击心脏，就像是个泵在血海中抽放。</p>\n<p>适当调节生活也是相当不错的。</p>\n<hr>\n<p>在这里我要说说《大江大河》这部电视剧，真的很不错！</p>\n<p>那几天一有空就看，晚上下班早早地就洗漱好躲被窝里看，本来被子就薄，还漏一个大口子，甚是好看甚是好看。</p>\n<p>短短的电视剧中反映了很多东西，我真的是喜欢这类的作品。</p>\n<p>例如：路遥《平凡的世界》，陈忠实《白鹿原》，余华《活着》、《兄弟》等作品。</p>\n<p>现在怕是出不了这类大作了，时代不同了。</p>\n<hr>\n<p>再过几天就回家过春节了，说到过年也是不怎么提得起兴致啊。</p>\n<p>跟个国庆一样，回家呆一周就又得回来过上班日子了。</p>\n<p>“回家就跟回娘家一样”难怪我爸如是说道……</p>\n<p>谁想呢，我也不想啊，好难啊。</p>\n<p>长大了，好多事情就自然而然变了。</p>\n<p>小时候的过年总是伴着地上厚厚的积雪，一捆烟花棒，一盒火柴或是口袋里塞着个黑口打火机。</p>\n<p>不一样咯。</p>\n<hr>\n<p>最后，一段《站在悬崖边的我》</p>\n<p>我站在悬崖边，视线慢慢下移<br>只看见一片山，飘着那一层云<br>都说居高思危，我却有点神往</p>\n<p>那是一张床垫，还是一张薄纸<br>那下面是什么，是那汪洋大海<br>还是坚硬的沙石，血肉模糊</p>\n<p>天色越来越暗，回去的路越来越糊<br>我站在悬崖边，开始犹豫</p>\n<p>前方需要勇气，可能粉身碎骨<br>后方道路平坦，也许一世平庸</p>\n<p>左右思索着，天却已经全黑了<br>我伸手，看不清楚自己的手指<br>一阵眩晕，脚下一滑，身体前倾</p>\n<p>我还没来得及惊呼<br>眼睛就睁开了</p>\n<p>站在悬崖边的我</p>\n"},{"title":"美好六月（2022）","date":"2022-06-30T13:10:55.000Z","_content":"\n六月很快也就要过去了。\n\n这一个月看似一切都在往好的方向前进，疫情得以控制，股市也得以触底反弹。就是在上海的人们还是不能在商场中堂食，除了这一点和常规做核酸和扫场所码进出以及口罩的佩戴，其他与之前基本无异。\n\n每周六一次全体核酸大筛查，72小时内的核酸证明才能进出公共场所。疫情的这几年总是反反复复，一波平息后就觉得终于可以不用去哪都戴口罩不用再捅鼻子捅嗓子了。但现实往往没过多久，它又拿着刀叉来人群中疯狂“索命”，隔三差五还带个兄弟。\n\n最近唐山的事件沸沸扬扬，当小纸船中的水蒸干之后，总会让火一烧而光。网络是把双刃剑，像这类事情若不是网络的传播，在早十几年前就像大海中滴入了一滴水，什么波浪都不会起。不过这种事情我相信还是有很多的，只是没有烧起来。\n\n最近去打了狂犬疫苗，被猫抓得实在太多，求个心安……由于现在附近只有一个医院可以打这个疫苗，去排队的时候真是惊呆了，原来每天有这么多人要打狂犬疫苗的。一共要打四针，第一次打两针，后面隔一星期打一针，再隔二星期打一针，一针八十块啊还不能走医保。医疗资源还是很匮乏的，尽管如今医疗水平上去了，医院数量也多了，但还是架不住好的医院太少了，专业的人太少了，生病的人，太多了。大城市尚且如此，小城市就更加困难了，医疗的未来还需要加速发展。\n\n上海最近连续几天都是零新增了，俄乌局面也开始缓和，一切都在变好。\n\n2022已经过去一半了。","source":"_posts/better-june.md","raw":"---\ntitle: 美好六月（2022）\ndate: 2022-06-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n六月很快也就要过去了。\n\n这一个月看似一切都在往好的方向前进，疫情得以控制，股市也得以触底反弹。就是在上海的人们还是不能在商场中堂食，除了这一点和常规做核酸和扫场所码进出以及口罩的佩戴，其他与之前基本无异。\n\n每周六一次全体核酸大筛查，72小时内的核酸证明才能进出公共场所。疫情的这几年总是反反复复，一波平息后就觉得终于可以不用去哪都戴口罩不用再捅鼻子捅嗓子了。但现实往往没过多久，它又拿着刀叉来人群中疯狂“索命”，隔三差五还带个兄弟。\n\n最近唐山的事件沸沸扬扬，当小纸船中的水蒸干之后，总会让火一烧而光。网络是把双刃剑，像这类事情若不是网络的传播，在早十几年前就像大海中滴入了一滴水，什么波浪都不会起。不过这种事情我相信还是有很多的，只是没有烧起来。\n\n最近去打了狂犬疫苗，被猫抓得实在太多，求个心安……由于现在附近只有一个医院可以打这个疫苗，去排队的时候真是惊呆了，原来每天有这么多人要打狂犬疫苗的。一共要打四针，第一次打两针，后面隔一星期打一针，再隔二星期打一针，一针八十块啊还不能走医保。医疗资源还是很匮乏的，尽管如今医疗水平上去了，医院数量也多了，但还是架不住好的医院太少了，专业的人太少了，生病的人，太多了。大城市尚且如此，小城市就更加困难了，医疗的未来还需要加速发展。\n\n上海最近连续几天都是零新增了，俄乌局面也开始缓和，一切都在变好。\n\n2022已经过去一半了。","slug":"better-june","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh90025k9i1elcwahfn","content":"<p>六月很快也就要过去了。</p>\n<p>这一个月看似一切都在往好的方向前进，疫情得以控制，股市也得以触底反弹。就是在上海的人们还是不能在商场中堂食，除了这一点和常规做核酸和扫场所码进出以及口罩的佩戴，其他与之前基本无异。</p>\n<p>每周六一次全体核酸大筛查，72小时内的核酸证明才能进出公共场所。疫情的这几年总是反反复复，一波平息后就觉得终于可以不用去哪都戴口罩不用再捅鼻子捅嗓子了。但现实往往没过多久，它又拿着刀叉来人群中疯狂“索命”，隔三差五还带个兄弟。</p>\n<p>最近唐山的事件沸沸扬扬，当小纸船中的水蒸干之后，总会让火一烧而光。网络是把双刃剑，像这类事情若不是网络的传播，在早十几年前就像大海中滴入了一滴水，什么波浪都不会起。不过这种事情我相信还是有很多的，只是没有烧起来。</p>\n<p>最近去打了狂犬疫苗，被猫抓得实在太多，求个心安……由于现在附近只有一个医院可以打这个疫苗，去排队的时候真是惊呆了，原来每天有这么多人要打狂犬疫苗的。一共要打四针，第一次打两针，后面隔一星期打一针，再隔二星期打一针，一针八十块啊还不能走医保。医疗资源还是很匮乏的，尽管如今医疗水平上去了，医院数量也多了，但还是架不住好的医院太少了，专业的人太少了，生病的人，太多了。大城市尚且如此，小城市就更加困难了，医疗的未来还需要加速发展。</p>\n<p>上海最近连续几天都是零新增了，俄乌局面也开始缓和，一切都在变好。</p>\n<p>2022已经过去一半了。</p>\n","excerpt":"","more":"<p>六月很快也就要过去了。</p>\n<p>这一个月看似一切都在往好的方向前进，疫情得以控制，股市也得以触底反弹。就是在上海的人们还是不能在商场中堂食，除了这一点和常规做核酸和扫场所码进出以及口罩的佩戴，其他与之前基本无异。</p>\n<p>每周六一次全体核酸大筛查，72小时内的核酸证明才能进出公共场所。疫情的这几年总是反反复复，一波平息后就觉得终于可以不用去哪都戴口罩不用再捅鼻子捅嗓子了。但现实往往没过多久，它又拿着刀叉来人群中疯狂“索命”，隔三差五还带个兄弟。</p>\n<p>最近唐山的事件沸沸扬扬，当小纸船中的水蒸干之后，总会让火一烧而光。网络是把双刃剑，像这类事情若不是网络的传播，在早十几年前就像大海中滴入了一滴水，什么波浪都不会起。不过这种事情我相信还是有很多的，只是没有烧起来。</p>\n<p>最近去打了狂犬疫苗，被猫抓得实在太多，求个心安……由于现在附近只有一个医院可以打这个疫苗，去排队的时候真是惊呆了，原来每天有这么多人要打狂犬疫苗的。一共要打四针，第一次打两针，后面隔一星期打一针，再隔二星期打一针，一针八十块啊还不能走医保。医疗资源还是很匮乏的，尽管如今医疗水平上去了，医院数量也多了，但还是架不住好的医院太少了，专业的人太少了，生病的人，太多了。大城市尚且如此，小城市就更加困难了，医疗的未来还需要加速发展。</p>\n<p>上海最近连续几天都是零新增了，俄乌局面也开始缓和，一切都在变好。</p>\n<p>2022已经过去一半了。</p>\n"},{"title":"二分搜索之搜索数组中目标元素的首尾下标","date":"2018-10-15T09:02:16.000Z","_content":"\n今天总结一下二分搜索。**假设这里的数组已经是升序排序好了的。**\n\n我们知道二分搜索的效率很高，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用 O(log n) 完成搜索任务。它的基本思想：将 n 个元素分成个数大致相同的两半，取 a[n/2] 与需要查找的目标值 x 作比较，如果 x=a[n/2] 则找到 x，算法运算终止。详情可跳转[百度百科](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95/6230633)。\n\n- 我们通常最基本的二分搜索是这样实现的(Java):\n```\n    /**\n     * 二分搜索\n     * \n     * @param arr\n     *            已升序排序数组\n     * @param key\n     *            目标查找值\n     * @return\n     */\n    public static int commonBinarySearch(int[] arr, int key) {\n        int low = 0;\n        int high = arr.length - 1;\n        int middle = 0; // 定义middle\n\n        if (key < arr[low] || key > arr[high] || low > high) {\n            return -1;\n        }\n\n        while (low <= high) {\n            middle = (low + high) / 2;\n            if (arr[middle] > key) {\n                // 比关键字大则关键字在左区域\n                high = middle - 1;\n            } else if (arr[middle] < key) {\n                // 比关键字小则关键字在右区域\n                low = middle + 1;\n            } else {\n                return middle;\n            }\n        }\n\n        return -1; // 未找到结果，返回-1\n    }\n```\n若是数组中存在搜索目标元素，则只要查找到任意一个便会返回该值；若是没有找到即返回 -1。\n\n- 来看下一种，只返回目标元素第一次出现的位置下标(伪代码):\n```\nl = -1; u = n\nwhile l+1 != u\n    m = (l + u) / 2\n    if x[m] < t\n        l = m\n    else\n        u = m\np = u\nif p >= n || x[p] != t\n    p = -1\n```\nn 为数组的长度，p 就是最终我们需要的下标。若是 while 循环出来的最终结果 `u >= n` （其实最大也只会等于 n）或者 `x[u] != t`（t 为我们的目标元素），那么也就是无结果，返回 -1。\n\n- 我们再来看最后一个 function(该方法参数不同使得结果可以返回元素第一个出现的下标或者最后一个下标，也是 Java):\n```\n    /**\n     * \n     * @param nums\n     *            已经升序排序好的数组\n     * @param target\n     *            搜索目标元素\n     * @param left\n     *            是否是查找第一个元素下标。true:查找目标元素第一个出现下标, false:查找目标元素最后一个出现下标\n     * @return\n     */\n    private int extremeInsertionIndex(int[] nums, int target, boolean left) {\n        int lo = 0;\n        int hi = nums.length;\n\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] > target || (left && target == nums[mid])) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return lo;\n    }\n```\n目标元素出现的第一个下标：`int leftIdx = extremeInsertionIndex(nums, target, true);`<br>\n目标元素出现的最后一个下标：`int rightIdx = extremeInsertionIndex(nums, target, false) - 1;`这里需要减一，需要注意。\n\n---\n\n**总结一下**：二分搜索只需要注意它的边界值，原先的数组下标范围是 [0..n-1]，当你用 `lo = 0, hi = n-1` 去运行时，对应条件满足情况下值的赋值应该是 `lo = mid + 1, hi = mid - 1`；而若是用 `lo = -1, hi = n` 去作为条件运行时，对应条件满足情况下值的赋值就应该为 `lo = mid, hi = mid`，因为它两个值都是作为边界值。[0, n]、[-1, n-1]也是如此。\n\n---\n相关链接：\n\n- [编程珠玑（第二版）第四章习题](https://github.com/Folgerjun/Programming-Pearls/blob/master/Chapter-Four.md#2)\n- [LeetCode - Find First and Last Position of Element in Sorted Array](https://github.com/Folgerjun/leetcode-cn/blob/master/src/com/leetcode_cn/medium/FindFirstAndLastPositionOfElementInSortedArray.java)","source":"_posts/binary-search.md","raw":"---\ntitle: 二分搜索之搜索数组中目标元素的首尾下标\ndate: 2018-10-15 17:02:16\ncategories: [开发,算法]\ntags: [算法,Java,二分搜索]\n---\n\n今天总结一下二分搜索。**假设这里的数组已经是升序排序好了的。**\n\n我们知道二分搜索的效率很高，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用 O(log n) 完成搜索任务。它的基本思想：将 n 个元素分成个数大致相同的两半，取 a[n/2] 与需要查找的目标值 x 作比较，如果 x=a[n/2] 则找到 x，算法运算终止。详情可跳转[百度百科](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95/6230633)。\n\n- 我们通常最基本的二分搜索是这样实现的(Java):\n```\n    /**\n     * 二分搜索\n     * \n     * @param arr\n     *            已升序排序数组\n     * @param key\n     *            目标查找值\n     * @return\n     */\n    public static int commonBinarySearch(int[] arr, int key) {\n        int low = 0;\n        int high = arr.length - 1;\n        int middle = 0; // 定义middle\n\n        if (key < arr[low] || key > arr[high] || low > high) {\n            return -1;\n        }\n\n        while (low <= high) {\n            middle = (low + high) / 2;\n            if (arr[middle] > key) {\n                // 比关键字大则关键字在左区域\n                high = middle - 1;\n            } else if (arr[middle] < key) {\n                // 比关键字小则关键字在右区域\n                low = middle + 1;\n            } else {\n                return middle;\n            }\n        }\n\n        return -1; // 未找到结果，返回-1\n    }\n```\n若是数组中存在搜索目标元素，则只要查找到任意一个便会返回该值；若是没有找到即返回 -1。\n\n- 来看下一种，只返回目标元素第一次出现的位置下标(伪代码):\n```\nl = -1; u = n\nwhile l+1 != u\n    m = (l + u) / 2\n    if x[m] < t\n        l = m\n    else\n        u = m\np = u\nif p >= n || x[p] != t\n    p = -1\n```\nn 为数组的长度，p 就是最终我们需要的下标。若是 while 循环出来的最终结果 `u >= n` （其实最大也只会等于 n）或者 `x[u] != t`（t 为我们的目标元素），那么也就是无结果，返回 -1。\n\n- 我们再来看最后一个 function(该方法参数不同使得结果可以返回元素第一个出现的下标或者最后一个下标，也是 Java):\n```\n    /**\n     * \n     * @param nums\n     *            已经升序排序好的数组\n     * @param target\n     *            搜索目标元素\n     * @param left\n     *            是否是查找第一个元素下标。true:查找目标元素第一个出现下标, false:查找目标元素最后一个出现下标\n     * @return\n     */\n    private int extremeInsertionIndex(int[] nums, int target, boolean left) {\n        int lo = 0;\n        int hi = nums.length;\n\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] > target || (left && target == nums[mid])) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        return lo;\n    }\n```\n目标元素出现的第一个下标：`int leftIdx = extremeInsertionIndex(nums, target, true);`<br>\n目标元素出现的最后一个下标：`int rightIdx = extremeInsertionIndex(nums, target, false) - 1;`这里需要减一，需要注意。\n\n---\n\n**总结一下**：二分搜索只需要注意它的边界值，原先的数组下标范围是 [0..n-1]，当你用 `lo = 0, hi = n-1` 去运行时，对应条件满足情况下值的赋值应该是 `lo = mid + 1, hi = mid - 1`；而若是用 `lo = -1, hi = n` 去作为条件运行时，对应条件满足情况下值的赋值就应该为 `lo = mid, hi = mid`，因为它两个值都是作为边界值。[0, n]、[-1, n-1]也是如此。\n\n---\n相关链接：\n\n- [编程珠玑（第二版）第四章习题](https://github.com/Folgerjun/Programming-Pearls/blob/master/Chapter-Four.md#2)\n- [LeetCode - Find First and Last Position of Element in Sorted Array](https://github.com/Folgerjun/leetcode-cn/blob/master/src/com/leetcode_cn/medium/FindFirstAndLastPositionOfElementInSortedArray.java)","slug":"binary-search","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh90028k9i10f2v8hi8","content":"<p>今天总结一下二分搜索。<strong>假设这里的数组已经是升序排序好了的。</strong></p>\n<p>我们知道二分搜索的效率很高，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用 O(log n) 完成搜索任务。它的基本思想：将 n 个元素分成个数大致相同的两半，取 a[n&#x2F;2] 与需要查找的目标值 x 作比较，如果 x&#x3D;a[n&#x2F;2] 则找到 x，算法运算终止。详情可跳转<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95/6230633\">百度百科</a>。</p>\n<ul>\n<li><p>我们通常最基本的二分搜索是这样实现的(Java):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 二分搜索</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> *            已升序排序数组</span><br><span class=\"line\"> * @param key</span><br><span class=\"line\"> *            目标查找值</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int commonBinarySearch(int[] arr, int key) &#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = arr.length - 1;</span><br><span class=\"line\">    int middle = 0; // 定义middle</span><br><span class=\"line\"></span><br><span class=\"line\">    if (key &lt; arr[low] || key &gt; arr[high] || low &gt; high) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (low &lt;= high) &#123;</span><br><span class=\"line\">        middle = (low + high) / 2;</span><br><span class=\"line\">        if (arr[middle] &gt; key) &#123;</span><br><span class=\"line\">            // 比关键字大则关键字在左区域</span><br><span class=\"line\">            high = middle - 1;</span><br><span class=\"line\">        &#125; else if (arr[middle] &lt; key) &#123;</span><br><span class=\"line\">            // 比关键字小则关键字在右区域</span><br><span class=\"line\">            low = middle + 1;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return middle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1; // 未找到结果，返回-1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若是数组中存在搜索目标元素，则只要查找到任意一个便会返回该值；若是没有找到即返回 -1。</p>\n</li>\n<li><p>来看下一种，只返回目标元素第一次出现的位置下标(伪代码):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = -1; u = n</span><br><span class=\"line\">while l+1 != u</span><br><span class=\"line\">    m = (l + u) / 2</span><br><span class=\"line\">    if x[m] &lt; t</span><br><span class=\"line\">        l = m</span><br><span class=\"line\">    else</span><br><span class=\"line\">        u = m</span><br><span class=\"line\">p = u</span><br><span class=\"line\">if p &gt;= n || x[p] != t</span><br><span class=\"line\">    p = -1</span><br></pre></td></tr></table></figure>\n<p>n 为数组的长度，p 就是最终我们需要的下标。若是 while 循环出来的最终结果 <code>u &gt;= n</code> （其实最大也只会等于 n）或者 <code>x[u] != t</code>（t 为我们的目标元素），那么也就是无结果，返回 -1。</p>\n</li>\n<li><p>我们再来看最后一个 function(该方法参数不同使得结果可以返回元素第一个出现的下标或者最后一个下标，也是 Java):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            已经升序排序好的数组</span><br><span class=\"line\"> * @param target</span><br><span class=\"line\"> *            搜索目标元素</span><br><span class=\"line\"> * @param left</span><br><span class=\"line\"> *            是否是查找第一个元素下标。true:查找目标元素第一个出现下标, false:查找目标元素最后一个出现下标</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">private int extremeInsertionIndex(int[] nums, int target, boolean left) &#123;</span><br><span class=\"line\">    int lo = 0;</span><br><span class=\"line\">    int hi = nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (lo &lt; hi) &#123;</span><br><span class=\"line\">        int mid = (lo + hi) / 2;</span><br><span class=\"line\">        if (nums[mid] &gt; target || (left &amp;&amp; target == nums[mid])) &#123;</span><br><span class=\"line\">            hi = mid;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            lo = mid + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return lo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目标元素出现的第一个下标：<code>int leftIdx = extremeInsertionIndex(nums, target, true);</code><br><br>目标元素出现的最后一个下标：<code>int rightIdx = extremeInsertionIndex(nums, target, false) - 1;</code>这里需要减一，需要注意。</p>\n</li>\n</ul>\n<hr>\n<p><strong>总结一下</strong>：二分搜索只需要注意它的边界值，原先的数组下标范围是 [0..n-1]，当你用 <code>lo = 0, hi = n-1</code> 去运行时，对应条件满足情况下值的赋值应该是 <code>lo = mid + 1, hi = mid - 1</code>；而若是用 <code>lo = -1, hi = n</code> 去作为条件运行时，对应条件满足情况下值的赋值就应该为 <code>lo = mid, hi = mid</code>，因为它两个值都是作为边界值。[0, n]、[-1, n-1]也是如此。</p>\n<hr>\n<p>相关链接：</p>\n<ul>\n<li><a href=\"https://github.com/Folgerjun/Programming-Pearls/blob/master/Chapter-Four.md#2\">编程珠玑（第二版）第四章习题</a></li>\n<li><a href=\"https://github.com/Folgerjun/leetcode-cn/blob/master/src/com/leetcode_cn/medium/FindFirstAndLastPositionOfElementInSortedArray.java\">LeetCode - Find First and Last Position of Element in Sorted Array</a></li>\n</ul>\n","excerpt":"","more":"<p>今天总结一下二分搜索。<strong>假设这里的数组已经是升序排序好了的。</strong></p>\n<p>我们知道二分搜索的效率很高，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用 O(log n) 完成搜索任务。它的基本思想：将 n 个元素分成个数大致相同的两半，取 a[n&#x2F;2] 与需要查找的目标值 x 作比较，如果 x&#x3D;a[n&#x2F;2] 则找到 x，算法运算终止。详情可跳转<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95/6230633\">百度百科</a>。</p>\n<ul>\n<li><p>我们通常最基本的二分搜索是这样实现的(Java):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 二分搜索</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> *            已升序排序数组</span><br><span class=\"line\"> * @param key</span><br><span class=\"line\"> *            目标查找值</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int commonBinarySearch(int[] arr, int key) &#123;</span><br><span class=\"line\">    int low = 0;</span><br><span class=\"line\">    int high = arr.length - 1;</span><br><span class=\"line\">    int middle = 0; // 定义middle</span><br><span class=\"line\"></span><br><span class=\"line\">    if (key &lt; arr[low] || key &gt; arr[high] || low &gt; high) &#123;</span><br><span class=\"line\">        return -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (low &lt;= high) &#123;</span><br><span class=\"line\">        middle = (low + high) / 2;</span><br><span class=\"line\">        if (arr[middle] &gt; key) &#123;</span><br><span class=\"line\">            // 比关键字大则关键字在左区域</span><br><span class=\"line\">            high = middle - 1;</span><br><span class=\"line\">        &#125; else if (arr[middle] &lt; key) &#123;</span><br><span class=\"line\">            // 比关键字小则关键字在右区域</span><br><span class=\"line\">            low = middle + 1;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return middle;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1; // 未找到结果，返回-1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若是数组中存在搜索目标元素，则只要查找到任意一个便会返回该值；若是没有找到即返回 -1。</p>\n</li>\n<li><p>来看下一种，只返回目标元素第一次出现的位置下标(伪代码):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = -1; u = n</span><br><span class=\"line\">while l+1 != u</span><br><span class=\"line\">    m = (l + u) / 2</span><br><span class=\"line\">    if x[m] &lt; t</span><br><span class=\"line\">        l = m</span><br><span class=\"line\">    else</span><br><span class=\"line\">        u = m</span><br><span class=\"line\">p = u</span><br><span class=\"line\">if p &gt;= n || x[p] != t</span><br><span class=\"line\">    p = -1</span><br></pre></td></tr></table></figure>\n<p>n 为数组的长度，p 就是最终我们需要的下标。若是 while 循环出来的最终结果 <code>u &gt;= n</code> （其实最大也只会等于 n）或者 <code>x[u] != t</code>（t 为我们的目标元素），那么也就是无结果，返回 -1。</p>\n</li>\n<li><p>我们再来看最后一个 function(该方法参数不同使得结果可以返回元素第一个出现的下标或者最后一个下标，也是 Java):</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            已经升序排序好的数组</span><br><span class=\"line\"> * @param target</span><br><span class=\"line\"> *            搜索目标元素</span><br><span class=\"line\"> * @param left</span><br><span class=\"line\"> *            是否是查找第一个元素下标。true:查找目标元素第一个出现下标, false:查找目标元素最后一个出现下标</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">private int extremeInsertionIndex(int[] nums, int target, boolean left) &#123;</span><br><span class=\"line\">    int lo = 0;</span><br><span class=\"line\">    int hi = nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (lo &lt; hi) &#123;</span><br><span class=\"line\">        int mid = (lo + hi) / 2;</span><br><span class=\"line\">        if (nums[mid] &gt; target || (left &amp;&amp; target == nums[mid])) &#123;</span><br><span class=\"line\">            hi = mid;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            lo = mid + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return lo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目标元素出现的第一个下标：<code>int leftIdx = extremeInsertionIndex(nums, target, true);</code><br><br>目标元素出现的最后一个下标：<code>int rightIdx = extremeInsertionIndex(nums, target, false) - 1;</code>这里需要减一，需要注意。</p>\n</li>\n</ul>\n<hr>\n<p><strong>总结一下</strong>：二分搜索只需要注意它的边界值，原先的数组下标范围是 [0..n-1]，当你用 <code>lo = 0, hi = n-1</code> 去运行时，对应条件满足情况下值的赋值应该是 <code>lo = mid + 1, hi = mid - 1</code>；而若是用 <code>lo = -1, hi = n</code> 去作为条件运行时，对应条件满足情况下值的赋值就应该为 <code>lo = mid, hi = mid</code>，因为它两个值都是作为边界值。[0, n]、[-1, n-1]也是如此。</p>\n<hr>\n<p>相关链接：</p>\n<ul>\n<li><a href=\"https://github.com/Folgerjun/Programming-Pearls/blob/master/Chapter-Four.md#2\">编程珠玑（第二版）第四章习题</a></li>\n<li><a href=\"https://github.com/Folgerjun/leetcode-cn/blob/master/src/com/leetcode_cn/medium/FindFirstAndLastPositionOfElementInSortedArray.java\">LeetCode - Find First and Last Position of Element in Sorted Array</a></li>\n</ul>\n"},{"title":"黑色六月（2018）","date":"2018-07-06T03:46:11.000Z","_content":"# 对于我来说的黑色六月  2018\n\n---\n上个月发生了很多事情，很多事情。今年最丧的一个月！借着上班空余时间也算是记录生活吧。\n\n## 股市大震荡\n其实今年股市都不理想，震荡不稳。然而被美国一加息操作，刷刷往下滑，千股跌停，真是一片绿油油。我虽然没有时间去炒股，不过我也买了基金，至今也是跌了15个点啊，能不心疼么。之前是国外在割韭菜，现在是国内国外联手割韭菜了，还好我本金不大不然也是血亏。\n\n阳光总在风雨后不是么？\n保持不浮躁，不要追涨杀跌就行了，还是要相信国运的。\n\n## 世界杯\n四年一度世界杯来了。不会踢足球的人却能在这段时光看赛事不觉得枯燥。足球虽然全场到处跑，进球又少，但是真的很令人着迷，一点都不会觉得无趣。\n\n有球赛的时候我就自己待在出租屋中，放着我心爱的投影，瘫在床上看比赛。\n\n没有球赛那我就找找电影看，玩玩游戏。乏了就关了大灯开启我的小台灯，趴在床上看看书，直到眼皮打架，关灯入眠，被第二日的刺光射醒。\n\n有点遗憾，今年也是爆了很多冷门。德国回家了，葡萄牙回家了。\n\n因为世界杯最近也出现了不少事情，赌球是自然不用说了。**本人好青年，不沾赌。**\n\n还有因为支持球队不同吵架，甚至分手的、离婚的，真不知道是怎么想的，我想是本来感情就出现了问题借此顺势触发的吧。\n\n## 分手了\n难以相信这段感情只维持了10个月，以前我还不信，说离开了校园步入社会，你将要面对的都是现实。\n\n曾经天真以为遇到了对的人，能携手同老。\n\n有些问题终究不可避免，即使你明白，不尽量让它浮现，但终是拦不住。\n\n**情这个东西，不负彼此就行，不负此生，真的太难了。**\n\n也许我就会这样一直单着吧。\n\n那一天，我还是去超市买了一听雪花，一袋花生，半只烤鸭。\n\n## 转正了\n人人都有一颗创业的心，谁说不是呢。可是蠢蠢欲动并不能代表你就可以。苦有谁吃不得，要是只要能吃得了苦就能创业成功，谁还会甘愿给别人打工。\n\n一没财，二没势，创业如今也是高门槛了。\n\n不像以前，近十年的世界翻天覆地，互联网技术层层迭代。近些年来的风口都是什么，大数据，云计算，直播，短视频APP...要是没有前沿的眼光，没有能跟上这个时代的眼界思维，没有一定的技术支持，就算站在风口你飞起来了，也会摔得很惨。\n\n雷军，我真的很敬佩。之前看了他的博客写的自己的心得。他是天才，大学就实现了财务自由，年纪轻轻成为了天使投资人，而且眼光很独到。更重要的是，雷军的为人，就是有人愿意相信他跟着他的步伐一起走，这又岂能是用钱财能换来的，用的都是真心。\n\n天才都在努力奋进，我们又怎么能安于现状，止步于前。**自己都觉得废了，那就真的是废了。**\n\n活到老，学到老。充实自己，不要再空虚了。\n\n---\n## 胡乱写一点\n眼看又是一年了，去年的五月六月也是我最难受的两个月。我虽然不怕苦，但是我也会痛。一些辛酸无人能说也无人可说，亦或是不想去说。我还是保持那个观点，人活世上，平安喜乐。有些事，该来的时候终会到来。\n\n我有很多喜欢的东西啊，兴趣爱好特别多。可是呢，鱼跟熊掌二者都不能兼得，何况是多者呢。今年换了家公司，虽然钱不多，但是好歹加班没有之前严重了，目前为止最晚也能九点回去。我喜欢popping、健身、口琴、看电影、玩游戏，可是我却安排不好自己的时间，晚上回去一晃就到了12点。有时候也会想，我内心到底在追求什么。我不求大富大贵，只求健康平安，一家和睦。可是这些都不是我现在这个年纪该去思考的问题，凡事都要讲资本，更何况如今需要的资本更是我们这种平凡人所不能轻易承受的。\n\n我怕空虚，所以我不想闲下来。身边有人陪伴的时间久了，突然变成了孑然一人。\n\n很多事情我都会选择自己来扛，我不愿去麻烦别人，不愿再去让别人尝一遍我尝过的辛酸无奈。自己苦点累点无所谓，只要我觉得值得。**生而为人，人各有命，命不在你，命在于天。**\n\n踏实走好每一步，但愿往后回味不会懊恼此刻的我。\n\n---\n\n愿你健康快乐平安幸福过好每一天。","source":"_posts/black-june-2018.md","raw":"---\ntitle: 黑色六月（2018）\ndate: 2018-7-6 11:46:11\ncategories: [生活,杂侃]\ntags: []\n---\n# 对于我来说的黑色六月  2018\n\n---\n上个月发生了很多事情，很多事情。今年最丧的一个月！借着上班空余时间也算是记录生活吧。\n\n## 股市大震荡\n其实今年股市都不理想，震荡不稳。然而被美国一加息操作，刷刷往下滑，千股跌停，真是一片绿油油。我虽然没有时间去炒股，不过我也买了基金，至今也是跌了15个点啊，能不心疼么。之前是国外在割韭菜，现在是国内国外联手割韭菜了，还好我本金不大不然也是血亏。\n\n阳光总在风雨后不是么？\n保持不浮躁，不要追涨杀跌就行了，还是要相信国运的。\n\n## 世界杯\n四年一度世界杯来了。不会踢足球的人却能在这段时光看赛事不觉得枯燥。足球虽然全场到处跑，进球又少，但是真的很令人着迷，一点都不会觉得无趣。\n\n有球赛的时候我就自己待在出租屋中，放着我心爱的投影，瘫在床上看比赛。\n\n没有球赛那我就找找电影看，玩玩游戏。乏了就关了大灯开启我的小台灯，趴在床上看看书，直到眼皮打架，关灯入眠，被第二日的刺光射醒。\n\n有点遗憾，今年也是爆了很多冷门。德国回家了，葡萄牙回家了。\n\n因为世界杯最近也出现了不少事情，赌球是自然不用说了。**本人好青年，不沾赌。**\n\n还有因为支持球队不同吵架，甚至分手的、离婚的，真不知道是怎么想的，我想是本来感情就出现了问题借此顺势触发的吧。\n\n## 分手了\n难以相信这段感情只维持了10个月，以前我还不信，说离开了校园步入社会，你将要面对的都是现实。\n\n曾经天真以为遇到了对的人，能携手同老。\n\n有些问题终究不可避免，即使你明白，不尽量让它浮现，但终是拦不住。\n\n**情这个东西，不负彼此就行，不负此生，真的太难了。**\n\n也许我就会这样一直单着吧。\n\n那一天，我还是去超市买了一听雪花，一袋花生，半只烤鸭。\n\n## 转正了\n人人都有一颗创业的心，谁说不是呢。可是蠢蠢欲动并不能代表你就可以。苦有谁吃不得，要是只要能吃得了苦就能创业成功，谁还会甘愿给别人打工。\n\n一没财，二没势，创业如今也是高门槛了。\n\n不像以前，近十年的世界翻天覆地，互联网技术层层迭代。近些年来的风口都是什么，大数据，云计算，直播，短视频APP...要是没有前沿的眼光，没有能跟上这个时代的眼界思维，没有一定的技术支持，就算站在风口你飞起来了，也会摔得很惨。\n\n雷军，我真的很敬佩。之前看了他的博客写的自己的心得。他是天才，大学就实现了财务自由，年纪轻轻成为了天使投资人，而且眼光很独到。更重要的是，雷军的为人，就是有人愿意相信他跟着他的步伐一起走，这又岂能是用钱财能换来的，用的都是真心。\n\n天才都在努力奋进，我们又怎么能安于现状，止步于前。**自己都觉得废了，那就真的是废了。**\n\n活到老，学到老。充实自己，不要再空虚了。\n\n---\n## 胡乱写一点\n眼看又是一年了，去年的五月六月也是我最难受的两个月。我虽然不怕苦，但是我也会痛。一些辛酸无人能说也无人可说，亦或是不想去说。我还是保持那个观点，人活世上，平安喜乐。有些事，该来的时候终会到来。\n\n我有很多喜欢的东西啊，兴趣爱好特别多。可是呢，鱼跟熊掌二者都不能兼得，何况是多者呢。今年换了家公司，虽然钱不多，但是好歹加班没有之前严重了，目前为止最晚也能九点回去。我喜欢popping、健身、口琴、看电影、玩游戏，可是我却安排不好自己的时间，晚上回去一晃就到了12点。有时候也会想，我内心到底在追求什么。我不求大富大贵，只求健康平安，一家和睦。可是这些都不是我现在这个年纪该去思考的问题，凡事都要讲资本，更何况如今需要的资本更是我们这种平凡人所不能轻易承受的。\n\n我怕空虚，所以我不想闲下来。身边有人陪伴的时间久了，突然变成了孑然一人。\n\n很多事情我都会选择自己来扛，我不愿去麻烦别人，不愿再去让别人尝一遍我尝过的辛酸无奈。自己苦点累点无所谓，只要我觉得值得。**生而为人，人各有命，命不在你，命在于天。**\n\n踏实走好每一步，但愿往后回味不会懊恼此刻的我。\n\n---\n\n愿你健康快乐平安幸福过好每一天。","slug":"black-june-2018","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh9002ck9i1797g8bbw","content":"<h1 id=\"对于我来说的黑色六月-2018\"><a href=\"#对于我来说的黑色六月-2018\" class=\"headerlink\" title=\"对于我来说的黑色六月  2018\"></a>对于我来说的黑色六月  2018</h1><hr>\n<p>上个月发生了很多事情，很多事情。今年最丧的一个月！借着上班空余时间也算是记录生活吧。</p>\n<h2 id=\"股市大震荡\"><a href=\"#股市大震荡\" class=\"headerlink\" title=\"股市大震荡\"></a>股市大震荡</h2><p>其实今年股市都不理想，震荡不稳。然而被美国一加息操作，刷刷往下滑，千股跌停，真是一片绿油油。我虽然没有时间去炒股，不过我也买了基金，至今也是跌了15个点啊，能不心疼么。之前是国外在割韭菜，现在是国内国外联手割韭菜了，还好我本金不大不然也是血亏。</p>\n<p>阳光总在风雨后不是么？<br>保持不浮躁，不要追涨杀跌就行了，还是要相信国运的。</p>\n<h2 id=\"世界杯\"><a href=\"#世界杯\" class=\"headerlink\" title=\"世界杯\"></a>世界杯</h2><p>四年一度世界杯来了。不会踢足球的人却能在这段时光看赛事不觉得枯燥。足球虽然全场到处跑，进球又少，但是真的很令人着迷，一点都不会觉得无趣。</p>\n<p>有球赛的时候我就自己待在出租屋中，放着我心爱的投影，瘫在床上看比赛。</p>\n<p>没有球赛那我就找找电影看，玩玩游戏。乏了就关了大灯开启我的小台灯，趴在床上看看书，直到眼皮打架，关灯入眠，被第二日的刺光射醒。</p>\n<p>有点遗憾，今年也是爆了很多冷门。德国回家了，葡萄牙回家了。</p>\n<p>因为世界杯最近也出现了不少事情，赌球是自然不用说了。<strong>本人好青年，不沾赌。</strong></p>\n<p>还有因为支持球队不同吵架，甚至分手的、离婚的，真不知道是怎么想的，我想是本来感情就出现了问题借此顺势触发的吧。</p>\n<h2 id=\"分手了\"><a href=\"#分手了\" class=\"headerlink\" title=\"分手了\"></a>分手了</h2><p>难以相信这段感情只维持了10个月，以前我还不信，说离开了校园步入社会，你将要面对的都是现实。</p>\n<p>曾经天真以为遇到了对的人，能携手同老。</p>\n<p>有些问题终究不可避免，即使你明白，不尽量让它浮现，但终是拦不住。</p>\n<p><strong>情这个东西，不负彼此就行，不负此生，真的太难了。</strong></p>\n<p>也许我就会这样一直单着吧。</p>\n<p>那一天，我还是去超市买了一听雪花，一袋花生，半只烤鸭。</p>\n<h2 id=\"转正了\"><a href=\"#转正了\" class=\"headerlink\" title=\"转正了\"></a>转正了</h2><p>人人都有一颗创业的心，谁说不是呢。可是蠢蠢欲动并不能代表你就可以。苦有谁吃不得，要是只要能吃得了苦就能创业成功，谁还会甘愿给别人打工。</p>\n<p>一没财，二没势，创业如今也是高门槛了。</p>\n<p>不像以前，近十年的世界翻天覆地，互联网技术层层迭代。近些年来的风口都是什么，大数据，云计算，直播，短视频APP…要是没有前沿的眼光，没有能跟上这个时代的眼界思维，没有一定的技术支持，就算站在风口你飞起来了，也会摔得很惨。</p>\n<p>雷军，我真的很敬佩。之前看了他的博客写的自己的心得。他是天才，大学就实现了财务自由，年纪轻轻成为了天使投资人，而且眼光很独到。更重要的是，雷军的为人，就是有人愿意相信他跟着他的步伐一起走，这又岂能是用钱财能换来的，用的都是真心。</p>\n<p>天才都在努力奋进，我们又怎么能安于现状，止步于前。<strong>自己都觉得废了，那就真的是废了。</strong></p>\n<p>活到老，学到老。充实自己，不要再空虚了。</p>\n<hr>\n<h2 id=\"胡乱写一点\"><a href=\"#胡乱写一点\" class=\"headerlink\" title=\"胡乱写一点\"></a>胡乱写一点</h2><p>眼看又是一年了，去年的五月六月也是我最难受的两个月。我虽然不怕苦，但是我也会痛。一些辛酸无人能说也无人可说，亦或是不想去说。我还是保持那个观点，人活世上，平安喜乐。有些事，该来的时候终会到来。</p>\n<p>我有很多喜欢的东西啊，兴趣爱好特别多。可是呢，鱼跟熊掌二者都不能兼得，何况是多者呢。今年换了家公司，虽然钱不多，但是好歹加班没有之前严重了，目前为止最晚也能九点回去。我喜欢popping、健身、口琴、看电影、玩游戏，可是我却安排不好自己的时间，晚上回去一晃就到了12点。有时候也会想，我内心到底在追求什么。我不求大富大贵，只求健康平安，一家和睦。可是这些都不是我现在这个年纪该去思考的问题，凡事都要讲资本，更何况如今需要的资本更是我们这种平凡人所不能轻易承受的。</p>\n<p>我怕空虚，所以我不想闲下来。身边有人陪伴的时间久了，突然变成了孑然一人。</p>\n<p>很多事情我都会选择自己来扛，我不愿去麻烦别人，不愿再去让别人尝一遍我尝过的辛酸无奈。自己苦点累点无所谓，只要我觉得值得。<strong>生而为人，人各有命，命不在你，命在于天。</strong></p>\n<p>踏实走好每一步，但愿往后回味不会懊恼此刻的我。</p>\n<hr>\n<p>愿你健康快乐平安幸福过好每一天。</p>\n","excerpt":"","more":"<h1 id=\"对于我来说的黑色六月-2018\"><a href=\"#对于我来说的黑色六月-2018\" class=\"headerlink\" title=\"对于我来说的黑色六月  2018\"></a>对于我来说的黑色六月  2018</h1><hr>\n<p>上个月发生了很多事情，很多事情。今年最丧的一个月！借着上班空余时间也算是记录生活吧。</p>\n<h2 id=\"股市大震荡\"><a href=\"#股市大震荡\" class=\"headerlink\" title=\"股市大震荡\"></a>股市大震荡</h2><p>其实今年股市都不理想，震荡不稳。然而被美国一加息操作，刷刷往下滑，千股跌停，真是一片绿油油。我虽然没有时间去炒股，不过我也买了基金，至今也是跌了15个点啊，能不心疼么。之前是国外在割韭菜，现在是国内国外联手割韭菜了，还好我本金不大不然也是血亏。</p>\n<p>阳光总在风雨后不是么？<br>保持不浮躁，不要追涨杀跌就行了，还是要相信国运的。</p>\n<h2 id=\"世界杯\"><a href=\"#世界杯\" class=\"headerlink\" title=\"世界杯\"></a>世界杯</h2><p>四年一度世界杯来了。不会踢足球的人却能在这段时光看赛事不觉得枯燥。足球虽然全场到处跑，进球又少，但是真的很令人着迷，一点都不会觉得无趣。</p>\n<p>有球赛的时候我就自己待在出租屋中，放着我心爱的投影，瘫在床上看比赛。</p>\n<p>没有球赛那我就找找电影看，玩玩游戏。乏了就关了大灯开启我的小台灯，趴在床上看看书，直到眼皮打架，关灯入眠，被第二日的刺光射醒。</p>\n<p>有点遗憾，今年也是爆了很多冷门。德国回家了，葡萄牙回家了。</p>\n<p>因为世界杯最近也出现了不少事情，赌球是自然不用说了。<strong>本人好青年，不沾赌。</strong></p>\n<p>还有因为支持球队不同吵架，甚至分手的、离婚的，真不知道是怎么想的，我想是本来感情就出现了问题借此顺势触发的吧。</p>\n<h2 id=\"分手了\"><a href=\"#分手了\" class=\"headerlink\" title=\"分手了\"></a>分手了</h2><p>难以相信这段感情只维持了10个月，以前我还不信，说离开了校园步入社会，你将要面对的都是现实。</p>\n<p>曾经天真以为遇到了对的人，能携手同老。</p>\n<p>有些问题终究不可避免，即使你明白，不尽量让它浮现，但终是拦不住。</p>\n<p><strong>情这个东西，不负彼此就行，不负此生，真的太难了。</strong></p>\n<p>也许我就会这样一直单着吧。</p>\n<p>那一天，我还是去超市买了一听雪花，一袋花生，半只烤鸭。</p>\n<h2 id=\"转正了\"><a href=\"#转正了\" class=\"headerlink\" title=\"转正了\"></a>转正了</h2><p>人人都有一颗创业的心，谁说不是呢。可是蠢蠢欲动并不能代表你就可以。苦有谁吃不得，要是只要能吃得了苦就能创业成功，谁还会甘愿给别人打工。</p>\n<p>一没财，二没势，创业如今也是高门槛了。</p>\n<p>不像以前，近十年的世界翻天覆地，互联网技术层层迭代。近些年来的风口都是什么，大数据，云计算，直播，短视频APP…要是没有前沿的眼光，没有能跟上这个时代的眼界思维，没有一定的技术支持，就算站在风口你飞起来了，也会摔得很惨。</p>\n<p>雷军，我真的很敬佩。之前看了他的博客写的自己的心得。他是天才，大学就实现了财务自由，年纪轻轻成为了天使投资人，而且眼光很独到。更重要的是，雷军的为人，就是有人愿意相信他跟着他的步伐一起走，这又岂能是用钱财能换来的，用的都是真心。</p>\n<p>天才都在努力奋进，我们又怎么能安于现状，止步于前。<strong>自己都觉得废了，那就真的是废了。</strong></p>\n<p>活到老，学到老。充实自己，不要再空虚了。</p>\n<hr>\n<h2 id=\"胡乱写一点\"><a href=\"#胡乱写一点\" class=\"headerlink\" title=\"胡乱写一点\"></a>胡乱写一点</h2><p>眼看又是一年了，去年的五月六月也是我最难受的两个月。我虽然不怕苦，但是我也会痛。一些辛酸无人能说也无人可说，亦或是不想去说。我还是保持那个观点，人活世上，平安喜乐。有些事，该来的时候终会到来。</p>\n<p>我有很多喜欢的东西啊，兴趣爱好特别多。可是呢，鱼跟熊掌二者都不能兼得，何况是多者呢。今年换了家公司，虽然钱不多，但是好歹加班没有之前严重了，目前为止最晚也能九点回去。我喜欢popping、健身、口琴、看电影、玩游戏，可是我却安排不好自己的时间，晚上回去一晃就到了12点。有时候也会想，我内心到底在追求什么。我不求大富大贵，只求健康平安，一家和睦。可是这些都不是我现在这个年纪该去思考的问题，凡事都要讲资本，更何况如今需要的资本更是我们这种平凡人所不能轻易承受的。</p>\n<p>我怕空虚，所以我不想闲下来。身边有人陪伴的时间久了，突然变成了孑然一人。</p>\n<p>很多事情我都会选择自己来扛，我不愿去麻烦别人，不愿再去让别人尝一遍我尝过的辛酸无奈。自己苦点累点无所谓，只要我觉得值得。<strong>生而为人，人各有命，命不在你，命在于天。</strong></p>\n<p>踏实走好每一步，但愿往后回味不会懊恼此刻的我。</p>\n<hr>\n<p>愿你健康快乐平安幸福过好每一天。</p>\n"},{"title":"萧瑟十月（2021）","date":"2021-10-30T06:50:55.000Z","_content":"\n月首，国庆节假日跑步进场，在还没享受到位又匆忙离场，不想上班。\n\n前半个十月，还是如同夏日般炎热干燥，一夜秋雨，寒气上身，瑟瑟发抖，纷纷穿上棉衣。\n\n这月买了迪士尼的年卡，看到了半夜川沙的吵闹，也看到了玩偶沦陷的男男女女，川沙妲己直接溢价几倍。\n\n终于看到了迪士尼的夜晚烟花秀，特别是漫威的那一系列完美衔接，真是如同身临大片场景，张嘴发不出惊叹。\n\n一年一度的双十一又要开始了，此时购物车已填满了心仪之物，预售方式也覆盖了绝大热门商品。本来以为够疯狂的世界了，前几天一则新闻又刷新了对世界的认知，格局还是太小了。一个带货主播一晚就可以产生上百亿的销售额，结舌。在领域做成头部都是了不起的人物。\n\n本来报名的横马又因为疫情延期了，本来票和酒店都定了，还好只扣了一点手续费。这次由于国庆旅游导致的多地爆发，还是让人们不能对疫情有所松懈。\n\n近来已无多运动，有些衣裤穿着穿着就穿不了了。已经开始吃沙拉了，小肚腩略微明显，脸蛋略微圆润。\n\n跟小邱玩了switch的分手厨房，游戏确实好玩，非常能锻炼手和脑的结合，也很讲究策略，两人得要很好的搭配。业余消遣，还不错的游戏。\n\n桂花开始飘香，秋风开始萧萧，我也还在劳忙，不知何时下岗。","source":"_posts/bleak-october.md","raw":"---\ntitle: 萧瑟十月（2021）\ndate: 2021-10-30 14:50:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n月首，国庆节假日跑步进场，在还没享受到位又匆忙离场，不想上班。\n\n前半个十月，还是如同夏日般炎热干燥，一夜秋雨，寒气上身，瑟瑟发抖，纷纷穿上棉衣。\n\n这月买了迪士尼的年卡，看到了半夜川沙的吵闹，也看到了玩偶沦陷的男男女女，川沙妲己直接溢价几倍。\n\n终于看到了迪士尼的夜晚烟花秀，特别是漫威的那一系列完美衔接，真是如同身临大片场景，张嘴发不出惊叹。\n\n一年一度的双十一又要开始了，此时购物车已填满了心仪之物，预售方式也覆盖了绝大热门商品。本来以为够疯狂的世界了，前几天一则新闻又刷新了对世界的认知，格局还是太小了。一个带货主播一晚就可以产生上百亿的销售额，结舌。在领域做成头部都是了不起的人物。\n\n本来报名的横马又因为疫情延期了，本来票和酒店都定了，还好只扣了一点手续费。这次由于国庆旅游导致的多地爆发，还是让人们不能对疫情有所松懈。\n\n近来已无多运动，有些衣裤穿着穿着就穿不了了。已经开始吃沙拉了，小肚腩略微明显，脸蛋略微圆润。\n\n跟小邱玩了switch的分手厨房，游戏确实好玩，非常能锻炼手和脑的结合，也很讲究策略，两人得要很好的搭配。业余消遣，还不错的游戏。\n\n桂花开始飘香，秋风开始萧萧，我也还在劳忙，不知何时下岗。","slug":"bleak-october","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh9002gk9i11id30759","content":"<p>月首，国庆节假日跑步进场，在还没享受到位又匆忙离场，不想上班。</p>\n<p>前半个十月，还是如同夏日般炎热干燥，一夜秋雨，寒气上身，瑟瑟发抖，纷纷穿上棉衣。</p>\n<p>这月买了迪士尼的年卡，看到了半夜川沙的吵闹，也看到了玩偶沦陷的男男女女，川沙妲己直接溢价几倍。</p>\n<p>终于看到了迪士尼的夜晚烟花秀，特别是漫威的那一系列完美衔接，真是如同身临大片场景，张嘴发不出惊叹。</p>\n<p>一年一度的双十一又要开始了，此时购物车已填满了心仪之物，预售方式也覆盖了绝大热门商品。本来以为够疯狂的世界了，前几天一则新闻又刷新了对世界的认知，格局还是太小了。一个带货主播一晚就可以产生上百亿的销售额，结舌。在领域做成头部都是了不起的人物。</p>\n<p>本来报名的横马又因为疫情延期了，本来票和酒店都定了，还好只扣了一点手续费。这次由于国庆旅游导致的多地爆发，还是让人们不能对疫情有所松懈。</p>\n<p>近来已无多运动，有些衣裤穿着穿着就穿不了了。已经开始吃沙拉了，小肚腩略微明显，脸蛋略微圆润。</p>\n<p>跟小邱玩了switch的分手厨房，游戏确实好玩，非常能锻炼手和脑的结合，也很讲究策略，两人得要很好的搭配。业余消遣，还不错的游戏。</p>\n<p>桂花开始飘香，秋风开始萧萧，我也还在劳忙，不知何时下岗。</p>\n","excerpt":"","more":"<p>月首，国庆节假日跑步进场，在还没享受到位又匆忙离场，不想上班。</p>\n<p>前半个十月，还是如同夏日般炎热干燥，一夜秋雨，寒气上身，瑟瑟发抖，纷纷穿上棉衣。</p>\n<p>这月买了迪士尼的年卡，看到了半夜川沙的吵闹，也看到了玩偶沦陷的男男女女，川沙妲己直接溢价几倍。</p>\n<p>终于看到了迪士尼的夜晚烟花秀，特别是漫威的那一系列完美衔接，真是如同身临大片场景，张嘴发不出惊叹。</p>\n<p>一年一度的双十一又要开始了，此时购物车已填满了心仪之物，预售方式也覆盖了绝大热门商品。本来以为够疯狂的世界了，前几天一则新闻又刷新了对世界的认知，格局还是太小了。一个带货主播一晚就可以产生上百亿的销售额，结舌。在领域做成头部都是了不起的人物。</p>\n<p>本来报名的横马又因为疫情延期了，本来票和酒店都定了，还好只扣了一点手续费。这次由于国庆旅游导致的多地爆发，还是让人们不能对疫情有所松懈。</p>\n<p>近来已无多运动，有些衣裤穿着穿着就穿不了了。已经开始吃沙拉了，小肚腩略微明显，脸蛋略微圆润。</p>\n<p>跟小邱玩了switch的分手厨房，游戏确实好玩，非常能锻炼手和脑的结合，也很讲究策略，两人得要很好的搭配。业余消遣，还不错的游戏。</p>\n<p>桂花开始飘香，秋风开始萧萧，我也还在劳忙，不知何时下岗。</p>\n"},{"title":"祈祷二月（2020）","date":"2020-02-20T02:10:55.000Z","_content":"\n> 由于疫情原因这个假期格外得长\n\n过完元宵我才回上海，在家又连续办公两周后才去的公司。\n\n中国加油！武汉加油！\n\n现在是两月底，从数据上来看疫情已经得到了有效的控制，疑似人数以及确诊人数都有比较大的降幅。当然，股市也是……\n\n反而看着国外数据越来越大，外围开始恐慌，中国当然也不可能独善其身。\n\n活在当下，生命至上！\n\n愿所有人 无疾无病 无忧无怖 无愧于心。\n\n---\n\n刚才有同事问我，当疫情结束后有什么特别想见的人。\n\n我沉默了，脑中却谁都想不起来，好像我的人生还并没有开始就已经迷茫了。","source":"_posts/bless-february.md","raw":"---\ntitle: 祈祷二月（2020）\ndate: 2020-02-20 10:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 由于疫情原因这个假期格外得长\n\n过完元宵我才回上海，在家又连续办公两周后才去的公司。\n\n中国加油！武汉加油！\n\n现在是两月底，从数据上来看疫情已经得到了有效的控制，疑似人数以及确诊人数都有比较大的降幅。当然，股市也是……\n\n反而看着国外数据越来越大，外围开始恐慌，中国当然也不可能独善其身。\n\n活在当下，生命至上！\n\n愿所有人 无疾无病 无忧无怖 无愧于心。\n\n---\n\n刚才有同事问我，当疫情结束后有什么特别想见的人。\n\n我沉默了，脑中却谁都想不起来，好像我的人生还并没有开始就已经迷茫了。","slug":"bless-february","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjh9002kk9i1d38a3094","content":"<blockquote>\n<p>由于疫情原因这个假期格外得长</p>\n</blockquote>\n<p>过完元宵我才回上海，在家又连续办公两周后才去的公司。</p>\n<p>中国加油！武汉加油！</p>\n<p>现在是两月底，从数据上来看疫情已经得到了有效的控制，疑似人数以及确诊人数都有比较大的降幅。当然，股市也是……</p>\n<p>反而看着国外数据越来越大，外围开始恐慌，中国当然也不可能独善其身。</p>\n<p>活在当下，生命至上！</p>\n<p>愿所有人 无疾无病 无忧无怖 无愧于心。</p>\n<hr>\n<p>刚才有同事问我，当疫情结束后有什么特别想见的人。</p>\n<p>我沉默了，脑中却谁都想不起来，好像我的人生还并没有开始就已经迷茫了。</p>\n","excerpt":"","more":"<blockquote>\n<p>由于疫情原因这个假期格外得长</p>\n</blockquote>\n<p>过完元宵我才回上海，在家又连续办公两周后才去的公司。</p>\n<p>中国加油！武汉加油！</p>\n<p>现在是两月底，从数据上来看疫情已经得到了有效的控制，疑似人数以及确诊人数都有比较大的降幅。当然，股市也是……</p>\n<p>反而看着国外数据越来越大，外围开始恐慌，中国当然也不可能独善其身。</p>\n<p>活在当下，生命至上！</p>\n<p>愿所有人 无疾无病 无忧无怖 无愧于心。</p>\n<hr>\n<p>刚才有同事问我，当疫情结束后有什么特别想见的人。</p>\n<p>我沉默了，脑中却谁都想不起来，好像我的人生还并没有开始就已经迷茫了。</p>\n"},{"title":"破局四月（2023）","date":"2023-05-02T13:10:55.000Z","_content":"\n\n首先说下这次北遇的婚纱照拍摄，总体来讲还是蛮不错的。\n\n我们是前一天在那附近找了个宾馆住了一晚，然后当天一大早骑了个自行车过去，早上八点到那，晚上全部弄完已经是十一点多了。三个内景一个外景，全程服务态度是蛮好的，摄影师也很有耐心，最后出来的片我们也是比较满意的，总之是安全下车了。\n\n\n四月份的天气已经开始回暖，后面几天已经是可以穿短袖短裤出门了。这个五一天气也是蛮好的，我们去了一趟启东吃龙虾，顺便学会了启东麻将打法，假期过得还是闪电那般快。假期结束回来周六还得上班，真是无心上班啊现在。\n\n\n前几天服务器又提示要续费了，一年大几百的费用我也基本就挂个博客，实在是划不来啊。不打算续了，直接白嫖 GitHub 的好了，不浪费钱了，现在钱不好赚啊。\n\n\n又重新买了塞尔达玩，都说是 YYDS，我这次好好玩玩，认真玩，深度体验体验。说真的，switch 确实一般，买来大多数时间就是放着落灰，躺着有时间就刷剧，没多少会去玩会游戏消遣，更别说是没有人一起玩了。\n\n\n过了四月已经是五月了，之后就是六月，日子过得快得哟！","source":"_posts/broken-april.md","raw":"---\ntitle: 破局四月（2023）\ndate: 2023-05-02 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n\n首先说下这次北遇的婚纱照拍摄，总体来讲还是蛮不错的。\n\n我们是前一天在那附近找了个宾馆住了一晚，然后当天一大早骑了个自行车过去，早上八点到那，晚上全部弄完已经是十一点多了。三个内景一个外景，全程服务态度是蛮好的，摄影师也很有耐心，最后出来的片我们也是比较满意的，总之是安全下车了。\n\n\n四月份的天气已经开始回暖，后面几天已经是可以穿短袖短裤出门了。这个五一天气也是蛮好的，我们去了一趟启东吃龙虾，顺便学会了启东麻将打法，假期过得还是闪电那般快。假期结束回来周六还得上班，真是无心上班啊现在。\n\n\n前几天服务器又提示要续费了，一年大几百的费用我也基本就挂个博客，实在是划不来啊。不打算续了，直接白嫖 GitHub 的好了，不浪费钱了，现在钱不好赚啊。\n\n\n又重新买了塞尔达玩，都说是 YYDS，我这次好好玩玩，认真玩，深度体验体验。说真的，switch 确实一般，买来大多数时间就是放着落灰，躺着有时间就刷剧，没多少会去玩会游戏消遣，更别说是没有人一起玩了。\n\n\n过了四月已经是五月了，之后就是六月，日子过得快得哟！","slug":"broken-april","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjha002ok9i1bhm3eq1s","content":"<p>首先说下这次北遇的婚纱照拍摄，总体来讲还是蛮不错的。</p>\n<p>我们是前一天在那附近找了个宾馆住了一晚，然后当天一大早骑了个自行车过去，早上八点到那，晚上全部弄完已经是十一点多了。三个内景一个外景，全程服务态度是蛮好的，摄影师也很有耐心，最后出来的片我们也是比较满意的，总之是安全下车了。</p>\n<p>四月份的天气已经开始回暖，后面几天已经是可以穿短袖短裤出门了。这个五一天气也是蛮好的，我们去了一趟启东吃龙虾，顺便学会了启东麻将打法，假期过得还是闪电那般快。假期结束回来周六还得上班，真是无心上班啊现在。</p>\n<p>前几天服务器又提示要续费了，一年大几百的费用我也基本就挂个博客，实在是划不来啊。不打算续了，直接白嫖 GitHub 的好了，不浪费钱了，现在钱不好赚啊。</p>\n<p>又重新买了塞尔达玩，都说是 YYDS，我这次好好玩玩，认真玩，深度体验体验。说真的，switch 确实一般，买来大多数时间就是放着落灰，躺着有时间就刷剧，没多少会去玩会游戏消遣，更别说是没有人一起玩了。</p>\n<p>过了四月已经是五月了，之后就是六月，日子过得快得哟！</p>\n","excerpt":"","more":"<p>首先说下这次北遇的婚纱照拍摄，总体来讲还是蛮不错的。</p>\n<p>我们是前一天在那附近找了个宾馆住了一晚，然后当天一大早骑了个自行车过去，早上八点到那，晚上全部弄完已经是十一点多了。三个内景一个外景，全程服务态度是蛮好的，摄影师也很有耐心，最后出来的片我们也是比较满意的，总之是安全下车了。</p>\n<p>四月份的天气已经开始回暖，后面几天已经是可以穿短袖短裤出门了。这个五一天气也是蛮好的，我们去了一趟启东吃龙虾，顺便学会了启东麻将打法，假期过得还是闪电那般快。假期结束回来周六还得上班，真是无心上班啊现在。</p>\n<p>前几天服务器又提示要续费了，一年大几百的费用我也基本就挂个博客，实在是划不来啊。不打算续了，直接白嫖 GitHub 的好了，不浪费钱了，现在钱不好赚啊。</p>\n<p>又重新买了塞尔达玩，都说是 YYDS，我这次好好玩玩，认真玩，深度体验体验。说真的，switch 确实一般，买来大多数时间就是放着落灰，躺着有时间就刷剧，没多少会去玩会游戏消遣，更别说是没有人一起玩了。</p>\n<p>过了四月已经是五月了，之后就是六月，日子过得快得哟！</p>\n"},{"title":"碌碌十月（2020）","date":"2020-10-29T08:10:55.000Z","_content":"\n> 看这一年写的博文就知道了，今年又没有什么技术上的深入。不知道都在忙些什么。\n\n国庆节回家也没干啥事，参加了表姐的婚礼，然后就在家呆着，看完了两部电视剧。外甥女胖乎乎的，见着都说是个小胖子，不乖，我抱着时间长就闹腾。\n\n国庆期间在网上把电脑配件都买了，加上显示器花了 6k+，10400F+B460 组合，大学室长推荐，性价比确实高平时玩玩足以，比之前那配置肯定好得多得多了。刚好下月横店半马开始，请个假回趟家把家里那台古董机给换了。\n\n换了电脑体验飞起，从此走上大型单机端游不归路。就这几天 steam 上又花了几百了，看着都在打折做活动就没忍住，之前大表哥打折时候没买刚好先把 GTA5 和古墓 10 玩了先，现在的游戏体验度确实很不错，沉浸式剧情体验加上 VR 的话肯定更爽，就是太费时间了。总感觉游戏娱乐行业有一股力量一直在潜伏，不久的将来就会一下子爆发起来，我是坚定看好娱乐行业，物质满足之后总是要追求精神的，何况精神上某种程度可以暂时弥补物质上的缺失。随着科技突破，软硬件的提升所带来的娱乐门槛的降低，不需多久，可期。\n\n前段时间报了个上海百威 10km 健康跑，绕着世纪公园跑两圈。我和一同事一起参加，结果跑着跑着我就不见他的车尾灯了，等我到终点时他已经在那休息了十五分钟……体验还行，赞助商安德玛的速干T恤款式和质量也不孬。下月的半马坚持到终点就成，重在参与，重在健身。\n\n最近也是，下班也早不了，公司也慢慢开始多了些硬性要求。今天 1024  也逃不开在公司“聚会”的命运，打工人不易啊。\n\n今年就等着 HUAWEI Mate40 发布准备换机呢，结果货少搞饥饿营销，想买还买不着。不会这次真成了华为手机绝唱麒麟芯片吧，手机价格三年翻一番，今年也受到各种被老美压制的影响，电子产品都多多少少涨了不少。等过段时间货都放出来了准备买一款绿色的，款式还挺中意，就不知道什么时候才能买得到了。","source":"_posts/bustle-october.md","raw":"---\ntitle: 碌碌十月（2020）\ndate: 2020-10-29 16:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 看这一年写的博文就知道了，今年又没有什么技术上的深入。不知道都在忙些什么。\n\n国庆节回家也没干啥事，参加了表姐的婚礼，然后就在家呆着，看完了两部电视剧。外甥女胖乎乎的，见着都说是个小胖子，不乖，我抱着时间长就闹腾。\n\n国庆期间在网上把电脑配件都买了，加上显示器花了 6k+，10400F+B460 组合，大学室长推荐，性价比确实高平时玩玩足以，比之前那配置肯定好得多得多了。刚好下月横店半马开始，请个假回趟家把家里那台古董机给换了。\n\n换了电脑体验飞起，从此走上大型单机端游不归路。就这几天 steam 上又花了几百了，看着都在打折做活动就没忍住，之前大表哥打折时候没买刚好先把 GTA5 和古墓 10 玩了先，现在的游戏体验度确实很不错，沉浸式剧情体验加上 VR 的话肯定更爽，就是太费时间了。总感觉游戏娱乐行业有一股力量一直在潜伏，不久的将来就会一下子爆发起来，我是坚定看好娱乐行业，物质满足之后总是要追求精神的，何况精神上某种程度可以暂时弥补物质上的缺失。随着科技突破，软硬件的提升所带来的娱乐门槛的降低，不需多久，可期。\n\n前段时间报了个上海百威 10km 健康跑，绕着世纪公园跑两圈。我和一同事一起参加，结果跑着跑着我就不见他的车尾灯了，等我到终点时他已经在那休息了十五分钟……体验还行，赞助商安德玛的速干T恤款式和质量也不孬。下月的半马坚持到终点就成，重在参与，重在健身。\n\n最近也是，下班也早不了，公司也慢慢开始多了些硬性要求。今天 1024  也逃不开在公司“聚会”的命运，打工人不易啊。\n\n今年就等着 HUAWEI Mate40 发布准备换机呢，结果货少搞饥饿营销，想买还买不着。不会这次真成了华为手机绝唱麒麟芯片吧，手机价格三年翻一番，今年也受到各种被老美压制的影响，电子产品都多多少少涨了不少。等过段时间货都放出来了准备买一款绿色的，款式还挺中意，就不知道什么时候才能买得到了。","slug":"bustle-october","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhb002rk9i17zexfgrt","content":"<blockquote>\n<p>看这一年写的博文就知道了，今年又没有什么技术上的深入。不知道都在忙些什么。</p>\n</blockquote>\n<p>国庆节回家也没干啥事，参加了表姐的婚礼，然后就在家呆着，看完了两部电视剧。外甥女胖乎乎的，见着都说是个小胖子，不乖，我抱着时间长就闹腾。</p>\n<p>国庆期间在网上把电脑配件都买了，加上显示器花了 6k+，10400F+B460 组合，大学室长推荐，性价比确实高平时玩玩足以，比之前那配置肯定好得多得多了。刚好下月横店半马开始，请个假回趟家把家里那台古董机给换了。</p>\n<p>换了电脑体验飞起，从此走上大型单机端游不归路。就这几天 steam 上又花了几百了，看着都在打折做活动就没忍住，之前大表哥打折时候没买刚好先把 GTA5 和古墓 10 玩了先，现在的游戏体验度确实很不错，沉浸式剧情体验加上 VR 的话肯定更爽，就是太费时间了。总感觉游戏娱乐行业有一股力量一直在潜伏，不久的将来就会一下子爆发起来，我是坚定看好娱乐行业，物质满足之后总是要追求精神的，何况精神上某种程度可以暂时弥补物质上的缺失。随着科技突破，软硬件的提升所带来的娱乐门槛的降低，不需多久，可期。</p>\n<p>前段时间报了个上海百威 10km 健康跑，绕着世纪公园跑两圈。我和一同事一起参加，结果跑着跑着我就不见他的车尾灯了，等我到终点时他已经在那休息了十五分钟……体验还行，赞助商安德玛的速干T恤款式和质量也不孬。下月的半马坚持到终点就成，重在参与，重在健身。</p>\n<p>最近也是，下班也早不了，公司也慢慢开始多了些硬性要求。今天 1024  也逃不开在公司“聚会”的命运，打工人不易啊。</p>\n<p>今年就等着 HUAWEI Mate40 发布准备换机呢，结果货少搞饥饿营销，想买还买不着。不会这次真成了华为手机绝唱麒麟芯片吧，手机价格三年翻一番，今年也受到各种被老美压制的影响，电子产品都多多少少涨了不少。等过段时间货都放出来了准备买一款绿色的，款式还挺中意，就不知道什么时候才能买得到了。</p>\n","excerpt":"","more":"<blockquote>\n<p>看这一年写的博文就知道了，今年又没有什么技术上的深入。不知道都在忙些什么。</p>\n</blockquote>\n<p>国庆节回家也没干啥事，参加了表姐的婚礼，然后就在家呆着，看完了两部电视剧。外甥女胖乎乎的，见着都说是个小胖子，不乖，我抱着时间长就闹腾。</p>\n<p>国庆期间在网上把电脑配件都买了，加上显示器花了 6k+，10400F+B460 组合，大学室长推荐，性价比确实高平时玩玩足以，比之前那配置肯定好得多得多了。刚好下月横店半马开始，请个假回趟家把家里那台古董机给换了。</p>\n<p>换了电脑体验飞起，从此走上大型单机端游不归路。就这几天 steam 上又花了几百了，看着都在打折做活动就没忍住，之前大表哥打折时候没买刚好先把 GTA5 和古墓 10 玩了先，现在的游戏体验度确实很不错，沉浸式剧情体验加上 VR 的话肯定更爽，就是太费时间了。总感觉游戏娱乐行业有一股力量一直在潜伏，不久的将来就会一下子爆发起来，我是坚定看好娱乐行业，物质满足之后总是要追求精神的，何况精神上某种程度可以暂时弥补物质上的缺失。随着科技突破，软硬件的提升所带来的娱乐门槛的降低，不需多久，可期。</p>\n<p>前段时间报了个上海百威 10km 健康跑，绕着世纪公园跑两圈。我和一同事一起参加，结果跑着跑着我就不见他的车尾灯了，等我到终点时他已经在那休息了十五分钟……体验还行，赞助商安德玛的速干T恤款式和质量也不孬。下月的半马坚持到终点就成，重在参与，重在健身。</p>\n<p>最近也是，下班也早不了，公司也慢慢开始多了些硬性要求。今天 1024  也逃不开在公司“聚会”的命运，打工人不易啊。</p>\n<p>今年就等着 HUAWEI Mate40 发布准备换机呢，结果货少搞饥饿营销，想买还买不着。不会这次真成了华为手机绝唱麒麟芯片吧，手机价格三年翻一番，今年也受到各种被老美压制的影响，电子产品都多多少少涨了不少。等过段时间货都放出来了准备买一款绿色的，款式还挺中意，就不知道什么时候才能买得到了。</p>\n"},{"title":"忙碌三月（2019）","date":"2019-04-03T01:10:26.000Z","_content":"\n> 三月头到三月底算是在这公司至今最忙的一段时间了\n\n\n从三月初去昆明之后回来又去临港来回三趟，之后又是世博文化中心项目急得要死，加班赶项目还花了两周末。\n\n还不错，今年公司五月去海岛旅游，该加紧锻炼了！\n\n---\n\n## 昆明\n说来惭愧，昆明这趟是我的“处女飞”，去的时候坐的是吉祥航空经济舱，体验是真特么差，便宜啊便宜。回来坐的是昆明航空经济舱，贵是贵了，体验也确实好很多，不知什么时候能体验下头等舱的魅力。\n\n去了昆明长水机场，那确实是偏了点，坐了两个多小时才到了目的地。之后在昆明医科大学吃了顿饭，附近找了个宾馆，乖乖，全程微信沟通，就过来送了个发票。\n\n![昆明路上拍摄的黄金龙头](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/dragon.jpg)\n\n你说这是“凤凰”？没差，龙凤呈祥！\n\n去的时候那边温度比上海要高个 10℃，宾馆中都不带空调的，听说是四季如春啊，蓝天白云真不错。虽然没有大都市那么繁华，也很安谧，宜居。\n\n晚上没事干搜了附近，去了家汗蒸店，结果一进去发现全是女的，尴尬。附近学校多嘛，女同学经常会来汗蒸放松放松，我就找了个角落闭目凝神静气。大概蒸了一个半小时，全身真的蒸透了，很舒服。\n\n## 临港\n临港创新科技城，规模不小设计造型独特，几年后估计又是一片天地。临港现在没有像市区那么繁华，街道上也几乎没什么人，打个车也没那么方便，不过看这发展的样子，未来也是个不错的地方，如果生活工作都在临港，那绝对幸福感不会低，看了下，均价三万一平吧。\n\n去临港三月去了三趟，过去要 8 号线 -> 2 号线 -> 16 号线，将近三小时的路程。不过还好，每次都待了个几天不然一天来回估计脑袋够呛。\n\n公司接的项目都这么高级，着实厉害。\n\n原先我们都是现场用 485 串口服务器直连现场服务器进行数据采集，包括这个临港项目也是。之后准备用 485 转 GPRS 透传功能直接与公司外网 IP 暴露出去的端口进行数据传输，这样就不用在现场布置服务器了，直接在公司服务器部署采集即可。不过这样必然对现场工人们的技术要求提高些，不光要保证传感器的完好还要保证采集设备的完好还要过程中接线的正确性，由于现场技术人员不在就需要他们要有一定的问题排查能力。有利有弊吧，不过总体是方便了不少。\n\n## 世博\n上海世博文化中心项目最近要收尾了，公司干活人数有限，之前催死了。这项目还是用的现场部署服务器进行数据采集，不过用的是 4G 路由器，无固定外网 IP，所以现场能访问公司服务器，而外部访问不了，这就需要之前我总结过的[使用 ssh 反向隧道穿透 NAT 访问 Linux 内网主机](http://putop.top/2018/11/03/ssh-nat-ubuntu/)。然后还有一个问题就是数据需要同步到公司服务器，不然无法给业主实时查看。针对业务需求，通过一系列的资料查找，最终选择阿里开源的项目 otter，具体可看[记录 otter 数据同步](https://blog.csdn.net/ffj0721/article/details/88836302)。\n\n加了几天班，终于也是告一段落了。\n\n还没缓过来，松江云廊屋盖项目也要来了，今年真是项目都堆积一起了。\n\n---\n\n期待五月的海岛游（听说是塞班岛，俺土鳖，哪都成！）\n\n","source":"_posts/busy-march.md","raw":"---\ntitle: 忙碌三月（2019）\ndate: 2019-04-03 09:10:26\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 三月头到三月底算是在这公司至今最忙的一段时间了\n\n\n从三月初去昆明之后回来又去临港来回三趟，之后又是世博文化中心项目急得要死，加班赶项目还花了两周末。\n\n还不错，今年公司五月去海岛旅游，该加紧锻炼了！\n\n---\n\n## 昆明\n说来惭愧，昆明这趟是我的“处女飞”，去的时候坐的是吉祥航空经济舱，体验是真特么差，便宜啊便宜。回来坐的是昆明航空经济舱，贵是贵了，体验也确实好很多，不知什么时候能体验下头等舱的魅力。\n\n去了昆明长水机场，那确实是偏了点，坐了两个多小时才到了目的地。之后在昆明医科大学吃了顿饭，附近找了个宾馆，乖乖，全程微信沟通，就过来送了个发票。\n\n![昆明路上拍摄的黄金龙头](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/dragon.jpg)\n\n你说这是“凤凰”？没差，龙凤呈祥！\n\n去的时候那边温度比上海要高个 10℃，宾馆中都不带空调的，听说是四季如春啊，蓝天白云真不错。虽然没有大都市那么繁华，也很安谧，宜居。\n\n晚上没事干搜了附近，去了家汗蒸店，结果一进去发现全是女的，尴尬。附近学校多嘛，女同学经常会来汗蒸放松放松，我就找了个角落闭目凝神静气。大概蒸了一个半小时，全身真的蒸透了，很舒服。\n\n## 临港\n临港创新科技城，规模不小设计造型独特，几年后估计又是一片天地。临港现在没有像市区那么繁华，街道上也几乎没什么人，打个车也没那么方便，不过看这发展的样子，未来也是个不错的地方，如果生活工作都在临港，那绝对幸福感不会低，看了下，均价三万一平吧。\n\n去临港三月去了三趟，过去要 8 号线 -> 2 号线 -> 16 号线，将近三小时的路程。不过还好，每次都待了个几天不然一天来回估计脑袋够呛。\n\n公司接的项目都这么高级，着实厉害。\n\n原先我们都是现场用 485 串口服务器直连现场服务器进行数据采集，包括这个临港项目也是。之后准备用 485 转 GPRS 透传功能直接与公司外网 IP 暴露出去的端口进行数据传输，这样就不用在现场布置服务器了，直接在公司服务器部署采集即可。不过这样必然对现场工人们的技术要求提高些，不光要保证传感器的完好还要保证采集设备的完好还要过程中接线的正确性，由于现场技术人员不在就需要他们要有一定的问题排查能力。有利有弊吧，不过总体是方便了不少。\n\n## 世博\n上海世博文化中心项目最近要收尾了，公司干活人数有限，之前催死了。这项目还是用的现场部署服务器进行数据采集，不过用的是 4G 路由器，无固定外网 IP，所以现场能访问公司服务器，而外部访问不了，这就需要之前我总结过的[使用 ssh 反向隧道穿透 NAT 访问 Linux 内网主机](http://putop.top/2018/11/03/ssh-nat-ubuntu/)。然后还有一个问题就是数据需要同步到公司服务器，不然无法给业主实时查看。针对业务需求，通过一系列的资料查找，最终选择阿里开源的项目 otter，具体可看[记录 otter 数据同步](https://blog.csdn.net/ffj0721/article/details/88836302)。\n\n加了几天班，终于也是告一段落了。\n\n还没缓过来，松江云廊屋盖项目也要来了，今年真是项目都堆积一起了。\n\n---\n\n期待五月的海岛游（听说是塞班岛，俺土鳖，哪都成！）\n\n","slug":"busy-march","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhb002wk9i10m6q03zc","content":"<blockquote>\n<p>三月头到三月底算是在这公司至今最忙的一段时间了</p>\n</blockquote>\n<p>从三月初去昆明之后回来又去临港来回三趟，之后又是世博文化中心项目急得要死，加班赶项目还花了两周末。</p>\n<p>还不错，今年公司五月去海岛旅游，该加紧锻炼了！</p>\n<hr>\n<h2 id=\"昆明\"><a href=\"#昆明\" class=\"headerlink\" title=\"昆明\"></a>昆明</h2><p>说来惭愧，昆明这趟是我的“处女飞”，去的时候坐的是吉祥航空经济舱，体验是真特么差，便宜啊便宜。回来坐的是昆明航空经济舱，贵是贵了，体验也确实好很多，不知什么时候能体验下头等舱的魅力。</p>\n<p>去了昆明长水机场，那确实是偏了点，坐了两个多小时才到了目的地。之后在昆明医科大学吃了顿饭，附近找了个宾馆，乖乖，全程微信沟通，就过来送了个发票。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/dragon.jpg\" alt=\"昆明路上拍摄的黄金龙头\"></p>\n<p>你说这是“凤凰”？没差，龙凤呈祥！</p>\n<p>去的时候那边温度比上海要高个 10℃，宾馆中都不带空调的，听说是四季如春啊，蓝天白云真不错。虽然没有大都市那么繁华，也很安谧，宜居。</p>\n<p>晚上没事干搜了附近，去了家汗蒸店，结果一进去发现全是女的，尴尬。附近学校多嘛，女同学经常会来汗蒸放松放松，我就找了个角落闭目凝神静气。大概蒸了一个半小时，全身真的蒸透了，很舒服。</p>\n<h2 id=\"临港\"><a href=\"#临港\" class=\"headerlink\" title=\"临港\"></a>临港</h2><p>临港创新科技城，规模不小设计造型独特，几年后估计又是一片天地。临港现在没有像市区那么繁华，街道上也几乎没什么人，打个车也没那么方便，不过看这发展的样子，未来也是个不错的地方，如果生活工作都在临港，那绝对幸福感不会低，看了下，均价三万一平吧。</p>\n<p>去临港三月去了三趟，过去要 8 号线 -&gt; 2 号线 -&gt; 16 号线，将近三小时的路程。不过还好，每次都待了个几天不然一天来回估计脑袋够呛。</p>\n<p>公司接的项目都这么高级，着实厉害。</p>\n<p>原先我们都是现场用 485 串口服务器直连现场服务器进行数据采集，包括这个临港项目也是。之后准备用 485 转 GPRS 透传功能直接与公司外网 IP 暴露出去的端口进行数据传输，这样就不用在现场布置服务器了，直接在公司服务器部署采集即可。不过这样必然对现场工人们的技术要求提高些，不光要保证传感器的完好还要保证采集设备的完好还要过程中接线的正确性，由于现场技术人员不在就需要他们要有一定的问题排查能力。有利有弊吧，不过总体是方便了不少。</p>\n<h2 id=\"世博\"><a href=\"#世博\" class=\"headerlink\" title=\"世博\"></a>世博</h2><p>上海世博文化中心项目最近要收尾了，公司干活人数有限，之前催死了。这项目还是用的现场部署服务器进行数据采集，不过用的是 4G 路由器，无固定外网 IP，所以现场能访问公司服务器，而外部访问不了，这就需要之前我总结过的<a href=\"http://putop.top/2018/11/03/ssh-nat-ubuntu/\">使用 ssh 反向隧道穿透 NAT 访问 Linux 内网主机</a>。然后还有一个问题就是数据需要同步到公司服务器，不然无法给业主实时查看。针对业务需求，通过一系列的资料查找，最终选择阿里开源的项目 otter，具体可看<a href=\"https://blog.csdn.net/ffj0721/article/details/88836302\">记录 otter 数据同步</a>。</p>\n<p>加了几天班，终于也是告一段落了。</p>\n<p>还没缓过来，松江云廊屋盖项目也要来了，今年真是项目都堆积一起了。</p>\n<hr>\n<p>期待五月的海岛游（听说是塞班岛，俺土鳖，哪都成！）</p>\n","excerpt":"","more":"<blockquote>\n<p>三月头到三月底算是在这公司至今最忙的一段时间了</p>\n</blockquote>\n<p>从三月初去昆明之后回来又去临港来回三趟，之后又是世博文化中心项目急得要死，加班赶项目还花了两周末。</p>\n<p>还不错，今年公司五月去海岛旅游，该加紧锻炼了！</p>\n<hr>\n<h2 id=\"昆明\"><a href=\"#昆明\" class=\"headerlink\" title=\"昆明\"></a>昆明</h2><p>说来惭愧，昆明这趟是我的“处女飞”，去的时候坐的是吉祥航空经济舱，体验是真特么差，便宜啊便宜。回来坐的是昆明航空经济舱，贵是贵了，体验也确实好很多，不知什么时候能体验下头等舱的魅力。</p>\n<p>去了昆明长水机场，那确实是偏了点，坐了两个多小时才到了目的地。之后在昆明医科大学吃了顿饭，附近找了个宾馆，乖乖，全程微信沟通，就过来送了个发票。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/dragon.jpg\" alt=\"昆明路上拍摄的黄金龙头\"></p>\n<p>你说这是“凤凰”？没差，龙凤呈祥！</p>\n<p>去的时候那边温度比上海要高个 10℃，宾馆中都不带空调的，听说是四季如春啊，蓝天白云真不错。虽然没有大都市那么繁华，也很安谧，宜居。</p>\n<p>晚上没事干搜了附近，去了家汗蒸店，结果一进去发现全是女的，尴尬。附近学校多嘛，女同学经常会来汗蒸放松放松，我就找了个角落闭目凝神静气。大概蒸了一个半小时，全身真的蒸透了，很舒服。</p>\n<h2 id=\"临港\"><a href=\"#临港\" class=\"headerlink\" title=\"临港\"></a>临港</h2><p>临港创新科技城，规模不小设计造型独特，几年后估计又是一片天地。临港现在没有像市区那么繁华，街道上也几乎没什么人，打个车也没那么方便，不过看这发展的样子，未来也是个不错的地方，如果生活工作都在临港，那绝对幸福感不会低，看了下，均价三万一平吧。</p>\n<p>去临港三月去了三趟，过去要 8 号线 -&gt; 2 号线 -&gt; 16 号线，将近三小时的路程。不过还好，每次都待了个几天不然一天来回估计脑袋够呛。</p>\n<p>公司接的项目都这么高级，着实厉害。</p>\n<p>原先我们都是现场用 485 串口服务器直连现场服务器进行数据采集，包括这个临港项目也是。之后准备用 485 转 GPRS 透传功能直接与公司外网 IP 暴露出去的端口进行数据传输，这样就不用在现场布置服务器了，直接在公司服务器部署采集即可。不过这样必然对现场工人们的技术要求提高些，不光要保证传感器的完好还要保证采集设备的完好还要过程中接线的正确性，由于现场技术人员不在就需要他们要有一定的问题排查能力。有利有弊吧，不过总体是方便了不少。</p>\n<h2 id=\"世博\"><a href=\"#世博\" class=\"headerlink\" title=\"世博\"></a>世博</h2><p>上海世博文化中心项目最近要收尾了，公司干活人数有限，之前催死了。这项目还是用的现场部署服务器进行数据采集，不过用的是 4G 路由器，无固定外网 IP，所以现场能访问公司服务器，而外部访问不了，这就需要之前我总结过的<a href=\"http://putop.top/2018/11/03/ssh-nat-ubuntu/\">使用 ssh 反向隧道穿透 NAT 访问 Linux 内网主机</a>。然后还有一个问题就是数据需要同步到公司服务器，不然无法给业主实时查看。针对业务需求，通过一系列的资料查找，最终选择阿里开源的项目 otter，具体可看<a href=\"https://blog.csdn.net/ffj0721/article/details/88836302\">记录 otter 数据同步</a>。</p>\n<p>加了几天班，终于也是告一段落了。</p>\n<p>还没缓过来，松江云廊屋盖项目也要来了，今年真是项目都堆积一起了。</p>\n<hr>\n<p>期待五月的海岛游（听说是塞班岛，俺土鳖，哪都成！）</p>\n"},{"title":"忙碌五月（2023）","date":"2023-05-28T13:10:55.000Z","_content":"\n> 这个五月忙忙碌碌，天气也时晴时雨。\n\n为什么这个月会是忙碌的呢，因为这个月我们又搬家了！沪漂的日子往往在搬家的时候最为狼狈。\n\n本来我们房子是六月初才到期，但是我们那不讲道理的二房东急急找了下家，想要我们提前搬走。本来确实我们可以不搬的，但一想到我们刚好也想早点搬走，就也去匆匆找了房子。找房子还算顺利，两趟就敲定了下来，这次是一房东，我是真不想再遇上个二房东了，有些二房东是真的难扯，就好比我们遇到的这个。搬的那天叫了一辆依维柯，本来以为是妥妥的了，毕竟我们上次搬家叫的车还没这个大，可谁想到，完全塞不下。后来又叫了一辆依维柯，满满塞下，这才全部搬了过来。两个人的东西也不少，真是不想再这么折腾搬家了，累不说，收拾还麻烦。\n\n最近几天做了一个小程序：[计分小能手](http://cdn.putop.top/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%AE%A1%E5%88%86%E5%B0%8F%E8%83%BD%E6%89%8B.jpg)，为什么会想到做这个小程序也是因为前段时间跟朋友一起打牌，才知道有这种计分的小程序，而且广告多到离谱。我就觉得这个可能以后会经常用到，不如自己做一个，于是就有了这。现在只是实现了简单的功能，因为我毕竟是做后端的，样式啊这种就完全是只是能用。做的过程也是遇到了很多问题，对小程序的开发也更加清楚了。\n\n上面说了搬家，现在我每天上下班变成了坐地铁，以前是骑个电瓶车就到了。也还好，地铁半个多小时，加上两边的步行，从出门到公司差不多五十分钟，还可以接受，每天也是变相可以多走走路。\n\n现在天气真开始越来越热了，我们这次租了个一楼，不知道大夏天会怎么样，因为原先的小院子跟房间改在了一起，所以空间还蛮大的，唯一不足就是通风了，夏天可能会有点闷，估计空调要不少开了。","source":"_posts/busy-may.md","raw":"---\ntitle: 忙碌五月（2023）\ndate: 2023-05-28 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个五月忙忙碌碌，天气也时晴时雨。\n\n为什么这个月会是忙碌的呢，因为这个月我们又搬家了！沪漂的日子往往在搬家的时候最为狼狈。\n\n本来我们房子是六月初才到期，但是我们那不讲道理的二房东急急找了下家，想要我们提前搬走。本来确实我们可以不搬的，但一想到我们刚好也想早点搬走，就也去匆匆找了房子。找房子还算顺利，两趟就敲定了下来，这次是一房东，我是真不想再遇上个二房东了，有些二房东是真的难扯，就好比我们遇到的这个。搬的那天叫了一辆依维柯，本来以为是妥妥的了，毕竟我们上次搬家叫的车还没这个大，可谁想到，完全塞不下。后来又叫了一辆依维柯，满满塞下，这才全部搬了过来。两个人的东西也不少，真是不想再这么折腾搬家了，累不说，收拾还麻烦。\n\n最近几天做了一个小程序：[计分小能手](http://cdn.putop.top/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%AE%A1%E5%88%86%E5%B0%8F%E8%83%BD%E6%89%8B.jpg)，为什么会想到做这个小程序也是因为前段时间跟朋友一起打牌，才知道有这种计分的小程序，而且广告多到离谱。我就觉得这个可能以后会经常用到，不如自己做一个，于是就有了这。现在只是实现了简单的功能，因为我毕竟是做后端的，样式啊这种就完全是只是能用。做的过程也是遇到了很多问题，对小程序的开发也更加清楚了。\n\n上面说了搬家，现在我每天上下班变成了坐地铁，以前是骑个电瓶车就到了。也还好，地铁半个多小时，加上两边的步行，从出门到公司差不多五十分钟，还可以接受，每天也是变相可以多走走路。\n\n现在天气真开始越来越热了，我们这次租了个一楼，不知道大夏天会怎么样，因为原先的小院子跟房间改在了一起，所以空间还蛮大的，唯一不足就是通风了，夏天可能会有点闷，估计空调要不少开了。","slug":"busy-may","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhc002zk9i17lru8se7","content":"<blockquote>\n<p>这个五月忙忙碌碌，天气也时晴时雨。</p>\n</blockquote>\n<p>为什么这个月会是忙碌的呢，因为这个月我们又搬家了！沪漂的日子往往在搬家的时候最为狼狈。</p>\n<p>本来我们房子是六月初才到期，但是我们那不讲道理的二房东急急找了下家，想要我们提前搬走。本来确实我们可以不搬的，但一想到我们刚好也想早点搬走，就也去匆匆找了房子。找房子还算顺利，两趟就敲定了下来，这次是一房东，我是真不想再遇上个二房东了，有些二房东是真的难扯，就好比我们遇到的这个。搬的那天叫了一辆依维柯，本来以为是妥妥的了，毕竟我们上次搬家叫的车还没这个大，可谁想到，完全塞不下。后来又叫了一辆依维柯，满满塞下，这才全部搬了过来。两个人的东西也不少，真是不想再这么折腾搬家了，累不说，收拾还麻烦。</p>\n<p>最近几天做了一个小程序：<a href=\"http://cdn.putop.top/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%AE%A1%E5%88%86%E5%B0%8F%E8%83%BD%E6%89%8B.jpg\">计分小能手</a>，为什么会想到做这个小程序也是因为前段时间跟朋友一起打牌，才知道有这种计分的小程序，而且广告多到离谱。我就觉得这个可能以后会经常用到，不如自己做一个，于是就有了这。现在只是实现了简单的功能，因为我毕竟是做后端的，样式啊这种就完全是只是能用。做的过程也是遇到了很多问题，对小程序的开发也更加清楚了。</p>\n<p>上面说了搬家，现在我每天上下班变成了坐地铁，以前是骑个电瓶车就到了。也还好，地铁半个多小时，加上两边的步行，从出门到公司差不多五十分钟，还可以接受，每天也是变相可以多走走路。</p>\n<p>现在天气真开始越来越热了，我们这次租了个一楼，不知道大夏天会怎么样，因为原先的小院子跟房间改在了一起，所以空间还蛮大的，唯一不足就是通风了，夏天可能会有点闷，估计空调要不少开了。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个五月忙忙碌碌，天气也时晴时雨。</p>\n</blockquote>\n<p>为什么这个月会是忙碌的呢，因为这个月我们又搬家了！沪漂的日子往往在搬家的时候最为狼狈。</p>\n<p>本来我们房子是六月初才到期，但是我们那不讲道理的二房东急急找了下家，想要我们提前搬走。本来确实我们可以不搬的，但一想到我们刚好也想早点搬走，就也去匆匆找了房子。找房子还算顺利，两趟就敲定了下来，这次是一房东，我是真不想再遇上个二房东了，有些二房东是真的难扯，就好比我们遇到的这个。搬的那天叫了一辆依维柯，本来以为是妥妥的了，毕竟我们上次搬家叫的车还没这个大，可谁想到，完全塞不下。后来又叫了一辆依维柯，满满塞下，这才全部搬了过来。两个人的东西也不少，真是不想再这么折腾搬家了，累不说，收拾还麻烦。</p>\n<p>最近几天做了一个小程序：<a href=\"http://cdn.putop.top/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%AE%A1%E5%88%86%E5%B0%8F%E8%83%BD%E6%89%8B.jpg\">计分小能手</a>，为什么会想到做这个小程序也是因为前段时间跟朋友一起打牌，才知道有这种计分的小程序，而且广告多到离谱。我就觉得这个可能以后会经常用到，不如自己做一个，于是就有了这。现在只是实现了简单的功能，因为我毕竟是做后端的，样式啊这种就完全是只是能用。做的过程也是遇到了很多问题，对小程序的开发也更加清楚了。</p>\n<p>上面说了搬家，现在我每天上下班变成了坐地铁，以前是骑个电瓶车就到了。也还好，地铁半个多小时，加上两边的步行，从出门到公司差不多五十分钟，还可以接受，每天也是变相可以多走走路。</p>\n<p>现在天气真开始越来越热了，我们这次租了个一楼，不知道大夏天会怎么样，因为原先的小院子跟房间改在了一起，所以空间还蛮大的，唯一不足就是通风了，夏天可能会有点闷，估计空调要不少开了。</p>\n"},{"title":"忙碌十一月（2018）","date":"2018-11-27T03:51:05.000Z","_content":"\n> 这个十一月为什么说忙碌呢，因为忙着抽纸巾擤鼻涕，感冒了；因为忙着买买买，剁手了；因为忙着来来回回，出差了。\n\n- 感冒\n\n怪我，都怪我，前一段时间温差变化大，我懒啊，没及时加被子，还没穿裤子就睡了，半夜那个冻的，知道冷但就是没爬起来加被子，然后，感冒了一周，鼻子都搞破皮了……\n\n后来晚上还去夜跑，跑完当时感觉好点了，结果洗了个澡之后，鼻涕又来了，睡觉时候那个呼吸难受的啊，还好我床头纸管够……\n\n- 买买买\n\n最近买了不少东西，买了件大衣，结果稍稍大了点，不换了吧来来回回的，凑活穿。还买了几双鞋，什么耐克阿迪的，便宜的太丑，好看的太贵还没货，倒是对彪马越来越感兴趣，价格还行，款式也还行（不还是因为较之便宜嘛……）。\n\n气的是有双鞋刚买了不到一个月就又看到大降价，差了一百来块呢，唉，安慰自己毕竟早穿上了这么多天呢不是……\n\n平时感觉穿的也都有，但是人嘛，喜新厌旧，而且这个购物啊，确实是精神上不一样啊，单身狗的刺激手段之一了，避免一直陷在麻木的生活状态之中。偶尔还是需要精神刺激的，啊，好疼~\n\n搞了套迪卡侬的运动装备，迪卡侬性价比真高，懊恼自己以前怎么不去了解，东西感觉都不错，大赞！以后运动装备就尽量选择迪卡侬了。\n\n- 金链子\n\n去年就跟老姐说过今年要给老妈买条大金链子的，身上什么首饰也没有，着实不好了点。故趁着发工资了，给老姐打过去 2000 块，“给老妈买条大金链子！其余的你补上！”哈哈，2000 肯定是不够买的，怪儿子出门在外没挣到什么钱，心意到了啊。回头给老爸搞双皮鞋，本来是去年买的，唉，加油加油！\n\n说到金，家里爷爷还留给我一个纯金戒指来着。小时候我看着那戒指，心想，这纯金戒指，得值多少钱啊。现在知道了，也就值个千把块钱……还用来传家呢……看什么时候给它化了，弄成其他的，金戒指也忒俗气了些。\n\n- 路上姑娘\n\n今儿早又看到这姑娘了，所以我才把这提上来。\n\n姑娘长发小脸，笑意浓浓，纤细身材，气质不凡。\n\n我们往往是在五角场附近相遇的。我骑着车，她低着头。\n\n虽然我看她时她没看过我，但我却看到她眼睛在笑，即使我那只是短短的一瞥，看得却异常清楚。有一种熟悉的感觉爬上了我的心头。可能是我接触异性少了，脑子出现了毛病……用我大学室友一句口头禅来说就是：这个不孬。\n\n也正是这几个月来遇到了很多次，且位置都大差不差，我这才记住了，不知道她是否注意到我没……\n\n人的一生会遇到许许多多的人。佛说，前世的五百次回眸，才换来今生的擦肩而过。\n\n如果无缘，我只愿你一生安好，陌生人。\n\n- 出差\n\n出差了出差了，人生中的第一次出差啊。这次去杭州出差了一周，期间自然不是很顺利。项目上的就不多说了，这个晚上啊，因为还有一位同事一起的，所以我们就定的标间。\n\n我那几天都是凌晨才慢慢睡去。为什么？旁边有位打呼跟电钻工装修一样的，要搁你，你能睡得着不……我还那会感冒没好全，身体素质是真不好，鼻血都流了好几回也不知道是不是擤鼻涕用力过猛了。\n\n而且我这个头啊，右脑勺还真刺疼，公司体检卡发了，不过要下月才开始能预约，希望一切健康，买的保险用不上啊……\n\n说到买的保险，买了个泰康的，送了个洗牙套餐，上月预约的都只能预约到一月份了，全家现在就我这口牙还行，最近好像也是开始出问题了，我得勤刷牙了，晚上不忘记能刷就刷。\n\n拉回来说这个出差。由于我也没有经验，也没有什么准备，导致我根本就找不到可以冲账的发票，最后还是用的领导的燃油发票来报。看来，以后要多攒攒发票了，虽说出差少，备着吧。\n\n- 余华\n\n余华，当代著名作家，他的许多作品获过国内外奖项。\n\n不知道，没关系。《活着》这部小说，总看过吧，没看过总听说过吧。没听说过？那我劝你现在就拿起手机打开 APP，订购一本，不要 998，也不要 198，它只要二十来块就能买到。\n\n记得当时我是花了一个晚上把《活着》给看完的，情节太紧凑了根本不给我歇的机会，看了停不下来，等歇下来了，原来后面没了，翻到了最后一页。\n\n最近我又在看他的另一本长篇小说《兄弟》。文人骚客，不骚就不叫文人了。不过里面骚的恰到好处，连接情节，更能吸引读者，引人入胜。\n\n大体上，我看到现在，主色调还是悲的，也是在文革前后那段时间下描述的故事。极具讽刺意味。\n\n只要能捱过来，那就都不是事。\n\n- 蒋劲夫家暴\n\n今天早上又刷到了这个新闻。家暴，我是不可能家暴的，真的很气愤也只会动动嘴皮子，大不了就出门透透气。个人认为，家暴确实是做不得，也不是男人该做的事。当然，会有些人有暴力倾向，更可怕的是有些女人还会十分享受被家暴的过程，这种人呢肯定是有的，而且可能还不少。\n\n大家夫妻之间，情侣之间搞搞 SM 啊什么的我倒是觉得很正常，别动不动就搞出血还搞出命，不值当啊！所以，两人在一起，这些东西都是需要熟知的，要了解清楚，三观不合的怎么可能长久，那种一夜情的就没必要查户口了。\n\n---\n\n真快啊都要 2018 12 月份了，下次写个年终总结，好好借机回顾一下自己这一年来的成长。长肯定是有长的，长哪就不知道了。\n\n哈哈，生死本无常，人应多思量。","source":"_posts/busy-november-2018.md","raw":"---\ntitle: 忙碌十一月（2018）\ndate: 2018-11-27 11:51:05\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个十一月为什么说忙碌呢，因为忙着抽纸巾擤鼻涕，感冒了；因为忙着买买买，剁手了；因为忙着来来回回，出差了。\n\n- 感冒\n\n怪我，都怪我，前一段时间温差变化大，我懒啊，没及时加被子，还没穿裤子就睡了，半夜那个冻的，知道冷但就是没爬起来加被子，然后，感冒了一周，鼻子都搞破皮了……\n\n后来晚上还去夜跑，跑完当时感觉好点了，结果洗了个澡之后，鼻涕又来了，睡觉时候那个呼吸难受的啊，还好我床头纸管够……\n\n- 买买买\n\n最近买了不少东西，买了件大衣，结果稍稍大了点，不换了吧来来回回的，凑活穿。还买了几双鞋，什么耐克阿迪的，便宜的太丑，好看的太贵还没货，倒是对彪马越来越感兴趣，价格还行，款式也还行（不还是因为较之便宜嘛……）。\n\n气的是有双鞋刚买了不到一个月就又看到大降价，差了一百来块呢，唉，安慰自己毕竟早穿上了这么多天呢不是……\n\n平时感觉穿的也都有，但是人嘛，喜新厌旧，而且这个购物啊，确实是精神上不一样啊，单身狗的刺激手段之一了，避免一直陷在麻木的生活状态之中。偶尔还是需要精神刺激的，啊，好疼~\n\n搞了套迪卡侬的运动装备，迪卡侬性价比真高，懊恼自己以前怎么不去了解，东西感觉都不错，大赞！以后运动装备就尽量选择迪卡侬了。\n\n- 金链子\n\n去年就跟老姐说过今年要给老妈买条大金链子的，身上什么首饰也没有，着实不好了点。故趁着发工资了，给老姐打过去 2000 块，“给老妈买条大金链子！其余的你补上！”哈哈，2000 肯定是不够买的，怪儿子出门在外没挣到什么钱，心意到了啊。回头给老爸搞双皮鞋，本来是去年买的，唉，加油加油！\n\n说到金，家里爷爷还留给我一个纯金戒指来着。小时候我看着那戒指，心想，这纯金戒指，得值多少钱啊。现在知道了，也就值个千把块钱……还用来传家呢……看什么时候给它化了，弄成其他的，金戒指也忒俗气了些。\n\n- 路上姑娘\n\n今儿早又看到这姑娘了，所以我才把这提上来。\n\n姑娘长发小脸，笑意浓浓，纤细身材，气质不凡。\n\n我们往往是在五角场附近相遇的。我骑着车，她低着头。\n\n虽然我看她时她没看过我，但我却看到她眼睛在笑，即使我那只是短短的一瞥，看得却异常清楚。有一种熟悉的感觉爬上了我的心头。可能是我接触异性少了，脑子出现了毛病……用我大学室友一句口头禅来说就是：这个不孬。\n\n也正是这几个月来遇到了很多次，且位置都大差不差，我这才记住了，不知道她是否注意到我没……\n\n人的一生会遇到许许多多的人。佛说，前世的五百次回眸，才换来今生的擦肩而过。\n\n如果无缘，我只愿你一生安好，陌生人。\n\n- 出差\n\n出差了出差了，人生中的第一次出差啊。这次去杭州出差了一周，期间自然不是很顺利。项目上的就不多说了，这个晚上啊，因为还有一位同事一起的，所以我们就定的标间。\n\n我那几天都是凌晨才慢慢睡去。为什么？旁边有位打呼跟电钻工装修一样的，要搁你，你能睡得着不……我还那会感冒没好全，身体素质是真不好，鼻血都流了好几回也不知道是不是擤鼻涕用力过猛了。\n\n而且我这个头啊，右脑勺还真刺疼，公司体检卡发了，不过要下月才开始能预约，希望一切健康，买的保险用不上啊……\n\n说到买的保险，买了个泰康的，送了个洗牙套餐，上月预约的都只能预约到一月份了，全家现在就我这口牙还行，最近好像也是开始出问题了，我得勤刷牙了，晚上不忘记能刷就刷。\n\n拉回来说这个出差。由于我也没有经验，也没有什么准备，导致我根本就找不到可以冲账的发票，最后还是用的领导的燃油发票来报。看来，以后要多攒攒发票了，虽说出差少，备着吧。\n\n- 余华\n\n余华，当代著名作家，他的许多作品获过国内外奖项。\n\n不知道，没关系。《活着》这部小说，总看过吧，没看过总听说过吧。没听说过？那我劝你现在就拿起手机打开 APP，订购一本，不要 998，也不要 198，它只要二十来块就能买到。\n\n记得当时我是花了一个晚上把《活着》给看完的，情节太紧凑了根本不给我歇的机会，看了停不下来，等歇下来了，原来后面没了，翻到了最后一页。\n\n最近我又在看他的另一本长篇小说《兄弟》。文人骚客，不骚就不叫文人了。不过里面骚的恰到好处，连接情节，更能吸引读者，引人入胜。\n\n大体上，我看到现在，主色调还是悲的，也是在文革前后那段时间下描述的故事。极具讽刺意味。\n\n只要能捱过来，那就都不是事。\n\n- 蒋劲夫家暴\n\n今天早上又刷到了这个新闻。家暴，我是不可能家暴的，真的很气愤也只会动动嘴皮子，大不了就出门透透气。个人认为，家暴确实是做不得，也不是男人该做的事。当然，会有些人有暴力倾向，更可怕的是有些女人还会十分享受被家暴的过程，这种人呢肯定是有的，而且可能还不少。\n\n大家夫妻之间，情侣之间搞搞 SM 啊什么的我倒是觉得很正常，别动不动就搞出血还搞出命，不值当啊！所以，两人在一起，这些东西都是需要熟知的，要了解清楚，三观不合的怎么可能长久，那种一夜情的就没必要查户口了。\n\n---\n\n真快啊都要 2018 12 月份了，下次写个年终总结，好好借机回顾一下自己这一年来的成长。长肯定是有长的，长哪就不知道了。\n\n哈哈，生死本无常，人应多思量。","slug":"busy-november-2018","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhc0034k9i199acfeef","content":"<blockquote>\n<p>这个十一月为什么说忙碌呢，因为忙着抽纸巾擤鼻涕，感冒了；因为忙着买买买，剁手了；因为忙着来来回回，出差了。</p>\n</blockquote>\n<ul>\n<li>感冒</li>\n</ul>\n<p>怪我，都怪我，前一段时间温差变化大，我懒啊，没及时加被子，还没穿裤子就睡了，半夜那个冻的，知道冷但就是没爬起来加被子，然后，感冒了一周，鼻子都搞破皮了……</p>\n<p>后来晚上还去夜跑，跑完当时感觉好点了，结果洗了个澡之后，鼻涕又来了，睡觉时候那个呼吸难受的啊，还好我床头纸管够……</p>\n<ul>\n<li>买买买</li>\n</ul>\n<p>最近买了不少东西，买了件大衣，结果稍稍大了点，不换了吧来来回回的，凑活穿。还买了几双鞋，什么耐克阿迪的，便宜的太丑，好看的太贵还没货，倒是对彪马越来越感兴趣，价格还行，款式也还行（不还是因为较之便宜嘛……）。</p>\n<p>气的是有双鞋刚买了不到一个月就又看到大降价，差了一百来块呢，唉，安慰自己毕竟早穿上了这么多天呢不是……</p>\n<p>平时感觉穿的也都有，但是人嘛，喜新厌旧，而且这个购物啊，确实是精神上不一样啊，单身狗的刺激手段之一了，避免一直陷在麻木的生活状态之中。偶尔还是需要精神刺激的，啊，好疼~</p>\n<p>搞了套迪卡侬的运动装备，迪卡侬性价比真高，懊恼自己以前怎么不去了解，东西感觉都不错，大赞！以后运动装备就尽量选择迪卡侬了。</p>\n<ul>\n<li>金链子</li>\n</ul>\n<p>去年就跟老姐说过今年要给老妈买条大金链子的，身上什么首饰也没有，着实不好了点。故趁着发工资了，给老姐打过去 2000 块，“给老妈买条大金链子！其余的你补上！”哈哈，2000 肯定是不够买的，怪儿子出门在外没挣到什么钱，心意到了啊。回头给老爸搞双皮鞋，本来是去年买的，唉，加油加油！</p>\n<p>说到金，家里爷爷还留给我一个纯金戒指来着。小时候我看着那戒指，心想，这纯金戒指，得值多少钱啊。现在知道了，也就值个千把块钱……还用来传家呢……看什么时候给它化了，弄成其他的，金戒指也忒俗气了些。</p>\n<ul>\n<li>路上姑娘</li>\n</ul>\n<p>今儿早又看到这姑娘了，所以我才把这提上来。</p>\n<p>姑娘长发小脸，笑意浓浓，纤细身材，气质不凡。</p>\n<p>我们往往是在五角场附近相遇的。我骑着车，她低着头。</p>\n<p>虽然我看她时她没看过我，但我却看到她眼睛在笑，即使我那只是短短的一瞥，看得却异常清楚。有一种熟悉的感觉爬上了我的心头。可能是我接触异性少了，脑子出现了毛病……用我大学室友一句口头禅来说就是：这个不孬。</p>\n<p>也正是这几个月来遇到了很多次，且位置都大差不差，我这才记住了，不知道她是否注意到我没……</p>\n<p>人的一生会遇到许许多多的人。佛说，前世的五百次回眸，才换来今生的擦肩而过。</p>\n<p>如果无缘，我只愿你一生安好，陌生人。</p>\n<ul>\n<li>出差</li>\n</ul>\n<p>出差了出差了，人生中的第一次出差啊。这次去杭州出差了一周，期间自然不是很顺利。项目上的就不多说了，这个晚上啊，因为还有一位同事一起的，所以我们就定的标间。</p>\n<p>我那几天都是凌晨才慢慢睡去。为什么？旁边有位打呼跟电钻工装修一样的，要搁你，你能睡得着不……我还那会感冒没好全，身体素质是真不好，鼻血都流了好几回也不知道是不是擤鼻涕用力过猛了。</p>\n<p>而且我这个头啊，右脑勺还真刺疼，公司体检卡发了，不过要下月才开始能预约，希望一切健康，买的保险用不上啊……</p>\n<p>说到买的保险，买了个泰康的，送了个洗牙套餐，上月预约的都只能预约到一月份了，全家现在就我这口牙还行，最近好像也是开始出问题了，我得勤刷牙了，晚上不忘记能刷就刷。</p>\n<p>拉回来说这个出差。由于我也没有经验，也没有什么准备，导致我根本就找不到可以冲账的发票，最后还是用的领导的燃油发票来报。看来，以后要多攒攒发票了，虽说出差少，备着吧。</p>\n<ul>\n<li>余华</li>\n</ul>\n<p>余华，当代著名作家，他的许多作品获过国内外奖项。</p>\n<p>不知道，没关系。《活着》这部小说，总看过吧，没看过总听说过吧。没听说过？那我劝你现在就拿起手机打开 APP，订购一本，不要 998，也不要 198，它只要二十来块就能买到。</p>\n<p>记得当时我是花了一个晚上把《活着》给看完的，情节太紧凑了根本不给我歇的机会，看了停不下来，等歇下来了，原来后面没了，翻到了最后一页。</p>\n<p>最近我又在看他的另一本长篇小说《兄弟》。文人骚客，不骚就不叫文人了。不过里面骚的恰到好处，连接情节，更能吸引读者，引人入胜。</p>\n<p>大体上，我看到现在，主色调还是悲的，也是在文革前后那段时间下描述的故事。极具讽刺意味。</p>\n<p>只要能捱过来，那就都不是事。</p>\n<ul>\n<li>蒋劲夫家暴</li>\n</ul>\n<p>今天早上又刷到了这个新闻。家暴，我是不可能家暴的，真的很气愤也只会动动嘴皮子，大不了就出门透透气。个人认为，家暴确实是做不得，也不是男人该做的事。当然，会有些人有暴力倾向，更可怕的是有些女人还会十分享受被家暴的过程，这种人呢肯定是有的，而且可能还不少。</p>\n<p>大家夫妻之间，情侣之间搞搞 SM 啊什么的我倒是觉得很正常，别动不动就搞出血还搞出命，不值当啊！所以，两人在一起，这些东西都是需要熟知的，要了解清楚，三观不合的怎么可能长久，那种一夜情的就没必要查户口了。</p>\n<hr>\n<p>真快啊都要 2018 12 月份了，下次写个年终总结，好好借机回顾一下自己这一年来的成长。长肯定是有长的，长哪就不知道了。</p>\n<p>哈哈，生死本无常，人应多思量。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个十一月为什么说忙碌呢，因为忙着抽纸巾擤鼻涕，感冒了；因为忙着买买买，剁手了；因为忙着来来回回，出差了。</p>\n</blockquote>\n<ul>\n<li>感冒</li>\n</ul>\n<p>怪我，都怪我，前一段时间温差变化大，我懒啊，没及时加被子，还没穿裤子就睡了，半夜那个冻的，知道冷但就是没爬起来加被子，然后，感冒了一周，鼻子都搞破皮了……</p>\n<p>后来晚上还去夜跑，跑完当时感觉好点了，结果洗了个澡之后，鼻涕又来了，睡觉时候那个呼吸难受的啊，还好我床头纸管够……</p>\n<ul>\n<li>买买买</li>\n</ul>\n<p>最近买了不少东西，买了件大衣，结果稍稍大了点，不换了吧来来回回的，凑活穿。还买了几双鞋，什么耐克阿迪的，便宜的太丑，好看的太贵还没货，倒是对彪马越来越感兴趣，价格还行，款式也还行（不还是因为较之便宜嘛……）。</p>\n<p>气的是有双鞋刚买了不到一个月就又看到大降价，差了一百来块呢，唉，安慰自己毕竟早穿上了这么多天呢不是……</p>\n<p>平时感觉穿的也都有，但是人嘛，喜新厌旧，而且这个购物啊，确实是精神上不一样啊，单身狗的刺激手段之一了，避免一直陷在麻木的生活状态之中。偶尔还是需要精神刺激的，啊，好疼~</p>\n<p>搞了套迪卡侬的运动装备，迪卡侬性价比真高，懊恼自己以前怎么不去了解，东西感觉都不错，大赞！以后运动装备就尽量选择迪卡侬了。</p>\n<ul>\n<li>金链子</li>\n</ul>\n<p>去年就跟老姐说过今年要给老妈买条大金链子的，身上什么首饰也没有，着实不好了点。故趁着发工资了，给老姐打过去 2000 块，“给老妈买条大金链子！其余的你补上！”哈哈，2000 肯定是不够买的，怪儿子出门在外没挣到什么钱，心意到了啊。回头给老爸搞双皮鞋，本来是去年买的，唉，加油加油！</p>\n<p>说到金，家里爷爷还留给我一个纯金戒指来着。小时候我看着那戒指，心想，这纯金戒指，得值多少钱啊。现在知道了，也就值个千把块钱……还用来传家呢……看什么时候给它化了，弄成其他的，金戒指也忒俗气了些。</p>\n<ul>\n<li>路上姑娘</li>\n</ul>\n<p>今儿早又看到这姑娘了，所以我才把这提上来。</p>\n<p>姑娘长发小脸，笑意浓浓，纤细身材，气质不凡。</p>\n<p>我们往往是在五角场附近相遇的。我骑着车，她低着头。</p>\n<p>虽然我看她时她没看过我，但我却看到她眼睛在笑，即使我那只是短短的一瞥，看得却异常清楚。有一种熟悉的感觉爬上了我的心头。可能是我接触异性少了，脑子出现了毛病……用我大学室友一句口头禅来说就是：这个不孬。</p>\n<p>也正是这几个月来遇到了很多次，且位置都大差不差，我这才记住了，不知道她是否注意到我没……</p>\n<p>人的一生会遇到许许多多的人。佛说，前世的五百次回眸，才换来今生的擦肩而过。</p>\n<p>如果无缘，我只愿你一生安好，陌生人。</p>\n<ul>\n<li>出差</li>\n</ul>\n<p>出差了出差了，人生中的第一次出差啊。这次去杭州出差了一周，期间自然不是很顺利。项目上的就不多说了，这个晚上啊，因为还有一位同事一起的，所以我们就定的标间。</p>\n<p>我那几天都是凌晨才慢慢睡去。为什么？旁边有位打呼跟电钻工装修一样的，要搁你，你能睡得着不……我还那会感冒没好全，身体素质是真不好，鼻血都流了好几回也不知道是不是擤鼻涕用力过猛了。</p>\n<p>而且我这个头啊，右脑勺还真刺疼，公司体检卡发了，不过要下月才开始能预约，希望一切健康，买的保险用不上啊……</p>\n<p>说到买的保险，买了个泰康的，送了个洗牙套餐，上月预约的都只能预约到一月份了，全家现在就我这口牙还行，最近好像也是开始出问题了，我得勤刷牙了，晚上不忘记能刷就刷。</p>\n<p>拉回来说这个出差。由于我也没有经验，也没有什么准备，导致我根本就找不到可以冲账的发票，最后还是用的领导的燃油发票来报。看来，以后要多攒攒发票了，虽说出差少，备着吧。</p>\n<ul>\n<li>余华</li>\n</ul>\n<p>余华，当代著名作家，他的许多作品获过国内外奖项。</p>\n<p>不知道，没关系。《活着》这部小说，总看过吧，没看过总听说过吧。没听说过？那我劝你现在就拿起手机打开 APP，订购一本，不要 998，也不要 198，它只要二十来块就能买到。</p>\n<p>记得当时我是花了一个晚上把《活着》给看完的，情节太紧凑了根本不给我歇的机会，看了停不下来，等歇下来了，原来后面没了，翻到了最后一页。</p>\n<p>最近我又在看他的另一本长篇小说《兄弟》。文人骚客，不骚就不叫文人了。不过里面骚的恰到好处，连接情节，更能吸引读者，引人入胜。</p>\n<p>大体上，我看到现在，主色调还是悲的，也是在文革前后那段时间下描述的故事。极具讽刺意味。</p>\n<p>只要能捱过来，那就都不是事。</p>\n<ul>\n<li>蒋劲夫家暴</li>\n</ul>\n<p>今天早上又刷到了这个新闻。家暴，我是不可能家暴的，真的很气愤也只会动动嘴皮子，大不了就出门透透气。个人认为，家暴确实是做不得，也不是男人该做的事。当然，会有些人有暴力倾向，更可怕的是有些女人还会十分享受被家暴的过程，这种人呢肯定是有的，而且可能还不少。</p>\n<p>大家夫妻之间，情侣之间搞搞 SM 啊什么的我倒是觉得很正常，别动不动就搞出血还搞出命，不值当啊！所以，两人在一起，这些东西都是需要熟知的，要了解清楚，三观不合的怎么可能长久，那种一夜情的就没必要查户口了。</p>\n<hr>\n<p>真快啊都要 2018 12 月份了，下次写个年终总结，好好借机回顾一下自己这一年来的成长。长肯定是有长的，长哪就不知道了。</p>\n<p>哈哈，生死本无常，人应多思量。</p>\n"},{"title":"剁手十一月（2019）","date":"2019-11-27T06:30:49.000Z","_content":"\n> 众所周知，这是一个神奇的自我高潮的“送钱”之月。\n\n双手被下了诅咒，一时无法掌控，前方有个迷洞，迫不及待想要填补塞透。\n\n---\n\n由于上海进博会的举办，公司做了调休安排，我就趁那几天回了趟家，顺便带着老爸老妈去逛了逛商场，买了点衣物。\n\n太久没碰车了，大早上从家出发去义乌随即又去浦江县城，到了下午直犯困。\n\n虽然他们口中一直说不要乱花钱，破费，但是从他们眼中我还是看出了他们内心的开心。\n\n他们开心我开心。为父母做的其实很少，他们却为了我们舍弃的太多。生命轮回。\n\n我把这些当做是生活的记录，以前小时候写文本日记，可是那些都随着时光消逝渐渐不见了。每次想起都不免觉得可惜，都是逝去的青春啊，我也少了些给子孙吹嘘的资本。如今虽然每月记录一番，时至今日也有一年有半，有时我自己也会翻出往常写的内容，带着回忆走一遍，着实很有意味。**人的一生都在不停地前行，不停地否定自己，不停地回想过去，不停地重摆手臂。**年轻气盛，那时把与初恋之间来往的所有信件给丢失了，每每念及，捶胸哀气。这些都是我们逝去的青春，年轻的见证啊。**人的成长在于勇于自嘲，别人没有栓住你，自己要会放过自己。**\n\n失魂落魄之时，大叹三声；</br>\n买定离手之时，大笑三声。</br>\n口袋空空之时，大唉三声；</br>\n包子入口之时，大赞三声。\n\n爱存心间，忧怖伴边；</br>\n忧怖心间，爱在心尖。\n\n愿我们都成为我们彼此心中我们的人。\n\n---\n\n周末打发时间，去看了场晓月老板的 livehouse，刚好大学机油也来了上海。\n\n很幸运，这次又抽到了电影的超前点映。这次是《平原上的夏洛克》，随是小成本制作，全素人出镜，但全影中有笑点有感悟，个人觉得还是非常值得一看的。意外，还看到了肖央。\n\n![平原上的夏洛克 超前点映](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/pysdxlk.jpg)\n\n---\n\n十一月十七号，苏州（太湖）马拉松，半程 21.0975 公里。这是我参加的第一个马拉松赛事，成绩 224，虽然这成绩不算好，但是毕竟第一次参与，还是比较满意了（跑完就是胜利！）。\n\n一回生，没考虑到的事情还不少，就不细细说了。说一下参赛体验吧，在赛场上我看到了年过古稀的老爷爷，刚上小学的小朋友，坐在轮椅上用双手奋力推轮的朋友……之前这些都是在网上看到某某报道上，谁谁谁今年多少岁跑了半马全马。现场看到的感觉真的很不一样，很有触动，这让我感觉马拉松这项活动赛事更加的有意义了，真的不虚此行，希望每一个人都能在其中体验一番，重在参与嘛。\n\n场边市民的热情，志愿者的体贴服务，赛场上参赛者的激情，真的很带劲啊！\n\n以后一定要带女朋友（老婆）甚至是子女都感受一下这全民健身的气氛。政府也是大力支持，光就大半天的封路操作就挺猛的，还是主大道高架。\n\n再接再厉，争取下次半马进 215。（又报了个嘉善的，下月八号，Go Go Go）\n\n---\n\n降温咯，怕不穿羽绒服今年就没机会咯。\n\n一晃眼，十一月就要过去了，就要迎来今年的最后一个月份同时也是 21 世纪 10 年代的最后一月，往后就是 21 世纪 20 年代咯。\n\n年会时间定了，今年又是主持，希望能抽到个奖吧，也不晓得是不是内定了的。\n\n---\n\n祝好。P & L.","source":"_posts/chophand-november.md","raw":"---\ntitle: 剁手十一月（2019）\ndate: 2019-11-27 14:30:49\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 众所周知，这是一个神奇的自我高潮的“送钱”之月。\n\n双手被下了诅咒，一时无法掌控，前方有个迷洞，迫不及待想要填补塞透。\n\n---\n\n由于上海进博会的举办，公司做了调休安排，我就趁那几天回了趟家，顺便带着老爸老妈去逛了逛商场，买了点衣物。\n\n太久没碰车了，大早上从家出发去义乌随即又去浦江县城，到了下午直犯困。\n\n虽然他们口中一直说不要乱花钱，破费，但是从他们眼中我还是看出了他们内心的开心。\n\n他们开心我开心。为父母做的其实很少，他们却为了我们舍弃的太多。生命轮回。\n\n我把这些当做是生活的记录，以前小时候写文本日记，可是那些都随着时光消逝渐渐不见了。每次想起都不免觉得可惜，都是逝去的青春啊，我也少了些给子孙吹嘘的资本。如今虽然每月记录一番，时至今日也有一年有半，有时我自己也会翻出往常写的内容，带着回忆走一遍，着实很有意味。**人的一生都在不停地前行，不停地否定自己，不停地回想过去，不停地重摆手臂。**年轻气盛，那时把与初恋之间来往的所有信件给丢失了，每每念及，捶胸哀气。这些都是我们逝去的青春，年轻的见证啊。**人的成长在于勇于自嘲，别人没有栓住你，自己要会放过自己。**\n\n失魂落魄之时，大叹三声；</br>\n买定离手之时，大笑三声。</br>\n口袋空空之时，大唉三声；</br>\n包子入口之时，大赞三声。\n\n爱存心间，忧怖伴边；</br>\n忧怖心间，爱在心尖。\n\n愿我们都成为我们彼此心中我们的人。\n\n---\n\n周末打发时间，去看了场晓月老板的 livehouse，刚好大学机油也来了上海。\n\n很幸运，这次又抽到了电影的超前点映。这次是《平原上的夏洛克》，随是小成本制作，全素人出镜，但全影中有笑点有感悟，个人觉得还是非常值得一看的。意外，还看到了肖央。\n\n![平原上的夏洛克 超前点映](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/pysdxlk.jpg)\n\n---\n\n十一月十七号，苏州（太湖）马拉松，半程 21.0975 公里。这是我参加的第一个马拉松赛事，成绩 224，虽然这成绩不算好，但是毕竟第一次参与，还是比较满意了（跑完就是胜利！）。\n\n一回生，没考虑到的事情还不少，就不细细说了。说一下参赛体验吧，在赛场上我看到了年过古稀的老爷爷，刚上小学的小朋友，坐在轮椅上用双手奋力推轮的朋友……之前这些都是在网上看到某某报道上，谁谁谁今年多少岁跑了半马全马。现场看到的感觉真的很不一样，很有触动，这让我感觉马拉松这项活动赛事更加的有意义了，真的不虚此行，希望每一个人都能在其中体验一番，重在参与嘛。\n\n场边市民的热情，志愿者的体贴服务，赛场上参赛者的激情，真的很带劲啊！\n\n以后一定要带女朋友（老婆）甚至是子女都感受一下这全民健身的气氛。政府也是大力支持，光就大半天的封路操作就挺猛的，还是主大道高架。\n\n再接再厉，争取下次半马进 215。（又报了个嘉善的，下月八号，Go Go Go）\n\n---\n\n降温咯，怕不穿羽绒服今年就没机会咯。\n\n一晃眼，十一月就要过去了，就要迎来今年的最后一个月份同时也是 21 世纪 10 年代的最后一月，往后就是 21 世纪 20 年代咯。\n\n年会时间定了，今年又是主持，希望能抽到个奖吧，也不晓得是不是内定了的。\n\n---\n\n祝好。P & L.","slug":"chophand-november","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhc0037k9i1ag6meaft","content":"<blockquote>\n<p>众所周知，这是一个神奇的自我高潮的“送钱”之月。</p>\n</blockquote>\n<p>双手被下了诅咒，一时无法掌控，前方有个迷洞，迫不及待想要填补塞透。</p>\n<hr>\n<p>由于上海进博会的举办，公司做了调休安排，我就趁那几天回了趟家，顺便带着老爸老妈去逛了逛商场，买了点衣物。</p>\n<p>太久没碰车了，大早上从家出发去义乌随即又去浦江县城，到了下午直犯困。</p>\n<p>虽然他们口中一直说不要乱花钱，破费，但是从他们眼中我还是看出了他们内心的开心。</p>\n<p>他们开心我开心。为父母做的其实很少，他们却为了我们舍弃的太多。生命轮回。</p>\n<p>我把这些当做是生活的记录，以前小时候写文本日记，可是那些都随着时光消逝渐渐不见了。每次想起都不免觉得可惜，都是逝去的青春啊，我也少了些给子孙吹嘘的资本。如今虽然每月记录一番，时至今日也有一年有半，有时我自己也会翻出往常写的内容，带着回忆走一遍，着实很有意味。<strong>人的一生都在不停地前行，不停地否定自己，不停地回想过去，不停地重摆手臂。</strong>年轻气盛，那时把与初恋之间来往的所有信件给丢失了，每每念及，捶胸哀气。这些都是我们逝去的青春，年轻的见证啊。<strong>人的成长在于勇于自嘲，别人没有栓住你，自己要会放过自己。</strong></p>\n<p>失魂落魄之时，大叹三声；</br><br>买定离手之时，大笑三声。</br><br>口袋空空之时，大唉三声；</br><br>包子入口之时，大赞三声。</p>\n<p>爱存心间，忧怖伴边；</br><br>忧怖心间，爱在心尖。</p>\n<p>愿我们都成为我们彼此心中我们的人。</p>\n<hr>\n<p>周末打发时间，去看了场晓月老板的 livehouse，刚好大学机油也来了上海。</p>\n<p>很幸运，这次又抽到了电影的超前点映。这次是《平原上的夏洛克》，随是小成本制作，全素人出镜，但全影中有笑点有感悟，个人觉得还是非常值得一看的。意外，还看到了肖央。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/pysdxlk.jpg\" alt=\"平原上的夏洛克 超前点映\"></p>\n<hr>\n<p>十一月十七号，苏州（太湖）马拉松，半程 21.0975 公里。这是我参加的第一个马拉松赛事，成绩 224，虽然这成绩不算好，但是毕竟第一次参与，还是比较满意了（跑完就是胜利！）。</p>\n<p>一回生，没考虑到的事情还不少，就不细细说了。说一下参赛体验吧，在赛场上我看到了年过古稀的老爷爷，刚上小学的小朋友，坐在轮椅上用双手奋力推轮的朋友……之前这些都是在网上看到某某报道上，谁谁谁今年多少岁跑了半马全马。现场看到的感觉真的很不一样，很有触动，这让我感觉马拉松这项活动赛事更加的有意义了，真的不虚此行，希望每一个人都能在其中体验一番，重在参与嘛。</p>\n<p>场边市民的热情，志愿者的体贴服务，赛场上参赛者的激情，真的很带劲啊！</p>\n<p>以后一定要带女朋友（老婆）甚至是子女都感受一下这全民健身的气氛。政府也是大力支持，光就大半天的封路操作就挺猛的，还是主大道高架。</p>\n<p>再接再厉，争取下次半马进 215。（又报了个嘉善的，下月八号，Go Go Go）</p>\n<hr>\n<p>降温咯，怕不穿羽绒服今年就没机会咯。</p>\n<p>一晃眼，十一月就要过去了，就要迎来今年的最后一个月份同时也是 21 世纪 10 年代的最后一月，往后就是 21 世纪 20 年代咯。</p>\n<p>年会时间定了，今年又是主持，希望能抽到个奖吧，也不晓得是不是内定了的。</p>\n<hr>\n<p>祝好。P &amp; L.</p>\n","excerpt":"","more":"<blockquote>\n<p>众所周知，这是一个神奇的自我高潮的“送钱”之月。</p>\n</blockquote>\n<p>双手被下了诅咒，一时无法掌控，前方有个迷洞，迫不及待想要填补塞透。</p>\n<hr>\n<p>由于上海进博会的举办，公司做了调休安排，我就趁那几天回了趟家，顺便带着老爸老妈去逛了逛商场，买了点衣物。</p>\n<p>太久没碰车了，大早上从家出发去义乌随即又去浦江县城，到了下午直犯困。</p>\n<p>虽然他们口中一直说不要乱花钱，破费，但是从他们眼中我还是看出了他们内心的开心。</p>\n<p>他们开心我开心。为父母做的其实很少，他们却为了我们舍弃的太多。生命轮回。</p>\n<p>我把这些当做是生活的记录，以前小时候写文本日记，可是那些都随着时光消逝渐渐不见了。每次想起都不免觉得可惜，都是逝去的青春啊，我也少了些给子孙吹嘘的资本。如今虽然每月记录一番，时至今日也有一年有半，有时我自己也会翻出往常写的内容，带着回忆走一遍，着实很有意味。<strong>人的一生都在不停地前行，不停地否定自己，不停地回想过去，不停地重摆手臂。</strong>年轻气盛，那时把与初恋之间来往的所有信件给丢失了，每每念及，捶胸哀气。这些都是我们逝去的青春，年轻的见证啊。<strong>人的成长在于勇于自嘲，别人没有栓住你，自己要会放过自己。</strong></p>\n<p>失魂落魄之时，大叹三声；</br><br>买定离手之时，大笑三声。</br><br>口袋空空之时，大唉三声；</br><br>包子入口之时，大赞三声。</p>\n<p>爱存心间，忧怖伴边；</br><br>忧怖心间，爱在心尖。</p>\n<p>愿我们都成为我们彼此心中我们的人。</p>\n<hr>\n<p>周末打发时间，去看了场晓月老板的 livehouse，刚好大学机油也来了上海。</p>\n<p>很幸运，这次又抽到了电影的超前点映。这次是《平原上的夏洛克》，随是小成本制作，全素人出镜，但全影中有笑点有感悟，个人觉得还是非常值得一看的。意外，还看到了肖央。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/pysdxlk.jpg\" alt=\"平原上的夏洛克 超前点映\"></p>\n<hr>\n<p>十一月十七号，苏州（太湖）马拉松，半程 21.0975 公里。这是我参加的第一个马拉松赛事，成绩 224，虽然这成绩不算好，但是毕竟第一次参与，还是比较满意了（跑完就是胜利！）。</p>\n<p>一回生，没考虑到的事情还不少，就不细细说了。说一下参赛体验吧，在赛场上我看到了年过古稀的老爷爷，刚上小学的小朋友，坐在轮椅上用双手奋力推轮的朋友……之前这些都是在网上看到某某报道上，谁谁谁今年多少岁跑了半马全马。现场看到的感觉真的很不一样，很有触动，这让我感觉马拉松这项活动赛事更加的有意义了，真的不虚此行，希望每一个人都能在其中体验一番，重在参与嘛。</p>\n<p>场边市民的热情，志愿者的体贴服务，赛场上参赛者的激情，真的很带劲啊！</p>\n<p>以后一定要带女朋友（老婆）甚至是子女都感受一下这全民健身的气氛。政府也是大力支持，光就大半天的封路操作就挺猛的，还是主大道高架。</p>\n<p>再接再厉，争取下次半马进 215。（又报了个嘉善的，下月八号，Go Go Go）</p>\n<hr>\n<p>降温咯，怕不穿羽绒服今年就没机会咯。</p>\n<p>一晃眼，十一月就要过去了，就要迎来今年的最后一个月份同时也是 21 世纪 10 年代的最后一月，往后就是 21 世纪 20 年代咯。</p>\n<p>年会时间定了，今年又是主持，希望能抽到个奖吧，也不晓得是不是内定了的。</p>\n<hr>\n<p>祝好。P &amp; L.</p>\n"},{"title":"ClickHouse 实战整理 - 统计 pv uv","date":"2022-03-08T13:10:55.000Z","_content":"\n\n> [ClickHouse 官方文档](https://clickhouse.com/docs/en/)\n>\n> 文中举例均为简单示例，根据业务自行扩展。\n\n实际业务场景中很多会需要统计 pv uv 值，比如页面的 pv uv 值，商品、店铺的 pv uv 值……\n\n这边举一个简单的例子，比如说统计商品访问的 pv uv：\n\n- 简单的源数据表创建如下：\n\n```sql\nCREATE TABLE IF NOT EXISTS test.product_operation\n(\n    ts_date_time  DateTime COMMENT '事件触发时间',\n    gen_date_time DateTime COMMENT '入库时间',\n    product_id    UInt64 COMMENT '商品ID',\n    user_id       UInt64 COMMENT '用户ID',\n    operation     UInt16 COMMENT '商品操作类型（1：访问，2：购买，3：收藏）'\n) ENGINE = MergeTree()\n      ORDER BY (toDate(ts_date_time), operation);\n```\n\n像这种数据量可能很大，又需要预先聚合计算以减小获取耗时的，我们添加 [物化视图](https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/aggregatingmergetree/#ju-he-wu-hua-shi-tu-de-shi-li) 来帮助我们做这个事。\n\n- 创建按天聚合数据的物化视图：\n\n```sql\nCREATE MATERIALIZED VIEW IF NOT EXISTS test.product_operation_day_pv_uv_mv\n            ENGINE = AggregatingMergeTree()\n                ORDER BY (ts_date, product_id, operation)\nAS\nSELECT toDate(ts_date_time)        as ts_date,\n       product_id,\n       operation,\n       sumState(1)                 as pv,\n       uniqState(user_id, ts_date) as uv\nFROM test.product_operation\nGROUP BY ts_date, product_id, operation;\n```\n\n- 创建总的聚合数据的物化视图：\n\n```sql\nCREATE MATERIALIZED VIEW IF NOT EXISTS test.product_operation_total_pv_uv_mv\n            ENGINE = AggregatingMergeTree()\n                ORDER BY (product_id, operation)\nAS\nSELECT product_id,\n       operation,\n       sumState(1)        as pv,\n       uniqState(user_id) as uv\nFROM test.product_operation\nGROUP BY product_id, operation;\n```\n\n- 现在我们往源数据表中插入一条数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-26 10:10:10'), now(), 1, 1, 1)\n```\n\n- 再查询：\n\n> 忽略时区问题导致的时间显示\n\n```sql\nSELECT * FROM  test.product_operation ORDER BY gen_date_time DESC;\n```\n\n| ts\\_date\\_time      | gen\\_date\\_time     | product\\_id | user\\_id | operation |\n| :------------------ | :------------------ | :---------- | :------- | :-------- |\n| 2022-01-26 02:10:10 | 2022-01-26 03:54:36 | 1           | 1        | 1         |\n\n- 查询视图（day）：\n\n```sql\nSELECT ts_date, product_id, operation, sumMerge(pv) AS pv, uniqMerge(uv) AS uv\nFROM test.product_operation_day_pv_uv_mv GROUP BY ts_date, product_id, operation;\n```\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-26 | 1           | 1         | 1    | 1    |\n\n- 查询视图（total）：\n\n```sql\nSELECT product_id, operation, sumMerge(pv) AS pv, uniqMerge(uv) AS uv\nFROM test.product_operation_total_pv_uv_mv GROUP BY product_id, operation;\n```\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 1    | 1    |\n\n- 再往源数据插入数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-26 23:10:10'), now(), 1, 1, 1);\n```\n\n- 查询视图：\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-26 | 1           | 1         | 2    | 1    |\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 2    | 1    |\n\n- 换个 `user_id` 插入数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-26 23:20:10'), now(), 1, 2, 1);\n```\n\n- 查询视图：\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-25 | 1           | 1         | 3    | 2    |\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 3    | 2    |\n\n- 再换个 `ts_date_time` 插入数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-27 10:20:10'), now(), 1, 1, 1),\n       (toDateTime('2022-01-27 11:20:10'), now(), 1, 2, 1);\n```\n\n- 查询视图：\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-26 | 1           | 1         | 3    | 2    |\n| 2022-01-27 | 1           | 1         | 2    | 2    |\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 5    | 2    |\n\n---\n\n综上，实现不难，clickhouse 丰富的聚合函数可以节省很多操作。\n\n还可以用 [Kafka引擎](https://clickhouse.com/docs/zh/engines/table-engines/integrations/kafka/) 做数据的增量同步，结合视图。","source":"_posts/clickhouse-in-action-pv-uv.md","raw":"---\ntitle: ClickHouse 实战整理 - 统计 pv uv\ndate: 2022-03-08 21:10:55\ncategories: [开发,数据库]\ntags: [ClickHouse]\n---\n\n\n> [ClickHouse 官方文档](https://clickhouse.com/docs/en/)\n>\n> 文中举例均为简单示例，根据业务自行扩展。\n\n实际业务场景中很多会需要统计 pv uv 值，比如页面的 pv uv 值，商品、店铺的 pv uv 值……\n\n这边举一个简单的例子，比如说统计商品访问的 pv uv：\n\n- 简单的源数据表创建如下：\n\n```sql\nCREATE TABLE IF NOT EXISTS test.product_operation\n(\n    ts_date_time  DateTime COMMENT '事件触发时间',\n    gen_date_time DateTime COMMENT '入库时间',\n    product_id    UInt64 COMMENT '商品ID',\n    user_id       UInt64 COMMENT '用户ID',\n    operation     UInt16 COMMENT '商品操作类型（1：访问，2：购买，3：收藏）'\n) ENGINE = MergeTree()\n      ORDER BY (toDate(ts_date_time), operation);\n```\n\n像这种数据量可能很大，又需要预先聚合计算以减小获取耗时的，我们添加 [物化视图](https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/aggregatingmergetree/#ju-he-wu-hua-shi-tu-de-shi-li) 来帮助我们做这个事。\n\n- 创建按天聚合数据的物化视图：\n\n```sql\nCREATE MATERIALIZED VIEW IF NOT EXISTS test.product_operation_day_pv_uv_mv\n            ENGINE = AggregatingMergeTree()\n                ORDER BY (ts_date, product_id, operation)\nAS\nSELECT toDate(ts_date_time)        as ts_date,\n       product_id,\n       operation,\n       sumState(1)                 as pv,\n       uniqState(user_id, ts_date) as uv\nFROM test.product_operation\nGROUP BY ts_date, product_id, operation;\n```\n\n- 创建总的聚合数据的物化视图：\n\n```sql\nCREATE MATERIALIZED VIEW IF NOT EXISTS test.product_operation_total_pv_uv_mv\n            ENGINE = AggregatingMergeTree()\n                ORDER BY (product_id, operation)\nAS\nSELECT product_id,\n       operation,\n       sumState(1)        as pv,\n       uniqState(user_id) as uv\nFROM test.product_operation\nGROUP BY product_id, operation;\n```\n\n- 现在我们往源数据表中插入一条数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-26 10:10:10'), now(), 1, 1, 1)\n```\n\n- 再查询：\n\n> 忽略时区问题导致的时间显示\n\n```sql\nSELECT * FROM  test.product_operation ORDER BY gen_date_time DESC;\n```\n\n| ts\\_date\\_time      | gen\\_date\\_time     | product\\_id | user\\_id | operation |\n| :------------------ | :------------------ | :---------- | :------- | :-------- |\n| 2022-01-26 02:10:10 | 2022-01-26 03:54:36 | 1           | 1        | 1         |\n\n- 查询视图（day）：\n\n```sql\nSELECT ts_date, product_id, operation, sumMerge(pv) AS pv, uniqMerge(uv) AS uv\nFROM test.product_operation_day_pv_uv_mv GROUP BY ts_date, product_id, operation;\n```\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-26 | 1           | 1         | 1    | 1    |\n\n- 查询视图（total）：\n\n```sql\nSELECT product_id, operation, sumMerge(pv) AS pv, uniqMerge(uv) AS uv\nFROM test.product_operation_total_pv_uv_mv GROUP BY product_id, operation;\n```\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 1    | 1    |\n\n- 再往源数据插入数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-26 23:10:10'), now(), 1, 1, 1);\n```\n\n- 查询视图：\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-26 | 1           | 1         | 2    | 1    |\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 2    | 1    |\n\n- 换个 `user_id` 插入数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-26 23:20:10'), now(), 1, 2, 1);\n```\n\n- 查询视图：\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-25 | 1           | 1         | 3    | 2    |\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 3    | 2    |\n\n- 再换个 `ts_date_time` 插入数据：\n\n```sql\nINSERT INTO test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)\nVALUES (toDateTime('2022-01-27 10:20:10'), now(), 1, 1, 1),\n       (toDateTime('2022-01-27 11:20:10'), now(), 1, 2, 1);\n```\n\n- 查询视图：\n\n| ts\\_date   | product\\_id | operation | pv   | uv   |\n| :--------- | :---------- | :-------- | :--- | :--- |\n| 2022-01-26 | 1           | 1         | 3    | 2    |\n| 2022-01-27 | 1           | 1         | 2    | 2    |\n\n| product\\_id | operation | pv   | uv   |\n| :---------- | :-------- | :--- | :--- |\n| 1           | 1         | 5    | 2    |\n\n---\n\n综上，实现不难，clickhouse 丰富的聚合函数可以节省很多操作。\n\n还可以用 [Kafka引擎](https://clickhouse.com/docs/zh/engines/table-engines/integrations/kafka/) 做数据的增量同步，结合视图。","slug":"clickhouse-in-action-pv-uv","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhc003ck9i177k2hlaw","content":"<blockquote>\n<p><a href=\"https://clickhouse.com/docs/en/\">ClickHouse 官方文档</a></p>\n<p>文中举例均为简单示例，根据业务自行扩展。</p>\n</blockquote>\n<p>实际业务场景中很多会需要统计 pv uv 值，比如页面的 pv uv 值，商品、店铺的 pv uv 值……</p>\n<p>这边举一个简单的例子，比如说统计商品访问的 pv uv：</p>\n<ul>\n<li>简单的源数据表创建如下：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> test.product_operation</span><br><span class=\"line\">(</span><br><span class=\"line\">    ts_date_time  DateTime COMMENT <span class=\"string\">&#x27;事件触发时间&#x27;</span>,</span><br><span class=\"line\">    gen_date_time DateTime COMMENT <span class=\"string\">&#x27;入库时间&#x27;</span>,</span><br><span class=\"line\">    product_id    UInt64 COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">    user_id       UInt64 COMMENT <span class=\"string\">&#x27;用户ID&#x27;</span>,</span><br><span class=\"line\">    operation     UInt16 COMMENT <span class=\"string\">&#x27;商品操作类型（1：访问，2：购买，3：收藏）&#x27;</span></span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> MergeTree()</span><br><span class=\"line\">      <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (toDate(ts_date_time), operation);</span><br></pre></td></tr></table></figure>\n\n<p>像这种数据量可能很大，又需要预先聚合计算以减小获取耗时的，我们添加 <a href=\"https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/aggregatingmergetree/#ju-he-wu-hua-shi-tu-de-shi-li\">物化视图</a> 来帮助我们做这个事。</p>\n<ul>\n<li>创建按天聚合数据的物化视图：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> MATERIALIZED <span class=\"keyword\">VIEW</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> test.product_operation_day_pv_uv_mv</span><br><span class=\"line\">            ENGINE <span class=\"operator\">=</span> AggregatingMergeTree()</span><br><span class=\"line\">                <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (ts_date, product_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> toDate(ts_date_time)        <span class=\"keyword\">as</span> ts_date,</span><br><span class=\"line\">       product_id,</span><br><span class=\"line\">       operation,</span><br><span class=\"line\">       sumState(<span class=\"number\">1</span>)                 <span class=\"keyword\">as</span> pv,</span><br><span class=\"line\">       uniqState(user_id, ts_date) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> ts_date, product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建总的聚合数据的物化视图：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> MATERIALIZED <span class=\"keyword\">VIEW</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> test.product_operation_total_pv_uv_mv</span><br><span class=\"line\">            ENGINE <span class=\"operator\">=</span> AggregatingMergeTree()</span><br><span class=\"line\">                <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (product_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> product_id,</span><br><span class=\"line\">       operation,</span><br><span class=\"line\">       sumState(<span class=\"number\">1</span>)        <span class=\"keyword\">as</span> pv,</span><br><span class=\"line\">       uniqState(user_id) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在我们往源数据表中插入一条数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-26 10:10:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>再查询：</li>\n</ul>\n<blockquote>\n<p>忽略时区问题导致的时间显示</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span>  test.product_operation <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> gen_date_time <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date_time</th>\n<th align=\"left\">gen_date_time</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">user_id</th>\n<th align=\"left\">operation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26 02:10:10</td>\n<td align=\"left\">2022-01-26 03:54:36</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>查询视图（day）：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ts_date, product_id, operation, sumMerge(pv) <span class=\"keyword\">AS</span> pv, uniqMerge(uv) <span class=\"keyword\">AS</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation_day_pv_uv_mv <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> ts_date, product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>查询视图（total）：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> product_id, operation, sumMerge(pv) <span class=\"keyword\">AS</span> pv, uniqMerge(uv) <span class=\"keyword\">AS</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation_total_pv_uv_mv <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>再往源数据插入数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-26 23:10:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询视图：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>换个 <code>user_id</code> 插入数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-26 23:20:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询视图：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-25</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">3</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">3</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<ul>\n<li>再换个 <code>ts_date_time</code> 插入数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-27 10:20:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">       (toDateTime(<span class=\"string\">&#x27;2022-01-27 11:20:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询视图：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">3</td>\n<td align=\"left\">2</td>\n</tr>\n<tr>\n<td align=\"left\">2022-01-27</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">5</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<hr>\n<p>综上，实现不难，clickhouse 丰富的聚合函数可以节省很多操作。</p>\n<p>还可以用 <a href=\"https://clickhouse.com/docs/zh/engines/table-engines/integrations/kafka/\">Kafka引擎</a> 做数据的增量同步，结合视图。</p>\n","excerpt":"","more":"<blockquote>\n<p><a href=\"https://clickhouse.com/docs/en/\">ClickHouse 官方文档</a></p>\n<p>文中举例均为简单示例，根据业务自行扩展。</p>\n</blockquote>\n<p>实际业务场景中很多会需要统计 pv uv 值，比如页面的 pv uv 值，商品、店铺的 pv uv 值……</p>\n<p>这边举一个简单的例子，比如说统计商品访问的 pv uv：</p>\n<ul>\n<li>简单的源数据表创建如下：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> test.product_operation</span><br><span class=\"line\">(</span><br><span class=\"line\">    ts_date_time  DateTime COMMENT <span class=\"string\">&#x27;事件触发时间&#x27;</span>,</span><br><span class=\"line\">    gen_date_time DateTime COMMENT <span class=\"string\">&#x27;入库时间&#x27;</span>,</span><br><span class=\"line\">    product_id    UInt64 COMMENT <span class=\"string\">&#x27;商品ID&#x27;</span>,</span><br><span class=\"line\">    user_id       UInt64 COMMENT <span class=\"string\">&#x27;用户ID&#x27;</span>,</span><br><span class=\"line\">    operation     UInt16 COMMENT <span class=\"string\">&#x27;商品操作类型（1：访问，2：购买，3：收藏）&#x27;</span></span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> MergeTree()</span><br><span class=\"line\">      <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (toDate(ts_date_time), operation);</span><br></pre></td></tr></table></figure>\n\n<p>像这种数据量可能很大，又需要预先聚合计算以减小获取耗时的，我们添加 <a href=\"https://clickhouse.com/docs/zh/engines/table-engines/mergetree-family/aggregatingmergetree/#ju-he-wu-hua-shi-tu-de-shi-li\">物化视图</a> 来帮助我们做这个事。</p>\n<ul>\n<li>创建按天聚合数据的物化视图：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> MATERIALIZED <span class=\"keyword\">VIEW</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> test.product_operation_day_pv_uv_mv</span><br><span class=\"line\">            ENGINE <span class=\"operator\">=</span> AggregatingMergeTree()</span><br><span class=\"line\">                <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (ts_date, product_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> toDate(ts_date_time)        <span class=\"keyword\">as</span> ts_date,</span><br><span class=\"line\">       product_id,</span><br><span class=\"line\">       operation,</span><br><span class=\"line\">       sumState(<span class=\"number\">1</span>)                 <span class=\"keyword\">as</span> pv,</span><br><span class=\"line\">       uniqState(user_id, ts_date) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> ts_date, product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>创建总的聚合数据的物化视图：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> MATERIALIZED <span class=\"keyword\">VIEW</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> test.product_operation_total_pv_uv_mv</span><br><span class=\"line\">            ENGINE <span class=\"operator\">=</span> AggregatingMergeTree()</span><br><span class=\"line\">                <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> (product_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">AS</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> product_id,</span><br><span class=\"line\">       operation,</span><br><span class=\"line\">       sumState(<span class=\"number\">1</span>)        <span class=\"keyword\">as</span> pv,</span><br><span class=\"line\">       uniqState(user_id) <span class=\"keyword\">as</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在我们往源数据表中插入一条数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-26 10:10:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>再查询：</li>\n</ul>\n<blockquote>\n<p>忽略时区问题导致的时间显示</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span>  test.product_operation <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> gen_date_time <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date_time</th>\n<th align=\"left\">gen_date_time</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">user_id</th>\n<th align=\"left\">operation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26 02:10:10</td>\n<td align=\"left\">2022-01-26 03:54:36</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>查询视图（day）：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> ts_date, product_id, operation, sumMerge(pv) <span class=\"keyword\">AS</span> pv, uniqMerge(uv) <span class=\"keyword\">AS</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation_day_pv_uv_mv <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> ts_date, product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>查询视图（total）：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> product_id, operation, sumMerge(pv) <span class=\"keyword\">AS</span> pv, uniqMerge(uv) <span class=\"keyword\">AS</span> uv</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> test.product_operation_total_pv_uv_mv <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> product_id, operation;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>再往源数据插入数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-26 23:10:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询视图：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>换个 <code>user_id</code> 插入数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-26 23:20:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询视图：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-25</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">3</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">3</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<ul>\n<li>再换个 <code>ts_date_time</code> 插入数据：</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> test.product_operation(ts_date_time, gen_date_time, product_id, user_id, operation)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (toDateTime(<span class=\"string\">&#x27;2022-01-27 10:20:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\">       (toDateTime(<span class=\"string\">&#x27;2022-01-27 11:20:10&#x27;</span>), now(), <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查询视图：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ts_date</th>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2022-01-26</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">3</td>\n<td align=\"left\">2</td>\n</tr>\n<tr>\n<td align=\"left\">2022-01-27</td>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">2</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">product_id</th>\n<th align=\"left\">operation</th>\n<th align=\"left\">pv</th>\n<th align=\"left\">uv</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">1</td>\n<td align=\"left\">5</td>\n<td align=\"left\">2</td>\n</tr>\n</tbody></table>\n<hr>\n<p>综上，实现不难，clickhouse 丰富的聚合函数可以节省很多操作。</p>\n<p>还可以用 <a href=\"https://clickhouse.com/docs/zh/engines/table-engines/integrations/kafka/\">Kafka引擎</a> 做数据的增量同步，结合视图。</p>\n"},{"title":"Java8集合框架新增方法汇总","date":"2018-08-17T08:32:49.000Z","_content":"\n> 本想着自己总结记录汇总下这些新方法的，结果一搜，一点，乖乖，真的是太详细了，然后我就搬过来了。。[原文地址](https://www.cnblogs.com/CarpenterLee/p/6507161.html)\n\n其中当然也涉及Lambda表达式，简化代码，何乐不为。\n\n---\n\n## Collection\n### forEach()\n该方法的签名为`void forEach(Consumer<? super E> action)`,作用是对容器中的每个元素执行`action`指定的动作，其中`Consumer`是个函数接口，里面只有一个待实现方法`void accept(T t)`（后面我们会看到，这个方法叫什么不重要，甚至不需要记住它的名字）。\n\n**需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串**\n\nJava7及以前我们可以用增强的for循环实现：\n```\n// 使用曾强for循环迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor(String str : list) {\n    if(str.length() > 3)\n        System.out.println(str);\n}\n```\n现在使用forEach()方法结合匿名内部类，可以这样实现：\n```\n// 使用forEach()结合匿名内部类迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach(new Consumer<String>() {\n    @Override\n    public void accept(String str) {\n        if(str.length() > 3)\n            System.out.println(str);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`Comsumer`接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：\n```\n// 使用forEach()结合Lambda表达式迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach( str -> {\n        if(str.length() > 3)\n            System.out.println(str);\n});\n```\n上述代码给`forEach()`方法传入一个Lambda表达式，我们不需要知道`accept()`方法，也不需要知道`Consumer`接口，**类型推导帮我们做了一切**。\n\n### removeIf()\n该方法签名为`boolean removeIf(Predicate<? super E> filter)`,作用是**删除容器中所有满足`filter`指定条件的元素**，其中`Perdicate`是一个函数接口，里面只有一个待实现方法`boolean test(T t)`，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。\n\n**需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。**\n\n我们知道如果需要在迭代过程中对容器进行删除操作必须使用迭代器，否则会抛出`ConcurrentModificationException`，所以上述任务传统的写法是：\n```\n// 使用迭代器删除列表元素\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nIterator<String> it = list.iterator();\nwhile(it.hasNext()) {\n    if(it.next().length() > 3) // 删除长度大于3的元素\n        it.remove();\n}\n```\n现在使用`removeIf()`方法结合匿名内部类，我们可以这样实现：\n```\n// 使用removeIf()结合匿名名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(new Predicate<String>() { // 删除长度大于3的元素\n    @Override\n    public boolean test(String str) {\n        return str.length() > 3;\n    }\n});\n```\n上述代码使用`removeIf()`方法，并使用匿名内部类实现`Precicate`接口。相信你已经想到用Lambda表达式该怎么写了：\n```\n// 使用removeIf()结合Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(str -> str.length() > 3); // 删除长度大于3的元素\n```\n使用Lambda表达式不需要记住`Predicate`接口名，也不需要记住`test()`方法名，只需要知道此处需要返回一个boolean类型的Lambda表达式就行了。\n\n### replaceAll()\n该方法签名为`void replaceAll(UnaryOperator<E> operator)`，作用是**对每个元素执行`operator`指定的操作，并用操作结果来替换原来的元素。**其中`UnaryOperator`是一个函数接口，里面只有一个待实现函数`T apply(T t)`。\n\n**需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。**\n\nJava7及之前似乎没有优雅的办法：\n```\n// 使用下标实现元素替换\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor (int i=0; i<list.size(); i++) {\n    String str = list.get(i);\n    if (str.length() > 3)\n        list.set(i, str.toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类可以实现如下：\n```\n// 使用匿名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(new UnaryOperator<String>() {\n    @Override\n    public String apply(String str) {\n        if(str.length() > 3)\n            return str.toUpperCase();\n        return str;\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`UnaryOperator`接口。我们知道可以用更为简洁的Lambda表达式实现：\n```\n// 使用Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(str -> {\n    if(str.length() > 3)\n        return str.toUpperCase();\n    return str;\n});\n```\n\n### sort()\n该方法定义在`List`接口中，方法签名为`void sort(Comparator<? super E> c)`，该方法**根据`c`指定的比较规则对容器元素进行排序。**`Comparator`接口我们并不陌生，其中有一个方法`int compare(T o1, To2)`需要实现，显然该接口是个函数接口。\n\n**需求：假设有一个字符串列表，按照字符串长度增序对元素排序。**\n\n由于Java7以及之前`sort()`方法在`Collections`工具类，所以代码要这样写：\n```\n// Collections.sort()方法\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nCollections.sort(list, new Comparator<String>() {\n    @Override\n    public int compare(String str1, String str2) {\n        return str1.length() - str2.length();\n    }\n});\n```\n现在可以直接使用`List.sort()`方法，结合Lambda表达式，可以这样写：\n```\n// List.sort()方法结合Lambda表达式\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.sort((str1, str2) -> str1.length() - str2.length());\n```\n\n### spliterator()\n方法签名为`Spliterator<E> spliterator()`，该方法返回容器的**可拆分迭代器**。从名字来看该方法跟`iterator()`方法有点像，我们知道`Iterator`是用来迭代容器的，`Spliterator`也有类似作用，但二者有如下不同：\n\n- `Spliterator`即可以像`Iterator`那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。\n- `Spliterator`是可以拆分的，一个`Spliterator`可以通过调用`Spliterator<T> trySplit()`方法来尝试分成两个。一个是`this`，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。\n\n可通过（多次）调用`Spliterator.trySplit()`方法来分解负载，以便多线程处理。\n\n### stream() / parallelStream()\n`stream()`和`parallelStream()`分别**返回容器的`stream`视图表示，**不同之处在于`parallelStream()`返回并行的`Stream`。**`Stream`是Java函数式编程的核心类，我之前也有[文章](http://putop.top/2018/07/13/stream-jdk1.8/)详细介绍过**。\n\n## Map\n相比`Collection`，`Map`中加入了更多的方法，我们以`HashMap`为例来逐一探秘。\n\n### forEach()\n该方法签名为`void forEach(BiConsumer<? super K, ? super V> action)`，作用是**对`Map`中每个映射执行`action`指定的操作**，其中`BiConsumer`是一个函数接口，里面有一个待实现方法`void accept(T t, U u)`。`BinConsumer`接口名字和`accept()`方法名字都不重要，不须记住。\n\n**需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系**\n\nJava7以及之前经典的代码如下：\n```\n// Java7以及之前迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \"=\" + entry.getValue());\n}\n```\n使用`Map.forEach()` 方法，结合匿名内部类，实现如下：\n```\n// 使用forEach()结合匿名内部类迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach(new BiConsumer<Integer, String>() {\n    @Override\n    public void accept(Integer k, String v) {\n        System.out.println(k + \"=\" + v);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`BiConsumer`接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：\n```\n// 使用forEach()结合Lambda表达式迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach((k, v) -> System.out.println(k + \"=\" + v));\n}\n```\n\n### getOrDefault()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V getOrDefault(Object key, V defaultValue)`，作用是**按照给定的`key`查询`Map`中对应的`value`，如果没有找到则返回`defaultValue`**。使用该方法程序员可以省去查询指定键值是否存在的麻烦。\n\n**需求：假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue**\n```\n// 查询Map中指定的值，不存在时使用默认值\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\n// Java7以及之前做法\nif (map.containsKey(4)) { // 1\n    System.out.println(map.get(4));\n} else {\n    System.out.println(\"NoValue\");\n}\n// Java8使用Map.getOrDefault()\nSystem.out.println(map.getOrDefault(4, \"NoValue\")); // 2\n```\n\n### putIfAbsent()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V putIfAbsent(K key, V value)`，作用是只有在**不存在`key`值的映射或映射值为null时**，才将`value`指定的值放入到`Map`中，否则不对`Map`做更改。该方法将条件判断和赋值合二为一，使用起来更加方便。\n\n### remove()\n我们都知道`Map`中有一个`remove(Object key)`方法，来根据指定`key`值删除`Map`中的映射关系；Java8新增了`remove(Object key, Object value)`方法，只有在当前`Map`中**`key`正好映射到`value`时**才删除该映射，否则什么也不做。\n\n### replace()\n在Java7及以前，要想替换`Map`中的映射关系可通过`put(K key, V value)`方法来实现，该方法总是会用新值替换原来的值，为了更精确的控制替换行为，Java8在`Map`中加入了两个`replace()`方法，分别如下：\n\n- `replace(K key, V value)`，只有在当前`Map`中**`key`的映射存在时**才用`value`去替换原来的值，否则什么也不做。\n- `replace(K key, V oldValue, V newValue)`，只有在当前`Map`中**`key`的映射存在且等于`oldValue`时**才用`newValue`去替换原来的值，否则什么也不做。\n\n### replaceAll()\n该方法签名为`replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`，作用是对`Map`中的每个映射执行`function`指定的操作，并用`function`的执行结果替换原来的`value`，其中`BiFunction`是一个函数接口，里面有一个待实现方法`R apply(T t, U u)`，不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字。\n\n**需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写**\n\nJava7以及之前经典的代码如下：\n```\n// Java7以及之前替换所有Map中所有映射关系\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()) {\n    entry.setValue(entry.getValue().toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类，实现如下：\n```\n// 使用replaceAll()结合匿名内部类实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll(new BiFunction<Integer, String, String>() {\n    @Override\n    public String apply(Integer k, String v) {\n        return v.toUpperCase();\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`BiFunction`接口。更进一步的，使用Lambda表达式实现如下：\n```\n// 使用replaceAll()结合Lambda表达式实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll((k, v) -> v.toUpperCase());\n```\n简洁到让人难以置信。\n\n### merge()\n该方法签名为`merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)`，作用是：\n\n- 如果`Map`中`key`对应的映射不存在或者为`null`，则将`value`（不能是`null`）关联到`key`上；\n- 否则执行`remappingFunction`，如果执行结果非`null`则用该结果跟`key`关联，否则在`Map`中删除`key`的映射。\n\n参数中`BiFunction`函数接口前面已经介绍过，里面有一个待实现方法`R apply(T t, U u)`。`merge()`方法虽然语义有些复杂，但该方法的用法很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：\n```\nmap.merge(key, newMeg, (v1, v2) -> v1 + v2);\n```\n\n### compute()\n该方法签名为`compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`，作用是**把`remappingFunction`的计算结果关联到`key`上，如果计算结果为`null`，则在`Map`中删除`key`的映射**。\n\n要实现上述`merge()`方法中错误信息拼接的例子，使用`compute()`代码如下：\n```\nmap.compute(key, (k, v) -> v == null ? newMsg : v.concat(newMsg));\n```\n\n### computeIfAbsent()\n该方法签名为`v computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`，作用是：**只有在当前`Map`中不存在`key`值的映射或映射值为`null`时，才调用`mappingFunction`，并在`mappingFunction`执行结果非`null`时，将结果跟`key`关联**。\n\n`Function`是一个函数接口，里面有一个待实现方法`R apply(T t)`。\n\n`computeIfAbsent()`常用来对`Map`的某个`key`值建立初始化映射，比如我们要实现一个多值映射，`Map`的定义可能是`Map<K, Set<V>>`，要向`Map`中放入新值，可通过如下代码实现：\n```\nMap<Integer, Set<String>> map = new HashMap<>();\n// Java7及以前的实现方式\nif (map.containsKey(1)){\n    map.get(1).add(\"one\");\n} else {\n    Set<String> valueSet = new HashSet<String>();\n    valueSet.add(\"one\");\n    map.put(1, valueSet);\n}\n// Java8的实现方式\nmap.computeIfAbsent(1, v -> new HashSet<String>()).add(\"yi\");\n```\n使用`computeIfAbsent()`将条件判断和添加操作合二为一，使代码更简洁。\n\n### computeIfPresent()\n该方法签名为`V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`，作用跟`computeIfAbsent()`相反，即，**只有在当前`Map`中存在`key`值的映射且非`null`时**，才调用`remappingFunction`，如果`remappingFunction`执行结果为`null`，则删除`key`的映射，否则使用该结果替换`key`原来的映射。\n\n*这个函数的功能跟如下代码是等效的：*\n```\n// Java7及以前跟computeIfPresent()等效的代码\nif (map.get(key) != null) {\n    V oldValue = map.get(key);\n    V newValue = remappingFunction.apply(key, oldValue);\n    if (newValue != null)\n        map.put(key, newValue);\n    else\n        map.remove(key);\n    return newValue;\n}\nreturn null;\n```\n\n---\nEnd.\n","source":"_posts/collections-addF-jdk1.8.md","raw":"---\ntitle: Java8集合框架新增方法汇总\ndate: 2018-8-17 16:32:49\ncategories: [开发,总结]\ntags: [Java,Lambda]\n---\n\n> 本想着自己总结记录汇总下这些新方法的，结果一搜，一点，乖乖，真的是太详细了，然后我就搬过来了。。[原文地址](https://www.cnblogs.com/CarpenterLee/p/6507161.html)\n\n其中当然也涉及Lambda表达式，简化代码，何乐不为。\n\n---\n\n## Collection\n### forEach()\n该方法的签名为`void forEach(Consumer<? super E> action)`,作用是对容器中的每个元素执行`action`指定的动作，其中`Consumer`是个函数接口，里面只有一个待实现方法`void accept(T t)`（后面我们会看到，这个方法叫什么不重要，甚至不需要记住它的名字）。\n\n**需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串**\n\nJava7及以前我们可以用增强的for循环实现：\n```\n// 使用曾强for循环迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor(String str : list) {\n    if(str.length() > 3)\n        System.out.println(str);\n}\n```\n现在使用forEach()方法结合匿名内部类，可以这样实现：\n```\n// 使用forEach()结合匿名内部类迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach(new Consumer<String>() {\n    @Override\n    public void accept(String str) {\n        if(str.length() > 3)\n            System.out.println(str);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`Comsumer`接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：\n```\n// 使用forEach()结合Lambda表达式迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach( str -> {\n        if(str.length() > 3)\n            System.out.println(str);\n});\n```\n上述代码给`forEach()`方法传入一个Lambda表达式，我们不需要知道`accept()`方法，也不需要知道`Consumer`接口，**类型推导帮我们做了一切**。\n\n### removeIf()\n该方法签名为`boolean removeIf(Predicate<? super E> filter)`,作用是**删除容器中所有满足`filter`指定条件的元素**，其中`Perdicate`是一个函数接口，里面只有一个待实现方法`boolean test(T t)`，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。\n\n**需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。**\n\n我们知道如果需要在迭代过程中对容器进行删除操作必须使用迭代器，否则会抛出`ConcurrentModificationException`，所以上述任务传统的写法是：\n```\n// 使用迭代器删除列表元素\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nIterator<String> it = list.iterator();\nwhile(it.hasNext()) {\n    if(it.next().length() > 3) // 删除长度大于3的元素\n        it.remove();\n}\n```\n现在使用`removeIf()`方法结合匿名内部类，我们可以这样实现：\n```\n// 使用removeIf()结合匿名名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(new Predicate<String>() { // 删除长度大于3的元素\n    @Override\n    public boolean test(String str) {\n        return str.length() > 3;\n    }\n});\n```\n上述代码使用`removeIf()`方法，并使用匿名内部类实现`Precicate`接口。相信你已经想到用Lambda表达式该怎么写了：\n```\n// 使用removeIf()结合Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(str -> str.length() > 3); // 删除长度大于3的元素\n```\n使用Lambda表达式不需要记住`Predicate`接口名，也不需要记住`test()`方法名，只需要知道此处需要返回一个boolean类型的Lambda表达式就行了。\n\n### replaceAll()\n该方法签名为`void replaceAll(UnaryOperator<E> operator)`，作用是**对每个元素执行`operator`指定的操作，并用操作结果来替换原来的元素。**其中`UnaryOperator`是一个函数接口，里面只有一个待实现函数`T apply(T t)`。\n\n**需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。**\n\nJava7及之前似乎没有优雅的办法：\n```\n// 使用下标实现元素替换\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor (int i=0; i<list.size(); i++) {\n    String str = list.get(i);\n    if (str.length() > 3)\n        list.set(i, str.toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类可以实现如下：\n```\n// 使用匿名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(new UnaryOperator<String>() {\n    @Override\n    public String apply(String str) {\n        if(str.length() > 3)\n            return str.toUpperCase();\n        return str;\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`UnaryOperator`接口。我们知道可以用更为简洁的Lambda表达式实现：\n```\n// 使用Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(str -> {\n    if(str.length() > 3)\n        return str.toUpperCase();\n    return str;\n});\n```\n\n### sort()\n该方法定义在`List`接口中，方法签名为`void sort(Comparator<? super E> c)`，该方法**根据`c`指定的比较规则对容器元素进行排序。**`Comparator`接口我们并不陌生，其中有一个方法`int compare(T o1, To2)`需要实现，显然该接口是个函数接口。\n\n**需求：假设有一个字符串列表，按照字符串长度增序对元素排序。**\n\n由于Java7以及之前`sort()`方法在`Collections`工具类，所以代码要这样写：\n```\n// Collections.sort()方法\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nCollections.sort(list, new Comparator<String>() {\n    @Override\n    public int compare(String str1, String str2) {\n        return str1.length() - str2.length();\n    }\n});\n```\n现在可以直接使用`List.sort()`方法，结合Lambda表达式，可以这样写：\n```\n// List.sort()方法结合Lambda表达式\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.sort((str1, str2) -> str1.length() - str2.length());\n```\n\n### spliterator()\n方法签名为`Spliterator<E> spliterator()`，该方法返回容器的**可拆分迭代器**。从名字来看该方法跟`iterator()`方法有点像，我们知道`Iterator`是用来迭代容器的，`Spliterator`也有类似作用，但二者有如下不同：\n\n- `Spliterator`即可以像`Iterator`那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。\n- `Spliterator`是可以拆分的，一个`Spliterator`可以通过调用`Spliterator<T> trySplit()`方法来尝试分成两个。一个是`this`，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。\n\n可通过（多次）调用`Spliterator.trySplit()`方法来分解负载，以便多线程处理。\n\n### stream() / parallelStream()\n`stream()`和`parallelStream()`分别**返回容器的`stream`视图表示，**不同之处在于`parallelStream()`返回并行的`Stream`。**`Stream`是Java函数式编程的核心类，我之前也有[文章](http://putop.top/2018/07/13/stream-jdk1.8/)详细介绍过**。\n\n## Map\n相比`Collection`，`Map`中加入了更多的方法，我们以`HashMap`为例来逐一探秘。\n\n### forEach()\n该方法签名为`void forEach(BiConsumer<? super K, ? super V> action)`，作用是**对`Map`中每个映射执行`action`指定的操作**，其中`BiConsumer`是一个函数接口，里面有一个待实现方法`void accept(T t, U u)`。`BinConsumer`接口名字和`accept()`方法名字都不重要，不须记住。\n\n**需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系**\n\nJava7以及之前经典的代码如下：\n```\n// Java7以及之前迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()) {\n    System.out.println(entry.getKey() + \"=\" + entry.getValue());\n}\n```\n使用`Map.forEach()` 方法，结合匿名内部类，实现如下：\n```\n// 使用forEach()结合匿名内部类迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach(new BiConsumer<Integer, String>() {\n    @Override\n    public void accept(Integer k, String v) {\n        System.out.println(k + \"=\" + v);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`BiConsumer`接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：\n```\n// 使用forEach()结合Lambda表达式迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach((k, v) -> System.out.println(k + \"=\" + v));\n}\n```\n\n### getOrDefault()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V getOrDefault(Object key, V defaultValue)`，作用是**按照给定的`key`查询`Map`中对应的`value`，如果没有找到则返回`defaultValue`**。使用该方法程序员可以省去查询指定键值是否存在的麻烦。\n\n**需求：假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue**\n```\n// 查询Map中指定的值，不存在时使用默认值\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\n// Java7以及之前做法\nif (map.containsKey(4)) { // 1\n    System.out.println(map.get(4));\n} else {\n    System.out.println(\"NoValue\");\n}\n// Java8使用Map.getOrDefault()\nSystem.out.println(map.getOrDefault(4, \"NoValue\")); // 2\n```\n\n### putIfAbsent()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V putIfAbsent(K key, V value)`，作用是只有在**不存在`key`值的映射或映射值为null时**，才将`value`指定的值放入到`Map`中，否则不对`Map`做更改。该方法将条件判断和赋值合二为一，使用起来更加方便。\n\n### remove()\n我们都知道`Map`中有一个`remove(Object key)`方法，来根据指定`key`值删除`Map`中的映射关系；Java8新增了`remove(Object key, Object value)`方法，只有在当前`Map`中**`key`正好映射到`value`时**才删除该映射，否则什么也不做。\n\n### replace()\n在Java7及以前，要想替换`Map`中的映射关系可通过`put(K key, V value)`方法来实现，该方法总是会用新值替换原来的值，为了更精确的控制替换行为，Java8在`Map`中加入了两个`replace()`方法，分别如下：\n\n- `replace(K key, V value)`，只有在当前`Map`中**`key`的映射存在时**才用`value`去替换原来的值，否则什么也不做。\n- `replace(K key, V oldValue, V newValue)`，只有在当前`Map`中**`key`的映射存在且等于`oldValue`时**才用`newValue`去替换原来的值，否则什么也不做。\n\n### replaceAll()\n该方法签名为`replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`，作用是对`Map`中的每个映射执行`function`指定的操作，并用`function`的执行结果替换原来的`value`，其中`BiFunction`是一个函数接口，里面有一个待实现方法`R apply(T t, U u)`，不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字。\n\n**需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写**\n\nJava7以及之前经典的代码如下：\n```\n// Java7以及之前替换所有Map中所有映射关系\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()) {\n    entry.setValue(entry.getValue().toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类，实现如下：\n```\n// 使用replaceAll()结合匿名内部类实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll(new BiFunction<Integer, String, String>() {\n    @Override\n    public String apply(Integer k, String v) {\n        return v.toUpperCase();\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`BiFunction`接口。更进一步的，使用Lambda表达式实现如下：\n```\n// 使用replaceAll()结合Lambda表达式实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll((k, v) -> v.toUpperCase());\n```\n简洁到让人难以置信。\n\n### merge()\n该方法签名为`merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)`，作用是：\n\n- 如果`Map`中`key`对应的映射不存在或者为`null`，则将`value`（不能是`null`）关联到`key`上；\n- 否则执行`remappingFunction`，如果执行结果非`null`则用该结果跟`key`关联，否则在`Map`中删除`key`的映射。\n\n参数中`BiFunction`函数接口前面已经介绍过，里面有一个待实现方法`R apply(T t, U u)`。`merge()`方法虽然语义有些复杂，但该方法的用法很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：\n```\nmap.merge(key, newMeg, (v1, v2) -> v1 + v2);\n```\n\n### compute()\n该方法签名为`compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`，作用是**把`remappingFunction`的计算结果关联到`key`上，如果计算结果为`null`，则在`Map`中删除`key`的映射**。\n\n要实现上述`merge()`方法中错误信息拼接的例子，使用`compute()`代码如下：\n```\nmap.compute(key, (k, v) -> v == null ? newMsg : v.concat(newMsg));\n```\n\n### computeIfAbsent()\n该方法签名为`v computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`，作用是：**只有在当前`Map`中不存在`key`值的映射或映射值为`null`时，才调用`mappingFunction`，并在`mappingFunction`执行结果非`null`时，将结果跟`key`关联**。\n\n`Function`是一个函数接口，里面有一个待实现方法`R apply(T t)`。\n\n`computeIfAbsent()`常用来对`Map`的某个`key`值建立初始化映射，比如我们要实现一个多值映射，`Map`的定义可能是`Map<K, Set<V>>`，要向`Map`中放入新值，可通过如下代码实现：\n```\nMap<Integer, Set<String>> map = new HashMap<>();\n// Java7及以前的实现方式\nif (map.containsKey(1)){\n    map.get(1).add(\"one\");\n} else {\n    Set<String> valueSet = new HashSet<String>();\n    valueSet.add(\"one\");\n    map.put(1, valueSet);\n}\n// Java8的实现方式\nmap.computeIfAbsent(1, v -> new HashSet<String>()).add(\"yi\");\n```\n使用`computeIfAbsent()`将条件判断和添加操作合二为一，使代码更简洁。\n\n### computeIfPresent()\n该方法签名为`V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`，作用跟`computeIfAbsent()`相反，即，**只有在当前`Map`中存在`key`值的映射且非`null`时**，才调用`remappingFunction`，如果`remappingFunction`执行结果为`null`，则删除`key`的映射，否则使用该结果替换`key`原来的映射。\n\n*这个函数的功能跟如下代码是等效的：*\n```\n// Java7及以前跟computeIfPresent()等效的代码\nif (map.get(key) != null) {\n    V oldValue = map.get(key);\n    V newValue = remappingFunction.apply(key, oldValue);\n    if (newValue != null)\n        map.put(key, newValue);\n    else\n        map.remove(key);\n    return newValue;\n}\nreturn null;\n```\n\n---\nEnd.\n","slug":"collections-addF-jdk1.8","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhc003fk9i17gmzbm9k","content":"<blockquote>\n<p>本想着自己总结记录汇总下这些新方法的，结果一搜，一点，乖乖，真的是太详细了，然后我就搬过来了。。<a href=\"https://www.cnblogs.com/CarpenterLee/p/6507161.html\">原文地址</a></p>\n</blockquote>\n<p>其中当然也涉及Lambda表达式，简化代码，何乐不为。</p>\n<hr>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>,作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么不重要，甚至不需要记住它的名字）。</p>\n<p><strong>需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串</strong></p>\n<p>Java7及以前我们可以用增强的for循环实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用曾强for循环迭代</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">for(String str : list) &#123;</span><br><span class=\"line\">    if(str.length() &gt; 3)</span><br><span class=\"line\">        System.out.println(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在使用forEach()方法结合匿名内部类，可以这样实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合匿名内部类迭代</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void accept(String str) &#123;</span><br><span class=\"line\">        if(str.length() &gt; 3)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合Lambda表达式迭代</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.forEach( str -&gt; &#123;</span><br><span class=\"line\">        if(str.length() &gt; 3)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，<strong>类型推导帮我们做了一切</strong>。</p>\n<h3 id=\"removeIf\"><a href=\"#removeIf\" class=\"headerlink\" title=\"removeIf()\"></a>removeIf()</h3><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>,作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Perdicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>\n<p><strong>需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</strong></p>\n<p>我们知道如果需要在迭代过程中对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用迭代器删除列表元素</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\">while(it.hasNext()) &#123;</span><br><span class=\"line\">    if(it.next().length() &gt; 3) // 删除长度大于3的元素</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可以这样实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用removeIf()结合匿名名内部类实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.removeIf(new Predicate&lt;String&gt;() &#123; // 删除长度大于3的元素</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean test(String str) &#123;</span><br><span class=\"line\">        return str.length() &gt; 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用removeIf()结合Lambda表达式实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.removeIf(str -&gt; str.length() &gt; 3); // 删除长度大于3的元素</span><br></pre></td></tr></table></figure>\n<p>使用Lambda表达式不需要记住<code>Predicate</code>接口名，也不需要记住<code>test()</code>方法名，只需要知道此处需要返回一个boolean类型的Lambda表达式就行了。</p>\n<h3 id=\"replaceAll\"><a href=\"#replaceAll\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h3><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素。</strong>其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>\n<p><strong>需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</strong></p>\n<p>Java7及之前似乎没有优雅的办法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用下标实现元素替换</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">for (int i=0; i&lt;list.size(); i++) &#123;</span><br><span class=\"line\">    String str = list.get(i);</span><br><span class=\"line\">    if (str.length() &gt; 3)</span><br><span class=\"line\">        list.set(i, str.toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用匿名内部类实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.replaceAll(new UnaryOperator&lt;String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String apply(String str) &#123;</span><br><span class=\"line\">        if(str.length() &gt; 3)</span><br><span class=\"line\">            return str.toUpperCase();</span><br><span class=\"line\">        return str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用Lambda表达式实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.replaceAll(str -&gt; &#123;</span><br><span class=\"line\">    if(str.length() &gt; 3)</span><br><span class=\"line\">        return str.toUpperCase();</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序。</strong><code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, To2)</code>需要实现，显然该接口是个函数接口。</p>\n<p><strong>需求：假设有一个字符串列表，按照字符串长度增序对元素排序。</strong></p>\n<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类，所以代码要这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Collections.sort()方法</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compare(String str1, String str2) &#123;</span><br><span class=\"line\">        return str1.length() - str2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在可以直接使用<code>List.sort()</code>方法，结合Lambda表达式，可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// List.sort()方法结合Lambda表达式</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.sort((str1, str2) -&gt; str1.length() - str2.length());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"spliterator\"><a href=\"#spliterator\" class=\"headerlink\" title=\"spliterator()\"></a>spliterator()</h3><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>\n<ul>\n<li><code>Spliterator</code>即可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>\n<li><code>Spliterator</code>是可以拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>\n</ul>\n<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>\n<h3 id=\"stream-parallelStream\"><a href=\"#stream-parallelStream\" class=\"headerlink\" title=\"stream() &#x2F; parallelStream()\"></a>stream() &#x2F; parallelStream()</h3><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回容器的<code>stream</code>视图表示，</strong>不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。**<code>Stream</code>是Java函数式编程的核心类，我之前也有<a href=\"http://putop.top/2018/07/13/stream-jdk1.8/\">文章</a>详细介绍过**。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。</p>\n<h3 id=\"forEach-1\"><a href=\"#forEach-1\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，不须记住。</p>\n<p><strong>需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系</strong></p>\n<p>Java7以及之前经典的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java7以及之前迭代Map</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>Map.forEach()</code> 方法，结合匿名内部类，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合匿名内部类迭代Map</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.forEach(new BiConsumer&lt;Integer, String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void accept(Integer k, String v) &#123;</span><br><span class=\"line\">        System.out.println(k + &quot;=&quot; + v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合Lambda表达式迭代Map</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.forEach((k, v) -&gt; System.out.println(k + &quot;=&quot; + v));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getOrDefault\"><a href=\"#getOrDefault\" class=\"headerlink\" title=\"getOrDefault()\"></a>getOrDefault()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是**按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>**。使用该方法程序员可以省去查询指定键值是否存在的麻烦。</p>\n<p><strong>需求：假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查询Map中指定的值，不存在时使用默认值</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">// Java7以及之前做法</span><br><span class=\"line\">if (map.containsKey(4)) &#123; // 1</span><br><span class=\"line\">    System.out.println(map.get(4));</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    System.out.println(&quot;NoValue&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Java8使用Map.getOrDefault()</span><br><span class=\"line\">System.out.println(map.getOrDefault(4, &quot;NoValue&quot;)); // 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"putIfAbsent\"><a href=\"#putIfAbsent\" class=\"headerlink\" title=\"putIfAbsent()\"></a>putIfAbsent()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为null时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改。该方法将条件判断和赋值合二为一，使用起来更加方便。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中**<code>key</code>正好映射到<code>value</code>时**才删除该映射，否则什么也不做。</p>\n<h3 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h3><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法来实现，该方法总是会用新值替换原来的值，为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>\n<ul>\n<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在时**才用<code>value</code>去替换原来的值，否则什么也不做。</li>\n<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在且等于<code>oldValue</code>时**才用<code>newValue</code>去替换原来的值，否则什么也不做。</li>\n</ul>\n<h3 id=\"replaceAll-1\"><a href=\"#replaceAll-1\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h3><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>，不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字。</p>\n<p><strong>需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写</strong></p>\n<p>Java7以及之前经典的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java7以及之前替换所有Map中所有映射关系</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用replaceAll()结合匿名内部类实现</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.replaceAll(new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String apply(Integer k, String v) &#123;</span><br><span class=\"line\">        return v.toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用replaceAll()结合Lambda表达式实现</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>\n<p>简洁到让人难以置信。</p>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge()\"></a>merge()</h3><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>，作用是：</p>\n<ul>\n<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>\n<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射。</li>\n</ul>\n<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>。<code>merge()</code>方法虽然语义有些复杂，但该方法的用法很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.merge(key, newMeg, (v1, v2) -&gt; v1 + v2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"compute\"><a href=\"#compute\" class=\"headerlink\" title=\"compute()\"></a>compute()</h3><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，作用是<strong>把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射</strong>。</p>\n<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.compute(key, (k, v) -&gt; v == null ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"computeIfAbsent\"><a href=\"#computeIfAbsent\" class=\"headerlink\" title=\"computeIfAbsent()\"></a>computeIfAbsent()</h3><p>该方法签名为<code>v computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>，作用是：<strong>只有在当前<code>Map</code>中不存在<code>key</code>值的映射或映射值为<code>null</code>时，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联</strong>。</p>\n<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>。</p>\n<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射，比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K, Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">// Java7及以前的实现方式</span><br><span class=\"line\">if (map.containsKey(1))&#123;</span><br><span class=\"line\">    map.get(1).add(&quot;one&quot;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    Set&lt;String&gt; valueSet = new HashSet&lt;String&gt;();</span><br><span class=\"line\">    valueSet.add(&quot;one&quot;);</span><br><span class=\"line\">    map.put(1, valueSet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Java8的实现方式</span><br><span class=\"line\">map.computeIfAbsent(1, v -&gt; new HashSet&lt;String&gt;()).add(&quot;yi&quot;);</span><br></pre></td></tr></table></figure>\n<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更简洁。</p>\n<h3 id=\"computeIfPresent\"><a href=\"#computeIfPresent\" class=\"headerlink\" title=\"computeIfPresent()\"></a>computeIfPresent()</h3><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，<strong>只有在当前<code>Map</code>中存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射。</p>\n<p><em>这个函数的功能跟如下代码是等效的：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java7及以前跟computeIfPresent()等效的代码</span><br><span class=\"line\">if (map.get(key) != null) &#123;</span><br><span class=\"line\">    V oldValue = map.get(key);</span><br><span class=\"line\">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class=\"line\">    if (newValue != null)</span><br><span class=\"line\">        map.put(key, newValue);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        map.remove(key);</span><br><span class=\"line\">    return newValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>End.</p>\n","excerpt":"","more":"<blockquote>\n<p>本想着自己总结记录汇总下这些新方法的，结果一搜，一点，乖乖，真的是太详细了，然后我就搬过来了。。<a href=\"https://www.cnblogs.com/CarpenterLee/p/6507161.html\">原文地址</a></p>\n</blockquote>\n<p>其中当然也涉及Lambda表达式，简化代码，何乐不为。</p>\n<hr>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>,作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么不重要，甚至不需要记住它的名字）。</p>\n<p><strong>需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串</strong></p>\n<p>Java7及以前我们可以用增强的for循环实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用曾强for循环迭代</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">for(String str : list) &#123;</span><br><span class=\"line\">    if(str.length() &gt; 3)</span><br><span class=\"line\">        System.out.println(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在使用forEach()方法结合匿名内部类，可以这样实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合匿名内部类迭代</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void accept(String str) &#123;</span><br><span class=\"line\">        if(str.length() &gt; 3)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合Lambda表达式迭代</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.forEach( str -&gt; &#123;</span><br><span class=\"line\">        if(str.length() &gt; 3)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，<strong>类型推导帮我们做了一切</strong>。</p>\n<h3 id=\"removeIf\"><a href=\"#removeIf\" class=\"headerlink\" title=\"removeIf()\"></a>removeIf()</h3><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>,作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Perdicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>\n<p><strong>需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</strong></p>\n<p>我们知道如果需要在迭代过程中对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用迭代器删除列表元素</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\">while(it.hasNext()) &#123;</span><br><span class=\"line\">    if(it.next().length() &gt; 3) // 删除长度大于3的元素</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可以这样实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用removeIf()结合匿名名内部类实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.removeIf(new Predicate&lt;String&gt;() &#123; // 删除长度大于3的元素</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean test(String str) &#123;</span><br><span class=\"line\">        return str.length() &gt; 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用removeIf()结合Lambda表达式实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.removeIf(str -&gt; str.length() &gt; 3); // 删除长度大于3的元素</span><br></pre></td></tr></table></figure>\n<p>使用Lambda表达式不需要记住<code>Predicate</code>接口名，也不需要记住<code>test()</code>方法名，只需要知道此处需要返回一个boolean类型的Lambda表达式就行了。</p>\n<h3 id=\"replaceAll\"><a href=\"#replaceAll\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h3><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素。</strong>其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>\n<p><strong>需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</strong></p>\n<p>Java7及之前似乎没有优雅的办法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用下标实现元素替换</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">for (int i=0; i&lt;list.size(); i++) &#123;</span><br><span class=\"line\">    String str = list.get(i);</span><br><span class=\"line\">    if (str.length() &gt; 3)</span><br><span class=\"line\">        list.set(i, str.toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用匿名内部类实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.replaceAll(new UnaryOperator&lt;String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String apply(String str) &#123;</span><br><span class=\"line\">        if(str.length() &gt; 3)</span><br><span class=\"line\">            return str.toUpperCase();</span><br><span class=\"line\">        return str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用Lambda表达式实现</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.replaceAll(str -&gt; &#123;</span><br><span class=\"line\">    if(str.length() &gt; 3)</span><br><span class=\"line\">        return str.toUpperCase();</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h3><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序。</strong><code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, To2)</code>需要实现，显然该接口是个函数接口。</p>\n<p><strong>需求：假设有一个字符串列表，按照字符串长度增序对元素排序。</strong></p>\n<p>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类，所以代码要这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Collections.sort()方法</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public int compare(String str1, String str2) &#123;</span><br><span class=\"line\">        return str1.length() - str2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在可以直接使用<code>List.sort()</code>方法，结合Lambda表达式，可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// List.sort()方法结合Lambda表达式</span><br><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));</span><br><span class=\"line\">list.sort((str1, str2) -&gt; str1.length() - str2.length());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"spliterator\"><a href=\"#spliterator\" class=\"headerlink\" title=\"spliterator()\"></a>spliterator()</h3><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的<strong>可拆分迭代器</strong>。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>\n<ul>\n<li><code>Spliterator</code>即可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>\n<li><code>Spliterator</code>是可以拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是<code>this</code>，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>\n</ul>\n<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>\n<h3 id=\"stream-parallelStream\"><a href=\"#stream-parallelStream\" class=\"headerlink\" title=\"stream() &#x2F; parallelStream()\"></a>stream() &#x2F; parallelStream()</h3><p><code>stream()</code>和<code>parallelStream()</code>分别<strong>返回容器的<code>stream</code>视图表示，</strong>不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。**<code>Stream</code>是Java函数式编程的核心类，我之前也有<a href=\"http://putop.top/2018/07/13/stream-jdk1.8/\">文章</a>详细介绍过**。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>相比<code>Collection</code>，<code>Map</code>中加入了更多的方法，我们以<code>HashMap</code>为例来逐一探秘。</p>\n<h3 id=\"forEach-1\"><a href=\"#forEach-1\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h3><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code>，作用是<strong>对<code>Map</code>中每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，不须记住。</p>\n<p><strong>需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系</strong></p>\n<p>Java7以及之前经典的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java7以及之前迭代Map</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>Map.forEach()</code> 方法，结合匿名内部类，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合匿名内部类迭代Map</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.forEach(new BiConsumer&lt;Integer, String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void accept(Integer k, String v) &#123;</span><br><span class=\"line\">        System.out.println(k + &quot;=&quot; + v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用forEach()结合Lambda表达式迭代Map</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.forEach((k, v) -&gt; System.out.println(k + &quot;=&quot; + v));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getOrDefault\"><a href=\"#getOrDefault\" class=\"headerlink\" title=\"getOrDefault()\"></a>getOrDefault()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是**按照给定的<code>key</code>查询<code>Map</code>中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>**。使用该方法程序员可以省去查询指定键值是否存在的麻烦。</p>\n<p><strong>需求：假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查询Map中指定的值，不存在时使用默认值</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">// Java7以及之前做法</span><br><span class=\"line\">if (map.containsKey(4)) &#123; // 1</span><br><span class=\"line\">    System.out.println(map.get(4));</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    System.out.println(&quot;NoValue&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Java8使用Map.getOrDefault()</span><br><span class=\"line\">System.out.println(map.getOrDefault(4, &quot;NoValue&quot;)); // 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"putIfAbsent\"><a href=\"#putIfAbsent\" class=\"headerlink\" title=\"putIfAbsent()\"></a>putIfAbsent()</h3><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在<strong>不存在<code>key</code>值的映射或映射值为null时</strong>，才将<code>value</code>指定的值放入到<code>Map</code>中，否则不对<code>Map</code>做更改。该方法将条件判断和赋值合二为一，使用起来更加方便。</p>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><p>我们都知道<code>Map</code>中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除<code>Map</code>中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前<code>Map</code>中**<code>key</code>正好映射到<code>value</code>时**才删除该映射，否则什么也不做。</p>\n<h3 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h3><p>在Java7及以前，要想替换<code>Map</code>中的映射关系可通过<code>put(K key, V value)</code>方法来实现，该方法总是会用新值替换原来的值，为了更精确的控制替换行为，Java8在<code>Map</code>中加入了两个<code>replace()</code>方法，分别如下：</p>\n<ul>\n<li><code>replace(K key, V value)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在时**才用<code>value</code>去替换原来的值，否则什么也不做。</li>\n<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前<code>Map</code>中**<code>key</code>的映射存在且等于<code>oldValue</code>时**才用<code>newValue</code>去替换原来的值，否则什么也不做。</li>\n</ul>\n<h3 id=\"replaceAll-1\"><a href=\"#replaceAll-1\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h3><p>该方法签名为<code>replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>，不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字。</p>\n<p><strong>需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写</strong></p>\n<p>Java7以及之前经典的代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java7以及之前替换所有Map中所有映射关系</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用replaceAll()结合匿名内部类实现</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.replaceAll(new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String apply(Integer k, String v) &#123;</span><br><span class=\"line\">        return v.toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用replaceAll()结合Lambda表达式实现</span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(1, &quot;one&quot;);</span><br><span class=\"line\">map.put(2, &quot;two&quot;);</span><br><span class=\"line\">map.put(3, &quot;three&quot;);</span><br><span class=\"line\">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure>\n<p>简洁到让人难以置信。</p>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge()\"></a>merge()</h3><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code>，作用是：</p>\n<ul>\n<li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li>\n<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射。</li>\n</ul>\n<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>。<code>merge()</code>方法虽然语义有些复杂，但该方法的用法很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.merge(key, newMeg, (v1, v2) -&gt; v1 + v2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"compute\"><a href=\"#compute\" class=\"headerlink\" title=\"compute()\"></a>compute()</h3><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，作用是<strong>把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射</strong>。</p>\n<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map.compute(key, (k, v) -&gt; v == null ? newMsg : v.concat(newMsg));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"computeIfAbsent\"><a href=\"#computeIfAbsent\" class=\"headerlink\" title=\"computeIfAbsent()\"></a>computeIfAbsent()</h3><p>该方法签名为<code>v computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code>，作用是：<strong>只有在当前<code>Map</code>中不存在<code>key</code>值的映射或映射值为<code>null</code>时，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联</strong>。</p>\n<p><code>Function</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>。</p>\n<p><code>computeIfAbsent()</code>常用来对<code>Map</code>的某个<code>key</code>值建立初始化映射，比如我们要实现一个多值映射，<code>Map</code>的定义可能是<code>Map&lt;K, Set&lt;V&gt;&gt;</code>，要向<code>Map</code>中放入新值，可通过如下代码实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\">// Java7及以前的实现方式</span><br><span class=\"line\">if (map.containsKey(1))&#123;</span><br><span class=\"line\">    map.get(1).add(&quot;one&quot;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    Set&lt;String&gt; valueSet = new HashSet&lt;String&gt;();</span><br><span class=\"line\">    valueSet.add(&quot;one&quot;);</span><br><span class=\"line\">    map.put(1, valueSet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// Java8的实现方式</span><br><span class=\"line\">map.computeIfAbsent(1, v -&gt; new HashSet&lt;String&gt;()).add(&quot;yi&quot;);</span><br></pre></td></tr></table></figure>\n<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更简洁。</p>\n<h3 id=\"computeIfPresent\"><a href=\"#computeIfPresent\" class=\"headerlink\" title=\"computeIfPresent()\"></a>computeIfPresent()</h3><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，<strong>只有在当前<code>Map</code>中存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射。</p>\n<p><em>这个函数的功能跟如下代码是等效的：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java7及以前跟computeIfPresent()等效的代码</span><br><span class=\"line\">if (map.get(key) != null) &#123;</span><br><span class=\"line\">    V oldValue = map.get(key);</span><br><span class=\"line\">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class=\"line\">    if (newValue != null)</span><br><span class=\"line\">        map.put(key, newValue);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        map.remove(key);</span><br><span class=\"line\">    return newValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>End.</p>\n"},{"title":"安逸九月（2022）","date":"2022-09-30T13:10:55.000Z","_content":"\n\n九月大事无非就是我们订婚了。\n\n说起来也是几番坎坷。最开始义乌疫情爆发，后面义乌控制住了南通又开始有了，差一点又得要往后延期。好在也是顺利进行了。\n\n也算是人生的一个重要时刻，再往后身份越多责任也就越大了。\n\n今年的中秋跟国庆没有连在一起，有同事直接婚假请了十天跟国庆连在一起，直接就是半个月长假，太爽了！\n\n九月的天气已经渐渐转凉，开始穿起了长袖，甚至穿起了毛衣。感觉今年又比去年天冷得早，去年的国庆我还记得是大热天，直冒汗。\n\n国庆计划去衢州速速玩个一天，国庆要参加表弟的婚礼，然后又去南通。大学室友的婚礼也在国庆，无奈距离的问题再加上行程太满，应该是赶不过去了，实在太可惜了！\n\n又到了国庆，意味着距离元旦很近，也意味着距离过年也很近了！不知道是不是因为疫情，今年好像过得快了些。\n\n今日秋分，盗用朋友圈的一段话：\n\n> 秋分两色\n> 一半火红，一半枯黄；\n>\n> 岁月对折\n> 一半理想，一半现实。\n>\n> 今日·秋分\n\n\n\n路上的桂花也是香气四溢。","source":"_posts/comfortable-september.md","raw":"---\ntitle: 安逸九月（2022）\ndate: 2022-09-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n\n九月大事无非就是我们订婚了。\n\n说起来也是几番坎坷。最开始义乌疫情爆发，后面义乌控制住了南通又开始有了，差一点又得要往后延期。好在也是顺利进行了。\n\n也算是人生的一个重要时刻，再往后身份越多责任也就越大了。\n\n今年的中秋跟国庆没有连在一起，有同事直接婚假请了十天跟国庆连在一起，直接就是半个月长假，太爽了！\n\n九月的天气已经渐渐转凉，开始穿起了长袖，甚至穿起了毛衣。感觉今年又比去年天冷得早，去年的国庆我还记得是大热天，直冒汗。\n\n国庆计划去衢州速速玩个一天，国庆要参加表弟的婚礼，然后又去南通。大学室友的婚礼也在国庆，无奈距离的问题再加上行程太满，应该是赶不过去了，实在太可惜了！\n\n又到了国庆，意味着距离元旦很近，也意味着距离过年也很近了！不知道是不是因为疫情，今年好像过得快了些。\n\n今日秋分，盗用朋友圈的一段话：\n\n> 秋分两色\n> 一半火红，一半枯黄；\n>\n> 岁月对折\n> 一半理想，一半现实。\n>\n> 今日·秋分\n\n\n\n路上的桂花也是香气四溢。","slug":"comfortable-september","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhc003kk9i1cx3bd0yy","content":"<p>九月大事无非就是我们订婚了。</p>\n<p>说起来也是几番坎坷。最开始义乌疫情爆发，后面义乌控制住了南通又开始有了，差一点又得要往后延期。好在也是顺利进行了。</p>\n<p>也算是人生的一个重要时刻，再往后身份越多责任也就越大了。</p>\n<p>今年的中秋跟国庆没有连在一起，有同事直接婚假请了十天跟国庆连在一起，直接就是半个月长假，太爽了！</p>\n<p>九月的天气已经渐渐转凉，开始穿起了长袖，甚至穿起了毛衣。感觉今年又比去年天冷得早，去年的国庆我还记得是大热天，直冒汗。</p>\n<p>国庆计划去衢州速速玩个一天，国庆要参加表弟的婚礼，然后又去南通。大学室友的婚礼也在国庆，无奈距离的问题再加上行程太满，应该是赶不过去了，实在太可惜了！</p>\n<p>又到了国庆，意味着距离元旦很近，也意味着距离过年也很近了！不知道是不是因为疫情，今年好像过得快了些。</p>\n<p>今日秋分，盗用朋友圈的一段话：</p>\n<blockquote>\n<p>秋分两色<br>一半火红，一半枯黄；</p>\n<p>岁月对折<br>一半理想，一半现实。</p>\n<p>今日·秋分</p>\n</blockquote>\n<p>路上的桂花也是香气四溢。</p>\n","excerpt":"","more":"<p>九月大事无非就是我们订婚了。</p>\n<p>说起来也是几番坎坷。最开始义乌疫情爆发，后面义乌控制住了南通又开始有了，差一点又得要往后延期。好在也是顺利进行了。</p>\n<p>也算是人生的一个重要时刻，再往后身份越多责任也就越大了。</p>\n<p>今年的中秋跟国庆没有连在一起，有同事直接婚假请了十天跟国庆连在一起，直接就是半个月长假，太爽了！</p>\n<p>九月的天气已经渐渐转凉，开始穿起了长袖，甚至穿起了毛衣。感觉今年又比去年天冷得早，去年的国庆我还记得是大热天，直冒汗。</p>\n<p>国庆计划去衢州速速玩个一天，国庆要参加表弟的婚礼，然后又去南通。大学室友的婚礼也在国庆，无奈距离的问题再加上行程太满，应该是赶不过去了，实在太可惜了！</p>\n<p>又到了国庆，意味着距离元旦很近，也意味着距离过年也很近了！不知道是不是因为疫情，今年好像过得快了些。</p>\n<p>今日秋分，盗用朋友圈的一段话：</p>\n<blockquote>\n<p>秋分两色<br>一半火红，一半枯黄；</p>\n<p>岁月对折<br>一半理想，一半现实。</p>\n<p>今日·秋分</p>\n</blockquote>\n<p>路上的桂花也是香气四溢。</p>\n"},{"title":"Windows/CMD/Linux/Git常用命令整理","date":"2018-06-06T05:01:04.000Z","_content":"Windows/CMD/Linux/Git常用命令整理，由于平常经常会使用故趁热把这些都一起整理下。\n\n## 总览\n- [Windows Win+R 快捷操作](#1)\n- [CMD常用命令](#2)\n- [Linux常用命令](#3)\n- [Git常用命令](#4)\n- [参考资料](#5)\n\n---\n## <span id = 1>Windows Win+R 快捷操作</span>\n> 有时候不用去挨个点开什么控制面板啊再计算机什么的直接命令快速打开，列举平常使用率较高的几个\n### 打开本地服务\n`services.msc`这个对于开发人员是经常需要操作的\n### 打开注册表\n`regedit`有时候卸载或者重装软件的时候会需要操作注册表\n### 打开CMD界面\n`cmd`这个就不用说了，用管理员方式打开则需要右击操作\n### 打开组策略\n`gpedit.msc`可以查看计算机配置和用户配置\n### 打开记事本\n`notepad`\n### 磁盘清理\n`cleanmgr`可以快速清理一些回收垃圾\n### 查看win版本\n`winver`\n### 打开画图板\n`mspaint`\n### 远程连接\n`mstsc`\n### shutdown\n- `shutdown -r`表示重启\n- `shutdown -s -t 60`表示60秒后正常关机\n- `shutdown -s -t 60 -c 关机`则多了个提示消息<br>\n常用参数有：`\"-s\"正常关机、\"-f\"强制关机、\"-r\"重启、\"-t\"定时关机、\"-c\" 设置提示信息、\"-a\" 是取消定时关机`\n\n## <span id = 2>CMD常用命令</span>\n> 由于本人使用的都是Windows系统，平时难免会需要经常接触CMD来方便一些操作，列举平常使用率较高的几个(cd/dir/切换磁盘什么的这些就不说了...)\n### 查看IP信息\n`ipconfig`\n### 修改本机IP\n`netsh interface ip set address \"以太网\" static 192.168.30.100 255.255.255.0 192.168.30.1`<br>\n**注：这里`以太网`是网络名称，`192.168.30.100`是你要修改的IP`255.255.255.0`为子网掩码`192.168.30.1`为网关**\n### 网络诊断\n`ping putop.top`就是给putop.top发送数据包看有没有返回\n### 无线WLAN操作\n只要你输入`netsh wlan`就会出现许多提示，只要能看懂字就会操作了<br>\n如`netsh wlan connect wuxian`就是连接无线名为`wuxian`的无线网络了，`netsh wlan disconnect`就是断开无线连接\n### 查看端口状态\n- `netstat -ano`查看所有端口占用情况<br>\n- `netstat -aon|findstr \"8080\"`查看指定端口占用情况`8080`为端口号<br>\n- `tasklist|findstr \"2018\"`查看指定PID对应的进程`2018`为PID<br>\n- `taskkill /f /t /im java.exe`删除指定进程<br>\n完整语法为：\n```\nTASKKILL [/S system [/U username [/P [password]]]]\n         { [/FI filter] [/PID processid | /IM imagename] } [/T] [/F]\n\n    /S    system           指定要连接的远程系统。\n    /U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。\n    /P    [password]       为提供的用户上下文指定密码。如果忽略，提示输入。\n    /FI   filter           应用筛选器以选择一组任务。允许使用 \"*\"。例如，映像名称 eq acme*\n    /PID  processid        指定要终止的进程的 PID。使用 TaskList 取得 PID。\n    /IM   imagename        指定要终止的进程的映像名称。通配符 '*'可用来指定所有任务或映像名称。\n    /T                     终止指定的进程和由它启用的子进程。\n    /F                     指定强制终止进程。\n    /?                     显示帮助消息。\n```\n\n## <span id = 3>Linux常用命令</span>\n>平时部署项目也会用到Linux系统，整理下平时常用的几个(cd/ls/ll这些也不说了...)说来惭愧，经常用ftp操作感觉还挺方便还是Windows用多了啊\n### 系统显示\n- `date`显示系统时间\n- `cal 2018`显示2018年的日历表\n- `date 060610502018.00`设置日期和时间 月日时分年.秒\n- `clock -w`将时间修改保存到BIOS中\n- `cat /proc/cpuinfo`显示CPU info的信息\n- `lsusb -tv`显示USB设备\n\n### 关机、重启\n- `shutdown -h now`关闭系统\n- `shutdown -h hours:minutes &`按预定时间关闭系统\n- `shutdown -c`取消按预定时间关闭系统\n- `shutdown -r now`重启\n- `logout`注销\n\n### 文件和目录\n- `mkdir dir`创建名为dir的目录\n- `rmdir dir`删除名为dir的目录\n- `rm -rf dir`删除名为dir的目录并同时删除其内容\n- `rm -f file`删除名为file的文件\n- `mv dir new_dir`重命名/移动名为dir的目录\n- `cp file same_file`复制一个名为file的文件叫做same_file\n- `cp -a dir same_dir`复制一个名为dir的目录叫做same_dir\n- `cp dir/* .`复制一个目录下的所有文件到当前工作目录\n- `cp -a /tmp/dir`复制一个目录到当前工作目录\n\n### 磁盘空间\n- `df -h`显示已经挂载的分区列表\n- `du -sh dir`估算目录`dir`已经使用的磁盘空间\n\n### 文件权限\n- `ls -lh`显示权限\n- `chmod ugo+rwx dir`设置目录的所有人(u)、群组(g)以及其他人(o)以读（r）、写(w)和执行(x)的权限，使用 \"+\" 设置权限，使用 \"-\" 用于取消\n- `chattr +a file`只允许以追加方式读写文件\n- `chattr +i file1`设置成不可变的文件，不能被删除、修改、重命名或者链接\n- `chattr +S file`一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘\n- `chattr +u file`若文件被删除，系统会允许你在以后恢复这个被删除的文件 \n- `lsattr`显示特殊的属性\n\n### 解压/压缩文件\n- 压缩\n    + `tar –cvf jpg.tar *.jpg`将目录里所有jpg文件打包成tar.jpg\n    + `tar –czf jpg.tar.gz *.jpg`将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n    + `tar –cjf jpg.tar.bz2 *.jpg`将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n    + `tar –cZf jpg.tar.Z *.jpg`将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n    + `rar a jpg.rar *.jpg`rar格式的压缩，需要先下载rar for linux\n    + `zip jpg.zip *.jpg`zip格式的压缩，需要先下载zip for linux\n- 解压\n    + `tar –xvf file.tar`解压 tar包\n    + `tar -xzvf file.tar.gz`解压tar.gz\n    + `tar -xjvf file.tar.bz2`解压 tar.bz2\n    + `tar –xZvf file.tar.Z`解压tar.Z\n    + `unrar e file.rar`解压rar\n    + `unzip file.zip`解压zip\n\n### 查看文件内容\n- `cat file`从第一个字节开始正向查看文件`file`的内容\n- `tac file`从最后一行开始反向查看文件`file`的内容\n- `more file`查看一个长文件的内容\n- `head -2 file`查看一个文件的前两行\n- `tail -2 file`查看一个文件的最后两行\n- `tail -f /var/log/messages`实时查看被添加到一个文件中的内容，这个平时查看日志经常会用到\n\n### 进程\n- `ps -ef`查看所有运行进程\n- `ps -ef|grep java`指定查看java进程，java开发人员经常使用，比如鄙人\n- `kill PID`停止该PID表示进程，必要时加上`- 9`强制\n\n### 部署\n- `nohup java -jar xx.jar >/dev/null &`这是jar包的后台部署，加上`&`就是后台运行\n\n### top视图\n- `top`进入top视图<br>\n视图数据详解：\n```\n第一行：\n10:01:23 — 当前系统时间\n126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）\n2 users — 当前有2个用户登录系统\nload average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。\n\n第二行：\nTasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。\n\n第三行：cpu状态\n6.7% us — 用户空间占用CPU的百分比。\n0.4% sy — 内核空间占用CPU的百分比。\n0.0% ni — 改变过优先级的进程占用CPU的百分比\n92.9% id — 空闲CPU百分比\n0.0% wa — IO等待占用CPU的百分比\n0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比\n0.0% si — 软中断（Software Interrupts）占用CPU的百分比\n\n第四行：内存状态\n8306544k total — 物理内存总量（8GB）\n7775876k used — 使用中的内存总量（7.7GB）\n530668k free — 空闲内存总量（530M）\n79236k buffers — 缓存的内存量 （79M）\n\n第五行：swap交换分区\n2031608k total — 交换区总量（2GB）\n2556k used — 使用的交换区总量（2.5M）\n2029052k free — 空闲交换区总量（2GB）\n4231276k cached — 缓冲的交换区总量（4GB）\n\n第六行是空行\n\n第七行以下：各进程（任务）的状态监控\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\nCOMMAND — 进程名称（命令名/命令行）\n```\n\n## <span id = 4>Git常用命令</span>\n> 不免要使用git来版本管理\n\n- `git init`创建版本库\n- `git clone`克隆仓库\n- `git add`添加文件到暂存区\n- `git commit`提交更改,加上`- m`增加提交说明\n- `git status`查看状态\n- `git rm`删除文件\n- `git diff`文件对比\n- `git log`日志显示\n- `git push`上传\n- `git merge`合并\n- `git branch -d`删除分支\n- `git fetch`获取分支\n- `git pull`更新\n\n## <span id = 5>参考资料</span>\n- [Windows下常用的100个CMD指令以及常见的操作](https://blog.csdn.net/CDersTeam/article/details/51346911)\n- [Linux常用命令大全](https://www.cnblogs.com/yjd_hycf_space/p/7730690.html)\n- [Linux下的压缩zip,解压缩unzip命令详解及实例](https://www.cnblogs.com/zdz8207/p/3765604.html)\n- [Linux top命令的用法详细详解](https://blog.csdn.net/dxl342/article/details/53507673)\n- [Git教程 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n- [详解git fetch与git pull的区别](https://blog.csdn.net/riddle1981/article/details/74938111)","source":"_posts/common-instructions.md","raw":"---\ntitle: Windows/CMD/Linux/Git常用命令整理\ndate: 2018-6-6 13:01:04\ncategories: [开发,总结]\ntags: [Windows,CMD,Linux,Git]\n---\nWindows/CMD/Linux/Git常用命令整理，由于平常经常会使用故趁热把这些都一起整理下。\n\n## 总览\n- [Windows Win+R 快捷操作](#1)\n- [CMD常用命令](#2)\n- [Linux常用命令](#3)\n- [Git常用命令](#4)\n- [参考资料](#5)\n\n---\n## <span id = 1>Windows Win+R 快捷操作</span>\n> 有时候不用去挨个点开什么控制面板啊再计算机什么的直接命令快速打开，列举平常使用率较高的几个\n### 打开本地服务\n`services.msc`这个对于开发人员是经常需要操作的\n### 打开注册表\n`regedit`有时候卸载或者重装软件的时候会需要操作注册表\n### 打开CMD界面\n`cmd`这个就不用说了，用管理员方式打开则需要右击操作\n### 打开组策略\n`gpedit.msc`可以查看计算机配置和用户配置\n### 打开记事本\n`notepad`\n### 磁盘清理\n`cleanmgr`可以快速清理一些回收垃圾\n### 查看win版本\n`winver`\n### 打开画图板\n`mspaint`\n### 远程连接\n`mstsc`\n### shutdown\n- `shutdown -r`表示重启\n- `shutdown -s -t 60`表示60秒后正常关机\n- `shutdown -s -t 60 -c 关机`则多了个提示消息<br>\n常用参数有：`\"-s\"正常关机、\"-f\"强制关机、\"-r\"重启、\"-t\"定时关机、\"-c\" 设置提示信息、\"-a\" 是取消定时关机`\n\n## <span id = 2>CMD常用命令</span>\n> 由于本人使用的都是Windows系统，平时难免会需要经常接触CMD来方便一些操作，列举平常使用率较高的几个(cd/dir/切换磁盘什么的这些就不说了...)\n### 查看IP信息\n`ipconfig`\n### 修改本机IP\n`netsh interface ip set address \"以太网\" static 192.168.30.100 255.255.255.0 192.168.30.1`<br>\n**注：这里`以太网`是网络名称，`192.168.30.100`是你要修改的IP`255.255.255.0`为子网掩码`192.168.30.1`为网关**\n### 网络诊断\n`ping putop.top`就是给putop.top发送数据包看有没有返回\n### 无线WLAN操作\n只要你输入`netsh wlan`就会出现许多提示，只要能看懂字就会操作了<br>\n如`netsh wlan connect wuxian`就是连接无线名为`wuxian`的无线网络了，`netsh wlan disconnect`就是断开无线连接\n### 查看端口状态\n- `netstat -ano`查看所有端口占用情况<br>\n- `netstat -aon|findstr \"8080\"`查看指定端口占用情况`8080`为端口号<br>\n- `tasklist|findstr \"2018\"`查看指定PID对应的进程`2018`为PID<br>\n- `taskkill /f /t /im java.exe`删除指定进程<br>\n完整语法为：\n```\nTASKKILL [/S system [/U username [/P [password]]]]\n         { [/FI filter] [/PID processid | /IM imagename] } [/T] [/F]\n\n    /S    system           指定要连接的远程系统。\n    /U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。\n    /P    [password]       为提供的用户上下文指定密码。如果忽略，提示输入。\n    /FI   filter           应用筛选器以选择一组任务。允许使用 \"*\"。例如，映像名称 eq acme*\n    /PID  processid        指定要终止的进程的 PID。使用 TaskList 取得 PID。\n    /IM   imagename        指定要终止的进程的映像名称。通配符 '*'可用来指定所有任务或映像名称。\n    /T                     终止指定的进程和由它启用的子进程。\n    /F                     指定强制终止进程。\n    /?                     显示帮助消息。\n```\n\n## <span id = 3>Linux常用命令</span>\n>平时部署项目也会用到Linux系统，整理下平时常用的几个(cd/ls/ll这些也不说了...)说来惭愧，经常用ftp操作感觉还挺方便还是Windows用多了啊\n### 系统显示\n- `date`显示系统时间\n- `cal 2018`显示2018年的日历表\n- `date 060610502018.00`设置日期和时间 月日时分年.秒\n- `clock -w`将时间修改保存到BIOS中\n- `cat /proc/cpuinfo`显示CPU info的信息\n- `lsusb -tv`显示USB设备\n\n### 关机、重启\n- `shutdown -h now`关闭系统\n- `shutdown -h hours:minutes &`按预定时间关闭系统\n- `shutdown -c`取消按预定时间关闭系统\n- `shutdown -r now`重启\n- `logout`注销\n\n### 文件和目录\n- `mkdir dir`创建名为dir的目录\n- `rmdir dir`删除名为dir的目录\n- `rm -rf dir`删除名为dir的目录并同时删除其内容\n- `rm -f file`删除名为file的文件\n- `mv dir new_dir`重命名/移动名为dir的目录\n- `cp file same_file`复制一个名为file的文件叫做same_file\n- `cp -a dir same_dir`复制一个名为dir的目录叫做same_dir\n- `cp dir/* .`复制一个目录下的所有文件到当前工作目录\n- `cp -a /tmp/dir`复制一个目录到当前工作目录\n\n### 磁盘空间\n- `df -h`显示已经挂载的分区列表\n- `du -sh dir`估算目录`dir`已经使用的磁盘空间\n\n### 文件权限\n- `ls -lh`显示权限\n- `chmod ugo+rwx dir`设置目录的所有人(u)、群组(g)以及其他人(o)以读（r）、写(w)和执行(x)的权限，使用 \"+\" 设置权限，使用 \"-\" 用于取消\n- `chattr +a file`只允许以追加方式读写文件\n- `chattr +i file1`设置成不可变的文件，不能被删除、修改、重命名或者链接\n- `chattr +S file`一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘\n- `chattr +u file`若文件被删除，系统会允许你在以后恢复这个被删除的文件 \n- `lsattr`显示特殊的属性\n\n### 解压/压缩文件\n- 压缩\n    + `tar –cvf jpg.tar *.jpg`将目录里所有jpg文件打包成tar.jpg\n    + `tar –czf jpg.tar.gz *.jpg`将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n    + `tar –cjf jpg.tar.bz2 *.jpg`将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n    + `tar –cZf jpg.tar.Z *.jpg`将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n    + `rar a jpg.rar *.jpg`rar格式的压缩，需要先下载rar for linux\n    + `zip jpg.zip *.jpg`zip格式的压缩，需要先下载zip for linux\n- 解压\n    + `tar –xvf file.tar`解压 tar包\n    + `tar -xzvf file.tar.gz`解压tar.gz\n    + `tar -xjvf file.tar.bz2`解压 tar.bz2\n    + `tar –xZvf file.tar.Z`解压tar.Z\n    + `unrar e file.rar`解压rar\n    + `unzip file.zip`解压zip\n\n### 查看文件内容\n- `cat file`从第一个字节开始正向查看文件`file`的内容\n- `tac file`从最后一行开始反向查看文件`file`的内容\n- `more file`查看一个长文件的内容\n- `head -2 file`查看一个文件的前两行\n- `tail -2 file`查看一个文件的最后两行\n- `tail -f /var/log/messages`实时查看被添加到一个文件中的内容，这个平时查看日志经常会用到\n\n### 进程\n- `ps -ef`查看所有运行进程\n- `ps -ef|grep java`指定查看java进程，java开发人员经常使用，比如鄙人\n- `kill PID`停止该PID表示进程，必要时加上`- 9`强制\n\n### 部署\n- `nohup java -jar xx.jar >/dev/null &`这是jar包的后台部署，加上`&`就是后台运行\n\n### top视图\n- `top`进入top视图<br>\n视图数据详解：\n```\n第一行：\n10:01:23 — 当前系统时间\n126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）\n2 users — 当前有2个用户登录系统\nload average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。\n\n第二行：\nTasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。\n\n第三行：cpu状态\n6.7% us — 用户空间占用CPU的百分比。\n0.4% sy — 内核空间占用CPU的百分比。\n0.0% ni — 改变过优先级的进程占用CPU的百分比\n92.9% id — 空闲CPU百分比\n0.0% wa — IO等待占用CPU的百分比\n0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比\n0.0% si — 软中断（Software Interrupts）占用CPU的百分比\n\n第四行：内存状态\n8306544k total — 物理内存总量（8GB）\n7775876k used — 使用中的内存总量（7.7GB）\n530668k free — 空闲内存总量（530M）\n79236k buffers — 缓存的内存量 （79M）\n\n第五行：swap交换分区\n2031608k total — 交换区总量（2GB）\n2556k used — 使用的交换区总量（2.5M）\n2029052k free — 空闲交换区总量（2GB）\n4231276k cached — 缓冲的交换区总量（4GB）\n\n第六行是空行\n\n第七行以下：各进程（任务）的状态监控\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\nCOMMAND — 进程名称（命令名/命令行）\n```\n\n## <span id = 4>Git常用命令</span>\n> 不免要使用git来版本管理\n\n- `git init`创建版本库\n- `git clone`克隆仓库\n- `git add`添加文件到暂存区\n- `git commit`提交更改,加上`- m`增加提交说明\n- `git status`查看状态\n- `git rm`删除文件\n- `git diff`文件对比\n- `git log`日志显示\n- `git push`上传\n- `git merge`合并\n- `git branch -d`删除分支\n- `git fetch`获取分支\n- `git pull`更新\n\n## <span id = 5>参考资料</span>\n- [Windows下常用的100个CMD指令以及常见的操作](https://blog.csdn.net/CDersTeam/article/details/51346911)\n- [Linux常用命令大全](https://www.cnblogs.com/yjd_hycf_space/p/7730690.html)\n- [Linux下的压缩zip,解压缩unzip命令详解及实例](https://www.cnblogs.com/zdz8207/p/3765604.html)\n- [Linux top命令的用法详细详解](https://blog.csdn.net/dxl342/article/details/53507673)\n- [Git教程 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n- [详解git fetch与git pull的区别](https://blog.csdn.net/riddle1981/article/details/74938111)","slug":"common-instructions","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhd003nk9i1b25j4upl","content":"<p>Windows&#x2F;CMD&#x2F;Linux&#x2F;Git常用命令整理，由于平常经常会使用故趁热把这些都一起整理下。</p>\n<h2 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h2><ul>\n<li><a href=\"#1\">Windows Win+R 快捷操作</a></li>\n<li><a href=\"#2\">CMD常用命令</a></li>\n<li><a href=\"#3\">Linux常用命令</a></li>\n<li><a href=\"#4\">Git常用命令</a></li>\n<li><a href=\"#5\">参考资料</a></li>\n</ul>\n<hr>\n<h2 id=\"Windows-Win-R-快捷操作\"><a href=\"#Windows-Win-R-快捷操作\" class=\"headerlink\" title=\"Windows Win+R 快捷操作\"></a><span id = 1>Windows Win+R 快捷操作</span></h2><blockquote>\n<p>有时候不用去挨个点开什么控制面板啊再计算机什么的直接命令快速打开，列举平常使用率较高的几个</p>\n</blockquote>\n<h3 id=\"打开本地服务\"><a href=\"#打开本地服务\" class=\"headerlink\" title=\"打开本地服务\"></a>打开本地服务</h3><p><code>services.msc</code>这个对于开发人员是经常需要操作的</p>\n<h3 id=\"打开注册表\"><a href=\"#打开注册表\" class=\"headerlink\" title=\"打开注册表\"></a>打开注册表</h3><p><code>regedit</code>有时候卸载或者重装软件的时候会需要操作注册表</p>\n<h3 id=\"打开CMD界面\"><a href=\"#打开CMD界面\" class=\"headerlink\" title=\"打开CMD界面\"></a>打开CMD界面</h3><p><code>cmd</code>这个就不用说了，用管理员方式打开则需要右击操作</p>\n<h3 id=\"打开组策略\"><a href=\"#打开组策略\" class=\"headerlink\" title=\"打开组策略\"></a>打开组策略</h3><p><code>gpedit.msc</code>可以查看计算机配置和用户配置</p>\n<h3 id=\"打开记事本\"><a href=\"#打开记事本\" class=\"headerlink\" title=\"打开记事本\"></a>打开记事本</h3><p><code>notepad</code></p>\n<h3 id=\"磁盘清理\"><a href=\"#磁盘清理\" class=\"headerlink\" title=\"磁盘清理\"></a>磁盘清理</h3><p><code>cleanmgr</code>可以快速清理一些回收垃圾</p>\n<h3 id=\"查看win版本\"><a href=\"#查看win版本\" class=\"headerlink\" title=\"查看win版本\"></a>查看win版本</h3><p><code>winver</code></p>\n<h3 id=\"打开画图板\"><a href=\"#打开画图板\" class=\"headerlink\" title=\"打开画图板\"></a>打开画图板</h3><p><code>mspaint</code></p>\n<h3 id=\"远程连接\"><a href=\"#远程连接\" class=\"headerlink\" title=\"远程连接\"></a>远程连接</h3><p><code>mstsc</code></p>\n<h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><ul>\n<li><code>shutdown -r</code>表示重启</li>\n<li><code>shutdown -s -t 60</code>表示60秒后正常关机</li>\n<li><code>shutdown -s -t 60 -c 关机</code>则多了个提示消息<br><br>常用参数有：<code>&quot;-s&quot;正常关机、&quot;-f&quot;强制关机、&quot;-r&quot;重启、&quot;-t&quot;定时关机、&quot;-c&quot; 设置提示信息、&quot;-a&quot; 是取消定时关机</code></li>\n</ul>\n<h2 id=\"CMD常用命令\"><a href=\"#CMD常用命令\" class=\"headerlink\" title=\"CMD常用命令\"></a><span id = 2>CMD常用命令</span></h2><blockquote>\n<p>由于本人使用的都是Windows系统，平时难免会需要经常接触CMD来方便一些操作，列举平常使用率较高的几个(cd&#x2F;dir&#x2F;切换磁盘什么的这些就不说了…)</p>\n</blockquote>\n<h3 id=\"查看IP信息\"><a href=\"#查看IP信息\" class=\"headerlink\" title=\"查看IP信息\"></a>查看IP信息</h3><p><code>ipconfig</code></p>\n<h3 id=\"修改本机IP\"><a href=\"#修改本机IP\" class=\"headerlink\" title=\"修改本机IP\"></a>修改本机IP</h3><p><code>netsh interface ip set address &quot;以太网&quot; static 192.168.30.100 255.255.255.0 192.168.30.1</code><br><br><strong>注：这里<code>以太网</code>是网络名称，<code>192.168.30.100</code>是你要修改的IP<code>255.255.255.0</code>为子网掩码<code>192.168.30.1</code>为网关</strong></p>\n<h3 id=\"网络诊断\"><a href=\"#网络诊断\" class=\"headerlink\" title=\"网络诊断\"></a>网络诊断</h3><p><code>ping putop.top</code>就是给putop.top发送数据包看有没有返回</p>\n<h3 id=\"无线WLAN操作\"><a href=\"#无线WLAN操作\" class=\"headerlink\" title=\"无线WLAN操作\"></a>无线WLAN操作</h3><p>只要你输入<code>netsh wlan</code>就会出现许多提示，只要能看懂字就会操作了<br><br>如<code>netsh wlan connect wuxian</code>就是连接无线名为<code>wuxian</code>的无线网络了，<code>netsh wlan disconnect</code>就是断开无线连接</p>\n<h3 id=\"查看端口状态\"><a href=\"#查看端口状态\" class=\"headerlink\" title=\"查看端口状态\"></a>查看端口状态</h3><ul>\n<li><code>netstat -ano</code>查看所有端口占用情况<br></li>\n<li><code>netstat -aon|findstr &quot;8080&quot;</code>查看指定端口占用情况<code>8080</code>为端口号<br></li>\n<li><code>tasklist|findstr &quot;2018&quot;</code>查看指定PID对应的进程<code>2018</code>为PID<br></li>\n<li><code>taskkill /f /t /im java.exe</code>删除指定进程<br><br>完整语法为：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASKKILL [/S system [/U username [/P [password]]]]</span><br><span class=\"line\">         &#123; [/FI filter] [/PID processid | /IM imagename] &#125; [/T] [/F]</span><br><span class=\"line\"></span><br><span class=\"line\">    /S    system           指定要连接的远程系统。</span><br><span class=\"line\">    /U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。</span><br><span class=\"line\">    /P    [password]       为提供的用户上下文指定密码。如果忽略，提示输入。</span><br><span class=\"line\">    /FI   filter           应用筛选器以选择一组任务。允许使用 &quot;*&quot;。例如，映像名称 eq acme*</span><br><span class=\"line\">    /PID  processid        指定要终止的进程的 PID。使用 TaskList 取得 PID。</span><br><span class=\"line\">    /IM   imagename        指定要终止的进程的映像名称。通配符 &#x27;*&#x27;可用来指定所有任务或映像名称。</span><br><span class=\"line\">    /T                     终止指定的进程和由它启用的子进程。</span><br><span class=\"line\">    /F                     指定强制终止进程。</span><br><span class=\"line\">    /?                     显示帮助消息。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Linux常用命令\"><a href=\"#Linux常用命令\" class=\"headerlink\" title=\"Linux常用命令\"></a><span id = 3>Linux常用命令</span></h2><blockquote>\n<p>平时部署项目也会用到Linux系统，整理下平时常用的几个(cd&#x2F;ls&#x2F;ll这些也不说了…)说来惭愧，经常用ftp操作感觉还挺方便还是Windows用多了啊</p>\n</blockquote>\n<h3 id=\"系统显示\"><a href=\"#系统显示\" class=\"headerlink\" title=\"系统显示\"></a>系统显示</h3><ul>\n<li><code>date</code>显示系统时间</li>\n<li><code>cal 2018</code>显示2018年的日历表</li>\n<li><code>date 060610502018.00</code>设置日期和时间 月日时分年.秒</li>\n<li><code>clock -w</code>将时间修改保存到BIOS中</li>\n<li><code>cat /proc/cpuinfo</code>显示CPU info的信息</li>\n<li><code>lsusb -tv</code>显示USB设备</li>\n</ul>\n<h3 id=\"关机、重启\"><a href=\"#关机、重启\" class=\"headerlink\" title=\"关机、重启\"></a>关机、重启</h3><ul>\n<li><code>shutdown -h now</code>关闭系统</li>\n<li><code>shutdown -h hours:minutes &amp;</code>按预定时间关闭系统</li>\n<li><code>shutdown -c</code>取消按预定时间关闭系统</li>\n<li><code>shutdown -r now</code>重启</li>\n<li><code>logout</code>注销</li>\n</ul>\n<h3 id=\"文件和目录\"><a href=\"#文件和目录\" class=\"headerlink\" title=\"文件和目录\"></a>文件和目录</h3><ul>\n<li><code>mkdir dir</code>创建名为dir的目录</li>\n<li><code>rmdir dir</code>删除名为dir的目录</li>\n<li><code>rm -rf dir</code>删除名为dir的目录并同时删除其内容</li>\n<li><code>rm -f file</code>删除名为file的文件</li>\n<li><code>mv dir new_dir</code>重命名&#x2F;移动名为dir的目录</li>\n<li><code>cp file same_file</code>复制一个名为file的文件叫做same_file</li>\n<li><code>cp -a dir same_dir</code>复制一个名为dir的目录叫做same_dir</li>\n<li><code>cp dir/* .</code>复制一个目录下的所有文件到当前工作目录</li>\n<li><code>cp -a /tmp/dir</code>复制一个目录到当前工作目录</li>\n</ul>\n<h3 id=\"磁盘空间\"><a href=\"#磁盘空间\" class=\"headerlink\" title=\"磁盘空间\"></a>磁盘空间</h3><ul>\n<li><code>df -h</code>显示已经挂载的分区列表</li>\n<li><code>du -sh dir</code>估算目录<code>dir</code>已经使用的磁盘空间</li>\n</ul>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><ul>\n<li><code>ls -lh</code>显示权限</li>\n<li><code>chmod ugo+rwx dir</code>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r）、写(w)和执行(x)的权限，使用 “+” 设置权限，使用 “-“ 用于取消</li>\n<li><code>chattr +a file</code>只允许以追加方式读写文件</li>\n<li><code>chattr +i file1</code>设置成不可变的文件，不能被删除、修改、重命名或者链接</li>\n<li><code>chattr +S file</code>一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</li>\n<li><code>chattr +u file</code>若文件被删除，系统会允许你在以后恢复这个被删除的文件 </li>\n<li><code>lsattr</code>显示特殊的属性</li>\n</ul>\n<h3 id=\"解压-压缩文件\"><a href=\"#解压-压缩文件\" class=\"headerlink\" title=\"解压&#x2F;压缩文件\"></a>解压&#x2F;压缩文件</h3><ul>\n<li>压缩<ul>\n<li><code>tar –cvf jpg.tar *.jpg</code>将目录里所有jpg文件打包成tar.jpg</li>\n<li><code>tar –czf jpg.tar.gz *.jpg</code>将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</li>\n<li><code>tar –cjf jpg.tar.bz2 *.jpg</code>将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</li>\n<li><code>tar –cZf jpg.tar.Z *.jpg</code>将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</li>\n<li><code>rar a jpg.rar *.jpg</code>rar格式的压缩，需要先下载rar for linux</li>\n<li><code>zip jpg.zip *.jpg</code>zip格式的压缩，需要先下载zip for linux</li>\n</ul>\n</li>\n<li>解压<ul>\n<li><code>tar –xvf file.tar</code>解压 tar包</li>\n<li><code>tar -xzvf file.tar.gz</code>解压tar.gz</li>\n<li><code>tar -xjvf file.tar.bz2</code>解压 tar.bz2</li>\n<li><code>tar –xZvf file.tar.Z</code>解压tar.Z</li>\n<li><code>unrar e file.rar</code>解压rar</li>\n<li><code>unzip file.zip</code>解压zip</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看文件内容\"><a href=\"#查看文件内容\" class=\"headerlink\" title=\"查看文件内容\"></a>查看文件内容</h3><ul>\n<li><code>cat file</code>从第一个字节开始正向查看文件<code>file</code>的内容</li>\n<li><code>tac file</code>从最后一行开始反向查看文件<code>file</code>的内容</li>\n<li><code>more file</code>查看一个长文件的内容</li>\n<li><code>head -2 file</code>查看一个文件的前两行</li>\n<li><code>tail -2 file</code>查看一个文件的最后两行</li>\n<li><code>tail -f /var/log/messages</code>实时查看被添加到一个文件中的内容，这个平时查看日志经常会用到</li>\n</ul>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><ul>\n<li><code>ps -ef</code>查看所有运行进程</li>\n<li><code>ps -ef|grep java</code>指定查看java进程，java开发人员经常使用，比如鄙人</li>\n<li><code>kill PID</code>停止该PID表示进程，必要时加上<code>- 9</code>强制</li>\n</ul>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><ul>\n<li><code>nohup java -jar xx.jar &gt;/dev/null &amp;</code>这是jar包的后台部署，加上<code>&amp;</code>就是后台运行</li>\n</ul>\n<h3 id=\"top视图\"><a href=\"#top视图\" class=\"headerlink\" title=\"top视图\"></a>top视图</h3><ul>\n<li><code>top</code>进入top视图<br><br>视图数据详解：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行：</span><br><span class=\"line\">10:01:23 — 当前系统时间</span><br><span class=\"line\">126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）</span><br><span class=\"line\">2 users — 当前有2个用户登录系统</span><br><span class=\"line\">load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</span><br><span class=\"line\"></span><br><span class=\"line\">第二行：</span><br><span class=\"line\">Tasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</span><br><span class=\"line\"></span><br><span class=\"line\">第三行：cpu状态</span><br><span class=\"line\">6.7% us — 用户空间占用CPU的百分比。</span><br><span class=\"line\">0.4% sy — 内核空间占用CPU的百分比。</span><br><span class=\"line\">0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class=\"line\">92.9% id — 空闲CPU百分比</span><br><span class=\"line\">0.0% wa — IO等待占用CPU的百分比</span><br><span class=\"line\">0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class=\"line\">0.0% si — 软中断（Software Interrupts）占用CPU的百分比</span><br><span class=\"line\"></span><br><span class=\"line\">第四行：内存状态</span><br><span class=\"line\">8306544k total — 物理内存总量（8GB）</span><br><span class=\"line\">7775876k used — 使用中的内存总量（7.7GB）</span><br><span class=\"line\">530668k free — 空闲内存总量（530M）</span><br><span class=\"line\">79236k buffers — 缓存的内存量 （79M）</span><br><span class=\"line\"></span><br><span class=\"line\">第五行：swap交换分区</span><br><span class=\"line\">2031608k total — 交换区总量（2GB）</span><br><span class=\"line\">2556k used — 使用的交换区总量（2.5M）</span><br><span class=\"line\">2029052k free — 空闲交换区总量（2GB）</span><br><span class=\"line\">4231276k cached — 缓冲的交换区总量（4GB）</span><br><span class=\"line\"></span><br><span class=\"line\">第六行是空行</span><br><span class=\"line\"></span><br><span class=\"line\">第七行以下：各进程（任务）的状态监控</span><br><span class=\"line\">PID — 进程id</span><br><span class=\"line\">USER — 进程所有者</span><br><span class=\"line\">PR — 进程优先级</span><br><span class=\"line\">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class=\"line\">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class=\"line\">RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class=\"line\">SHR — 共享内存大小，单位kb</span><br><span class=\"line\">S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class=\"line\">%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class=\"line\">%MEM — 进程使用的物理内存百分比</span><br><span class=\"line\">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class=\"line\">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a><span id = 4>Git常用命令</span></h2><blockquote>\n<p>不免要使用git来版本管理</p>\n</blockquote>\n<ul>\n<li><code>git init</code>创建版本库</li>\n<li><code>git clone</code>克隆仓库</li>\n<li><code>git add</code>添加文件到暂存区</li>\n<li><code>git commit</code>提交更改,加上<code>- m</code>增加提交说明</li>\n<li><code>git status</code>查看状态</li>\n<li><code>git rm</code>删除文件</li>\n<li><code>git diff</code>文件对比</li>\n<li><code>git log</code>日志显示</li>\n<li><code>git push</code>上传</li>\n<li><code>git merge</code>合并</li>\n<li><code>git branch -d</code>删除分支</li>\n<li><code>git fetch</code>获取分支</li>\n<li><code>git pull</code>更新</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><span id = 5>参考资料</span></h2><ul>\n<li><a href=\"https://blog.csdn.net/CDersTeam/article/details/51346911\">Windows下常用的100个CMD指令以及常见的操作</a></li>\n<li><a href=\"https://www.cnblogs.com/yjd_hycf_space/p/7730690.html\">Linux常用命令大全</a></li>\n<li><a href=\"https://www.cnblogs.com/zdz8207/p/3765604.html\">Linux下的压缩zip,解压缩unzip命令详解及实例</a></li>\n<li><a href=\"https://blog.csdn.net/dxl342/article/details/53507673\">Linux top命令的用法详细详解</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">Git教程 - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/riddle1981/article/details/74938111\">详解git fetch与git pull的区别</a></li>\n</ul>\n","excerpt":"","more":"<p>Windows&#x2F;CMD&#x2F;Linux&#x2F;Git常用命令整理，由于平常经常会使用故趁热把这些都一起整理下。</p>\n<h2 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h2><ul>\n<li><a href=\"#1\">Windows Win+R 快捷操作</a></li>\n<li><a href=\"#2\">CMD常用命令</a></li>\n<li><a href=\"#3\">Linux常用命令</a></li>\n<li><a href=\"#4\">Git常用命令</a></li>\n<li><a href=\"#5\">参考资料</a></li>\n</ul>\n<hr>\n<h2 id=\"Windows-Win-R-快捷操作\"><a href=\"#Windows-Win-R-快捷操作\" class=\"headerlink\" title=\"Windows Win+R 快捷操作\"></a><span id = 1>Windows Win+R 快捷操作</span></h2><blockquote>\n<p>有时候不用去挨个点开什么控制面板啊再计算机什么的直接命令快速打开，列举平常使用率较高的几个</p>\n</blockquote>\n<h3 id=\"打开本地服务\"><a href=\"#打开本地服务\" class=\"headerlink\" title=\"打开本地服务\"></a>打开本地服务</h3><p><code>services.msc</code>这个对于开发人员是经常需要操作的</p>\n<h3 id=\"打开注册表\"><a href=\"#打开注册表\" class=\"headerlink\" title=\"打开注册表\"></a>打开注册表</h3><p><code>regedit</code>有时候卸载或者重装软件的时候会需要操作注册表</p>\n<h3 id=\"打开CMD界面\"><a href=\"#打开CMD界面\" class=\"headerlink\" title=\"打开CMD界面\"></a>打开CMD界面</h3><p><code>cmd</code>这个就不用说了，用管理员方式打开则需要右击操作</p>\n<h3 id=\"打开组策略\"><a href=\"#打开组策略\" class=\"headerlink\" title=\"打开组策略\"></a>打开组策略</h3><p><code>gpedit.msc</code>可以查看计算机配置和用户配置</p>\n<h3 id=\"打开记事本\"><a href=\"#打开记事本\" class=\"headerlink\" title=\"打开记事本\"></a>打开记事本</h3><p><code>notepad</code></p>\n<h3 id=\"磁盘清理\"><a href=\"#磁盘清理\" class=\"headerlink\" title=\"磁盘清理\"></a>磁盘清理</h3><p><code>cleanmgr</code>可以快速清理一些回收垃圾</p>\n<h3 id=\"查看win版本\"><a href=\"#查看win版本\" class=\"headerlink\" title=\"查看win版本\"></a>查看win版本</h3><p><code>winver</code></p>\n<h3 id=\"打开画图板\"><a href=\"#打开画图板\" class=\"headerlink\" title=\"打开画图板\"></a>打开画图板</h3><p><code>mspaint</code></p>\n<h3 id=\"远程连接\"><a href=\"#远程连接\" class=\"headerlink\" title=\"远程连接\"></a>远程连接</h3><p><code>mstsc</code></p>\n<h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><ul>\n<li><code>shutdown -r</code>表示重启</li>\n<li><code>shutdown -s -t 60</code>表示60秒后正常关机</li>\n<li><code>shutdown -s -t 60 -c 关机</code>则多了个提示消息<br><br>常用参数有：<code>&quot;-s&quot;正常关机、&quot;-f&quot;强制关机、&quot;-r&quot;重启、&quot;-t&quot;定时关机、&quot;-c&quot; 设置提示信息、&quot;-a&quot; 是取消定时关机</code></li>\n</ul>\n<h2 id=\"CMD常用命令\"><a href=\"#CMD常用命令\" class=\"headerlink\" title=\"CMD常用命令\"></a><span id = 2>CMD常用命令</span></h2><blockquote>\n<p>由于本人使用的都是Windows系统，平时难免会需要经常接触CMD来方便一些操作，列举平常使用率较高的几个(cd&#x2F;dir&#x2F;切换磁盘什么的这些就不说了…)</p>\n</blockquote>\n<h3 id=\"查看IP信息\"><a href=\"#查看IP信息\" class=\"headerlink\" title=\"查看IP信息\"></a>查看IP信息</h3><p><code>ipconfig</code></p>\n<h3 id=\"修改本机IP\"><a href=\"#修改本机IP\" class=\"headerlink\" title=\"修改本机IP\"></a>修改本机IP</h3><p><code>netsh interface ip set address &quot;以太网&quot; static 192.168.30.100 255.255.255.0 192.168.30.1</code><br><br><strong>注：这里<code>以太网</code>是网络名称，<code>192.168.30.100</code>是你要修改的IP<code>255.255.255.0</code>为子网掩码<code>192.168.30.1</code>为网关</strong></p>\n<h3 id=\"网络诊断\"><a href=\"#网络诊断\" class=\"headerlink\" title=\"网络诊断\"></a>网络诊断</h3><p><code>ping putop.top</code>就是给putop.top发送数据包看有没有返回</p>\n<h3 id=\"无线WLAN操作\"><a href=\"#无线WLAN操作\" class=\"headerlink\" title=\"无线WLAN操作\"></a>无线WLAN操作</h3><p>只要你输入<code>netsh wlan</code>就会出现许多提示，只要能看懂字就会操作了<br><br>如<code>netsh wlan connect wuxian</code>就是连接无线名为<code>wuxian</code>的无线网络了，<code>netsh wlan disconnect</code>就是断开无线连接</p>\n<h3 id=\"查看端口状态\"><a href=\"#查看端口状态\" class=\"headerlink\" title=\"查看端口状态\"></a>查看端口状态</h3><ul>\n<li><code>netstat -ano</code>查看所有端口占用情况<br></li>\n<li><code>netstat -aon|findstr &quot;8080&quot;</code>查看指定端口占用情况<code>8080</code>为端口号<br></li>\n<li><code>tasklist|findstr &quot;2018&quot;</code>查看指定PID对应的进程<code>2018</code>为PID<br></li>\n<li><code>taskkill /f /t /im java.exe</code>删除指定进程<br><br>完整语法为：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TASKKILL [/S system [/U username [/P [password]]]]</span><br><span class=\"line\">         &#123; [/FI filter] [/PID processid | /IM imagename] &#125; [/T] [/F]</span><br><span class=\"line\"></span><br><span class=\"line\">    /S    system           指定要连接的远程系统。</span><br><span class=\"line\">    /U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。</span><br><span class=\"line\">    /P    [password]       为提供的用户上下文指定密码。如果忽略，提示输入。</span><br><span class=\"line\">    /FI   filter           应用筛选器以选择一组任务。允许使用 &quot;*&quot;。例如，映像名称 eq acme*</span><br><span class=\"line\">    /PID  processid        指定要终止的进程的 PID。使用 TaskList 取得 PID。</span><br><span class=\"line\">    /IM   imagename        指定要终止的进程的映像名称。通配符 &#x27;*&#x27;可用来指定所有任务或映像名称。</span><br><span class=\"line\">    /T                     终止指定的进程和由它启用的子进程。</span><br><span class=\"line\">    /F                     指定强制终止进程。</span><br><span class=\"line\">    /?                     显示帮助消息。</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Linux常用命令\"><a href=\"#Linux常用命令\" class=\"headerlink\" title=\"Linux常用命令\"></a><span id = 3>Linux常用命令</span></h2><blockquote>\n<p>平时部署项目也会用到Linux系统，整理下平时常用的几个(cd&#x2F;ls&#x2F;ll这些也不说了…)说来惭愧，经常用ftp操作感觉还挺方便还是Windows用多了啊</p>\n</blockquote>\n<h3 id=\"系统显示\"><a href=\"#系统显示\" class=\"headerlink\" title=\"系统显示\"></a>系统显示</h3><ul>\n<li><code>date</code>显示系统时间</li>\n<li><code>cal 2018</code>显示2018年的日历表</li>\n<li><code>date 060610502018.00</code>设置日期和时间 月日时分年.秒</li>\n<li><code>clock -w</code>将时间修改保存到BIOS中</li>\n<li><code>cat /proc/cpuinfo</code>显示CPU info的信息</li>\n<li><code>lsusb -tv</code>显示USB设备</li>\n</ul>\n<h3 id=\"关机、重启\"><a href=\"#关机、重启\" class=\"headerlink\" title=\"关机、重启\"></a>关机、重启</h3><ul>\n<li><code>shutdown -h now</code>关闭系统</li>\n<li><code>shutdown -h hours:minutes &amp;</code>按预定时间关闭系统</li>\n<li><code>shutdown -c</code>取消按预定时间关闭系统</li>\n<li><code>shutdown -r now</code>重启</li>\n<li><code>logout</code>注销</li>\n</ul>\n<h3 id=\"文件和目录\"><a href=\"#文件和目录\" class=\"headerlink\" title=\"文件和目录\"></a>文件和目录</h3><ul>\n<li><code>mkdir dir</code>创建名为dir的目录</li>\n<li><code>rmdir dir</code>删除名为dir的目录</li>\n<li><code>rm -rf dir</code>删除名为dir的目录并同时删除其内容</li>\n<li><code>rm -f file</code>删除名为file的文件</li>\n<li><code>mv dir new_dir</code>重命名&#x2F;移动名为dir的目录</li>\n<li><code>cp file same_file</code>复制一个名为file的文件叫做same_file</li>\n<li><code>cp -a dir same_dir</code>复制一个名为dir的目录叫做same_dir</li>\n<li><code>cp dir/* .</code>复制一个目录下的所有文件到当前工作目录</li>\n<li><code>cp -a /tmp/dir</code>复制一个目录到当前工作目录</li>\n</ul>\n<h3 id=\"磁盘空间\"><a href=\"#磁盘空间\" class=\"headerlink\" title=\"磁盘空间\"></a>磁盘空间</h3><ul>\n<li><code>df -h</code>显示已经挂载的分区列表</li>\n<li><code>du -sh dir</code>估算目录<code>dir</code>已经使用的磁盘空间</li>\n</ul>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><ul>\n<li><code>ls -lh</code>显示权限</li>\n<li><code>chmod ugo+rwx dir</code>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r）、写(w)和执行(x)的权限，使用 “+” 设置权限，使用 “-“ 用于取消</li>\n<li><code>chattr +a file</code>只允许以追加方式读写文件</li>\n<li><code>chattr +i file1</code>设置成不可变的文件，不能被删除、修改、重命名或者链接</li>\n<li><code>chattr +S file</code>一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</li>\n<li><code>chattr +u file</code>若文件被删除，系统会允许你在以后恢复这个被删除的文件 </li>\n<li><code>lsattr</code>显示特殊的属性</li>\n</ul>\n<h3 id=\"解压-压缩文件\"><a href=\"#解压-压缩文件\" class=\"headerlink\" title=\"解压&#x2F;压缩文件\"></a>解压&#x2F;压缩文件</h3><ul>\n<li>压缩<ul>\n<li><code>tar –cvf jpg.tar *.jpg</code>将目录里所有jpg文件打包成tar.jpg</li>\n<li><code>tar –czf jpg.tar.gz *.jpg</code>将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</li>\n<li><code>tar –cjf jpg.tar.bz2 *.jpg</code>将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</li>\n<li><code>tar –cZf jpg.tar.Z *.jpg</code>将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</li>\n<li><code>rar a jpg.rar *.jpg</code>rar格式的压缩，需要先下载rar for linux</li>\n<li><code>zip jpg.zip *.jpg</code>zip格式的压缩，需要先下载zip for linux</li>\n</ul>\n</li>\n<li>解压<ul>\n<li><code>tar –xvf file.tar</code>解压 tar包</li>\n<li><code>tar -xzvf file.tar.gz</code>解压tar.gz</li>\n<li><code>tar -xjvf file.tar.bz2</code>解压 tar.bz2</li>\n<li><code>tar –xZvf file.tar.Z</code>解压tar.Z</li>\n<li><code>unrar e file.rar</code>解压rar</li>\n<li><code>unzip file.zip</code>解压zip</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"查看文件内容\"><a href=\"#查看文件内容\" class=\"headerlink\" title=\"查看文件内容\"></a>查看文件内容</h3><ul>\n<li><code>cat file</code>从第一个字节开始正向查看文件<code>file</code>的内容</li>\n<li><code>tac file</code>从最后一行开始反向查看文件<code>file</code>的内容</li>\n<li><code>more file</code>查看一个长文件的内容</li>\n<li><code>head -2 file</code>查看一个文件的前两行</li>\n<li><code>tail -2 file</code>查看一个文件的最后两行</li>\n<li><code>tail -f /var/log/messages</code>实时查看被添加到一个文件中的内容，这个平时查看日志经常会用到</li>\n</ul>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><ul>\n<li><code>ps -ef</code>查看所有运行进程</li>\n<li><code>ps -ef|grep java</code>指定查看java进程，java开发人员经常使用，比如鄙人</li>\n<li><code>kill PID</code>停止该PID表示进程，必要时加上<code>- 9</code>强制</li>\n</ul>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><ul>\n<li><code>nohup java -jar xx.jar &gt;/dev/null &amp;</code>这是jar包的后台部署，加上<code>&amp;</code>就是后台运行</li>\n</ul>\n<h3 id=\"top视图\"><a href=\"#top视图\" class=\"headerlink\" title=\"top视图\"></a>top视图</h3><ul>\n<li><code>top</code>进入top视图<br><br>视图数据详解：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行：</span><br><span class=\"line\">10:01:23 — 当前系统时间</span><br><span class=\"line\">126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）</span><br><span class=\"line\">2 users — 当前有2个用户登录系统</span><br><span class=\"line\">load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</span><br><span class=\"line\"></span><br><span class=\"line\">第二行：</span><br><span class=\"line\">Tasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</span><br><span class=\"line\"></span><br><span class=\"line\">第三行：cpu状态</span><br><span class=\"line\">6.7% us — 用户空间占用CPU的百分比。</span><br><span class=\"line\">0.4% sy — 内核空间占用CPU的百分比。</span><br><span class=\"line\">0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class=\"line\">92.9% id — 空闲CPU百分比</span><br><span class=\"line\">0.0% wa — IO等待占用CPU的百分比</span><br><span class=\"line\">0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class=\"line\">0.0% si — 软中断（Software Interrupts）占用CPU的百分比</span><br><span class=\"line\"></span><br><span class=\"line\">第四行：内存状态</span><br><span class=\"line\">8306544k total — 物理内存总量（8GB）</span><br><span class=\"line\">7775876k used — 使用中的内存总量（7.7GB）</span><br><span class=\"line\">530668k free — 空闲内存总量（530M）</span><br><span class=\"line\">79236k buffers — 缓存的内存量 （79M）</span><br><span class=\"line\"></span><br><span class=\"line\">第五行：swap交换分区</span><br><span class=\"line\">2031608k total — 交换区总量（2GB）</span><br><span class=\"line\">2556k used — 使用的交换区总量（2.5M）</span><br><span class=\"line\">2029052k free — 空闲交换区总量（2GB）</span><br><span class=\"line\">4231276k cached — 缓冲的交换区总量（4GB）</span><br><span class=\"line\"></span><br><span class=\"line\">第六行是空行</span><br><span class=\"line\"></span><br><span class=\"line\">第七行以下：各进程（任务）的状态监控</span><br><span class=\"line\">PID — 进程id</span><br><span class=\"line\">USER — 进程所有者</span><br><span class=\"line\">PR — 进程优先级</span><br><span class=\"line\">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class=\"line\">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class=\"line\">RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class=\"line\">SHR — 共享内存大小，单位kb</span><br><span class=\"line\">S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class=\"line\">%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class=\"line\">%MEM — 进程使用的物理内存百分比</span><br><span class=\"line\">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class=\"line\">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a><span id = 4>Git常用命令</span></h2><blockquote>\n<p>不免要使用git来版本管理</p>\n</blockquote>\n<ul>\n<li><code>git init</code>创建版本库</li>\n<li><code>git clone</code>克隆仓库</li>\n<li><code>git add</code>添加文件到暂存区</li>\n<li><code>git commit</code>提交更改,加上<code>- m</code>增加提交说明</li>\n<li><code>git status</code>查看状态</li>\n<li><code>git rm</code>删除文件</li>\n<li><code>git diff</code>文件对比</li>\n<li><code>git log</code>日志显示</li>\n<li><code>git push</code>上传</li>\n<li><code>git merge</code>合并</li>\n<li><code>git branch -d</code>删除分支</li>\n<li><code>git fetch</code>获取分支</li>\n<li><code>git pull</code>更新</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a><span id = 5>参考资料</span></h2><ul>\n<li><a href=\"https://blog.csdn.net/CDersTeam/article/details/51346911\">Windows下常用的100个CMD指令以及常见的操作</a></li>\n<li><a href=\"https://www.cnblogs.com/yjd_hycf_space/p/7730690.html\">Linux常用命令大全</a></li>\n<li><a href=\"https://www.cnblogs.com/zdz8207/p/3765604.html\">Linux下的压缩zip,解压缩unzip命令详解及实例</a></li>\n<li><a href=\"https://blog.csdn.net/dxl342/article/details/53507673\">Linux top命令的用法详细详解</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">Git教程 - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/riddle1981/article/details/74938111\">详解git fetch与git pull的区别</a></li>\n</ul>\n"},{"title":"凉爽九月（2018）","date":"2018-09-30T05:06:00.000Z","_content":"\n> 近几日天愈发见凉，夜晚也裸睡不得了。\n\n这帮人，唉。步入社会后确实大家之间的联系会越来越少，有这个心境，时间上也不允许啊，都得赚钱吃饭没办法……\n\n本来是原先计划五人中秋一同去重庆耍几天。可奈何机票小贵，下不了这个手，何况有人明年还准备在苏州买婚房了，攒钱中，羡慕。后，众人纷纷拿不准放松地点，最终决定周边自驾游，先去杭州再去横店，这是计划。\n\n什么！？女朋友亲戚忌日周年？还有这种事情的？何况婚都还没接呢，这就得过去，还是个大事。对了，就是明年准备在苏州买婚房那位，然后就五人缺席一人，计划照旧。\n\n提前一个月我就买好了来回车票，就等那天放飞了，一年到头没有个生活，唉，哭唧唧。\n\n什么！？临时上头派你去大连出差？还有这种事情的？连中秋都在大连过，我的乖乖宝贝啊。\n\n又缺一人，剩三人。谁玩球谁玩！遂，计划猝！\n\n车票退回，亏几十手续费。特么还买了张杭州博览会的门票，二十，也废了。哭唧唧。\n\n临时决定还是回家吧，买了 22 号下午的票，24 号上午回来。哭唧唧。\n\n---\n\n不说那些伤心事了。\n\n最近欧皇啊，豆瓣上海观影活动中连抽中了两次。\n\n- 第一次是《悲伤逆流成河》（不是郭敬明导的），讲的是校园暴力的。我没有看过小说原著，不过说实在的郭敬明骂声很多，但是他的书看的人还不少，至少我这个年龄层次的，挺多，小女生就喜欢看这些。电影看完后感触也是有的，反映了很多人性的东西，电影全程看完也没有睡意，我比较幸运从小也没有经历过那些校园暴力，最多也就只是一些小朋友之间的矛盾。看完之后我在想，那些真实世界里经历过校园暴力的人的身心会怎么样，他们可能那时候小也许没有想那么多，但是等到长大了，懂事后，回头想起那段时间，会是个什么样的心情。电影放完之后还来了两电影中新人演员，都很年轻，演技虽然青涩也是可认可的，其中主演的演技真的很用力，感染力很强！\n\n![悲伤逆流成河 点映](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/douban-sad.jpg)\n\n**我说来个中间点的位置，结果给我来了张最后排的还是个角落。。**\n\n- 然后昨天去看的《李茶的姑妈》，开心麻花出品国产喜剧。这个赞！国产喜剧除了星爷很少能让观众全场一直笑到最后的，我也是笑出了声，边上那些女孩子就更别说了，猪声……支持国产喜剧，看好开心麻花！没拍图片，也是做了个角落不过还好，不是最后排了。（卢靖姗身材真棒！！真喜欢这种健康的身材）\n\n---\n\n本来是计划中秋去放飞顺道回趟家，然后国庆宅出租房七天领悟自然真理。\n\n现在变成了中秋回家，国庆回家。也好，趁着假期在家多呆呆，山美水清环境好（家附近在通国道，环境其实破坏了很多啊）。\n\n我姐中秋把一个男的叫到家里来吃了个饭，通过相亲认识的，这还是第一个来家里吃饭的，不知道能不能成。人嘛看上去还行，就这样看吧，老姐也是要奔三了。**至于我嘛，现在只想躺在床上顺道还把钱给赚了**。婚姻这事，看缘分吗？\n\n又跟家里聊了下，爸妈都是普通农民，辛苦一辈子把我和我姐拉扯大又盖了个新房，已经是很了不起了。现在就是家里种着几亩葡萄，收获季节比较忙。等到我要结婚买房了也不能太指望家里，毕竟他们二老还要养老的，需要备点钱，虽然以后每月都有养老金。\n\n现在是这么想的，先在上海再打拼几年，能多赚点钱就赚，当然身体还是继续要锻炼的。看以后缘分有没有，如果缘分来了，购房资格有了，手上又能够勉强付得起个首付了，那就没准要扎根上海了。不过这还太遥远了。\n\n---\n\n今天真是厉害了，骑个自行车被交警拦下来记录信息警告了。。\n\n说下次再抓到就要罚款 50 块了，运气不好运气不好，也是我的第一次了。\n\n以后骑车得小心了，负责的交警也是好的，确实随着共享单车出现这个自行车越来越难管理了。大城市是得好好整顿整顿。\n\n---\n\n我就是对未知的特别感兴趣，什么都想了解下，也特别喜欢扩宽自己的眼界。世界变化太快，生活中也经常时不时会触及到不同的领域，俗话说`技多不压身`，多学学总没错。但也说`要专精`。我个人是觉得，眼界是一定要不断扩宽，不能做一只井底之蛙。在领域不断放大的同时也要放绝大多的精力在某一个具体领域中探求，前提是你要清楚找准了自己想要专精的领域。不过这就是难处了，大多都是在迷茫中啊。\n\n失败了不可怕，可怕的是失败后无法重拾的心。\n\n每年要给自己定些目标。用一张图来结束此篇：\n\n![扩宽眼界](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Broaden-the-horizon.png)\n","source":"_posts/cool-september-2018.md","raw":"---\ntitle: 凉爽九月（2018）\ndate: 2018-9-30 13:06:00\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 近几日天愈发见凉，夜晚也裸睡不得了。\n\n这帮人，唉。步入社会后确实大家之间的联系会越来越少，有这个心境，时间上也不允许啊，都得赚钱吃饭没办法……\n\n本来是原先计划五人中秋一同去重庆耍几天。可奈何机票小贵，下不了这个手，何况有人明年还准备在苏州买婚房了，攒钱中，羡慕。后，众人纷纷拿不准放松地点，最终决定周边自驾游，先去杭州再去横店，这是计划。\n\n什么！？女朋友亲戚忌日周年？还有这种事情的？何况婚都还没接呢，这就得过去，还是个大事。对了，就是明年准备在苏州买婚房那位，然后就五人缺席一人，计划照旧。\n\n提前一个月我就买好了来回车票，就等那天放飞了，一年到头没有个生活，唉，哭唧唧。\n\n什么！？临时上头派你去大连出差？还有这种事情的？连中秋都在大连过，我的乖乖宝贝啊。\n\n又缺一人，剩三人。谁玩球谁玩！遂，计划猝！\n\n车票退回，亏几十手续费。特么还买了张杭州博览会的门票，二十，也废了。哭唧唧。\n\n临时决定还是回家吧，买了 22 号下午的票，24 号上午回来。哭唧唧。\n\n---\n\n不说那些伤心事了。\n\n最近欧皇啊，豆瓣上海观影活动中连抽中了两次。\n\n- 第一次是《悲伤逆流成河》（不是郭敬明导的），讲的是校园暴力的。我没有看过小说原著，不过说实在的郭敬明骂声很多，但是他的书看的人还不少，至少我这个年龄层次的，挺多，小女生就喜欢看这些。电影看完后感触也是有的，反映了很多人性的东西，电影全程看完也没有睡意，我比较幸运从小也没有经历过那些校园暴力，最多也就只是一些小朋友之间的矛盾。看完之后我在想，那些真实世界里经历过校园暴力的人的身心会怎么样，他们可能那时候小也许没有想那么多，但是等到长大了，懂事后，回头想起那段时间，会是个什么样的心情。电影放完之后还来了两电影中新人演员，都很年轻，演技虽然青涩也是可认可的，其中主演的演技真的很用力，感染力很强！\n\n![悲伤逆流成河 点映](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/douban-sad.jpg)\n\n**我说来个中间点的位置，结果给我来了张最后排的还是个角落。。**\n\n- 然后昨天去看的《李茶的姑妈》，开心麻花出品国产喜剧。这个赞！国产喜剧除了星爷很少能让观众全场一直笑到最后的，我也是笑出了声，边上那些女孩子就更别说了，猪声……支持国产喜剧，看好开心麻花！没拍图片，也是做了个角落不过还好，不是最后排了。（卢靖姗身材真棒！！真喜欢这种健康的身材）\n\n---\n\n本来是计划中秋去放飞顺道回趟家，然后国庆宅出租房七天领悟自然真理。\n\n现在变成了中秋回家，国庆回家。也好，趁着假期在家多呆呆，山美水清环境好（家附近在通国道，环境其实破坏了很多啊）。\n\n我姐中秋把一个男的叫到家里来吃了个饭，通过相亲认识的，这还是第一个来家里吃饭的，不知道能不能成。人嘛看上去还行，就这样看吧，老姐也是要奔三了。**至于我嘛，现在只想躺在床上顺道还把钱给赚了**。婚姻这事，看缘分吗？\n\n又跟家里聊了下，爸妈都是普通农民，辛苦一辈子把我和我姐拉扯大又盖了个新房，已经是很了不起了。现在就是家里种着几亩葡萄，收获季节比较忙。等到我要结婚买房了也不能太指望家里，毕竟他们二老还要养老的，需要备点钱，虽然以后每月都有养老金。\n\n现在是这么想的，先在上海再打拼几年，能多赚点钱就赚，当然身体还是继续要锻炼的。看以后缘分有没有，如果缘分来了，购房资格有了，手上又能够勉强付得起个首付了，那就没准要扎根上海了。不过这还太遥远了。\n\n---\n\n今天真是厉害了，骑个自行车被交警拦下来记录信息警告了。。\n\n说下次再抓到就要罚款 50 块了，运气不好运气不好，也是我的第一次了。\n\n以后骑车得小心了，负责的交警也是好的，确实随着共享单车出现这个自行车越来越难管理了。大城市是得好好整顿整顿。\n\n---\n\n我就是对未知的特别感兴趣，什么都想了解下，也特别喜欢扩宽自己的眼界。世界变化太快，生活中也经常时不时会触及到不同的领域，俗话说`技多不压身`，多学学总没错。但也说`要专精`。我个人是觉得，眼界是一定要不断扩宽，不能做一只井底之蛙。在领域不断放大的同时也要放绝大多的精力在某一个具体领域中探求，前提是你要清楚找准了自己想要专精的领域。不过这就是难处了，大多都是在迷茫中啊。\n\n失败了不可怕，可怕的是失败后无法重拾的心。\n\n每年要给自己定些目标。用一张图来结束此篇：\n\n![扩宽眼界](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Broaden-the-horizon.png)\n","slug":"cool-september-2018","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhd003sk9i174bc9hzo","content":"<blockquote>\n<p>近几日天愈发见凉，夜晚也裸睡不得了。</p>\n</blockquote>\n<p>这帮人，唉。步入社会后确实大家之间的联系会越来越少，有这个心境，时间上也不允许啊，都得赚钱吃饭没办法……</p>\n<p>本来是原先计划五人中秋一同去重庆耍几天。可奈何机票小贵，下不了这个手，何况有人明年还准备在苏州买婚房了，攒钱中，羡慕。后，众人纷纷拿不准放松地点，最终决定周边自驾游，先去杭州再去横店，这是计划。</p>\n<p>什么！？女朋友亲戚忌日周年？还有这种事情的？何况婚都还没接呢，这就得过去，还是个大事。对了，就是明年准备在苏州买婚房那位，然后就五人缺席一人，计划照旧。</p>\n<p>提前一个月我就买好了来回车票，就等那天放飞了，一年到头没有个生活，唉，哭唧唧。</p>\n<p>什么！？临时上头派你去大连出差？还有这种事情的？连中秋都在大连过，我的乖乖宝贝啊。</p>\n<p>又缺一人，剩三人。谁玩球谁玩！遂，计划猝！</p>\n<p>车票退回，亏几十手续费。特么还买了张杭州博览会的门票，二十，也废了。哭唧唧。</p>\n<p>临时决定还是回家吧，买了 22 号下午的票，24 号上午回来。哭唧唧。</p>\n<hr>\n<p>不说那些伤心事了。</p>\n<p>最近欧皇啊，豆瓣上海观影活动中连抽中了两次。</p>\n<ul>\n<li>第一次是《悲伤逆流成河》（不是郭敬明导的），讲的是校园暴力的。我没有看过小说原著，不过说实在的郭敬明骂声很多，但是他的书看的人还不少，至少我这个年龄层次的，挺多，小女生就喜欢看这些。电影看完后感触也是有的，反映了很多人性的东西，电影全程看完也没有睡意，我比较幸运从小也没有经历过那些校园暴力，最多也就只是一些小朋友之间的矛盾。看完之后我在想，那些真实世界里经历过校园暴力的人的身心会怎么样，他们可能那时候小也许没有想那么多，但是等到长大了，懂事后，回头想起那段时间，会是个什么样的心情。电影放完之后还来了两电影中新人演员，都很年轻，演技虽然青涩也是可认可的，其中主演的演技真的很用力，感染力很强！</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/douban-sad.jpg\" alt=\"悲伤逆流成河 点映\"></p>\n<p><strong>我说来个中间点的位置，结果给我来了张最后排的还是个角落。。</strong></p>\n<ul>\n<li>然后昨天去看的《李茶的姑妈》，开心麻花出品国产喜剧。这个赞！国产喜剧除了星爷很少能让观众全场一直笑到最后的，我也是笑出了声，边上那些女孩子就更别说了，猪声……支持国产喜剧，看好开心麻花！没拍图片，也是做了个角落不过还好，不是最后排了。（卢靖姗身材真棒！！真喜欢这种健康的身材）</li>\n</ul>\n<hr>\n<p>本来是计划中秋去放飞顺道回趟家，然后国庆宅出租房七天领悟自然真理。</p>\n<p>现在变成了中秋回家，国庆回家。也好，趁着假期在家多呆呆，山美水清环境好（家附近在通国道，环境其实破坏了很多啊）。</p>\n<p>我姐中秋把一个男的叫到家里来吃了个饭，通过相亲认识的，这还是第一个来家里吃饭的，不知道能不能成。人嘛看上去还行，就这样看吧，老姐也是要奔三了。<strong>至于我嘛，现在只想躺在床上顺道还把钱给赚了</strong>。婚姻这事，看缘分吗？</p>\n<p>又跟家里聊了下，爸妈都是普通农民，辛苦一辈子把我和我姐拉扯大又盖了个新房，已经是很了不起了。现在就是家里种着几亩葡萄，收获季节比较忙。等到我要结婚买房了也不能太指望家里，毕竟他们二老还要养老的，需要备点钱，虽然以后每月都有养老金。</p>\n<p>现在是这么想的，先在上海再打拼几年，能多赚点钱就赚，当然身体还是继续要锻炼的。看以后缘分有没有，如果缘分来了，购房资格有了，手上又能够勉强付得起个首付了，那就没准要扎根上海了。不过这还太遥远了。</p>\n<hr>\n<p>今天真是厉害了，骑个自行车被交警拦下来记录信息警告了。。</p>\n<p>说下次再抓到就要罚款 50 块了，运气不好运气不好，也是我的第一次了。</p>\n<p>以后骑车得小心了，负责的交警也是好的，确实随着共享单车出现这个自行车越来越难管理了。大城市是得好好整顿整顿。</p>\n<hr>\n<p>我就是对未知的特别感兴趣，什么都想了解下，也特别喜欢扩宽自己的眼界。世界变化太快，生活中也经常时不时会触及到不同的领域，俗话说<code>技多不压身</code>，多学学总没错。但也说<code>要专精</code>。我个人是觉得，眼界是一定要不断扩宽，不能做一只井底之蛙。在领域不断放大的同时也要放绝大多的精力在某一个具体领域中探求，前提是你要清楚找准了自己想要专精的领域。不过这就是难处了，大多都是在迷茫中啊。</p>\n<p>失败了不可怕，可怕的是失败后无法重拾的心。</p>\n<p>每年要给自己定些目标。用一张图来结束此篇：</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Broaden-the-horizon.png\" alt=\"扩宽眼界\"></p>\n","excerpt":"","more":"<blockquote>\n<p>近几日天愈发见凉，夜晚也裸睡不得了。</p>\n</blockquote>\n<p>这帮人，唉。步入社会后确实大家之间的联系会越来越少，有这个心境，时间上也不允许啊，都得赚钱吃饭没办法……</p>\n<p>本来是原先计划五人中秋一同去重庆耍几天。可奈何机票小贵，下不了这个手，何况有人明年还准备在苏州买婚房了，攒钱中，羡慕。后，众人纷纷拿不准放松地点，最终决定周边自驾游，先去杭州再去横店，这是计划。</p>\n<p>什么！？女朋友亲戚忌日周年？还有这种事情的？何况婚都还没接呢，这就得过去，还是个大事。对了，就是明年准备在苏州买婚房那位，然后就五人缺席一人，计划照旧。</p>\n<p>提前一个月我就买好了来回车票，就等那天放飞了，一年到头没有个生活，唉，哭唧唧。</p>\n<p>什么！？临时上头派你去大连出差？还有这种事情的？连中秋都在大连过，我的乖乖宝贝啊。</p>\n<p>又缺一人，剩三人。谁玩球谁玩！遂，计划猝！</p>\n<p>车票退回，亏几十手续费。特么还买了张杭州博览会的门票，二十，也废了。哭唧唧。</p>\n<p>临时决定还是回家吧，买了 22 号下午的票，24 号上午回来。哭唧唧。</p>\n<hr>\n<p>不说那些伤心事了。</p>\n<p>最近欧皇啊，豆瓣上海观影活动中连抽中了两次。</p>\n<ul>\n<li>第一次是《悲伤逆流成河》（不是郭敬明导的），讲的是校园暴力的。我没有看过小说原著，不过说实在的郭敬明骂声很多，但是他的书看的人还不少，至少我这个年龄层次的，挺多，小女生就喜欢看这些。电影看完后感触也是有的，反映了很多人性的东西，电影全程看完也没有睡意，我比较幸运从小也没有经历过那些校园暴力，最多也就只是一些小朋友之间的矛盾。看完之后我在想，那些真实世界里经历过校园暴力的人的身心会怎么样，他们可能那时候小也许没有想那么多，但是等到长大了，懂事后，回头想起那段时间，会是个什么样的心情。电影放完之后还来了两电影中新人演员，都很年轻，演技虽然青涩也是可认可的，其中主演的演技真的很用力，感染力很强！</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/douban-sad.jpg\" alt=\"悲伤逆流成河 点映\"></p>\n<p><strong>我说来个中间点的位置，结果给我来了张最后排的还是个角落。。</strong></p>\n<ul>\n<li>然后昨天去看的《李茶的姑妈》，开心麻花出品国产喜剧。这个赞！国产喜剧除了星爷很少能让观众全场一直笑到最后的，我也是笑出了声，边上那些女孩子就更别说了，猪声……支持国产喜剧，看好开心麻花！没拍图片，也是做了个角落不过还好，不是最后排了。（卢靖姗身材真棒！！真喜欢这种健康的身材）</li>\n</ul>\n<hr>\n<p>本来是计划中秋去放飞顺道回趟家，然后国庆宅出租房七天领悟自然真理。</p>\n<p>现在变成了中秋回家，国庆回家。也好，趁着假期在家多呆呆，山美水清环境好（家附近在通国道，环境其实破坏了很多啊）。</p>\n<p>我姐中秋把一个男的叫到家里来吃了个饭，通过相亲认识的，这还是第一个来家里吃饭的，不知道能不能成。人嘛看上去还行，就这样看吧，老姐也是要奔三了。<strong>至于我嘛，现在只想躺在床上顺道还把钱给赚了</strong>。婚姻这事，看缘分吗？</p>\n<p>又跟家里聊了下，爸妈都是普通农民，辛苦一辈子把我和我姐拉扯大又盖了个新房，已经是很了不起了。现在就是家里种着几亩葡萄，收获季节比较忙。等到我要结婚买房了也不能太指望家里，毕竟他们二老还要养老的，需要备点钱，虽然以后每月都有养老金。</p>\n<p>现在是这么想的，先在上海再打拼几年，能多赚点钱就赚，当然身体还是继续要锻炼的。看以后缘分有没有，如果缘分来了，购房资格有了，手上又能够勉强付得起个首付了，那就没准要扎根上海了。不过这还太遥远了。</p>\n<hr>\n<p>今天真是厉害了，骑个自行车被交警拦下来记录信息警告了。。</p>\n<p>说下次再抓到就要罚款 50 块了，运气不好运气不好，也是我的第一次了。</p>\n<p>以后骑车得小心了，负责的交警也是好的，确实随着共享单车出现这个自行车越来越难管理了。大城市是得好好整顿整顿。</p>\n<hr>\n<p>我就是对未知的特别感兴趣，什么都想了解下，也特别喜欢扩宽自己的眼界。世界变化太快，生活中也经常时不时会触及到不同的领域，俗话说<code>技多不压身</code>，多学学总没错。但也说<code>要专精</code>。我个人是觉得，眼界是一定要不断扩宽，不能做一只井底之蛙。在领域不断放大的同时也要放绝大多的精力在某一个具体领域中探求，前提是你要清楚找准了自己想要专精的领域。不过这就是难处了，大多都是在迷茫中啊。</p>\n<p>失败了不可怕，可怕的是失败后无法重拾的心。</p>\n<p>每年要给自己定些目标。用一张图来结束此篇：</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/Broaden-the-horizon.png\" alt=\"扩宽眼界\"></p>\n"},{"title":"危险十二月（2021）","date":"2022-01-01T13:10:55.000Z","_content":"\n**躲过了迪士尼，没想到在园区中招了**\n\n今天是 12 月 7 日，上午 2 号楼说是有密切接触者然后下午确诊了。然后整个园区被封锁，大家难免有点慌乱。接下来做了核酸，然后就是等结果，也不能出去，所有人都在公司。现在已经过了 12 点了，还没有消息，估计今天是走不掉了，是集体在公司通宵的一天。没想到离疫情可以这么近。\n\n一点左右眼皮开始打架，迷迷糊糊在工位上眯了一会，身体实在是难受。之后公司发了睡袋，在地板上又迷迷糊糊躺了两三个小时，现在浑身都不舒服。七点就起来了，公司发了牙刷，看来还得要一段时间，至少要 48 小时了。庆幸最近没有去休闲广场搓麻将。\n\n在公司睡了两个晚上，今天终于解禁了，终于能回去洗个热水澡，躺在柔软的大床上了。现在是 12 月 9 日下午 6 点。对面整栋楼的人都带去酒店隔离了，来了好几辆大巴车，好险。\n\n---\n\n**海马体初体验**\n\n由于小邱说想去摄影想了好几年，但是一直没去，我就索性给她预约了长泰广场的海马体。结果没成想小姑娘羞涩，怎么也不想去，于是乎第一次就退了。然后这次是她自己主动提出的，那就没办法了，不想去也要去，于是就开始了摄影前的“减肥”。这个肥有这么好减的吗？一斤没瘦甚至去拍摄前一晚还点了夜宵吃……\n\n首先，里面的工作人员不是很多，一个人要负责服装、化妆、发型、道具。我们是圣诞当天去拍的，可能也是跟特殊日子特别忙有关系。场地就是一个小房间，背景一块布，然后摄影师会帮凹造型，全场七八个造型，咔咔咔。我们俩都一本正经极其严肃，出来的效果可想而知。简直是销售界的精英……\n\n然后约了元旦去门店看片，再给修一修……\n\n---\n\n今年元旦也是没能回家……","source":"_posts/danger-december.md","raw":"---\ntitle: 危险十二月（2021）\ndate: 2022-01-01 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n**躲过了迪士尼，没想到在园区中招了**\n\n今天是 12 月 7 日，上午 2 号楼说是有密切接触者然后下午确诊了。然后整个园区被封锁，大家难免有点慌乱。接下来做了核酸，然后就是等结果，也不能出去，所有人都在公司。现在已经过了 12 点了，还没有消息，估计今天是走不掉了，是集体在公司通宵的一天。没想到离疫情可以这么近。\n\n一点左右眼皮开始打架，迷迷糊糊在工位上眯了一会，身体实在是难受。之后公司发了睡袋，在地板上又迷迷糊糊躺了两三个小时，现在浑身都不舒服。七点就起来了，公司发了牙刷，看来还得要一段时间，至少要 48 小时了。庆幸最近没有去休闲广场搓麻将。\n\n在公司睡了两个晚上，今天终于解禁了，终于能回去洗个热水澡，躺在柔软的大床上了。现在是 12 月 9 日下午 6 点。对面整栋楼的人都带去酒店隔离了，来了好几辆大巴车，好险。\n\n---\n\n**海马体初体验**\n\n由于小邱说想去摄影想了好几年，但是一直没去，我就索性给她预约了长泰广场的海马体。结果没成想小姑娘羞涩，怎么也不想去，于是乎第一次就退了。然后这次是她自己主动提出的，那就没办法了，不想去也要去，于是就开始了摄影前的“减肥”。这个肥有这么好减的吗？一斤没瘦甚至去拍摄前一晚还点了夜宵吃……\n\n首先，里面的工作人员不是很多，一个人要负责服装、化妆、发型、道具。我们是圣诞当天去拍的，可能也是跟特殊日子特别忙有关系。场地就是一个小房间，背景一块布，然后摄影师会帮凹造型，全场七八个造型，咔咔咔。我们俩都一本正经极其严肃，出来的效果可想而知。简直是销售界的精英……\n\n然后约了元旦去门店看片，再给修一修……\n\n---\n\n今年元旦也是没能回家……","slug":"danger-december","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhd003vk9i1gvm55a4e","content":"<p><strong>躲过了迪士尼，没想到在园区中招了</strong></p>\n<p>今天是 12 月 7 日，上午 2 号楼说是有密切接触者然后下午确诊了。然后整个园区被封锁，大家难免有点慌乱。接下来做了核酸，然后就是等结果，也不能出去，所有人都在公司。现在已经过了 12 点了，还没有消息，估计今天是走不掉了，是集体在公司通宵的一天。没想到离疫情可以这么近。</p>\n<p>一点左右眼皮开始打架，迷迷糊糊在工位上眯了一会，身体实在是难受。之后公司发了睡袋，在地板上又迷迷糊糊躺了两三个小时，现在浑身都不舒服。七点就起来了，公司发了牙刷，看来还得要一段时间，至少要 48 小时了。庆幸最近没有去休闲广场搓麻将。</p>\n<p>在公司睡了两个晚上，今天终于解禁了，终于能回去洗个热水澡，躺在柔软的大床上了。现在是 12 月 9 日下午 6 点。对面整栋楼的人都带去酒店隔离了，来了好几辆大巴车，好险。</p>\n<hr>\n<p><strong>海马体初体验</strong></p>\n<p>由于小邱说想去摄影想了好几年，但是一直没去，我就索性给她预约了长泰广场的海马体。结果没成想小姑娘羞涩，怎么也不想去，于是乎第一次就退了。然后这次是她自己主动提出的，那就没办法了，不想去也要去，于是就开始了摄影前的“减肥”。这个肥有这么好减的吗？一斤没瘦甚至去拍摄前一晚还点了夜宵吃……</p>\n<p>首先，里面的工作人员不是很多，一个人要负责服装、化妆、发型、道具。我们是圣诞当天去拍的，可能也是跟特殊日子特别忙有关系。场地就是一个小房间，背景一块布，然后摄影师会帮凹造型，全场七八个造型，咔咔咔。我们俩都一本正经极其严肃，出来的效果可想而知。简直是销售界的精英……</p>\n<p>然后约了元旦去门店看片，再给修一修……</p>\n<hr>\n<p>今年元旦也是没能回家……</p>\n","excerpt":"","more":"<p><strong>躲过了迪士尼，没想到在园区中招了</strong></p>\n<p>今天是 12 月 7 日，上午 2 号楼说是有密切接触者然后下午确诊了。然后整个园区被封锁，大家难免有点慌乱。接下来做了核酸，然后就是等结果，也不能出去，所有人都在公司。现在已经过了 12 点了，还没有消息，估计今天是走不掉了，是集体在公司通宵的一天。没想到离疫情可以这么近。</p>\n<p>一点左右眼皮开始打架，迷迷糊糊在工位上眯了一会，身体实在是难受。之后公司发了睡袋，在地板上又迷迷糊糊躺了两三个小时，现在浑身都不舒服。七点就起来了，公司发了牙刷，看来还得要一段时间，至少要 48 小时了。庆幸最近没有去休闲广场搓麻将。</p>\n<p>在公司睡了两个晚上，今天终于解禁了，终于能回去洗个热水澡，躺在柔软的大床上了。现在是 12 月 9 日下午 6 点。对面整栋楼的人都带去酒店隔离了，来了好几辆大巴车，好险。</p>\n<hr>\n<p><strong>海马体初体验</strong></p>\n<p>由于小邱说想去摄影想了好几年，但是一直没去，我就索性给她预约了长泰广场的海马体。结果没成想小姑娘羞涩，怎么也不想去，于是乎第一次就退了。然后这次是她自己主动提出的，那就没办法了，不想去也要去，于是就开始了摄影前的“减肥”。这个肥有这么好减的吗？一斤没瘦甚至去拍摄前一晚还点了夜宵吃……</p>\n<p>首先，里面的工作人员不是很多，一个人要负责服装、化妆、发型、道具。我们是圣诞当天去拍的，可能也是跟特殊日子特别忙有关系。场地就是一个小房间，背景一块布，然后摄影师会帮凹造型，全场七八个造型，咔咔咔。我们俩都一本正经极其严肃，出来的效果可想而知。简直是销售界的精英……</p>\n<p>然后约了元旦去门店看片，再给修一修……</p>\n<hr>\n<p>今年元旦也是没能回家……</p>\n"},{"title":"头晕九月（2019）","date":"2019-09-28T02:59:49.000Z","_content":"\n> 为什么现在这个头越来越疼了？\n\n好难啊，好南啊。\n\n---\n\n## 废\n最近因为好多电视剧都太优秀了，完全停不下来啊，一部接着一部，晚上回去好久都没看过书了……有几本买来都两年了，塑封都还在呢。一想我现在才25岁，正当青春活力年少，怎能沉迷于银幕中，看完这几部就决心告一段落了，一部有五六十集呢。\n\n上次说的杨浦图书馆，好嘛，就那次去了一趟，环境很重要，在屋里虽也能看但心还是无法长静下来。这次中秋无所事事，无计可划，不如早些时辰去占个位儿，带上几个白面馍馍，看个一天大半天书的，也是个快乐的想法。\n\n## 中秋\n今年中秋不回家，国庆回吧，家离上海倒是不远，只是来回也得费点心力，在家歇一晚上，第二天又得忙活准备回来。到时候要给家里打个电话，家是温暖的港湾，是背后的倚靠。大中华中秋团圆夜，今年得独自倚窗赏月喝闷酒了。说到酒，我发现白酒喝多了我就会想吐。\n\n不出意外，窝着呆了三天。\n\n## 惨\n\n诸事不顺，病魔缠身。\n\n感冒见好，又来低烧。\n\n躺在床上，汗浸衣裳。\n\n一觉醒来，面目荒凉。\n\n---\n祖国七十大寿！","source":"_posts/dizzy-september.md","raw":"---\ntitle: 头晕九月（2019）\ndate: 2019-9-28 10:59:49\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 为什么现在这个头越来越疼了？\n\n好难啊，好南啊。\n\n---\n\n## 废\n最近因为好多电视剧都太优秀了，完全停不下来啊，一部接着一部，晚上回去好久都没看过书了……有几本买来都两年了，塑封都还在呢。一想我现在才25岁，正当青春活力年少，怎能沉迷于银幕中，看完这几部就决心告一段落了，一部有五六十集呢。\n\n上次说的杨浦图书馆，好嘛，就那次去了一趟，环境很重要，在屋里虽也能看但心还是无法长静下来。这次中秋无所事事，无计可划，不如早些时辰去占个位儿，带上几个白面馍馍，看个一天大半天书的，也是个快乐的想法。\n\n## 中秋\n今年中秋不回家，国庆回吧，家离上海倒是不远，只是来回也得费点心力，在家歇一晚上，第二天又得忙活准备回来。到时候要给家里打个电话，家是温暖的港湾，是背后的倚靠。大中华中秋团圆夜，今年得独自倚窗赏月喝闷酒了。说到酒，我发现白酒喝多了我就会想吐。\n\n不出意外，窝着呆了三天。\n\n## 惨\n\n诸事不顺，病魔缠身。\n\n感冒见好，又来低烧。\n\n躺在床上，汗浸衣裳。\n\n一觉醒来，面目荒凉。\n\n---\n祖国七十大寿！","slug":"dizzy-september","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhd0040k9i10wn07iwc","content":"<blockquote>\n<p>为什么现在这个头越来越疼了？</p>\n</blockquote>\n<p>好难啊，好南啊。</p>\n<hr>\n<h2 id=\"废\"><a href=\"#废\" class=\"headerlink\" title=\"废\"></a>废</h2><p>最近因为好多电视剧都太优秀了，完全停不下来啊，一部接着一部，晚上回去好久都没看过书了……有几本买来都两年了，塑封都还在呢。一想我现在才25岁，正当青春活力年少，怎能沉迷于银幕中，看完这几部就决心告一段落了，一部有五六十集呢。</p>\n<p>上次说的杨浦图书馆，好嘛，就那次去了一趟，环境很重要，在屋里虽也能看但心还是无法长静下来。这次中秋无所事事，无计可划，不如早些时辰去占个位儿，带上几个白面馍馍，看个一天大半天书的，也是个快乐的想法。</p>\n<h2 id=\"中秋\"><a href=\"#中秋\" class=\"headerlink\" title=\"中秋\"></a>中秋</h2><p>今年中秋不回家，国庆回吧，家离上海倒是不远，只是来回也得费点心力，在家歇一晚上，第二天又得忙活准备回来。到时候要给家里打个电话，家是温暖的港湾，是背后的倚靠。大中华中秋团圆夜，今年得独自倚窗赏月喝闷酒了。说到酒，我发现白酒喝多了我就会想吐。</p>\n<p>不出意外，窝着呆了三天。</p>\n<h2 id=\"惨\"><a href=\"#惨\" class=\"headerlink\" title=\"惨\"></a>惨</h2><p>诸事不顺，病魔缠身。</p>\n<p>感冒见好，又来低烧。</p>\n<p>躺在床上，汗浸衣裳。</p>\n<p>一觉醒来，面目荒凉。</p>\n<hr>\n<p>祖国七十大寿！</p>\n","excerpt":"","more":"<blockquote>\n<p>为什么现在这个头越来越疼了？</p>\n</blockquote>\n<p>好难啊，好南啊。</p>\n<hr>\n<h2 id=\"废\"><a href=\"#废\" class=\"headerlink\" title=\"废\"></a>废</h2><p>最近因为好多电视剧都太优秀了，完全停不下来啊，一部接着一部，晚上回去好久都没看过书了……有几本买来都两年了，塑封都还在呢。一想我现在才25岁，正当青春活力年少，怎能沉迷于银幕中，看完这几部就决心告一段落了，一部有五六十集呢。</p>\n<p>上次说的杨浦图书馆，好嘛，就那次去了一趟，环境很重要，在屋里虽也能看但心还是无法长静下来。这次中秋无所事事，无计可划，不如早些时辰去占个位儿，带上几个白面馍馍，看个一天大半天书的，也是个快乐的想法。</p>\n<h2 id=\"中秋\"><a href=\"#中秋\" class=\"headerlink\" title=\"中秋\"></a>中秋</h2><p>今年中秋不回家，国庆回吧，家离上海倒是不远，只是来回也得费点心力，在家歇一晚上，第二天又得忙活准备回来。到时候要给家里打个电话，家是温暖的港湾，是背后的倚靠。大中华中秋团圆夜，今年得独自倚窗赏月喝闷酒了。说到酒，我发现白酒喝多了我就会想吐。</p>\n<p>不出意外，窝着呆了三天。</p>\n<h2 id=\"惨\"><a href=\"#惨\" class=\"headerlink\" title=\"惨\"></a>惨</h2><p>诸事不顺，病魔缠身。</p>\n<p>感冒见好，又来低烧。</p>\n<p>躺在床上，汗浸衣裳。</p>\n<p>一觉醒来，面目荒凉。</p>\n<hr>\n<p>祖国七十大寿！</p>\n"},{"title":"空荡八月（2021）","date":"2021-08-26T12:10:55.000Z","_content":"\n八月，身边多了许多空位，少了许多欢声笑语。\n\n每天都有熟悉的人奔赴更好的前程，也有不少人一直在等待那一刻的来临，包括我。\n\n但看来，那一刻我是等不到了，至少没有那么快。\n\n现在每一天其实没有多少活，大多都是闲的状态，大家也都在各自准备着，没办法，行业的问题。\n\n---\n\n现在每天下午都犯困得不行，晚上回去就又精神抖擞。脑袋晕昏昏的，就想躺着从白天睡到晚上。\n\n> 秋乏症状：<br>\n> 1、人容易疲乏，经常工作一会就觉得无精打采，打不起精神，注意力不集中，容易困倦、打哈欠、疲劳，昏昏欲睡。人们通常选择喝浓茶或者浓咖啡，但是都起不到提高注意力和专注力的效果，说明秋天容易疲劳。<br>\n> 2、容易口舌干燥，天气比较干燥，容易口干、口渴，甚至会引起嗓子疼、喉咙发炎等等症状。<br>\n> 3、睡眠质量差，白天不能集中专注力，困倦至极，到晚上更难以入睡，入睡以后睡眠的质量也会很差，而且会经常做梦。<br>\n> 4、人容易暴躁，人在这种情况下特别容易焦虑，性格容易暴躁，容易产生倦怠等情绪。\n\n---\n\n终于有猫了！\n\n一只名叫球球的英短虎斑就这样成为了我沪漂生活中的第一只小猫咪。\n\n球球刚来的时候特别安静，放到笼子里自己就在那躺着睡觉。到了第三天就开始不装了，飞檐走壁，到处乱钻乱咬，不过还好能自己跑到猫砂里方便，算懂事。\n\n有猫的生活确实多了一点情趣，是得像自己的孩子一样对待新成员，皮得很。\n\n--- \n\n八月的尾巴我也是要离开这家公司了，没办法，行业的问题，抵不过。\n\n本来想着多留些时间能出去玩玩休息下，结果这几天上海又出现了病例，风险等级一下子就给提高了，那就躺着吧。\n\n希望多年后自己的这个选择不会让自己失望，月底入职新公司。\n\n---\n\n机械迷城（Machinarium），最近终于通关了，陆陆续续玩了些时间。虽然是 09 年的游戏，但是丝毫不觉得逊色，许多场景令我绝呼！太喜欢这种解密系的游戏了，下次趁着 Steam 搞活动一定要把 \nAmanita Design 的游戏多买点。昨天《刺客信条·大革命》打折就买了，这两天体验体验其中的超真实场景。","source":"_posts/exchange-august.md","raw":"---\ntitle: 空荡八月（2021）\ndate: 2021-08-26 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n八月，身边多了许多空位，少了许多欢声笑语。\n\n每天都有熟悉的人奔赴更好的前程，也有不少人一直在等待那一刻的来临，包括我。\n\n但看来，那一刻我是等不到了，至少没有那么快。\n\n现在每一天其实没有多少活，大多都是闲的状态，大家也都在各自准备着，没办法，行业的问题。\n\n---\n\n现在每天下午都犯困得不行，晚上回去就又精神抖擞。脑袋晕昏昏的，就想躺着从白天睡到晚上。\n\n> 秋乏症状：<br>\n> 1、人容易疲乏，经常工作一会就觉得无精打采，打不起精神，注意力不集中，容易困倦、打哈欠、疲劳，昏昏欲睡。人们通常选择喝浓茶或者浓咖啡，但是都起不到提高注意力和专注力的效果，说明秋天容易疲劳。<br>\n> 2、容易口舌干燥，天气比较干燥，容易口干、口渴，甚至会引起嗓子疼、喉咙发炎等等症状。<br>\n> 3、睡眠质量差，白天不能集中专注力，困倦至极，到晚上更难以入睡，入睡以后睡眠的质量也会很差，而且会经常做梦。<br>\n> 4、人容易暴躁，人在这种情况下特别容易焦虑，性格容易暴躁，容易产生倦怠等情绪。\n\n---\n\n终于有猫了！\n\n一只名叫球球的英短虎斑就这样成为了我沪漂生活中的第一只小猫咪。\n\n球球刚来的时候特别安静，放到笼子里自己就在那躺着睡觉。到了第三天就开始不装了，飞檐走壁，到处乱钻乱咬，不过还好能自己跑到猫砂里方便，算懂事。\n\n有猫的生活确实多了一点情趣，是得像自己的孩子一样对待新成员，皮得很。\n\n--- \n\n八月的尾巴我也是要离开这家公司了，没办法，行业的问题，抵不过。\n\n本来想着多留些时间能出去玩玩休息下，结果这几天上海又出现了病例，风险等级一下子就给提高了，那就躺着吧。\n\n希望多年后自己的这个选择不会让自己失望，月底入职新公司。\n\n---\n\n机械迷城（Machinarium），最近终于通关了，陆陆续续玩了些时间。虽然是 09 年的游戏，但是丝毫不觉得逊色，许多场景令我绝呼！太喜欢这种解密系的游戏了，下次趁着 Steam 搞活动一定要把 \nAmanita Design 的游戏多买点。昨天《刺客信条·大革命》打折就买了，这两天体验体验其中的超真实场景。","slug":"exchange-august","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhd0043k9i1g2ik3yt2","content":"<p>八月，身边多了许多空位，少了许多欢声笑语。</p>\n<p>每天都有熟悉的人奔赴更好的前程，也有不少人一直在等待那一刻的来临，包括我。</p>\n<p>但看来，那一刻我是等不到了，至少没有那么快。</p>\n<p>现在每一天其实没有多少活，大多都是闲的状态，大家也都在各自准备着，没办法，行业的问题。</p>\n<hr>\n<p>现在每天下午都犯困得不行，晚上回去就又精神抖擞。脑袋晕昏昏的，就想躺着从白天睡到晚上。</p>\n<blockquote>\n<p>秋乏症状：<br><br>1、人容易疲乏，经常工作一会就觉得无精打采，打不起精神，注意力不集中，容易困倦、打哈欠、疲劳，昏昏欲睡。人们通常选择喝浓茶或者浓咖啡，但是都起不到提高注意力和专注力的效果，说明秋天容易疲劳。<br><br>2、容易口舌干燥，天气比较干燥，容易口干、口渴，甚至会引起嗓子疼、喉咙发炎等等症状。<br><br>3、睡眠质量差，白天不能集中专注力，困倦至极，到晚上更难以入睡，入睡以后睡眠的质量也会很差，而且会经常做梦。<br><br>4、人容易暴躁，人在这种情况下特别容易焦虑，性格容易暴躁，容易产生倦怠等情绪。</p>\n</blockquote>\n<hr>\n<p>终于有猫了！</p>\n<p>一只名叫球球的英短虎斑就这样成为了我沪漂生活中的第一只小猫咪。</p>\n<p>球球刚来的时候特别安静，放到笼子里自己就在那躺着睡觉。到了第三天就开始不装了，飞檐走壁，到处乱钻乱咬，不过还好能自己跑到猫砂里方便，算懂事。</p>\n<p>有猫的生活确实多了一点情趣，是得像自己的孩子一样对待新成员，皮得很。</p>\n<hr>\n<p>八月的尾巴我也是要离开这家公司了，没办法，行业的问题，抵不过。</p>\n<p>本来想着多留些时间能出去玩玩休息下，结果这几天上海又出现了病例，风险等级一下子就给提高了，那就躺着吧。</p>\n<p>希望多年后自己的这个选择不会让自己失望，月底入职新公司。</p>\n<hr>\n<p>机械迷城（Machinarium），最近终于通关了，陆陆续续玩了些时间。虽然是 09 年的游戏，但是丝毫不觉得逊色，许多场景令我绝呼！太喜欢这种解密系的游戏了，下次趁着 Steam 搞活动一定要把<br>Amanita Design 的游戏多买点。昨天《刺客信条·大革命》打折就买了，这两天体验体验其中的超真实场景。</p>\n","excerpt":"","more":"<p>八月，身边多了许多空位，少了许多欢声笑语。</p>\n<p>每天都有熟悉的人奔赴更好的前程，也有不少人一直在等待那一刻的来临，包括我。</p>\n<p>但看来，那一刻我是等不到了，至少没有那么快。</p>\n<p>现在每一天其实没有多少活，大多都是闲的状态，大家也都在各自准备着，没办法，行业的问题。</p>\n<hr>\n<p>现在每天下午都犯困得不行，晚上回去就又精神抖擞。脑袋晕昏昏的，就想躺着从白天睡到晚上。</p>\n<blockquote>\n<p>秋乏症状：<br><br>1、人容易疲乏，经常工作一会就觉得无精打采，打不起精神，注意力不集中，容易困倦、打哈欠、疲劳，昏昏欲睡。人们通常选择喝浓茶或者浓咖啡，但是都起不到提高注意力和专注力的效果，说明秋天容易疲劳。<br><br>2、容易口舌干燥，天气比较干燥，容易口干、口渴，甚至会引起嗓子疼、喉咙发炎等等症状。<br><br>3、睡眠质量差，白天不能集中专注力，困倦至极，到晚上更难以入睡，入睡以后睡眠的质量也会很差，而且会经常做梦。<br><br>4、人容易暴躁，人在这种情况下特别容易焦虑，性格容易暴躁，容易产生倦怠等情绪。</p>\n</blockquote>\n<hr>\n<p>终于有猫了！</p>\n<p>一只名叫球球的英短虎斑就这样成为了我沪漂生活中的第一只小猫咪。</p>\n<p>球球刚来的时候特别安静，放到笼子里自己就在那躺着睡觉。到了第三天就开始不装了，飞檐走壁，到处乱钻乱咬，不过还好能自己跑到猫砂里方便，算懂事。</p>\n<p>有猫的生活确实多了一点情趣，是得像自己的孩子一样对待新成员，皮得很。</p>\n<hr>\n<p>八月的尾巴我也是要离开这家公司了，没办法，行业的问题，抵不过。</p>\n<p>本来想着多留些时间能出去玩玩休息下，结果这几天上海又出现了病例，风险等级一下子就给提高了，那就躺着吧。</p>\n<p>希望多年后自己的这个选择不会让自己失望，月底入职新公司。</p>\n<hr>\n<p>机械迷城（Machinarium），最近终于通关了，陆陆续续玩了些时间。虽然是 09 年的游戏，但是丝毫不觉得逊色，许多场景令我绝呼！太喜欢这种解密系的游戏了，下次趁着 Steam 搞活动一定要把<br>Amanita Design 的游戏多买点。昨天《刺客信条·大革命》打折就买了，这两天体验体验其中的超真实场景。</p>\n"},{"title":"惊险四月（2019）","date":"2019-04-28T07:56:14.000Z","_content":"\n> 就在昨天，公司自己刚搭没多久的小服务器中了 ETH 勒索病毒，还好刚起步数据量不大，真可怕！\n\n把环境又给装了一遍，轻车熟路了。\n\n专业事情还是需要专业人士来做，网络安全也是一个相当大的方面，只要被不法分子盯上就很有可能是一笔不小的损失了。\n\n虽然说现在的技术科技发展很快，但是安全方面却不是那么跟得上脚步。中午跟同事聊起来，有些公司还是用最初的刻盘来保存数据，银行系统还有很多是 XP，回到本初，最原始的即最安全也是不无道理，整得再花再虚，我最需要的还是安全实用。\n\n从这些角度继续往下想，有时候我们会埋怨某些系统太过于古老，技术太过于落后，这也是前几年我看到一些古老项目的想法。技术的世界日新月异，新轮子不断出现，内涵包裹越来越深，过于追求抽象化。\n\n当我们选择项目中要用的技术栈时，肯定会优先选择那些稳定的、有人长期维护的、社区较活跃的，这些现象也正说明了这个技术关注度高，较为成熟。不然找偏门技术栈的可能出现了 Bug，其创始人都不知道为什么会出现该怎么解决，那不就废了吗。现在开源社区大多都是拿来即用，也很少会有人去专门研究源码，这就是技术选型。\n\n当你接手了一个老项目，你了解了其作用与每个地方的功能后，发现市面上完全有成熟的技术可以取代之，且换架构后项目会更加清晰易理解。这个时候你就可以向上申报或者自己闲暇时间尝试给它换一个壳（当然是因人而异，也有可能是费力不讨好之事，若对自身有益且有闲时，可一做）。当完成这个“手术”之后，往往自己会对这个项目有了一个更深的理解，很可能还会找到几处优化的地方。改造成功一个项目，看着它，就像是你赋予了它生命一般，后期需要改动或是加功能打补丁都会更得心应手。\n\n最近在看《深入理解计算机系统》，本是一本基础教材。明白了“万变不离其宗”的道理之后，深知基础的重要性。别人问我：你们搞计算机的要记的东西不少，感觉很难啊。我说：只要你脑子不笨不呆，灵活会转会用心记就行。\n\n调调几个 API 谁不会呢，我才不管你是怎么实现的，我只要拿到我想要的数据得到我想要的结果就行了，不就是一堆数据传过来传过去。现在框架轮子多得死，一拼一凑就是一个“项目”。\n\n可不是嘛，平时要写的就是一大坨的业务逻辑处理代码，正常的有几个会拎不清呢？当然也是有的，所以这层就开始出现了能力的差别。越往细小的领域，这差距就会越大。\n\n业务逻辑写个几年，天花板就到头了，若是脑子不活络无管理能力的，那就是真的“废”了。虽说饿不死，至少以后找个公司维护维护老项目都能养活自己。这就导致了以后没有了 **竞争力**，年级越大越无奈，这一阶段的人可以说是到处都是，市场完全不会缺。\n\n前一段时间招了个实习生（上海理工研二），自动化专业想要来写代码（跨专业，基础确实是差），说实话已是一片红海，若是像我上面说的那样还要去那个阶段一起游泳，那我觉得真是有点不值了。\n\n---\n\n前几天智齿长出来了！右腮帮就像被人挥了一拳一样，感觉是真的不爽！本命年才会长智齿，真的是准啊，长大了长大了。\n\n同事搬过来变成了新室友，好家伙现在天天晚上都要粥煮起来吃，不吃睡不着，这吃下去再不长肉就真不科学了，再加上每天下午去楼下全家买两个包子或是两个馒头。搞了张尊享会员卡，也开始了没事喝喝咖啡的日子了（送的不喝那我就是有病了），血压低，多喝喝。\n\n哈哈，室友将他那辆二手永久车送我了！我自己去补了个胎，就花了二十换了辆自行车，怎么都不亏啊哈哈。刚好摩拜季卡到期了，共享单车又集体涨价，这辆三手车（可能不止三手了……）至少能骑个半年咯。\n\n等夏天到了，早上戴着墨镜骑着车听听音乐去上班，然后一身汗，湿透。\n\n---\n\n有名气有底蕴的大学是真的不一样，看了附近同济、复旦的校区后，自己的母校是何等的简陋。。。以后还要多去其它学校看看，欣赏欣赏别人大学的风景。\n\n生活在于折腾，前提是还能经得起折腾。年纪轻轻就不要想那么多，想要的想做的就尽量去满足自己，一旦念头消散可能就再无机会了。\n\n至少还能有可以愿意去回想的东西，还有内心觉得美好的日子，还有至今无悔的事情。\n\n也许现在的生活并不是那么尽人意，但若是有可以回去的机会我还是会选择那样过，还是想要经历那些经历过的事情，虽然也许无果但无悔、无愧，青春，知足。\n\n---\n\n我这个人啊，耳根子软，心也软又善，还重情义。你若对我一丝好，我便会含泪感动入睡。\n\n不过这不代表一向如此，上述只是我大多状态。人啊，久了都会不懂自己。\n\n最近在补权游，Valar Morghulis.","source":"_posts/exciting-april.md","raw":"---\ntitle: 惊险四月（2019）\ndate: 2019-4-28 15:56:14\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 就在昨天，公司自己刚搭没多久的小服务器中了 ETH 勒索病毒，还好刚起步数据量不大，真可怕！\n\n把环境又给装了一遍，轻车熟路了。\n\n专业事情还是需要专业人士来做，网络安全也是一个相当大的方面，只要被不法分子盯上就很有可能是一笔不小的损失了。\n\n虽然说现在的技术科技发展很快，但是安全方面却不是那么跟得上脚步。中午跟同事聊起来，有些公司还是用最初的刻盘来保存数据，银行系统还有很多是 XP，回到本初，最原始的即最安全也是不无道理，整得再花再虚，我最需要的还是安全实用。\n\n从这些角度继续往下想，有时候我们会埋怨某些系统太过于古老，技术太过于落后，这也是前几年我看到一些古老项目的想法。技术的世界日新月异，新轮子不断出现，内涵包裹越来越深，过于追求抽象化。\n\n当我们选择项目中要用的技术栈时，肯定会优先选择那些稳定的、有人长期维护的、社区较活跃的，这些现象也正说明了这个技术关注度高，较为成熟。不然找偏门技术栈的可能出现了 Bug，其创始人都不知道为什么会出现该怎么解决，那不就废了吗。现在开源社区大多都是拿来即用，也很少会有人去专门研究源码，这就是技术选型。\n\n当你接手了一个老项目，你了解了其作用与每个地方的功能后，发现市面上完全有成熟的技术可以取代之，且换架构后项目会更加清晰易理解。这个时候你就可以向上申报或者自己闲暇时间尝试给它换一个壳（当然是因人而异，也有可能是费力不讨好之事，若对自身有益且有闲时，可一做）。当完成这个“手术”之后，往往自己会对这个项目有了一个更深的理解，很可能还会找到几处优化的地方。改造成功一个项目，看着它，就像是你赋予了它生命一般，后期需要改动或是加功能打补丁都会更得心应手。\n\n最近在看《深入理解计算机系统》，本是一本基础教材。明白了“万变不离其宗”的道理之后，深知基础的重要性。别人问我：你们搞计算机的要记的东西不少，感觉很难啊。我说：只要你脑子不笨不呆，灵活会转会用心记就行。\n\n调调几个 API 谁不会呢，我才不管你是怎么实现的，我只要拿到我想要的数据得到我想要的结果就行了，不就是一堆数据传过来传过去。现在框架轮子多得死，一拼一凑就是一个“项目”。\n\n可不是嘛，平时要写的就是一大坨的业务逻辑处理代码，正常的有几个会拎不清呢？当然也是有的，所以这层就开始出现了能力的差别。越往细小的领域，这差距就会越大。\n\n业务逻辑写个几年，天花板就到头了，若是脑子不活络无管理能力的，那就是真的“废”了。虽说饿不死，至少以后找个公司维护维护老项目都能养活自己。这就导致了以后没有了 **竞争力**，年级越大越无奈，这一阶段的人可以说是到处都是，市场完全不会缺。\n\n前一段时间招了个实习生（上海理工研二），自动化专业想要来写代码（跨专业，基础确实是差），说实话已是一片红海，若是像我上面说的那样还要去那个阶段一起游泳，那我觉得真是有点不值了。\n\n---\n\n前几天智齿长出来了！右腮帮就像被人挥了一拳一样，感觉是真的不爽！本命年才会长智齿，真的是准啊，长大了长大了。\n\n同事搬过来变成了新室友，好家伙现在天天晚上都要粥煮起来吃，不吃睡不着，这吃下去再不长肉就真不科学了，再加上每天下午去楼下全家买两个包子或是两个馒头。搞了张尊享会员卡，也开始了没事喝喝咖啡的日子了（送的不喝那我就是有病了），血压低，多喝喝。\n\n哈哈，室友将他那辆二手永久车送我了！我自己去补了个胎，就花了二十换了辆自行车，怎么都不亏啊哈哈。刚好摩拜季卡到期了，共享单车又集体涨价，这辆三手车（可能不止三手了……）至少能骑个半年咯。\n\n等夏天到了，早上戴着墨镜骑着车听听音乐去上班，然后一身汗，湿透。\n\n---\n\n有名气有底蕴的大学是真的不一样，看了附近同济、复旦的校区后，自己的母校是何等的简陋。。。以后还要多去其它学校看看，欣赏欣赏别人大学的风景。\n\n生活在于折腾，前提是还能经得起折腾。年纪轻轻就不要想那么多，想要的想做的就尽量去满足自己，一旦念头消散可能就再无机会了。\n\n至少还能有可以愿意去回想的东西，还有内心觉得美好的日子，还有至今无悔的事情。\n\n也许现在的生活并不是那么尽人意，但若是有可以回去的机会我还是会选择那样过，还是想要经历那些经历过的事情，虽然也许无果但无悔、无愧，青春，知足。\n\n---\n\n我这个人啊，耳根子软，心也软又善，还重情义。你若对我一丝好，我便会含泪感动入睡。\n\n不过这不代表一向如此，上述只是我大多状态。人啊，久了都会不懂自己。\n\n最近在补权游，Valar Morghulis.","slug":"exciting-april","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhe0048k9i16mzignq9","content":"<blockquote>\n<p>就在昨天，公司自己刚搭没多久的小服务器中了 ETH 勒索病毒，还好刚起步数据量不大，真可怕！</p>\n</blockquote>\n<p>把环境又给装了一遍，轻车熟路了。</p>\n<p>专业事情还是需要专业人士来做，网络安全也是一个相当大的方面，只要被不法分子盯上就很有可能是一笔不小的损失了。</p>\n<p>虽然说现在的技术科技发展很快，但是安全方面却不是那么跟得上脚步。中午跟同事聊起来，有些公司还是用最初的刻盘来保存数据，银行系统还有很多是 XP，回到本初，最原始的即最安全也是不无道理，整得再花再虚，我最需要的还是安全实用。</p>\n<p>从这些角度继续往下想，有时候我们会埋怨某些系统太过于古老，技术太过于落后，这也是前几年我看到一些古老项目的想法。技术的世界日新月异，新轮子不断出现，内涵包裹越来越深，过于追求抽象化。</p>\n<p>当我们选择项目中要用的技术栈时，肯定会优先选择那些稳定的、有人长期维护的、社区较活跃的，这些现象也正说明了这个技术关注度高，较为成熟。不然找偏门技术栈的可能出现了 Bug，其创始人都不知道为什么会出现该怎么解决，那不就废了吗。现在开源社区大多都是拿来即用，也很少会有人去专门研究源码，这就是技术选型。</p>\n<p>当你接手了一个老项目，你了解了其作用与每个地方的功能后，发现市面上完全有成熟的技术可以取代之，且换架构后项目会更加清晰易理解。这个时候你就可以向上申报或者自己闲暇时间尝试给它换一个壳（当然是因人而异，也有可能是费力不讨好之事，若对自身有益且有闲时，可一做）。当完成这个“手术”之后，往往自己会对这个项目有了一个更深的理解，很可能还会找到几处优化的地方。改造成功一个项目，看着它，就像是你赋予了它生命一般，后期需要改动或是加功能打补丁都会更得心应手。</p>\n<p>最近在看《深入理解计算机系统》，本是一本基础教材。明白了“万变不离其宗”的道理之后，深知基础的重要性。别人问我：你们搞计算机的要记的东西不少，感觉很难啊。我说：只要你脑子不笨不呆，灵活会转会用心记就行。</p>\n<p>调调几个 API 谁不会呢，我才不管你是怎么实现的，我只要拿到我想要的数据得到我想要的结果就行了，不就是一堆数据传过来传过去。现在框架轮子多得死，一拼一凑就是一个“项目”。</p>\n<p>可不是嘛，平时要写的就是一大坨的业务逻辑处理代码，正常的有几个会拎不清呢？当然也是有的，所以这层就开始出现了能力的差别。越往细小的领域，这差距就会越大。</p>\n<p>业务逻辑写个几年，天花板就到头了，若是脑子不活络无管理能力的，那就是真的“废”了。虽说饿不死，至少以后找个公司维护维护老项目都能养活自己。这就导致了以后没有了 <strong>竞争力</strong>，年级越大越无奈，这一阶段的人可以说是到处都是，市场完全不会缺。</p>\n<p>前一段时间招了个实习生（上海理工研二），自动化专业想要来写代码（跨专业，基础确实是差），说实话已是一片红海，若是像我上面说的那样还要去那个阶段一起游泳，那我觉得真是有点不值了。</p>\n<hr>\n<p>前几天智齿长出来了！右腮帮就像被人挥了一拳一样，感觉是真的不爽！本命年才会长智齿，真的是准啊，长大了长大了。</p>\n<p>同事搬过来变成了新室友，好家伙现在天天晚上都要粥煮起来吃，不吃睡不着，这吃下去再不长肉就真不科学了，再加上每天下午去楼下全家买两个包子或是两个馒头。搞了张尊享会员卡，也开始了没事喝喝咖啡的日子了（送的不喝那我就是有病了），血压低，多喝喝。</p>\n<p>哈哈，室友将他那辆二手永久车送我了！我自己去补了个胎，就花了二十换了辆自行车，怎么都不亏啊哈哈。刚好摩拜季卡到期了，共享单车又集体涨价，这辆三手车（可能不止三手了……）至少能骑个半年咯。</p>\n<p>等夏天到了，早上戴着墨镜骑着车听听音乐去上班，然后一身汗，湿透。</p>\n<hr>\n<p>有名气有底蕴的大学是真的不一样，看了附近同济、复旦的校区后，自己的母校是何等的简陋。。。以后还要多去其它学校看看，欣赏欣赏别人大学的风景。</p>\n<p>生活在于折腾，前提是还能经得起折腾。年纪轻轻就不要想那么多，想要的想做的就尽量去满足自己，一旦念头消散可能就再无机会了。</p>\n<p>至少还能有可以愿意去回想的东西，还有内心觉得美好的日子，还有至今无悔的事情。</p>\n<p>也许现在的生活并不是那么尽人意，但若是有可以回去的机会我还是会选择那样过，还是想要经历那些经历过的事情，虽然也许无果但无悔、无愧，青春，知足。</p>\n<hr>\n<p>我这个人啊，耳根子软，心也软又善，还重情义。你若对我一丝好，我便会含泪感动入睡。</p>\n<p>不过这不代表一向如此，上述只是我大多状态。人啊，久了都会不懂自己。</p>\n<p>最近在补权游，Valar Morghulis.</p>\n","excerpt":"","more":"<blockquote>\n<p>就在昨天，公司自己刚搭没多久的小服务器中了 ETH 勒索病毒，还好刚起步数据量不大，真可怕！</p>\n</blockquote>\n<p>把环境又给装了一遍，轻车熟路了。</p>\n<p>专业事情还是需要专业人士来做，网络安全也是一个相当大的方面，只要被不法分子盯上就很有可能是一笔不小的损失了。</p>\n<p>虽然说现在的技术科技发展很快，但是安全方面却不是那么跟得上脚步。中午跟同事聊起来，有些公司还是用最初的刻盘来保存数据，银行系统还有很多是 XP，回到本初，最原始的即最安全也是不无道理，整得再花再虚，我最需要的还是安全实用。</p>\n<p>从这些角度继续往下想，有时候我们会埋怨某些系统太过于古老，技术太过于落后，这也是前几年我看到一些古老项目的想法。技术的世界日新月异，新轮子不断出现，内涵包裹越来越深，过于追求抽象化。</p>\n<p>当我们选择项目中要用的技术栈时，肯定会优先选择那些稳定的、有人长期维护的、社区较活跃的，这些现象也正说明了这个技术关注度高，较为成熟。不然找偏门技术栈的可能出现了 Bug，其创始人都不知道为什么会出现该怎么解决，那不就废了吗。现在开源社区大多都是拿来即用，也很少会有人去专门研究源码，这就是技术选型。</p>\n<p>当你接手了一个老项目，你了解了其作用与每个地方的功能后，发现市面上完全有成熟的技术可以取代之，且换架构后项目会更加清晰易理解。这个时候你就可以向上申报或者自己闲暇时间尝试给它换一个壳（当然是因人而异，也有可能是费力不讨好之事，若对自身有益且有闲时，可一做）。当完成这个“手术”之后，往往自己会对这个项目有了一个更深的理解，很可能还会找到几处优化的地方。改造成功一个项目，看着它，就像是你赋予了它生命一般，后期需要改动或是加功能打补丁都会更得心应手。</p>\n<p>最近在看《深入理解计算机系统》，本是一本基础教材。明白了“万变不离其宗”的道理之后，深知基础的重要性。别人问我：你们搞计算机的要记的东西不少，感觉很难啊。我说：只要你脑子不笨不呆，灵活会转会用心记就行。</p>\n<p>调调几个 API 谁不会呢，我才不管你是怎么实现的，我只要拿到我想要的数据得到我想要的结果就行了，不就是一堆数据传过来传过去。现在框架轮子多得死，一拼一凑就是一个“项目”。</p>\n<p>可不是嘛，平时要写的就是一大坨的业务逻辑处理代码，正常的有几个会拎不清呢？当然也是有的，所以这层就开始出现了能力的差别。越往细小的领域，这差距就会越大。</p>\n<p>业务逻辑写个几年，天花板就到头了，若是脑子不活络无管理能力的，那就是真的“废”了。虽说饿不死，至少以后找个公司维护维护老项目都能养活自己。这就导致了以后没有了 <strong>竞争力</strong>，年级越大越无奈，这一阶段的人可以说是到处都是，市场完全不会缺。</p>\n<p>前一段时间招了个实习生（上海理工研二），自动化专业想要来写代码（跨专业，基础确实是差），说实话已是一片红海，若是像我上面说的那样还要去那个阶段一起游泳，那我觉得真是有点不值了。</p>\n<hr>\n<p>前几天智齿长出来了！右腮帮就像被人挥了一拳一样，感觉是真的不爽！本命年才会长智齿，真的是准啊，长大了长大了。</p>\n<p>同事搬过来变成了新室友，好家伙现在天天晚上都要粥煮起来吃，不吃睡不着，这吃下去再不长肉就真不科学了，再加上每天下午去楼下全家买两个包子或是两个馒头。搞了张尊享会员卡，也开始了没事喝喝咖啡的日子了（送的不喝那我就是有病了），血压低，多喝喝。</p>\n<p>哈哈，室友将他那辆二手永久车送我了！我自己去补了个胎，就花了二十换了辆自行车，怎么都不亏啊哈哈。刚好摩拜季卡到期了，共享单车又集体涨价，这辆三手车（可能不止三手了……）至少能骑个半年咯。</p>\n<p>等夏天到了，早上戴着墨镜骑着车听听音乐去上班，然后一身汗，湿透。</p>\n<hr>\n<p>有名气有底蕴的大学是真的不一样，看了附近同济、复旦的校区后，自己的母校是何等的简陋。。。以后还要多去其它学校看看，欣赏欣赏别人大学的风景。</p>\n<p>生活在于折腾，前提是还能经得起折腾。年纪轻轻就不要想那么多，想要的想做的就尽量去满足自己，一旦念头消散可能就再无机会了。</p>\n<p>至少还能有可以愿意去回想的东西，还有内心觉得美好的日子，还有至今无悔的事情。</p>\n<p>也许现在的生活并不是那么尽人意，但若是有可以回去的机会我还是会选择那样过，还是想要经历那些经历过的事情，虽然也许无果但无悔、无愧，青春，知足。</p>\n<hr>\n<p>我这个人啊，耳根子软，心也软又善，还重情义。你若对我一丝好，我便会含泪感动入睡。</p>\n<p>不过这不代表一向如此，上述只是我大多状态。人啊，久了都会不懂自己。</p>\n<p>最近在补权游，Valar Morghulis.</p>\n"},{"title":"期待一月（2022）","date":"2022-01-25T13:10:55.000Z","_content":"\n\n- 元旦\n\n  今年这个元旦没有回家也没有出去玩，是的，因为疫情。\n\n  日子很快，一晃就过。\n\n- 生日\n\n  小邱的生日过得也不开心，当天还干了一架，晚上吃了一顿羊肉锅。\n\n  买了一个千层蛋糕，不过没有吃完后来丢了半个，太浪费了。\n\n  后来还有次喝酒喝大了，好家伙。\n\n- 回家\n\n  回家的票倒是买了，近来上海静安奶茶店疫情封锁引起的话题不小。\n\n  还好浦东这边没有，不然就真回不去了。\n\n  回家算了算能待个八天，已经有半年没回过家了，去年春节还没有回去。\n\n  到时候带点年货回去，再包上个红包。\n\n  回家的心已经很迫切，核酸肯定难免，真想早点回家了。\n\n- 疫情\n\n  疫情我想也是大概率今年或者明年就不会这么恐慌了，后期可能也就跟流感一样与人类长期共存，死亡率也降到跟流感差不多。海外疫苗好像已经有很大的进展，尽管大家对口罩、酒精、健康码、行程码已经习以为常。大家当然都不想自己的行程会受到未知因素的影响，已经过去了两年，该要对此做一个了结了。人类渴望自由生活的脚步不可阻挡。\n\n\n\n接下来就是喜迎春节了！","source":"_posts/expect-january.md","raw":"---\ntitle: 期待一月（2022）\ndate: 2022-01-25 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n\n- 元旦\n\n  今年这个元旦没有回家也没有出去玩，是的，因为疫情。\n\n  日子很快，一晃就过。\n\n- 生日\n\n  小邱的生日过得也不开心，当天还干了一架，晚上吃了一顿羊肉锅。\n\n  买了一个千层蛋糕，不过没有吃完后来丢了半个，太浪费了。\n\n  后来还有次喝酒喝大了，好家伙。\n\n- 回家\n\n  回家的票倒是买了，近来上海静安奶茶店疫情封锁引起的话题不小。\n\n  还好浦东这边没有，不然就真回不去了。\n\n  回家算了算能待个八天，已经有半年没回过家了，去年春节还没有回去。\n\n  到时候带点年货回去，再包上个红包。\n\n  回家的心已经很迫切，核酸肯定难免，真想早点回家了。\n\n- 疫情\n\n  疫情我想也是大概率今年或者明年就不会这么恐慌了，后期可能也就跟流感一样与人类长期共存，死亡率也降到跟流感差不多。海外疫苗好像已经有很大的进展，尽管大家对口罩、酒精、健康码、行程码已经习以为常。大家当然都不想自己的行程会受到未知因素的影响，已经过去了两年，该要对此做一个了结了。人类渴望自由生活的脚步不可阻挡。\n\n\n\n接下来就是喜迎春节了！","slug":"expect-january","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhe004bk9i139skh13w","content":"<ul>\n<li><p>元旦</p>\n<p>今年这个元旦没有回家也没有出去玩，是的，因为疫情。</p>\n<p>日子很快，一晃就过。</p>\n</li>\n<li><p>生日</p>\n<p>小邱的生日过得也不开心，当天还干了一架，晚上吃了一顿羊肉锅。</p>\n<p>买了一个千层蛋糕，不过没有吃完后来丢了半个，太浪费了。</p>\n<p>后来还有次喝酒喝大了，好家伙。</p>\n</li>\n<li><p>回家</p>\n<p>回家的票倒是买了，近来上海静安奶茶店疫情封锁引起的话题不小。</p>\n<p>还好浦东这边没有，不然就真回不去了。</p>\n<p>回家算了算能待个八天，已经有半年没回过家了，去年春节还没有回去。</p>\n<p>到时候带点年货回去，再包上个红包。</p>\n<p>回家的心已经很迫切，核酸肯定难免，真想早点回家了。</p>\n</li>\n<li><p>疫情</p>\n<p>疫情我想也是大概率今年或者明年就不会这么恐慌了，后期可能也就跟流感一样与人类长期共存，死亡率也降到跟流感差不多。海外疫苗好像已经有很大的进展，尽管大家对口罩、酒精、健康码、行程码已经习以为常。大家当然都不想自己的行程会受到未知因素的影响，已经过去了两年，该要对此做一个了结了。人类渴望自由生活的脚步不可阻挡。</p>\n</li>\n</ul>\n<p>接下来就是喜迎春节了！</p>\n","excerpt":"","more":"<ul>\n<li><p>元旦</p>\n<p>今年这个元旦没有回家也没有出去玩，是的，因为疫情。</p>\n<p>日子很快，一晃就过。</p>\n</li>\n<li><p>生日</p>\n<p>小邱的生日过得也不开心，当天还干了一架，晚上吃了一顿羊肉锅。</p>\n<p>买了一个千层蛋糕，不过没有吃完后来丢了半个，太浪费了。</p>\n<p>后来还有次喝酒喝大了，好家伙。</p>\n</li>\n<li><p>回家</p>\n<p>回家的票倒是买了，近来上海静安奶茶店疫情封锁引起的话题不小。</p>\n<p>还好浦东这边没有，不然就真回不去了。</p>\n<p>回家算了算能待个八天，已经有半年没回过家了，去年春节还没有回去。</p>\n<p>到时候带点年货回去，再包上个红包。</p>\n<p>回家的心已经很迫切，核酸肯定难免，真想早点回家了。</p>\n</li>\n<li><p>疫情</p>\n<p>疫情我想也是大概率今年或者明年就不会这么恐慌了，后期可能也就跟流感一样与人类长期共存，死亡率也降到跟流感差不多。海外疫苗好像已经有很大的进展，尽管大家对口罩、酒精、健康码、行程码已经习以为常。大家当然都不想自己的行程会受到未知因素的影响，已经过去了两年，该要对此做一个了结了。人类渴望自由生活的脚步不可阻挡。</p>\n</li>\n</ul>\n<p>接下来就是喜迎春节了！</p>\n"},{"title":"Face++与Java简单应用（新）","date":"2018-05-24T07:42:34.000Z","_content":"## 开篇\n- 前段时间逛了下[旷视官网](https://www.megvii.com/#jzl_kwd=41736852109&jzl_ctv=16511707555&jzl_mtt=1&jzl_adt=cl1)，真是变化好大页面好漂亮现在，依稀记得最开始上的官网哪来这么炫酷\n- 然后就继续点进去看了下[Face++API](https://console.faceplusplus.com.cn/documents/4887579)，果不其然参数变了不少，识别点越来越多了\n- 再接下来我又翻了翻自己很久前写的一篇[博文](https://blog.csdn.net/ffj0721/article/details/54322133)，这不行了，这之前写的啥玩意，代码也找不到了，而且现在也不能用了，故，立了个flag\n\n## 操刀\n开始操刀了，还是一样我选择了SpringBoot，没什么，就是方便。这次选择用BootStrap框架。\n\n- 首先操刀之前，先去上面官网去注册用户，创建个应用，目的是为了获取它的api-key和api-secret![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-key.png)\n- 现在不像之前那样复杂了，那时候还得下个jar包导入才能调它的方法，现在直接在线调用即可。具体代码如图位置：![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-java.png)这样的话只需要把你需要识别的图片路径，你刚获取的api-key和api-secret替换就行了，然后你就可以得到一串json格式的字符串。太长我就不放了，主要信息就在faces中。我这里主要就是简单获取faces下面attributes中的一些参数。具体可直接看它官网的API，很详细的。\n- 图片上传我使用的是BootStrap-FileInput插件，这个插件确实很美观，刚开始使用的时候不太会，故研究了会。特别需要注意需要导入此插件的js和css，不然你就会有种想砸键盘的感觉了。\n\nhtml：\n\n```\n<div class=\"modal-body\" style=\"text-align: center;\">  \n    <a href=\"\" class=\"form-control\" style=\"border:none;\">上传照骗</a>  \n    <input type=\"file\" name=\"picFile\" id=\"picFile\" class=\"file-loading\" />  \n</div>\n```\njs:\n```\n//参数1:控件id、参数2:上传地址  \ninit(\"picFile\", \"/sendPic\");\n\n//初始化fileinput控件（第一次初始化）  \nfunction init(ctrlName, uploadUrl) {  \n\tvar control = $('#' + ctrlName);  \n\t\t //初始化上传控件的样式  \n\t\t control.fileinput({  \n\t\t language: 'zh',                                         //设置语言  \n\t\t uploadUrl: uploadUrl,                                   //上传的地址  \n\t\t allowedFileExtensions: ['jpg', 'png', 'jpeg'],          //接收的文件后缀  \n\t\t showUpload: true,                                       //是否显示上传按钮  \n\t\t showCaption: false,                                     //是否显示标题  \n\t\t browseClass: \"btn btn-primary\",                         //按钮样式       \n\t\t dropZoneEnabled: false,                               //是否显示拖拽区域  \n\t\t //minImageWidth: 50,                                    //图片的最小宽度  \n\t\t //minImageHeight: 50,                                   //图片的最小高度  \n\t\t //maxImageWidth: 1000,                                  //图片的最大宽度  \n\t\t //maxImageHeight: 1000,                                 //图片的最大高度  \n\t\t maxFileSize: 2048,                                       //单位为kb，如果为0表示不限制文件大小  \n\t\t //minFileCount: 0,  \n\t\t //maxFileCount: 10,                                       //表示允许同时上传的最大文件个数  \n\t\t //enctype: 'multipart/form-data',  \n\t\t validateInitialCount:true,  \n\t\t previewFileIcon: \"<i class='glyphicon glyphicon-king'></i>\",  \n\t\t //msgFilesTooMany: \"选择上传的文件数量({n}) 超过允许的最大数值{m}！\",  \n\t\t uploadExtraData:function (previewId, index) {           //传参  \n\t\t    var data = {  \n\t\t             //此处自定义传参  \n\t\t       \t\t};  \n\t\t         return data;  \n\t\t        }  \n\t\t     });  \n\t\t  \n\t\t  //导入文件上传完成之后的事件  \n\t\t  $(\"#picFile\").on(\"fileuploaded\", function (event, data, previewId, index) {  \n\t\t            \n\t\t        });  \n\t\t    }\n\n```\n文件上传成功后后台还需要接收它，如何接收?且听我慢慢道来：\n```\nMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\nList<MultipartFile> fileList = multipartRequest.getFiles(dstFileName);\n```\n这两句可以接收到对应页面上传的图片，List说明它可以一次上传多张。既然能接收到，那就什么都不是事了。接下来想怎么玩就怎么玩。\n\n- 在页面用到BootStrap模态框的时候我发现它不能拖拽，然后网上冲浪了一会，发现把jquery-ui导入就可以使用draggable()方法。可全局可单页面，我这里是全局设置。\n```\n// 使模态框可拖拽\t\t    \n$(document).on(\"show.bs.modal\", \".modal\", function(){\n    $(this).draggable();\n    $(this).css(\"overflow-y\", \"scroll\");   \n    // 防止出现滚动条，出现的话，你会把滚动条一起拖着走的\n});\n```\n\n- 前端知识还需要恶补啊，现在页面想做点炫酷的效果是一点办法没有，布局排版还丑的一批。还需努力啊！\n\n## Screenshots\n\n- Index ![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/index.png)\n\n- One Person Result![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/individual.png)\n\n- More than One Person Result![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/multiplayer.png)\n\n## Links\n- [演示网址](http://47.96.88.132:8091/)\n- [GitHub地址](https://github.com/Folgerjun/face.putop.top)\n- [BootStrap-FileInput插件详情参考](http://www.jq22.com/jquery-info5231)\n- [之前写的一篇博文](https://blog.csdn.net/ffj0721/article/details/54322133)\n- [Face++API](https://console.faceplusplus.com.cn/documents/4887579)","source":"_posts/face-java.md","raw":"---\ntitle: Face++与Java简单应用（新）\ndate: 2018-5-24 15:42:34\ncategories: [开发,Web]\ntags: [Java,Face++,BootStrapFileInput]\n---\n## 开篇\n- 前段时间逛了下[旷视官网](https://www.megvii.com/#jzl_kwd=41736852109&jzl_ctv=16511707555&jzl_mtt=1&jzl_adt=cl1)，真是变化好大页面好漂亮现在，依稀记得最开始上的官网哪来这么炫酷\n- 然后就继续点进去看了下[Face++API](https://console.faceplusplus.com.cn/documents/4887579)，果不其然参数变了不少，识别点越来越多了\n- 再接下来我又翻了翻自己很久前写的一篇[博文](https://blog.csdn.net/ffj0721/article/details/54322133)，这不行了，这之前写的啥玩意，代码也找不到了，而且现在也不能用了，故，立了个flag\n\n## 操刀\n开始操刀了，还是一样我选择了SpringBoot，没什么，就是方便。这次选择用BootStrap框架。\n\n- 首先操刀之前，先去上面官网去注册用户，创建个应用，目的是为了获取它的api-key和api-secret![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-key.png)\n- 现在不像之前那样复杂了，那时候还得下个jar包导入才能调它的方法，现在直接在线调用即可。具体代码如图位置：![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-java.png)这样的话只需要把你需要识别的图片路径，你刚获取的api-key和api-secret替换就行了，然后你就可以得到一串json格式的字符串。太长我就不放了，主要信息就在faces中。我这里主要就是简单获取faces下面attributes中的一些参数。具体可直接看它官网的API，很详细的。\n- 图片上传我使用的是BootStrap-FileInput插件，这个插件确实很美观，刚开始使用的时候不太会，故研究了会。特别需要注意需要导入此插件的js和css，不然你就会有种想砸键盘的感觉了。\n\nhtml：\n\n```\n<div class=\"modal-body\" style=\"text-align: center;\">  \n    <a href=\"\" class=\"form-control\" style=\"border:none;\">上传照骗</a>  \n    <input type=\"file\" name=\"picFile\" id=\"picFile\" class=\"file-loading\" />  \n</div>\n```\njs:\n```\n//参数1:控件id、参数2:上传地址  \ninit(\"picFile\", \"/sendPic\");\n\n//初始化fileinput控件（第一次初始化）  \nfunction init(ctrlName, uploadUrl) {  \n\tvar control = $('#' + ctrlName);  \n\t\t //初始化上传控件的样式  \n\t\t control.fileinput({  \n\t\t language: 'zh',                                         //设置语言  \n\t\t uploadUrl: uploadUrl,                                   //上传的地址  \n\t\t allowedFileExtensions: ['jpg', 'png', 'jpeg'],          //接收的文件后缀  \n\t\t showUpload: true,                                       //是否显示上传按钮  \n\t\t showCaption: false,                                     //是否显示标题  \n\t\t browseClass: \"btn btn-primary\",                         //按钮样式       \n\t\t dropZoneEnabled: false,                               //是否显示拖拽区域  \n\t\t //minImageWidth: 50,                                    //图片的最小宽度  \n\t\t //minImageHeight: 50,                                   //图片的最小高度  \n\t\t //maxImageWidth: 1000,                                  //图片的最大宽度  \n\t\t //maxImageHeight: 1000,                                 //图片的最大高度  \n\t\t maxFileSize: 2048,                                       //单位为kb，如果为0表示不限制文件大小  \n\t\t //minFileCount: 0,  \n\t\t //maxFileCount: 10,                                       //表示允许同时上传的最大文件个数  \n\t\t //enctype: 'multipart/form-data',  \n\t\t validateInitialCount:true,  \n\t\t previewFileIcon: \"<i class='glyphicon glyphicon-king'></i>\",  \n\t\t //msgFilesTooMany: \"选择上传的文件数量({n}) 超过允许的最大数值{m}！\",  \n\t\t uploadExtraData:function (previewId, index) {           //传参  \n\t\t    var data = {  \n\t\t             //此处自定义传参  \n\t\t       \t\t};  \n\t\t         return data;  \n\t\t        }  \n\t\t     });  \n\t\t  \n\t\t  //导入文件上传完成之后的事件  \n\t\t  $(\"#picFile\").on(\"fileuploaded\", function (event, data, previewId, index) {  \n\t\t            \n\t\t        });  \n\t\t    }\n\n```\n文件上传成功后后台还需要接收它，如何接收?且听我慢慢道来：\n```\nMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\nList<MultipartFile> fileList = multipartRequest.getFiles(dstFileName);\n```\n这两句可以接收到对应页面上传的图片，List说明它可以一次上传多张。既然能接收到，那就什么都不是事了。接下来想怎么玩就怎么玩。\n\n- 在页面用到BootStrap模态框的时候我发现它不能拖拽，然后网上冲浪了一会，发现把jquery-ui导入就可以使用draggable()方法。可全局可单页面，我这里是全局设置。\n```\n// 使模态框可拖拽\t\t    \n$(document).on(\"show.bs.modal\", \".modal\", function(){\n    $(this).draggable();\n    $(this).css(\"overflow-y\", \"scroll\");   \n    // 防止出现滚动条，出现的话，你会把滚动条一起拖着走的\n});\n```\n\n- 前端知识还需要恶补啊，现在页面想做点炫酷的效果是一点办法没有，布局排版还丑的一批。还需努力啊！\n\n## Screenshots\n\n- Index ![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/index.png)\n\n- One Person Result![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/individual.png)\n\n- More than One Person Result![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/multiplayer.png)\n\n## Links\n- [演示网址](http://47.96.88.132:8091/)\n- [GitHub地址](https://github.com/Folgerjun/face.putop.top)\n- [BootStrap-FileInput插件详情参考](http://www.jq22.com/jquery-info5231)\n- [之前写的一篇博文](https://blog.csdn.net/ffj0721/article/details/54322133)\n- [Face++API](https://console.faceplusplus.com.cn/documents/4887579)","slug":"face-java","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhe004gk9i1dfu0cos7","content":"<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><ul>\n<li>前段时间逛了下<a href=\"https://www.megvii.com/#jzl_kwd=41736852109&jzl_ctv=16511707555&jzl_mtt=1&jzl_adt=cl1\">旷视官网</a>，真是变化好大页面好漂亮现在，依稀记得最开始上的官网哪来这么炫酷</li>\n<li>然后就继续点进去看了下<a href=\"https://console.faceplusplus.com.cn/documents/4887579\">Face++API</a>，果不其然参数变了不少，识别点越来越多了</li>\n<li>再接下来我又翻了翻自己很久前写的一篇<a href=\"https://blog.csdn.net/ffj0721/article/details/54322133\">博文</a>，这不行了，这之前写的啥玩意，代码也找不到了，而且现在也不能用了，故，立了个flag</li>\n</ul>\n<h2 id=\"操刀\"><a href=\"#操刀\" class=\"headerlink\" title=\"操刀\"></a>操刀</h2><p>开始操刀了，还是一样我选择了SpringBoot，没什么，就是方便。这次选择用BootStrap框架。</p>\n<ul>\n<li>首先操刀之前，先去上面官网去注册用户，创建个应用，目的是为了获取它的api-key和api-secret<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-key.png\"></li>\n<li>现在不像之前那样复杂了，那时候还得下个jar包导入才能调它的方法，现在直接在线调用即可。具体代码如图位置：<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-java.png\">这样的话只需要把你需要识别的图片路径，你刚获取的api-key和api-secret替换就行了，然后你就可以得到一串json格式的字符串。太长我就不放了，主要信息就在faces中。我这里主要就是简单获取faces下面attributes中的一些参数。具体可直接看它官网的API，很详细的。</li>\n<li>图片上传我使用的是BootStrap-FileInput插件，这个插件确实很美观，刚开始使用的时候不太会，故研究了会。特别需要注意需要导入此插件的js和css，不然你就会有种想砸键盘的感觉了。</li>\n</ul>\n<p>html：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;modal-body&quot; style=&quot;text-align: center;&quot;&gt;  </span><br><span class=\"line\">    &lt;a href=&quot;&quot; class=&quot;form-control&quot; style=&quot;border:none;&quot;&gt;上传照骗&lt;/a&gt;  </span><br><span class=\"line\">    &lt;input type=&quot;file&quot; name=&quot;picFile&quot; id=&quot;picFile&quot; class=&quot;file-loading&quot; /&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>js:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//参数1:控件id、参数2:上传地址  </span><br><span class=\"line\">init(&quot;picFile&quot;, &quot;/sendPic&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化fileinput控件（第一次初始化）  </span><br><span class=\"line\">function init(ctrlName, uploadUrl) &#123;  </span><br><span class=\"line\">\tvar control = $(&#x27;#&#x27; + ctrlName);  </span><br><span class=\"line\">\t\t //初始化上传控件的样式  </span><br><span class=\"line\">\t\t control.fileinput(&#123;  </span><br><span class=\"line\">\t\t language: &#x27;zh&#x27;,                                         //设置语言  </span><br><span class=\"line\">\t\t uploadUrl: uploadUrl,                                   //上传的地址  </span><br><span class=\"line\">\t\t allowedFileExtensions: [&#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;jpeg&#x27;],          //接收的文件后缀  </span><br><span class=\"line\">\t\t showUpload: true,                                       //是否显示上传按钮  </span><br><span class=\"line\">\t\t showCaption: false,                                     //是否显示标题  </span><br><span class=\"line\">\t\t browseClass: &quot;btn btn-primary&quot;,                         //按钮样式       </span><br><span class=\"line\">\t\t dropZoneEnabled: false,                               //是否显示拖拽区域  </span><br><span class=\"line\">\t\t //minImageWidth: 50,                                    //图片的最小宽度  </span><br><span class=\"line\">\t\t //minImageHeight: 50,                                   //图片的最小高度  </span><br><span class=\"line\">\t\t //maxImageWidth: 1000,                                  //图片的最大宽度  </span><br><span class=\"line\">\t\t //maxImageHeight: 1000,                                 //图片的最大高度  </span><br><span class=\"line\">\t\t maxFileSize: 2048,                                       //单位为kb，如果为0表示不限制文件大小  </span><br><span class=\"line\">\t\t //minFileCount: 0,  </span><br><span class=\"line\">\t\t //maxFileCount: 10,                                       //表示允许同时上传的最大文件个数  </span><br><span class=\"line\">\t\t //enctype: &#x27;multipart/form-data&#x27;,  </span><br><span class=\"line\">\t\t validateInitialCount:true,  </span><br><span class=\"line\">\t\t previewFileIcon: &quot;&lt;i class=&#x27;glyphicon glyphicon-king&#x27;&gt;&lt;/i&gt;&quot;,  </span><br><span class=\"line\">\t\t //msgFilesTooMany: &quot;选择上传的文件数量(&#123;n&#125;) 超过允许的最大数值&#123;m&#125;！&quot;,  </span><br><span class=\"line\">\t\t uploadExtraData:function (previewId, index) &#123;           //传参  </span><br><span class=\"line\">\t\t    var data = &#123;  </span><br><span class=\"line\">\t\t             //此处自定义传参  </span><br><span class=\"line\">\t\t       \t\t&#125;;  </span><br><span class=\"line\">\t\t         return data;  </span><br><span class=\"line\">\t\t        &#125;  </span><br><span class=\"line\">\t\t     &#125;);  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t  //导入文件上传完成之后的事件  </span><br><span class=\"line\">\t\t  $(&quot;#picFile&quot;).on(&quot;fileuploaded&quot;, function (event, data, previewId, index) &#123;  </span><br><span class=\"line\">\t\t            </span><br><span class=\"line\">\t\t        &#125;);  </span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>文件上传成功后后台还需要接收它，如何接收?且听我慢慢道来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;</span><br><span class=\"line\">List&lt;MultipartFile&gt; fileList = multipartRequest.getFiles(dstFileName);</span><br></pre></td></tr></table></figure>\n<p>这两句可以接收到对应页面上传的图片，List说明它可以一次上传多张。既然能接收到，那就什么都不是事了。接下来想怎么玩就怎么玩。</p>\n<ul>\n<li><p>在页面用到BootStrap模态框的时候我发现它不能拖拽，然后网上冲浪了一会，发现把jquery-ui导入就可以使用draggable()方法。可全局可单页面，我这里是全局设置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使模态框可拖拽\t\t    </span><br><span class=\"line\">$(document).on(&quot;show.bs.modal&quot;, &quot;.modal&quot;, function()&#123;</span><br><span class=\"line\">    $(this).draggable();</span><br><span class=\"line\">    $(this).css(&quot;overflow-y&quot;, &quot;scroll&quot;);   </span><br><span class=\"line\">    // 防止出现滚动条，出现的话，你会把滚动条一起拖着走的</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前端知识还需要恶补啊，现在页面想做点炫酷的效果是一点办法没有，布局排版还丑的一批。还需努力啊！</p>\n</li>\n</ul>\n<h2 id=\"Screenshots\"><a href=\"#Screenshots\" class=\"headerlink\" title=\"Screenshots\"></a>Screenshots</h2><ul>\n<li><p>Index <img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/index.png\"></p>\n</li>\n<li><p>One Person Result<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/individual.png\"></p>\n</li>\n<li><p>More than One Person Result<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/multiplayer.png\"></p>\n</li>\n</ul>\n<h2 id=\"Links\"><a href=\"#Links\" class=\"headerlink\" title=\"Links\"></a>Links</h2><ul>\n<li><a href=\"http://47.96.88.132:8091/\">演示网址</a></li>\n<li><a href=\"https://github.com/Folgerjun/face.putop.top\">GitHub地址</a></li>\n<li><a href=\"http://www.jq22.com/jquery-info5231\">BootStrap-FileInput插件详情参考</a></li>\n<li><a href=\"https://blog.csdn.net/ffj0721/article/details/54322133\">之前写的一篇博文</a></li>\n<li><a href=\"https://console.faceplusplus.com.cn/documents/4887579\">Face++API</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><ul>\n<li>前段时间逛了下<a href=\"https://www.megvii.com/#jzl_kwd=41736852109&jzl_ctv=16511707555&jzl_mtt=1&jzl_adt=cl1\">旷视官网</a>，真是变化好大页面好漂亮现在，依稀记得最开始上的官网哪来这么炫酷</li>\n<li>然后就继续点进去看了下<a href=\"https://console.faceplusplus.com.cn/documents/4887579\">Face++API</a>，果不其然参数变了不少，识别点越来越多了</li>\n<li>再接下来我又翻了翻自己很久前写的一篇<a href=\"https://blog.csdn.net/ffj0721/article/details/54322133\">博文</a>，这不行了，这之前写的啥玩意，代码也找不到了，而且现在也不能用了，故，立了个flag</li>\n</ul>\n<h2 id=\"操刀\"><a href=\"#操刀\" class=\"headerlink\" title=\"操刀\"></a>操刀</h2><p>开始操刀了，还是一样我选择了SpringBoot，没什么，就是方便。这次选择用BootStrap框架。</p>\n<ul>\n<li>首先操刀之前，先去上面官网去注册用户，创建个应用，目的是为了获取它的api-key和api-secret<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-key.png\"></li>\n<li>现在不像之前那样复杂了，那时候还得下个jar包导入才能调它的方法，现在直接在线调用即可。具体代码如图位置：<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/face-java.png\">这样的话只需要把你需要识别的图片路径，你刚获取的api-key和api-secret替换就行了，然后你就可以得到一串json格式的字符串。太长我就不放了，主要信息就在faces中。我这里主要就是简单获取faces下面attributes中的一些参数。具体可直接看它官网的API，很详细的。</li>\n<li>图片上传我使用的是BootStrap-FileInput插件，这个插件确实很美观，刚开始使用的时候不太会，故研究了会。特别需要注意需要导入此插件的js和css，不然你就会有种想砸键盘的感觉了。</li>\n</ul>\n<p>html：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;modal-body&quot; style=&quot;text-align: center;&quot;&gt;  </span><br><span class=\"line\">    &lt;a href=&quot;&quot; class=&quot;form-control&quot; style=&quot;border:none;&quot;&gt;上传照骗&lt;/a&gt;  </span><br><span class=\"line\">    &lt;input type=&quot;file&quot; name=&quot;picFile&quot; id=&quot;picFile&quot; class=&quot;file-loading&quot; /&gt;  </span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>js:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//参数1:控件id、参数2:上传地址  </span><br><span class=\"line\">init(&quot;picFile&quot;, &quot;/sendPic&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化fileinput控件（第一次初始化）  </span><br><span class=\"line\">function init(ctrlName, uploadUrl) &#123;  </span><br><span class=\"line\">\tvar control = $(&#x27;#&#x27; + ctrlName);  </span><br><span class=\"line\">\t\t //初始化上传控件的样式  </span><br><span class=\"line\">\t\t control.fileinput(&#123;  </span><br><span class=\"line\">\t\t language: &#x27;zh&#x27;,                                         //设置语言  </span><br><span class=\"line\">\t\t uploadUrl: uploadUrl,                                   //上传的地址  </span><br><span class=\"line\">\t\t allowedFileExtensions: [&#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;jpeg&#x27;],          //接收的文件后缀  </span><br><span class=\"line\">\t\t showUpload: true,                                       //是否显示上传按钮  </span><br><span class=\"line\">\t\t showCaption: false,                                     //是否显示标题  </span><br><span class=\"line\">\t\t browseClass: &quot;btn btn-primary&quot;,                         //按钮样式       </span><br><span class=\"line\">\t\t dropZoneEnabled: false,                               //是否显示拖拽区域  </span><br><span class=\"line\">\t\t //minImageWidth: 50,                                    //图片的最小宽度  </span><br><span class=\"line\">\t\t //minImageHeight: 50,                                   //图片的最小高度  </span><br><span class=\"line\">\t\t //maxImageWidth: 1000,                                  //图片的最大宽度  </span><br><span class=\"line\">\t\t //maxImageHeight: 1000,                                 //图片的最大高度  </span><br><span class=\"line\">\t\t maxFileSize: 2048,                                       //单位为kb，如果为0表示不限制文件大小  </span><br><span class=\"line\">\t\t //minFileCount: 0,  </span><br><span class=\"line\">\t\t //maxFileCount: 10,                                       //表示允许同时上传的最大文件个数  </span><br><span class=\"line\">\t\t //enctype: &#x27;multipart/form-data&#x27;,  </span><br><span class=\"line\">\t\t validateInitialCount:true,  </span><br><span class=\"line\">\t\t previewFileIcon: &quot;&lt;i class=&#x27;glyphicon glyphicon-king&#x27;&gt;&lt;/i&gt;&quot;,  </span><br><span class=\"line\">\t\t //msgFilesTooMany: &quot;选择上传的文件数量(&#123;n&#125;) 超过允许的最大数值&#123;m&#125;！&quot;,  </span><br><span class=\"line\">\t\t uploadExtraData:function (previewId, index) &#123;           //传参  </span><br><span class=\"line\">\t\t    var data = &#123;  </span><br><span class=\"line\">\t\t             //此处自定义传参  </span><br><span class=\"line\">\t\t       \t\t&#125;;  </span><br><span class=\"line\">\t\t         return data;  </span><br><span class=\"line\">\t\t        &#125;  </span><br><span class=\"line\">\t\t     &#125;);  </span><br><span class=\"line\">\t\t  </span><br><span class=\"line\">\t\t  //导入文件上传完成之后的事件  </span><br><span class=\"line\">\t\t  $(&quot;#picFile&quot;).on(&quot;fileuploaded&quot;, function (event, data, previewId, index) &#123;  </span><br><span class=\"line\">\t\t            </span><br><span class=\"line\">\t\t        &#125;);  </span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>文件上传成功后后台还需要接收它，如何接收?且听我慢慢道来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;</span><br><span class=\"line\">List&lt;MultipartFile&gt; fileList = multipartRequest.getFiles(dstFileName);</span><br></pre></td></tr></table></figure>\n<p>这两句可以接收到对应页面上传的图片，List说明它可以一次上传多张。既然能接收到，那就什么都不是事了。接下来想怎么玩就怎么玩。</p>\n<ul>\n<li><p>在页面用到BootStrap模态框的时候我发现它不能拖拽，然后网上冲浪了一会，发现把jquery-ui导入就可以使用draggable()方法。可全局可单页面，我这里是全局设置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使模态框可拖拽\t\t    </span><br><span class=\"line\">$(document).on(&quot;show.bs.modal&quot;, &quot;.modal&quot;, function()&#123;</span><br><span class=\"line\">    $(this).draggable();</span><br><span class=\"line\">    $(this).css(&quot;overflow-y&quot;, &quot;scroll&quot;);   </span><br><span class=\"line\">    // 防止出现滚动条，出现的话，你会把滚动条一起拖着走的</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>前端知识还需要恶补啊，现在页面想做点炫酷的效果是一点办法没有，布局排版还丑的一批。还需努力啊！</p>\n</li>\n</ul>\n<h2 id=\"Screenshots\"><a href=\"#Screenshots\" class=\"headerlink\" title=\"Screenshots\"></a>Screenshots</h2><ul>\n<li><p>Index <img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/index.png\"></p>\n</li>\n<li><p>One Person Result<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/individual.png\"></p>\n</li>\n<li><p>More than One Person Result<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/face/multiplayer.png\"></p>\n</li>\n</ul>\n<h2 id=\"Links\"><a href=\"#Links\" class=\"headerlink\" title=\"Links\"></a>Links</h2><ul>\n<li><a href=\"http://47.96.88.132:8091/\">演示网址</a></li>\n<li><a href=\"https://github.com/Folgerjun/face.putop.top\">GitHub地址</a></li>\n<li><a href=\"http://www.jq22.com/jquery-info5231\">BootStrap-FileInput插件详情参考</a></li>\n<li><a href=\"https://blog.csdn.net/ffj0721/article/details/54322133\">之前写的一篇博文</a></li>\n<li><a href=\"https://console.faceplusplus.com.cn/documents/4887579\">Face++API</a></li>\n</ul>\n"},{"title":"糊涂八月（2019）","date":"2019-08-28T02:59:49.000Z","_content":"\n> 稀里糊涂稀里糊涂啊\n\n狂风暴雨 阳光烈焰 雾雨蒙蒙\n\n---\n\n## 昆明\n不出意外，跟同事一起又跑了趟昆明。没想到的是呆了七天，干了七天的活，出去耍的时间都没有，惨兮兮。\n\n呈贡大学城也确实偏了点，连市区都没得去，只能在附近随便吃点喝点。米粉确实是正宗还实惠，十三块钱吃得我啤酒肚了，可总不能天天搞米粉吃吧。\n\n阴凉地小风吹得，舒服极了，站在太阳直射下却不一会就晒得通红，热得要炸。\n\n从去的那天开始内火就开始旺啊，上次来也不见得体内火气这么大，还是天气太干燥了，不适应。\n\n水果都是按公斤计价的，买了点桃子芒果，便宜倒也不是很便宜，总之比上海还是要便宜点的，在上海都不舍得买水果吃。\n\n一直心心念念想要吃炸虫子，吃爆浆的那种，可是到走的那天也没能吃着，亏边上同事还是在昆明读过几年书的，真的一点不靠谱啊。后来去了家农家乐随便吃了点，大盘的菜，量大，当然相对昆明的物价来说也不能算便宜。\n\n虽说附近是大学城，可真也不巧，刚好暑假。校园里也都没几个人，看到的大多是对对小情侣，不禁感叹：大学生活好啊！\n\n地区会影响人的外貌习性，总的看来，个人还是较喜欢沿海的南方妹子，下次有机会去传说中的成都/长沙养养眼，见识见识。\n\n唉，出差真的也是累得慌啊。\n\n## 七夕\n什么七不七的，那天半夜才在浦东下的飞机，热乎饭都没能吃上口。\n\n## 台风利奇马\n这个台风是真的厉害了，刚好周末登陆各种预警，那天真是狂风催嫩叶啊。刚登陆温岭的时候风速巨大，陆地后强度减弱，听新闻说也有不少人遭难，天灾。\n\n已经造成浙江损失一百多亿了。\n\n周五晚已经是暴雨连连了，想着周末也铁定出不了门了就在超市备了两天的伙食，自己随便开开火得了。周六确实是下了一天的雨，挂了一天的风，到了周日台风过去后雨过天晴，一切又像是都没发生过一样，只有地上的落叶能说明一切。\n\n## 无锡\n无锡太湖试验厅项目需要测个索力数据，没人啊，派我过去了呗。无锡太湖一日游，也就在边角眺望了一会。\n\n跟同事晚上吃了个自助，喝了点小酒，本想着再去洗个脚按个摩，奈何吃饱喝足累得慌，还是回去早点休息吧。\n\n做的事越来越杂，好像已经开始脱离了最初进来时的职责。\n\n## 周末\n现在有了个喜欢做饭的室友，周末比之前是好多了，对面就是超市买菜也方便。弄个一荤两素一汤，健康又实惠。不过这次周末有点奢侈，大荤大素的整了不少，室友还把“珍藏”的红酒给贡献了出来。说好的吃素，这整的，以后吃吃蔬菜就得了。\n\n身上的湿气重啊，房间里放的除湿袋不到一星期就积满了水，也可能跟我那朝北的小房间有关系，不过最近感觉全身都难受，站着不动都能往外出水来着。看看找个时间需要去拔个罐去去湿，出门在外要对自己好点。\n\n## 压抑\n不知道为什么，最近情绪不太高总觉得很压抑，胸闷有时候喘不过气来。\n\n很难受，周末就去找了同学一起聚一聚，也有好长时间没有聚过了，大家都多多少少有点压抑。\n\n胡吃海玩了之后回来还是不太好，我这是怎么了？凌晨两点的杭州夜景也治愈不了我。\n\n什么都没意思，好难受啊，何以解忧","source":"_posts/foolish-august.md","raw":"---\ntitle: 糊涂八月（2019）\ndate: 2019-8-28 10:59:49\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 稀里糊涂稀里糊涂啊\n\n狂风暴雨 阳光烈焰 雾雨蒙蒙\n\n---\n\n## 昆明\n不出意外，跟同事一起又跑了趟昆明。没想到的是呆了七天，干了七天的活，出去耍的时间都没有，惨兮兮。\n\n呈贡大学城也确实偏了点，连市区都没得去，只能在附近随便吃点喝点。米粉确实是正宗还实惠，十三块钱吃得我啤酒肚了，可总不能天天搞米粉吃吧。\n\n阴凉地小风吹得，舒服极了，站在太阳直射下却不一会就晒得通红，热得要炸。\n\n从去的那天开始内火就开始旺啊，上次来也不见得体内火气这么大，还是天气太干燥了，不适应。\n\n水果都是按公斤计价的，买了点桃子芒果，便宜倒也不是很便宜，总之比上海还是要便宜点的，在上海都不舍得买水果吃。\n\n一直心心念念想要吃炸虫子，吃爆浆的那种，可是到走的那天也没能吃着，亏边上同事还是在昆明读过几年书的，真的一点不靠谱啊。后来去了家农家乐随便吃了点，大盘的菜，量大，当然相对昆明的物价来说也不能算便宜。\n\n虽说附近是大学城，可真也不巧，刚好暑假。校园里也都没几个人，看到的大多是对对小情侣，不禁感叹：大学生活好啊！\n\n地区会影响人的外貌习性，总的看来，个人还是较喜欢沿海的南方妹子，下次有机会去传说中的成都/长沙养养眼，见识见识。\n\n唉，出差真的也是累得慌啊。\n\n## 七夕\n什么七不七的，那天半夜才在浦东下的飞机，热乎饭都没能吃上口。\n\n## 台风利奇马\n这个台风是真的厉害了，刚好周末登陆各种预警，那天真是狂风催嫩叶啊。刚登陆温岭的时候风速巨大，陆地后强度减弱，听新闻说也有不少人遭难，天灾。\n\n已经造成浙江损失一百多亿了。\n\n周五晚已经是暴雨连连了，想着周末也铁定出不了门了就在超市备了两天的伙食，自己随便开开火得了。周六确实是下了一天的雨，挂了一天的风，到了周日台风过去后雨过天晴，一切又像是都没发生过一样，只有地上的落叶能说明一切。\n\n## 无锡\n无锡太湖试验厅项目需要测个索力数据，没人啊，派我过去了呗。无锡太湖一日游，也就在边角眺望了一会。\n\n跟同事晚上吃了个自助，喝了点小酒，本想着再去洗个脚按个摩，奈何吃饱喝足累得慌，还是回去早点休息吧。\n\n做的事越来越杂，好像已经开始脱离了最初进来时的职责。\n\n## 周末\n现在有了个喜欢做饭的室友，周末比之前是好多了，对面就是超市买菜也方便。弄个一荤两素一汤，健康又实惠。不过这次周末有点奢侈，大荤大素的整了不少，室友还把“珍藏”的红酒给贡献了出来。说好的吃素，这整的，以后吃吃蔬菜就得了。\n\n身上的湿气重啊，房间里放的除湿袋不到一星期就积满了水，也可能跟我那朝北的小房间有关系，不过最近感觉全身都难受，站着不动都能往外出水来着。看看找个时间需要去拔个罐去去湿，出门在外要对自己好点。\n\n## 压抑\n不知道为什么，最近情绪不太高总觉得很压抑，胸闷有时候喘不过气来。\n\n很难受，周末就去找了同学一起聚一聚，也有好长时间没有聚过了，大家都多多少少有点压抑。\n\n胡吃海玩了之后回来还是不太好，我这是怎么了？凌晨两点的杭州夜景也治愈不了我。\n\n什么都没意思，好难受啊，何以解忧","slug":"foolish-august","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhe004jk9i1giqe4rdj","content":"<blockquote>\n<p>稀里糊涂稀里糊涂啊</p>\n</blockquote>\n<p>狂风暴雨 阳光烈焰 雾雨蒙蒙</p>\n<hr>\n<h2 id=\"昆明\"><a href=\"#昆明\" class=\"headerlink\" title=\"昆明\"></a>昆明</h2><p>不出意外，跟同事一起又跑了趟昆明。没想到的是呆了七天，干了七天的活，出去耍的时间都没有，惨兮兮。</p>\n<p>呈贡大学城也确实偏了点，连市区都没得去，只能在附近随便吃点喝点。米粉确实是正宗还实惠，十三块钱吃得我啤酒肚了，可总不能天天搞米粉吃吧。</p>\n<p>阴凉地小风吹得，舒服极了，站在太阳直射下却不一会就晒得通红，热得要炸。</p>\n<p>从去的那天开始内火就开始旺啊，上次来也不见得体内火气这么大，还是天气太干燥了，不适应。</p>\n<p>水果都是按公斤计价的，买了点桃子芒果，便宜倒也不是很便宜，总之比上海还是要便宜点的，在上海都不舍得买水果吃。</p>\n<p>一直心心念念想要吃炸虫子，吃爆浆的那种，可是到走的那天也没能吃着，亏边上同事还是在昆明读过几年书的，真的一点不靠谱啊。后来去了家农家乐随便吃了点，大盘的菜，量大，当然相对昆明的物价来说也不能算便宜。</p>\n<p>虽说附近是大学城，可真也不巧，刚好暑假。校园里也都没几个人，看到的大多是对对小情侣，不禁感叹：大学生活好啊！</p>\n<p>地区会影响人的外貌习性，总的看来，个人还是较喜欢沿海的南方妹子，下次有机会去传说中的成都&#x2F;长沙养养眼，见识见识。</p>\n<p>唉，出差真的也是累得慌啊。</p>\n<h2 id=\"七夕\"><a href=\"#七夕\" class=\"headerlink\" title=\"七夕\"></a>七夕</h2><p>什么七不七的，那天半夜才在浦东下的飞机，热乎饭都没能吃上口。</p>\n<h2 id=\"台风利奇马\"><a href=\"#台风利奇马\" class=\"headerlink\" title=\"台风利奇马\"></a>台风利奇马</h2><p>这个台风是真的厉害了，刚好周末登陆各种预警，那天真是狂风催嫩叶啊。刚登陆温岭的时候风速巨大，陆地后强度减弱，听新闻说也有不少人遭难，天灾。</p>\n<p>已经造成浙江损失一百多亿了。</p>\n<p>周五晚已经是暴雨连连了，想着周末也铁定出不了门了就在超市备了两天的伙食，自己随便开开火得了。周六确实是下了一天的雨，挂了一天的风，到了周日台风过去后雨过天晴，一切又像是都没发生过一样，只有地上的落叶能说明一切。</p>\n<h2 id=\"无锡\"><a href=\"#无锡\" class=\"headerlink\" title=\"无锡\"></a>无锡</h2><p>无锡太湖试验厅项目需要测个索力数据，没人啊，派我过去了呗。无锡太湖一日游，也就在边角眺望了一会。</p>\n<p>跟同事晚上吃了个自助，喝了点小酒，本想着再去洗个脚按个摩，奈何吃饱喝足累得慌，还是回去早点休息吧。</p>\n<p>做的事越来越杂，好像已经开始脱离了最初进来时的职责。</p>\n<h2 id=\"周末\"><a href=\"#周末\" class=\"headerlink\" title=\"周末\"></a>周末</h2><p>现在有了个喜欢做饭的室友，周末比之前是好多了，对面就是超市买菜也方便。弄个一荤两素一汤，健康又实惠。不过这次周末有点奢侈，大荤大素的整了不少，室友还把“珍藏”的红酒给贡献了出来。说好的吃素，这整的，以后吃吃蔬菜就得了。</p>\n<p>身上的湿气重啊，房间里放的除湿袋不到一星期就积满了水，也可能跟我那朝北的小房间有关系，不过最近感觉全身都难受，站着不动都能往外出水来着。看看找个时间需要去拔个罐去去湿，出门在外要对自己好点。</p>\n<h2 id=\"压抑\"><a href=\"#压抑\" class=\"headerlink\" title=\"压抑\"></a>压抑</h2><p>不知道为什么，最近情绪不太高总觉得很压抑，胸闷有时候喘不过气来。</p>\n<p>很难受，周末就去找了同学一起聚一聚，也有好长时间没有聚过了，大家都多多少少有点压抑。</p>\n<p>胡吃海玩了之后回来还是不太好，我这是怎么了？凌晨两点的杭州夜景也治愈不了我。</p>\n<p>什么都没意思，好难受啊，何以解忧</p>\n","excerpt":"","more":"<blockquote>\n<p>稀里糊涂稀里糊涂啊</p>\n</blockquote>\n<p>狂风暴雨 阳光烈焰 雾雨蒙蒙</p>\n<hr>\n<h2 id=\"昆明\"><a href=\"#昆明\" class=\"headerlink\" title=\"昆明\"></a>昆明</h2><p>不出意外，跟同事一起又跑了趟昆明。没想到的是呆了七天，干了七天的活，出去耍的时间都没有，惨兮兮。</p>\n<p>呈贡大学城也确实偏了点，连市区都没得去，只能在附近随便吃点喝点。米粉确实是正宗还实惠，十三块钱吃得我啤酒肚了，可总不能天天搞米粉吃吧。</p>\n<p>阴凉地小风吹得，舒服极了，站在太阳直射下却不一会就晒得通红，热得要炸。</p>\n<p>从去的那天开始内火就开始旺啊，上次来也不见得体内火气这么大，还是天气太干燥了，不适应。</p>\n<p>水果都是按公斤计价的，买了点桃子芒果，便宜倒也不是很便宜，总之比上海还是要便宜点的，在上海都不舍得买水果吃。</p>\n<p>一直心心念念想要吃炸虫子，吃爆浆的那种，可是到走的那天也没能吃着，亏边上同事还是在昆明读过几年书的，真的一点不靠谱啊。后来去了家农家乐随便吃了点，大盘的菜，量大，当然相对昆明的物价来说也不能算便宜。</p>\n<p>虽说附近是大学城，可真也不巧，刚好暑假。校园里也都没几个人，看到的大多是对对小情侣，不禁感叹：大学生活好啊！</p>\n<p>地区会影响人的外貌习性，总的看来，个人还是较喜欢沿海的南方妹子，下次有机会去传说中的成都&#x2F;长沙养养眼，见识见识。</p>\n<p>唉，出差真的也是累得慌啊。</p>\n<h2 id=\"七夕\"><a href=\"#七夕\" class=\"headerlink\" title=\"七夕\"></a>七夕</h2><p>什么七不七的，那天半夜才在浦东下的飞机，热乎饭都没能吃上口。</p>\n<h2 id=\"台风利奇马\"><a href=\"#台风利奇马\" class=\"headerlink\" title=\"台风利奇马\"></a>台风利奇马</h2><p>这个台风是真的厉害了，刚好周末登陆各种预警，那天真是狂风催嫩叶啊。刚登陆温岭的时候风速巨大，陆地后强度减弱，听新闻说也有不少人遭难，天灾。</p>\n<p>已经造成浙江损失一百多亿了。</p>\n<p>周五晚已经是暴雨连连了，想着周末也铁定出不了门了就在超市备了两天的伙食，自己随便开开火得了。周六确实是下了一天的雨，挂了一天的风，到了周日台风过去后雨过天晴，一切又像是都没发生过一样，只有地上的落叶能说明一切。</p>\n<h2 id=\"无锡\"><a href=\"#无锡\" class=\"headerlink\" title=\"无锡\"></a>无锡</h2><p>无锡太湖试验厅项目需要测个索力数据，没人啊，派我过去了呗。无锡太湖一日游，也就在边角眺望了一会。</p>\n<p>跟同事晚上吃了个自助，喝了点小酒，本想着再去洗个脚按个摩，奈何吃饱喝足累得慌，还是回去早点休息吧。</p>\n<p>做的事越来越杂，好像已经开始脱离了最初进来时的职责。</p>\n<h2 id=\"周末\"><a href=\"#周末\" class=\"headerlink\" title=\"周末\"></a>周末</h2><p>现在有了个喜欢做饭的室友，周末比之前是好多了，对面就是超市买菜也方便。弄个一荤两素一汤，健康又实惠。不过这次周末有点奢侈，大荤大素的整了不少，室友还把“珍藏”的红酒给贡献了出来。说好的吃素，这整的，以后吃吃蔬菜就得了。</p>\n<p>身上的湿气重啊，房间里放的除湿袋不到一星期就积满了水，也可能跟我那朝北的小房间有关系，不过最近感觉全身都难受，站着不动都能往外出水来着。看看找个时间需要去拔个罐去去湿，出门在外要对自己好点。</p>\n<h2 id=\"压抑\"><a href=\"#压抑\" class=\"headerlink\" title=\"压抑\"></a>压抑</h2><p>不知道为什么，最近情绪不太高总觉得很压抑，胸闷有时候喘不过气来。</p>\n<p>很难受，周末就去找了同学一起聚一聚，也有好长时间没有聚过了，大家都多多少少有点压抑。</p>\n<p>胡吃海玩了之后回来还是不太好，我这是怎么了？凌晨两点的杭州夜景也治愈不了我。</p>\n<p>什么都没意思，好难受啊，何以解忧</p>\n"},{"title":"解封五月（2022）","date":"2022-06-01T13:10:55.000Z","_content":"\n> 居家办公两个多月，终于要去公司办公了。\n\n端午搬家累得够呛，一居室确实很得劲。\n\n提供 72 小时内的核酸证明就可以，希望这波就此能控制住了。估计之后要长时间两天做一次核酸了，还好小区内就有做核酸的站点。\n\n突然要去公司上班一下子也不是那么适应。\n\n相信生活会越来越好！","source":"_posts/free-may.md","raw":"---\ntitle: 解封五月（2022）\ndate: 2022-06-01 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 居家办公两个多月，终于要去公司办公了。\n\n端午搬家累得够呛，一居室确实很得劲。\n\n提供 72 小时内的核酸证明就可以，希望这波就此能控制住了。估计之后要长时间两天做一次核酸了，还好小区内就有做核酸的站点。\n\n突然要去公司上班一下子也不是那么适应。\n\n相信生活会越来越好！","slug":"free-may","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhe004ok9i10t0ta5ge","content":"<blockquote>\n<p>居家办公两个多月，终于要去公司办公了。</p>\n</blockquote>\n<p>端午搬家累得够呛，一居室确实很得劲。</p>\n<p>提供 72 小时内的核酸证明就可以，希望这波就此能控制住了。估计之后要长时间两天做一次核酸了，还好小区内就有做核酸的站点。</p>\n<p>突然要去公司上班一下子也不是那么适应。</p>\n<p>相信生活会越来越好！</p>\n","excerpt":"","more":"<blockquote>\n<p>居家办公两个多月，终于要去公司办公了。</p>\n</blockquote>\n<p>端午搬家累得够呛，一居室确实很得劲。</p>\n<p>提供 72 小时内的核酸证明就可以，希望这波就此能控制住了。估计之后要长时间两天做一次核酸了，还好小区内就有做核酸的站点。</p>\n<p>突然要去公司上班一下子也不是那么适应。</p>\n<p>相信生活会越来越好！</p>\n"},{"title":"果味八月（2023）","date":"2023-09-08T13:10:55.000Z","_content":"\n> 今年高温好像没怎么持续，来了好几次台风\n\n如题。今年虽说高温不持续，但是夏季水果倒是吃了不少。西瓜、葡萄、香瓜……特别是西瓜，一个接着一个根本没得停。\n\n日子来到了九月份，最近要忙的事情不得少，眼瞅着就要到年底了。 \n\nGood Luck For US!","source":"_posts/fruit-august.md","raw":"---\ntitle: 果味八月（2023）\ndate: 2023-09-08 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 今年高温好像没怎么持续，来了好几次台风\n\n如题。今年虽说高温不持续，但是夏季水果倒是吃了不少。西瓜、葡萄、香瓜……特别是西瓜，一个接着一个根本没得停。\n\n日子来到了九月份，最近要忙的事情不得少，眼瞅着就要到年底了。 \n\nGood Luck For US!","slug":"fruit-august","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf004rk9i18bu363v1","content":"<blockquote>\n<p>今年高温好像没怎么持续，来了好几次台风</p>\n</blockquote>\n<p>如题。今年虽说高温不持续，但是夏季水果倒是吃了不少。西瓜、葡萄、香瓜……特别是西瓜，一个接着一个根本没得停。</p>\n<p>日子来到了九月份，最近要忙的事情不得少，眼瞅着就要到年底了。 </p>\n<p>Good Luck For US!</p>\n","excerpt":"","more":"<blockquote>\n<p>今年高温好像没怎么持续，来了好几次台风</p>\n</blockquote>\n<p>如题。今年虽说高温不持续，但是夏季水果倒是吃了不少。西瓜、葡萄、香瓜……特别是西瓜，一个接着一个根本没得停。</p>\n<p>日子来到了九月份，最近要忙的事情不得少，眼瞅着就要到年底了。 </p>\n<p>Good Luck For US!</p>\n"},{"title":"金秋十月（2019）","date":"2019-10-28T02:00:51.000Z","_content":"\n> 又是一年收获季 你有所收获吗？\n\n已然桂花飘香。\n\n---\n\n## 国庆\n庆祝中华人民共和国成立 70 周年！\n\n不出意料，国庆回家被“批斗”了...然后天天食素养病，最后一日终吃上了老妈亲手做的红烧肉，真好吃。\n\n回家第二天就跟着我姐他们去婚纱店试了结婚当天所要穿的礼服，还给我定制了套西装，破费破费了。\n\n隔天还专门去了趟杭州买了双英伦风皮鞋，算是人生第一双小皮鞋了。\n\n在上海的时候天天早上闹钟响起，我还不愿起，一回家还没等闹钟发力，就睁着眼再也睡不着了。一年中算是较长的一个假期了，满打满算现在一年在家的日子也不足一个月，唯一心愿就是两老能身体健康，每日心情舒坦，不要过多为我们操劳费心。当然，只有我们自己强大了有能力了，他们才会放心。\n\n## 昆明\n没错，又是昆明。第三次去了，这次是验收，希望一切顺利，完美结束吧。\n\n网络调试没问题，设备也都能正常工作，可就还是不知道啥时候能验收，拖啊。\n\n周四下午浦东飞过去，落地刚好昆明下过雨，微微凉。\n\n第二天一大早开始干活，所幸还比较顺利，只是现在他们还没有给我们提供学校的 vpn。还好那边有网络，ssh 和 teamviewer 两条路都准备了。\n\n这回算是终于吃到了，前几次都是匆匆忙忙得弄完活就赶紧走了，如图。\n\n![昆明炸虫子](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/insect.jpg)\n\n太焦了有点，香是真挺香的。下次有机会去吃那种 **爆浆**的。\n\n第一次去那边是寒假，上回去是暑假，这回是好啊，好久没看到那么多一群群的女人了。\n\n这回去各大学校校区逛了下，还是云大的最厉害啊，里头各种古建筑和景点。旁边的翠湖海鸥还没飞来过冬，没能看到，着实可惜了些。\n\n同事同学请吃烧烤，一直弄到凌晨两点才回到宾馆，草草躺床上睡了。我特么还要六点起来去坐高铁。你问我为什么有飞机不坐去坐高铁，我脑子是被驴给踢了，十一个半小时啊，一路上还都是山洞隧道，美景呢？沿途的风景和看风景的心情啥子都没有！\n\n回到上海住处又是晚上十点多了，草草洗漱睡觉，第二天还得去上班呢。\n\n卧槽，想到突然出差去结果早早买好的直火帮《第二个酒吧》演唱会没能去还是伤心啊！\n\n---\n\n这个十月加班有点多过得有点快。室友安利《绝命毒师》感觉还不错。","source":"_posts/goldenautumn-october.md","raw":"---\ntitle: 金秋十月（2019）\ndate: 2019-10-28 10:00:51\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 又是一年收获季 你有所收获吗？\n\n已然桂花飘香。\n\n---\n\n## 国庆\n庆祝中华人民共和国成立 70 周年！\n\n不出意料，国庆回家被“批斗”了...然后天天食素养病，最后一日终吃上了老妈亲手做的红烧肉，真好吃。\n\n回家第二天就跟着我姐他们去婚纱店试了结婚当天所要穿的礼服，还给我定制了套西装，破费破费了。\n\n隔天还专门去了趟杭州买了双英伦风皮鞋，算是人生第一双小皮鞋了。\n\n在上海的时候天天早上闹钟响起，我还不愿起，一回家还没等闹钟发力，就睁着眼再也睡不着了。一年中算是较长的一个假期了，满打满算现在一年在家的日子也不足一个月，唯一心愿就是两老能身体健康，每日心情舒坦，不要过多为我们操劳费心。当然，只有我们自己强大了有能力了，他们才会放心。\n\n## 昆明\n没错，又是昆明。第三次去了，这次是验收，希望一切顺利，完美结束吧。\n\n网络调试没问题，设备也都能正常工作，可就还是不知道啥时候能验收，拖啊。\n\n周四下午浦东飞过去，落地刚好昆明下过雨，微微凉。\n\n第二天一大早开始干活，所幸还比较顺利，只是现在他们还没有给我们提供学校的 vpn。还好那边有网络，ssh 和 teamviewer 两条路都准备了。\n\n这回算是终于吃到了，前几次都是匆匆忙忙得弄完活就赶紧走了，如图。\n\n![昆明炸虫子](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/insect.jpg)\n\n太焦了有点，香是真挺香的。下次有机会去吃那种 **爆浆**的。\n\n第一次去那边是寒假，上回去是暑假，这回是好啊，好久没看到那么多一群群的女人了。\n\n这回去各大学校校区逛了下，还是云大的最厉害啊，里头各种古建筑和景点。旁边的翠湖海鸥还没飞来过冬，没能看到，着实可惜了些。\n\n同事同学请吃烧烤，一直弄到凌晨两点才回到宾馆，草草躺床上睡了。我特么还要六点起来去坐高铁。你问我为什么有飞机不坐去坐高铁，我脑子是被驴给踢了，十一个半小时啊，一路上还都是山洞隧道，美景呢？沿途的风景和看风景的心情啥子都没有！\n\n回到上海住处又是晚上十点多了，草草洗漱睡觉，第二天还得去上班呢。\n\n卧槽，想到突然出差去结果早早买好的直火帮《第二个酒吧》演唱会没能去还是伤心啊！\n\n---\n\n这个十月加班有点多过得有点快。室友安利《绝命毒师》感觉还不错。","slug":"goldenautumn-october","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf004wk9i14a1h8cn6","content":"<blockquote>\n<p>又是一年收获季 你有所收获吗？</p>\n</blockquote>\n<p>已然桂花飘香。</p>\n<hr>\n<h2 id=\"国庆\"><a href=\"#国庆\" class=\"headerlink\" title=\"国庆\"></a>国庆</h2><p>庆祝中华人民共和国成立 70 周年！</p>\n<p>不出意料，国庆回家被“批斗”了…然后天天食素养病，最后一日终吃上了老妈亲手做的红烧肉，真好吃。</p>\n<p>回家第二天就跟着我姐他们去婚纱店试了结婚当天所要穿的礼服，还给我定制了套西装，破费破费了。</p>\n<p>隔天还专门去了趟杭州买了双英伦风皮鞋，算是人生第一双小皮鞋了。</p>\n<p>在上海的时候天天早上闹钟响起，我还不愿起，一回家还没等闹钟发力，就睁着眼再也睡不着了。一年中算是较长的一个假期了，满打满算现在一年在家的日子也不足一个月，唯一心愿就是两老能身体健康，每日心情舒坦，不要过多为我们操劳费心。当然，只有我们自己强大了有能力了，他们才会放心。</p>\n<h2 id=\"昆明\"><a href=\"#昆明\" class=\"headerlink\" title=\"昆明\"></a>昆明</h2><p>没错，又是昆明。第三次去了，这次是验收，希望一切顺利，完美结束吧。</p>\n<p>网络调试没问题，设备也都能正常工作，可就还是不知道啥时候能验收，拖啊。</p>\n<p>周四下午浦东飞过去，落地刚好昆明下过雨，微微凉。</p>\n<p>第二天一大早开始干活，所幸还比较顺利，只是现在他们还没有给我们提供学校的 vpn。还好那边有网络，ssh 和 teamviewer 两条路都准备了。</p>\n<p>这回算是终于吃到了，前几次都是匆匆忙忙得弄完活就赶紧走了，如图。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/insect.jpg\" alt=\"昆明炸虫子\"></p>\n<p>太焦了有点，香是真挺香的。下次有机会去吃那种 <strong>爆浆</strong>的。</p>\n<p>第一次去那边是寒假，上回去是暑假，这回是好啊，好久没看到那么多一群群的女人了。</p>\n<p>这回去各大学校校区逛了下，还是云大的最厉害啊，里头各种古建筑和景点。旁边的翠湖海鸥还没飞来过冬，没能看到，着实可惜了些。</p>\n<p>同事同学请吃烧烤，一直弄到凌晨两点才回到宾馆，草草躺床上睡了。我特么还要六点起来去坐高铁。你问我为什么有飞机不坐去坐高铁，我脑子是被驴给踢了，十一个半小时啊，一路上还都是山洞隧道，美景呢？沿途的风景和看风景的心情啥子都没有！</p>\n<p>回到上海住处又是晚上十点多了，草草洗漱睡觉，第二天还得去上班呢。</p>\n<p>卧槽，想到突然出差去结果早早买好的直火帮《第二个酒吧》演唱会没能去还是伤心啊！</p>\n<hr>\n<p>这个十月加班有点多过得有点快。室友安利《绝命毒师》感觉还不错。</p>\n","excerpt":"","more":"<blockquote>\n<p>又是一年收获季 你有所收获吗？</p>\n</blockquote>\n<p>已然桂花飘香。</p>\n<hr>\n<h2 id=\"国庆\"><a href=\"#国庆\" class=\"headerlink\" title=\"国庆\"></a>国庆</h2><p>庆祝中华人民共和国成立 70 周年！</p>\n<p>不出意料，国庆回家被“批斗”了…然后天天食素养病，最后一日终吃上了老妈亲手做的红烧肉，真好吃。</p>\n<p>回家第二天就跟着我姐他们去婚纱店试了结婚当天所要穿的礼服，还给我定制了套西装，破费破费了。</p>\n<p>隔天还专门去了趟杭州买了双英伦风皮鞋，算是人生第一双小皮鞋了。</p>\n<p>在上海的时候天天早上闹钟响起，我还不愿起，一回家还没等闹钟发力，就睁着眼再也睡不着了。一年中算是较长的一个假期了，满打满算现在一年在家的日子也不足一个月，唯一心愿就是两老能身体健康，每日心情舒坦，不要过多为我们操劳费心。当然，只有我们自己强大了有能力了，他们才会放心。</p>\n<h2 id=\"昆明\"><a href=\"#昆明\" class=\"headerlink\" title=\"昆明\"></a>昆明</h2><p>没错，又是昆明。第三次去了，这次是验收，希望一切顺利，完美结束吧。</p>\n<p>网络调试没问题，设备也都能正常工作，可就还是不知道啥时候能验收，拖啊。</p>\n<p>周四下午浦东飞过去，落地刚好昆明下过雨，微微凉。</p>\n<p>第二天一大早开始干活，所幸还比较顺利，只是现在他们还没有给我们提供学校的 vpn。还好那边有网络，ssh 和 teamviewer 两条路都准备了。</p>\n<p>这回算是终于吃到了，前几次都是匆匆忙忙得弄完活就赶紧走了，如图。</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/insect.jpg\" alt=\"昆明炸虫子\"></p>\n<p>太焦了有点，香是真挺香的。下次有机会去吃那种 <strong>爆浆</strong>的。</p>\n<p>第一次去那边是寒假，上回去是暑假，这回是好啊，好久没看到那么多一群群的女人了。</p>\n<p>这回去各大学校校区逛了下，还是云大的最厉害啊，里头各种古建筑和景点。旁边的翠湖海鸥还没飞来过冬，没能看到，着实可惜了些。</p>\n<p>同事同学请吃烧烤，一直弄到凌晨两点才回到宾馆，草草躺床上睡了。我特么还要六点起来去坐高铁。你问我为什么有飞机不坐去坐高铁，我脑子是被驴给踢了，十一个半小时啊，一路上还都是山洞隧道，美景呢？沿途的风景和看风景的心情啥子都没有！</p>\n<p>回到上海住处又是晚上十点多了，草草洗漱睡觉，第二天还得去上班呢。</p>\n<p>卧槽，想到突然出差去结果早早买好的直火帮《第二个酒吧》演唱会没能去还是伤心啊！</p>\n<hr>\n<p>这个十月加班有点多过得有点快。室友安利《绝命毒师》感觉还不错。</p>\n"},{"title":"绿色十月（2022）","date":"2022-10-30T13:10:55.000Z","_content":"\n> 真的是绿啊，绿油油（说的不是头啊...）\n\n说起这个月，那真的是实惨。\n\n首先国庆节回家吧，疫情原因在义乌车站滞留了一晚上（真的是治理一塌糊涂，说好的政府来接人，等了一个晚上我丢）\n\n过完节回来然后就开启了账户缩水之旅……\n\n十月的工作日虽然没几个，但是每一天都会有什么重大事件。什么谁谁谁减持什么了，什么房地产要出什么了，这个月的波动估计跟某会也有一定关系吧，小散就任其摆布，咱们也没得什么其他办法啊。\n\n账户这个样子，但是生活还是要接着过的。\n\n最近也去看附近的房子了。\n\n去看了看曹路的房子，曹路现在基础设施还不是很成熟，再加上地处较偏，再加上出了地铁口就是个公墓，所以很多人多少会有点忌讳，不建议在曹路上车。不过曹路感觉也不是很具性价比，价格也是上去了，再加上边上没有什么好一点的学校，近几年是不会有什么大的发展了，不过价格相比于我现在住的唐镇这边还是友好不少的。思考再三，为了以后的娃考虑，还是跳过了曹路，将目光瞄向了川沙。\n\n川沙以前是个老镇，基础设施还是比较成熟的，就是房子都比较老旧了。很多小区的路也是很窄，两辆车要会个车估计都很难，单价也是比唐镇要好一点，不过比曹路肯定是要高的。川沙这边大型商场，医院，学校还都挺好，生活还是比较便捷的，如果还在附近上班的话确实是个不错的地方。也看了一些个小区，毕竟我们预算有限，还要考虑学区，虽然这边小区不少，但能选择的也是不多啊，而且我们还刚开始看，这买房这么大的事，可不能草率，还得且看啊。再说谁也不知道之后的政策咋样，是错失良机呢还是避免高位接盘，都是五五开。不过让我选择的话，我也是倾向于川沙的，价格能接受，生活也便捷，离上班公司也不算远。之后张江再发展得好的话也许还能进一步带动川沙，工作也可能就一直在张江附近就能有着落，那这样的话，川沙确实是个不错的选择。\n\n一般楼梯房都是6楼，而6楼也是换得最多的，毕竟天天这样上上下下的，自然是要累腿要酸的，最近也是6楼的房子看得最多。趁着置换的政策下来，大家有资本的纷纷想要进行置换，当然了，谁不想住得更好的呢。\n\n房真的是民之根本，对我们中国来说。虽然现在外面的环境这么不好，但是上海的房价还是没怎么下跌，稳如老狗啊。不过跟我一样在等着房价下来再想接盘的应该不在少数，这么大的盘子也不会让波动弄得太大，不过谁也不好说，还是政策引导。\n\n刚需，能上就上吧，尽其所能，自住也不用想太多，价如葱那是自然不可能的，最多也是由政府统一管控租赁，近几年是不指望了。\n\n不过话说到最后，当下我觉得还是换些有价值的股票回报来得最大。\n\n一点个人见解，不一定对。\n\n共勉。","source":"_posts/green-october.md","raw":"---\ntitle: 绿色十月（2022）\ndate: 2022-10-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 真的是绿啊，绿油油（说的不是头啊...）\n\n说起这个月，那真的是实惨。\n\n首先国庆节回家吧，疫情原因在义乌车站滞留了一晚上（真的是治理一塌糊涂，说好的政府来接人，等了一个晚上我丢）\n\n过完节回来然后就开启了账户缩水之旅……\n\n十月的工作日虽然没几个，但是每一天都会有什么重大事件。什么谁谁谁减持什么了，什么房地产要出什么了，这个月的波动估计跟某会也有一定关系吧，小散就任其摆布，咱们也没得什么其他办法啊。\n\n账户这个样子，但是生活还是要接着过的。\n\n最近也去看附近的房子了。\n\n去看了看曹路的房子，曹路现在基础设施还不是很成熟，再加上地处较偏，再加上出了地铁口就是个公墓，所以很多人多少会有点忌讳，不建议在曹路上车。不过曹路感觉也不是很具性价比，价格也是上去了，再加上边上没有什么好一点的学校，近几年是不会有什么大的发展了，不过价格相比于我现在住的唐镇这边还是友好不少的。思考再三，为了以后的娃考虑，还是跳过了曹路，将目光瞄向了川沙。\n\n川沙以前是个老镇，基础设施还是比较成熟的，就是房子都比较老旧了。很多小区的路也是很窄，两辆车要会个车估计都很难，单价也是比唐镇要好一点，不过比曹路肯定是要高的。川沙这边大型商场，医院，学校还都挺好，生活还是比较便捷的，如果还在附近上班的话确实是个不错的地方。也看了一些个小区，毕竟我们预算有限，还要考虑学区，虽然这边小区不少，但能选择的也是不多啊，而且我们还刚开始看，这买房这么大的事，可不能草率，还得且看啊。再说谁也不知道之后的政策咋样，是错失良机呢还是避免高位接盘，都是五五开。不过让我选择的话，我也是倾向于川沙的，价格能接受，生活也便捷，离上班公司也不算远。之后张江再发展得好的话也许还能进一步带动川沙，工作也可能就一直在张江附近就能有着落，那这样的话，川沙确实是个不错的选择。\n\n一般楼梯房都是6楼，而6楼也是换得最多的，毕竟天天这样上上下下的，自然是要累腿要酸的，最近也是6楼的房子看得最多。趁着置换的政策下来，大家有资本的纷纷想要进行置换，当然了，谁不想住得更好的呢。\n\n房真的是民之根本，对我们中国来说。虽然现在外面的环境这么不好，但是上海的房价还是没怎么下跌，稳如老狗啊。不过跟我一样在等着房价下来再想接盘的应该不在少数，这么大的盘子也不会让波动弄得太大，不过谁也不好说，还是政策引导。\n\n刚需，能上就上吧，尽其所能，自住也不用想太多，价如葱那是自然不可能的，最多也是由政府统一管控租赁，近几年是不指望了。\n\n不过话说到最后，当下我觉得还是换些有价值的股票回报来得最大。\n\n一点个人见解，不一定对。\n\n共勉。","slug":"green-october","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf004zk9i18njib511","content":"<blockquote>\n<p>真的是绿啊，绿油油（说的不是头啊…）</p>\n</blockquote>\n<p>说起这个月，那真的是实惨。</p>\n<p>首先国庆节回家吧，疫情原因在义乌车站滞留了一晚上（真的是治理一塌糊涂，说好的政府来接人，等了一个晚上我丢）</p>\n<p>过完节回来然后就开启了账户缩水之旅……</p>\n<p>十月的工作日虽然没几个，但是每一天都会有什么重大事件。什么谁谁谁减持什么了，什么房地产要出什么了，这个月的波动估计跟某会也有一定关系吧，小散就任其摆布，咱们也没得什么其他办法啊。</p>\n<p>账户这个样子，但是生活还是要接着过的。</p>\n<p>最近也去看附近的房子了。</p>\n<p>去看了看曹路的房子，曹路现在基础设施还不是很成熟，再加上地处较偏，再加上出了地铁口就是个公墓，所以很多人多少会有点忌讳，不建议在曹路上车。不过曹路感觉也不是很具性价比，价格也是上去了，再加上边上没有什么好一点的学校，近几年是不会有什么大的发展了，不过价格相比于我现在住的唐镇这边还是友好不少的。思考再三，为了以后的娃考虑，还是跳过了曹路，将目光瞄向了川沙。</p>\n<p>川沙以前是个老镇，基础设施还是比较成熟的，就是房子都比较老旧了。很多小区的路也是很窄，两辆车要会个车估计都很难，单价也是比唐镇要好一点，不过比曹路肯定是要高的。川沙这边大型商场，医院，学校还都挺好，生活还是比较便捷的，如果还在附近上班的话确实是个不错的地方。也看了一些个小区，毕竟我们预算有限，还要考虑学区，虽然这边小区不少，但能选择的也是不多啊，而且我们还刚开始看，这买房这么大的事，可不能草率，还得且看啊。再说谁也不知道之后的政策咋样，是错失良机呢还是避免高位接盘，都是五五开。不过让我选择的话，我也是倾向于川沙的，价格能接受，生活也便捷，离上班公司也不算远。之后张江再发展得好的话也许还能进一步带动川沙，工作也可能就一直在张江附近就能有着落，那这样的话，川沙确实是个不错的选择。</p>\n<p>一般楼梯房都是6楼，而6楼也是换得最多的，毕竟天天这样上上下下的，自然是要累腿要酸的，最近也是6楼的房子看得最多。趁着置换的政策下来，大家有资本的纷纷想要进行置换，当然了，谁不想住得更好的呢。</p>\n<p>房真的是民之根本，对我们中国来说。虽然现在外面的环境这么不好，但是上海的房价还是没怎么下跌，稳如老狗啊。不过跟我一样在等着房价下来再想接盘的应该不在少数，这么大的盘子也不会让波动弄得太大，不过谁也不好说，还是政策引导。</p>\n<p>刚需，能上就上吧，尽其所能，自住也不用想太多，价如葱那是自然不可能的，最多也是由政府统一管控租赁，近几年是不指望了。</p>\n<p>不过话说到最后，当下我觉得还是换些有价值的股票回报来得最大。</p>\n<p>一点个人见解，不一定对。</p>\n<p>共勉。</p>\n","excerpt":"","more":"<blockquote>\n<p>真的是绿啊，绿油油（说的不是头啊…）</p>\n</blockquote>\n<p>说起这个月，那真的是实惨。</p>\n<p>首先国庆节回家吧，疫情原因在义乌车站滞留了一晚上（真的是治理一塌糊涂，说好的政府来接人，等了一个晚上我丢）</p>\n<p>过完节回来然后就开启了账户缩水之旅……</p>\n<p>十月的工作日虽然没几个，但是每一天都会有什么重大事件。什么谁谁谁减持什么了，什么房地产要出什么了，这个月的波动估计跟某会也有一定关系吧，小散就任其摆布，咱们也没得什么其他办法啊。</p>\n<p>账户这个样子，但是生活还是要接着过的。</p>\n<p>最近也去看附近的房子了。</p>\n<p>去看了看曹路的房子，曹路现在基础设施还不是很成熟，再加上地处较偏，再加上出了地铁口就是个公墓，所以很多人多少会有点忌讳，不建议在曹路上车。不过曹路感觉也不是很具性价比，价格也是上去了，再加上边上没有什么好一点的学校，近几年是不会有什么大的发展了，不过价格相比于我现在住的唐镇这边还是友好不少的。思考再三，为了以后的娃考虑，还是跳过了曹路，将目光瞄向了川沙。</p>\n<p>川沙以前是个老镇，基础设施还是比较成熟的，就是房子都比较老旧了。很多小区的路也是很窄，两辆车要会个车估计都很难，单价也是比唐镇要好一点，不过比曹路肯定是要高的。川沙这边大型商场，医院，学校还都挺好，生活还是比较便捷的，如果还在附近上班的话确实是个不错的地方。也看了一些个小区，毕竟我们预算有限，还要考虑学区，虽然这边小区不少，但能选择的也是不多啊，而且我们还刚开始看，这买房这么大的事，可不能草率，还得且看啊。再说谁也不知道之后的政策咋样，是错失良机呢还是避免高位接盘，都是五五开。不过让我选择的话，我也是倾向于川沙的，价格能接受，生活也便捷，离上班公司也不算远。之后张江再发展得好的话也许还能进一步带动川沙，工作也可能就一直在张江附近就能有着落，那这样的话，川沙确实是个不错的选择。</p>\n<p>一般楼梯房都是6楼，而6楼也是换得最多的，毕竟天天这样上上下下的，自然是要累腿要酸的，最近也是6楼的房子看得最多。趁着置换的政策下来，大家有资本的纷纷想要进行置换，当然了，谁不想住得更好的呢。</p>\n<p>房真的是民之根本，对我们中国来说。虽然现在外面的环境这么不好，但是上海的房价还是没怎么下跌，稳如老狗啊。不过跟我一样在等着房价下来再想接盘的应该不在少数，这么大的盘子也不会让波动弄得太大，不过谁也不好说，还是政策引导。</p>\n<p>刚需，能上就上吧，尽其所能，自住也不用想太多，价如葱那是自然不可能的，最多也是由政府统一管控租赁，近几年是不指望了。</p>\n<p>不过话说到最后，当下我觉得还是换些有价值的股票回报来得最大。</p>\n<p>一点个人见解，不一定对。</p>\n<p>共勉。</p>\n"},{"title":"愉快五月（2019）","date":"2019-05-23T03:07:30.000Z","_content":"\n> 这个五月过得是真的快啊~\n\n五一回家在家呆了三天，跟父母老姐和姐夫（已订婚）去了趟老家县城附近的自建的一个玻璃栈道景点。过年期间就在朋友圈看到刷屏了，这次趁着空一起去逛了逛。老家小县城本就四面环山，景色相当不错，也有几个国家 4A 级景点，什么仙华山、神丽峡、江南第一家啊……\n\n我老爸恐高啊，我也有点。全程在桥上老爸搭着老妈的肩膀小心翼翼地走在玻璃桥的边缘，事后一直被老妈嘲笑，家里也是很少有这样的机会一家人一起出去玩玩，我很喜欢一家人在一起的感觉。\n\n一定要多跟他们在一起！\n\n---\n\n五一回来上班一周，又出去耍了！公司旅游投票菲律宾和塞班岛，结果毫无疑问，塞班岛走起~大晚上的飞机四个半小时凌晨飞到那边，一下飞机热浪扑面而来，弄弄行李到达酒店，天就亮了，太快了吧。\n\n进房间洗洗躺下，大太阳就刺进来了，朝东的房间，太丫的亮了。结果躺了起，起了躺，后来终于睡着了，本来是十点钟门口集合导游大巴带我们去景点逛，这一睡也太舒服了，空调打得低。微信群里无人反馈（睡死了都），随着同事破门而入，一阵慌乱中奔向大巴。\n\n岛不大，逛逛一圈也用不了多久。\n\n景色是真的不错，碧海蓝天白云。\n\n（拍了不少帅比照，哈哈）\n\n就是太阳毒了点，回来黑了不少，后背轻微脱皮。本想晒成古天乐的，差点晒了个熊猫眼，下次再晒。在海边一点腥味都没闻到，在这样的海边上住着才是真的享受啊。\n\n不得不说，在老美的地盘花着美金消费就是高，资金不允许啊就没怎么玩多少项目，不过也是体验了拖伞和浮潜。大头都留在那边的赌场了……\n\n逛了一圈那边的礼品店，乍一眼都是从中国的地摊上运过来的，本地也没什么特色，我也就没买东西，哈哈（反正买了也没人送）\n\n玩着耍着，六天五晚的旅程就结束了，要回来上班咯。\n\n再上两三个星期就端午了，再之后就只有到中秋国庆了，能回家还是要回家的啊。\n\n---\n\n刚从塞班岛回来就又去了临港出差，开了个房还没走进去就听到老大声的“老公老公，啊啊啊嗯……”，真特么刺激，真好。\n\n晚上就在他们的欢声笑语中入睡。\n\n---\n\n生活都不易，且活且珍惜。\n\n做最好的自己。","source":"_posts/happy-may.md","raw":"---\ntitle: 愉快五月（2019）\ndate: 2019-5-23 11:07:30\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个五月过得是真的快啊~\n\n五一回家在家呆了三天，跟父母老姐和姐夫（已订婚）去了趟老家县城附近的自建的一个玻璃栈道景点。过年期间就在朋友圈看到刷屏了，这次趁着空一起去逛了逛。老家小县城本就四面环山，景色相当不错，也有几个国家 4A 级景点，什么仙华山、神丽峡、江南第一家啊……\n\n我老爸恐高啊，我也有点。全程在桥上老爸搭着老妈的肩膀小心翼翼地走在玻璃桥的边缘，事后一直被老妈嘲笑，家里也是很少有这样的机会一家人一起出去玩玩，我很喜欢一家人在一起的感觉。\n\n一定要多跟他们在一起！\n\n---\n\n五一回来上班一周，又出去耍了！公司旅游投票菲律宾和塞班岛，结果毫无疑问，塞班岛走起~大晚上的飞机四个半小时凌晨飞到那边，一下飞机热浪扑面而来，弄弄行李到达酒店，天就亮了，太快了吧。\n\n进房间洗洗躺下，大太阳就刺进来了，朝东的房间，太丫的亮了。结果躺了起，起了躺，后来终于睡着了，本来是十点钟门口集合导游大巴带我们去景点逛，这一睡也太舒服了，空调打得低。微信群里无人反馈（睡死了都），随着同事破门而入，一阵慌乱中奔向大巴。\n\n岛不大，逛逛一圈也用不了多久。\n\n景色是真的不错，碧海蓝天白云。\n\n（拍了不少帅比照，哈哈）\n\n就是太阳毒了点，回来黑了不少，后背轻微脱皮。本想晒成古天乐的，差点晒了个熊猫眼，下次再晒。在海边一点腥味都没闻到，在这样的海边上住着才是真的享受啊。\n\n不得不说，在老美的地盘花着美金消费就是高，资金不允许啊就没怎么玩多少项目，不过也是体验了拖伞和浮潜。大头都留在那边的赌场了……\n\n逛了一圈那边的礼品店，乍一眼都是从中国的地摊上运过来的，本地也没什么特色，我也就没买东西，哈哈（反正买了也没人送）\n\n玩着耍着，六天五晚的旅程就结束了，要回来上班咯。\n\n再上两三个星期就端午了，再之后就只有到中秋国庆了，能回家还是要回家的啊。\n\n---\n\n刚从塞班岛回来就又去了临港出差，开了个房还没走进去就听到老大声的“老公老公，啊啊啊嗯……”，真特么刺激，真好。\n\n晚上就在他们的欢声笑语中入睡。\n\n---\n\n生活都不易，且活且珍惜。\n\n做最好的自己。","slug":"happy-may","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf0054k9i1eyzkal7a","content":"<blockquote>\n<p>这个五月过得是真的快啊~</p>\n</blockquote>\n<p>五一回家在家呆了三天，跟父母老姐和姐夫（已订婚）去了趟老家县城附近的自建的一个玻璃栈道景点。过年期间就在朋友圈看到刷屏了，这次趁着空一起去逛了逛。老家小县城本就四面环山，景色相当不错，也有几个国家 4A 级景点，什么仙华山、神丽峡、江南第一家啊……</p>\n<p>我老爸恐高啊，我也有点。全程在桥上老爸搭着老妈的肩膀小心翼翼地走在玻璃桥的边缘，事后一直被老妈嘲笑，家里也是很少有这样的机会一家人一起出去玩玩，我很喜欢一家人在一起的感觉。</p>\n<p>一定要多跟他们在一起！</p>\n<hr>\n<p>五一回来上班一周，又出去耍了！公司旅游投票菲律宾和塞班岛，结果毫无疑问，塞班岛走起~大晚上的飞机四个半小时凌晨飞到那边，一下飞机热浪扑面而来，弄弄行李到达酒店，天就亮了，太快了吧。</p>\n<p>进房间洗洗躺下，大太阳就刺进来了，朝东的房间，太丫的亮了。结果躺了起，起了躺，后来终于睡着了，本来是十点钟门口集合导游大巴带我们去景点逛，这一睡也太舒服了，空调打得低。微信群里无人反馈（睡死了都），随着同事破门而入，一阵慌乱中奔向大巴。</p>\n<p>岛不大，逛逛一圈也用不了多久。</p>\n<p>景色是真的不错，碧海蓝天白云。</p>\n<p>（拍了不少帅比照，哈哈）</p>\n<p>就是太阳毒了点，回来黑了不少，后背轻微脱皮。本想晒成古天乐的，差点晒了个熊猫眼，下次再晒。在海边一点腥味都没闻到，在这样的海边上住着才是真的享受啊。</p>\n<p>不得不说，在老美的地盘花着美金消费就是高，资金不允许啊就没怎么玩多少项目，不过也是体验了拖伞和浮潜。大头都留在那边的赌场了……</p>\n<p>逛了一圈那边的礼品店，乍一眼都是从中国的地摊上运过来的，本地也没什么特色，我也就没买东西，哈哈（反正买了也没人送）</p>\n<p>玩着耍着，六天五晚的旅程就结束了，要回来上班咯。</p>\n<p>再上两三个星期就端午了，再之后就只有到中秋国庆了，能回家还是要回家的啊。</p>\n<hr>\n<p>刚从塞班岛回来就又去了临港出差，开了个房还没走进去就听到老大声的“老公老公，啊啊啊嗯……”，真特么刺激，真好。</p>\n<p>晚上就在他们的欢声笑语中入睡。</p>\n<hr>\n<p>生活都不易，且活且珍惜。</p>\n<p>做最好的自己。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个五月过得是真的快啊~</p>\n</blockquote>\n<p>五一回家在家呆了三天，跟父母老姐和姐夫（已订婚）去了趟老家县城附近的自建的一个玻璃栈道景点。过年期间就在朋友圈看到刷屏了，这次趁着空一起去逛了逛。老家小县城本就四面环山，景色相当不错，也有几个国家 4A 级景点，什么仙华山、神丽峡、江南第一家啊……</p>\n<p>我老爸恐高啊，我也有点。全程在桥上老爸搭着老妈的肩膀小心翼翼地走在玻璃桥的边缘，事后一直被老妈嘲笑，家里也是很少有这样的机会一家人一起出去玩玩，我很喜欢一家人在一起的感觉。</p>\n<p>一定要多跟他们在一起！</p>\n<hr>\n<p>五一回来上班一周，又出去耍了！公司旅游投票菲律宾和塞班岛，结果毫无疑问，塞班岛走起~大晚上的飞机四个半小时凌晨飞到那边，一下飞机热浪扑面而来，弄弄行李到达酒店，天就亮了，太快了吧。</p>\n<p>进房间洗洗躺下，大太阳就刺进来了，朝东的房间，太丫的亮了。结果躺了起，起了躺，后来终于睡着了，本来是十点钟门口集合导游大巴带我们去景点逛，这一睡也太舒服了，空调打得低。微信群里无人反馈（睡死了都），随着同事破门而入，一阵慌乱中奔向大巴。</p>\n<p>岛不大，逛逛一圈也用不了多久。</p>\n<p>景色是真的不错，碧海蓝天白云。</p>\n<p>（拍了不少帅比照，哈哈）</p>\n<p>就是太阳毒了点，回来黑了不少，后背轻微脱皮。本想晒成古天乐的，差点晒了个熊猫眼，下次再晒。在海边一点腥味都没闻到，在这样的海边上住着才是真的享受啊。</p>\n<p>不得不说，在老美的地盘花着美金消费就是高，资金不允许啊就没怎么玩多少项目，不过也是体验了拖伞和浮潜。大头都留在那边的赌场了……</p>\n<p>逛了一圈那边的礼品店，乍一眼都是从中国的地摊上运过来的，本地也没什么特色，我也就没买东西，哈哈（反正买了也没人送）</p>\n<p>玩着耍着，六天五晚的旅程就结束了，要回来上班咯。</p>\n<p>再上两三个星期就端午了，再之后就只有到中秋国庆了，能回家还是要回家的啊。</p>\n<hr>\n<p>刚从塞班岛回来就又去了临港出差，开了个房还没走进去就听到老大声的“老公老公，啊啊啊嗯……”，真特么刺激，真好。</p>\n<p>晚上就在他们的欢声笑语中入睡。</p>\n<hr>\n<p>生活都不易，且活且珍惜。</p>\n<p>做最好的自己。</p>\n"},{"title":"你好，依旧","date":"2018-12-18T03:51:59.000Z","_content":"# 你好，依旧 此篇作为对 2018 的整年回顾\n\n尾巴，走了；你好，依旧。\n\n2018 的尾巴已经来到，也是到了时候该让她的尾巴跟头部围成一个圈圈了。\n\n2018，看过几场电影，吃过几场温馨的饭，睡过几场懒觉，看过几次凌晨的星空。\n\n2018，分过一次手，游过几次怪味的泳，红过几次眼，回过不超五次的家。\n\n2018，我重新拾起了运动，不为别的，只为自己能够多活两年。\n\n2018，我重新调整了饮食，却始终调不过来作息。\n\n2018，我看了好多书，有科幻代表《三体》，有经典散文集《自在独行》，有轻描淡写一生历程的《浮生六记》，也有极具讽刺的《兄弟》等等。当然，专业书籍也不能拉下。我自知是个爱书之人，我爱看书与爱看电影是一回事，都是喜欢故事，喜欢在这些源于生活中而来的作品之间，有所感悟，体会情愫。我想，这与我善于思考，善于总结，有些许相关吧。最近在看《城南旧事》。\n\n今年 3 月，我换了份工作，因此也搬了个新的住处。很幸运，两位室友人很不错，还都是个硕士生，与优秀的人一同来往，谁人不喜欢呢？期间我还买了个方形玻璃缸，作为我那鳄龟的新住处（去年 8 月份买的两只苗子，现在只剩一只，长得倍儿快！有时间我可再另开一篇来专门絮叨絮叨）。后觉着这么个大缸就供着个龟大爷，浪费至极。于是我之后又陆陆续续往里丢过虾（包含着龙虾）、泥鳅，可几日后往往就不见其踪影，只有可怜的残骸在水中无目的晃荡。我不甘心，10 月份左右又进购了一批草金苗，大约五六十只。直到今日，12 月中旬，还剩下 7 只幸运儿，不知是否因为这气温影响了龟爷，还是幸运儿的过人闪躲之处，或是他们惺惺相惜，已成为了朋友？我不得知，我只知三天两头给它喂食鸡肉，应该是饿不着它的吧。话说幸运儿草金们，其中有两三条我甚是得意，身上条纹十分漂亮，尾巴又大又长，要是最终也遭遇不幸，我怕是会难过会后悔吧。可是，住所实在是小，我还能做些什么呢？我喜欢各种宠物，本想养猫养狗，一想处境，我便立刻就会打消这种不实际的念头，这也是我选择养龟的原因吧。\n\n由于换了份工作，该司并非互联网公司，工作强度自然也没有那么大。也正是因为如此，我有了更多的时间能做我自己喜欢做的事情，就比如看书，跑步。独处的日子，看书是最好的项目了。晚上我也有了时间自己随意煮煮蔬菜，煮煮鸡胸，煮煮面条，健康又便宜，因此还与菜场的大爷变得熟知。虽然这种生活长期也不错，但是我是知道的，我是不愿意的。在这段时间里，我有了时间可以巩固基础，有了时间可以学习其他的东西，有了时间可以将之前未完全消化的东西一一吸干。我并没忘给自己充电，虽然也看了不少非专业书籍，但是那也是必要的，那些充实了我的灵魂，渐渐造就了我的气质，每每读完一本书我都有所收获。厚积而薄发，我一直在等待它的到来！\n\n我在以前的随记中写过：**时间往往在你回顾的时候，才会觉得过得好快。**我也写过：**原来我早已习惯了孤独，只是在孤独的岁月之中穿插了一段不那么孤独的时光，使我暂忘孤独。**一个人的时候，往往会思考更多。虽说人类是群居动物，但是现在正慢慢走向独居世界，与外界网络相连即可。人们经常会畅想未来，畅想未来会变得多么科幻多么神奇多么智能，无可厚非，因为过去几年我们确实是发展可谓“神速”。但是我在想，过去是因为西方的互联网本就比中国发展要快，所以中国可以借鉴西方来避坑，从而快速发展。而如今，中国互联网已是首屈一指，无从可借鉴，只能我们自己一步一脚印来创新推进。畅想固然是好，人们也都想时代发展越快越好，可是我个人觉得还是不能太过于“妄想”，没必要过于急躁，就怕大家都在畅想美好未来的时候，天突然就塌了。当然，这也是我个人想法，**磨刀不误砍柴工**，美好生活人人都想，前提还是应脚踏实地。\n\n也是在今年，租了服务器，重新注册了域名，搭建了自己的个人博客，开始了持续的记录总结。简书却是我最近才注册的，不为别的，我只想把一些生活感悟、牢骚，在这记录，也只会记录这些。从今年开始，每月我在自己博客都会写上一篇月结记录，初衷是为了让自己觉得过得不会那么虚空，同样更重要的是为了记录我的岁月。为了这些宝贵资料不丢失，我也做了备份。曾经，年少气盛的我丢失过许多美好记忆的书信，使得现在我都后悔不已，这些都是属于我们独一无二的财富。**生活无远虑，只有近忧。**不管如何，我们都要学会记录生活，也许也许，终有一日我也会有个幸福的家庭，子孙后辈也会静静坐在身边听一个糟老头子讲述他的过往。\n\n犹记得去年 12 月底与朋友们欢聚苏州，共游园林。今年怕是没有机会了，前几日刚好去杭州出差，两位好友在杭州做事，便约出来一同吃了顿饭。这顿饭，我们吃了半小时，等了却将近两小时。那几日刚好是今年雪下得最大的日子，又正值周末，饭点，想想也难免。吃完后各自回府，下了地铁我本想打车，无奈道路积雪严重，天气恶劣。于是在等了十几分钟出租车后，我撑着小黑伞，踩着雪地，走了两三公里回到了宾馆，小黑伞已早成了小白伞了。距离毕业已过去了一年有余，大家身上也都多了一丝成熟稳重，几日前我还翻了下毕业相册，嗯，变化大倒是不大，就是头发好像都少了一些！\n\n2018，我放慢了工作节奏，给了自己更多的时间去回顾，去务实基础，**博观约取，厚积薄发**！\n\n2018，我同时也加强了锻炼，没有一个好身体将来又怎么能够撑得起一番事业！\n\n2018，是积累的一年，寒冬虽冷，却总有见到明媚一天的啊！\n\n你好，19！","source":"_posts/hello-2019.md","raw":"---\ntitle: 你好，依旧\ndate: 2018-12-18 11:51:59\ncategories: [生活,杂侃]\ntags: []\n---\n# 你好，依旧 此篇作为对 2018 的整年回顾\n\n尾巴，走了；你好，依旧。\n\n2018 的尾巴已经来到，也是到了时候该让她的尾巴跟头部围成一个圈圈了。\n\n2018，看过几场电影，吃过几场温馨的饭，睡过几场懒觉，看过几次凌晨的星空。\n\n2018，分过一次手，游过几次怪味的泳，红过几次眼，回过不超五次的家。\n\n2018，我重新拾起了运动，不为别的，只为自己能够多活两年。\n\n2018，我重新调整了饮食，却始终调不过来作息。\n\n2018，我看了好多书，有科幻代表《三体》，有经典散文集《自在独行》，有轻描淡写一生历程的《浮生六记》，也有极具讽刺的《兄弟》等等。当然，专业书籍也不能拉下。我自知是个爱书之人，我爱看书与爱看电影是一回事，都是喜欢故事，喜欢在这些源于生活中而来的作品之间，有所感悟，体会情愫。我想，这与我善于思考，善于总结，有些许相关吧。最近在看《城南旧事》。\n\n今年 3 月，我换了份工作，因此也搬了个新的住处。很幸运，两位室友人很不错，还都是个硕士生，与优秀的人一同来往，谁人不喜欢呢？期间我还买了个方形玻璃缸，作为我那鳄龟的新住处（去年 8 月份买的两只苗子，现在只剩一只，长得倍儿快！有时间我可再另开一篇来专门絮叨絮叨）。后觉着这么个大缸就供着个龟大爷，浪费至极。于是我之后又陆陆续续往里丢过虾（包含着龙虾）、泥鳅，可几日后往往就不见其踪影，只有可怜的残骸在水中无目的晃荡。我不甘心，10 月份左右又进购了一批草金苗，大约五六十只。直到今日，12 月中旬，还剩下 7 只幸运儿，不知是否因为这气温影响了龟爷，还是幸运儿的过人闪躲之处，或是他们惺惺相惜，已成为了朋友？我不得知，我只知三天两头给它喂食鸡肉，应该是饿不着它的吧。话说幸运儿草金们，其中有两三条我甚是得意，身上条纹十分漂亮，尾巴又大又长，要是最终也遭遇不幸，我怕是会难过会后悔吧。可是，住所实在是小，我还能做些什么呢？我喜欢各种宠物，本想养猫养狗，一想处境，我便立刻就会打消这种不实际的念头，这也是我选择养龟的原因吧。\n\n由于换了份工作，该司并非互联网公司，工作强度自然也没有那么大。也正是因为如此，我有了更多的时间能做我自己喜欢做的事情，就比如看书，跑步。独处的日子，看书是最好的项目了。晚上我也有了时间自己随意煮煮蔬菜，煮煮鸡胸，煮煮面条，健康又便宜，因此还与菜场的大爷变得熟知。虽然这种生活长期也不错，但是我是知道的，我是不愿意的。在这段时间里，我有了时间可以巩固基础，有了时间可以学习其他的东西，有了时间可以将之前未完全消化的东西一一吸干。我并没忘给自己充电，虽然也看了不少非专业书籍，但是那也是必要的，那些充实了我的灵魂，渐渐造就了我的气质，每每读完一本书我都有所收获。厚积而薄发，我一直在等待它的到来！\n\n我在以前的随记中写过：**时间往往在你回顾的时候，才会觉得过得好快。**我也写过：**原来我早已习惯了孤独，只是在孤独的岁月之中穿插了一段不那么孤独的时光，使我暂忘孤独。**一个人的时候，往往会思考更多。虽说人类是群居动物，但是现在正慢慢走向独居世界，与外界网络相连即可。人们经常会畅想未来，畅想未来会变得多么科幻多么神奇多么智能，无可厚非，因为过去几年我们确实是发展可谓“神速”。但是我在想，过去是因为西方的互联网本就比中国发展要快，所以中国可以借鉴西方来避坑，从而快速发展。而如今，中国互联网已是首屈一指，无从可借鉴，只能我们自己一步一脚印来创新推进。畅想固然是好，人们也都想时代发展越快越好，可是我个人觉得还是不能太过于“妄想”，没必要过于急躁，就怕大家都在畅想美好未来的时候，天突然就塌了。当然，这也是我个人想法，**磨刀不误砍柴工**，美好生活人人都想，前提还是应脚踏实地。\n\n也是在今年，租了服务器，重新注册了域名，搭建了自己的个人博客，开始了持续的记录总结。简书却是我最近才注册的，不为别的，我只想把一些生活感悟、牢骚，在这记录，也只会记录这些。从今年开始，每月我在自己博客都会写上一篇月结记录，初衷是为了让自己觉得过得不会那么虚空，同样更重要的是为了记录我的岁月。为了这些宝贵资料不丢失，我也做了备份。曾经，年少气盛的我丢失过许多美好记忆的书信，使得现在我都后悔不已，这些都是属于我们独一无二的财富。**生活无远虑，只有近忧。**不管如何，我们都要学会记录生活，也许也许，终有一日我也会有个幸福的家庭，子孙后辈也会静静坐在身边听一个糟老头子讲述他的过往。\n\n犹记得去年 12 月底与朋友们欢聚苏州，共游园林。今年怕是没有机会了，前几日刚好去杭州出差，两位好友在杭州做事，便约出来一同吃了顿饭。这顿饭，我们吃了半小时，等了却将近两小时。那几日刚好是今年雪下得最大的日子，又正值周末，饭点，想想也难免。吃完后各自回府，下了地铁我本想打车，无奈道路积雪严重，天气恶劣。于是在等了十几分钟出租车后，我撑着小黑伞，踩着雪地，走了两三公里回到了宾馆，小黑伞已早成了小白伞了。距离毕业已过去了一年有余，大家身上也都多了一丝成熟稳重，几日前我还翻了下毕业相册，嗯，变化大倒是不大，就是头发好像都少了一些！\n\n2018，我放慢了工作节奏，给了自己更多的时间去回顾，去务实基础，**博观约取，厚积薄发**！\n\n2018，我同时也加强了锻炼，没有一个好身体将来又怎么能够撑得起一番事业！\n\n2018，是积累的一年，寒冬虽冷，却总有见到明媚一天的啊！\n\n你好，19！","slug":"hello-2019","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf0057k9i1gi380im2","content":"<h1 id=\"你好，依旧-此篇作为对-2018-的整年回顾\"><a href=\"#你好，依旧-此篇作为对-2018-的整年回顾\" class=\"headerlink\" title=\"你好，依旧 此篇作为对 2018 的整年回顾\"></a>你好，依旧 此篇作为对 2018 的整年回顾</h1><p>尾巴，走了；你好，依旧。</p>\n<p>2018 的尾巴已经来到，也是到了时候该让她的尾巴跟头部围成一个圈圈了。</p>\n<p>2018，看过几场电影，吃过几场温馨的饭，睡过几场懒觉，看过几次凌晨的星空。</p>\n<p>2018，分过一次手，游过几次怪味的泳，红过几次眼，回过不超五次的家。</p>\n<p>2018，我重新拾起了运动，不为别的，只为自己能够多活两年。</p>\n<p>2018，我重新调整了饮食，却始终调不过来作息。</p>\n<p>2018，我看了好多书，有科幻代表《三体》，有经典散文集《自在独行》，有轻描淡写一生历程的《浮生六记》，也有极具讽刺的《兄弟》等等。当然，专业书籍也不能拉下。我自知是个爱书之人，我爱看书与爱看电影是一回事，都是喜欢故事，喜欢在这些源于生活中而来的作品之间，有所感悟，体会情愫。我想，这与我善于思考，善于总结，有些许相关吧。最近在看《城南旧事》。</p>\n<p>今年 3 月，我换了份工作，因此也搬了个新的住处。很幸运，两位室友人很不错，还都是个硕士生，与优秀的人一同来往，谁人不喜欢呢？期间我还买了个方形玻璃缸，作为我那鳄龟的新住处（去年 8 月份买的两只苗子，现在只剩一只，长得倍儿快！有时间我可再另开一篇来专门絮叨絮叨）。后觉着这么个大缸就供着个龟大爷，浪费至极。于是我之后又陆陆续续往里丢过虾（包含着龙虾）、泥鳅，可几日后往往就不见其踪影，只有可怜的残骸在水中无目的晃荡。我不甘心，10 月份左右又进购了一批草金苗，大约五六十只。直到今日，12 月中旬，还剩下 7 只幸运儿，不知是否因为这气温影响了龟爷，还是幸运儿的过人闪躲之处，或是他们惺惺相惜，已成为了朋友？我不得知，我只知三天两头给它喂食鸡肉，应该是饿不着它的吧。话说幸运儿草金们，其中有两三条我甚是得意，身上条纹十分漂亮，尾巴又大又长，要是最终也遭遇不幸，我怕是会难过会后悔吧。可是，住所实在是小，我还能做些什么呢？我喜欢各种宠物，本想养猫养狗，一想处境，我便立刻就会打消这种不实际的念头，这也是我选择养龟的原因吧。</p>\n<p>由于换了份工作，该司并非互联网公司，工作强度自然也没有那么大。也正是因为如此，我有了更多的时间能做我自己喜欢做的事情，就比如看书，跑步。独处的日子，看书是最好的项目了。晚上我也有了时间自己随意煮煮蔬菜，煮煮鸡胸，煮煮面条，健康又便宜，因此还与菜场的大爷变得熟知。虽然这种生活长期也不错，但是我是知道的，我是不愿意的。在这段时间里，我有了时间可以巩固基础，有了时间可以学习其他的东西，有了时间可以将之前未完全消化的东西一一吸干。我并没忘给自己充电，虽然也看了不少非专业书籍，但是那也是必要的，那些充实了我的灵魂，渐渐造就了我的气质，每每读完一本书我都有所收获。厚积而薄发，我一直在等待它的到来！</p>\n<p>我在以前的随记中写过：<strong>时间往往在你回顾的时候，才会觉得过得好快。</strong>我也写过：<strong>原来我早已习惯了孤独，只是在孤独的岁月之中穿插了一段不那么孤独的时光，使我暂忘孤独。</strong>一个人的时候，往往会思考更多。虽说人类是群居动物，但是现在正慢慢走向独居世界，与外界网络相连即可。人们经常会畅想未来，畅想未来会变得多么科幻多么神奇多么智能，无可厚非，因为过去几年我们确实是发展可谓“神速”。但是我在想，过去是因为西方的互联网本就比中国发展要快，所以中国可以借鉴西方来避坑，从而快速发展。而如今，中国互联网已是首屈一指，无从可借鉴，只能我们自己一步一脚印来创新推进。畅想固然是好，人们也都想时代发展越快越好，可是我个人觉得还是不能太过于“妄想”，没必要过于急躁，就怕大家都在畅想美好未来的时候，天突然就塌了。当然，这也是我个人想法，<strong>磨刀不误砍柴工</strong>，美好生活人人都想，前提还是应脚踏实地。</p>\n<p>也是在今年，租了服务器，重新注册了域名，搭建了自己的个人博客，开始了持续的记录总结。简书却是我最近才注册的，不为别的，我只想把一些生活感悟、牢骚，在这记录，也只会记录这些。从今年开始，每月我在自己博客都会写上一篇月结记录，初衷是为了让自己觉得过得不会那么虚空，同样更重要的是为了记录我的岁月。为了这些宝贵资料不丢失，我也做了备份。曾经，年少气盛的我丢失过许多美好记忆的书信，使得现在我都后悔不已，这些都是属于我们独一无二的财富。<strong>生活无远虑，只有近忧。</strong>不管如何，我们都要学会记录生活，也许也许，终有一日我也会有个幸福的家庭，子孙后辈也会静静坐在身边听一个糟老头子讲述他的过往。</p>\n<p>犹记得去年 12 月底与朋友们欢聚苏州，共游园林。今年怕是没有机会了，前几日刚好去杭州出差，两位好友在杭州做事，便约出来一同吃了顿饭。这顿饭，我们吃了半小时，等了却将近两小时。那几日刚好是今年雪下得最大的日子，又正值周末，饭点，想想也难免。吃完后各自回府，下了地铁我本想打车，无奈道路积雪严重，天气恶劣。于是在等了十几分钟出租车后，我撑着小黑伞，踩着雪地，走了两三公里回到了宾馆，小黑伞已早成了小白伞了。距离毕业已过去了一年有余，大家身上也都多了一丝成熟稳重，几日前我还翻了下毕业相册，嗯，变化大倒是不大，就是头发好像都少了一些！</p>\n<p>2018，我放慢了工作节奏，给了自己更多的时间去回顾，去务实基础，<strong>博观约取，厚积薄发</strong>！</p>\n<p>2018，我同时也加强了锻炼，没有一个好身体将来又怎么能够撑得起一番事业！</p>\n<p>2018，是积累的一年，寒冬虽冷，却总有见到明媚一天的啊！</p>\n<p>你好，19！</p>\n","excerpt":"","more":"<h1 id=\"你好，依旧-此篇作为对-2018-的整年回顾\"><a href=\"#你好，依旧-此篇作为对-2018-的整年回顾\" class=\"headerlink\" title=\"你好，依旧 此篇作为对 2018 的整年回顾\"></a>你好，依旧 此篇作为对 2018 的整年回顾</h1><p>尾巴，走了；你好，依旧。</p>\n<p>2018 的尾巴已经来到，也是到了时候该让她的尾巴跟头部围成一个圈圈了。</p>\n<p>2018，看过几场电影，吃过几场温馨的饭，睡过几场懒觉，看过几次凌晨的星空。</p>\n<p>2018，分过一次手，游过几次怪味的泳，红过几次眼，回过不超五次的家。</p>\n<p>2018，我重新拾起了运动，不为别的，只为自己能够多活两年。</p>\n<p>2018，我重新调整了饮食，却始终调不过来作息。</p>\n<p>2018，我看了好多书，有科幻代表《三体》，有经典散文集《自在独行》，有轻描淡写一生历程的《浮生六记》，也有极具讽刺的《兄弟》等等。当然，专业书籍也不能拉下。我自知是个爱书之人，我爱看书与爱看电影是一回事，都是喜欢故事，喜欢在这些源于生活中而来的作品之间，有所感悟，体会情愫。我想，这与我善于思考，善于总结，有些许相关吧。最近在看《城南旧事》。</p>\n<p>今年 3 月，我换了份工作，因此也搬了个新的住处。很幸运，两位室友人很不错，还都是个硕士生，与优秀的人一同来往，谁人不喜欢呢？期间我还买了个方形玻璃缸，作为我那鳄龟的新住处（去年 8 月份买的两只苗子，现在只剩一只，长得倍儿快！有时间我可再另开一篇来专门絮叨絮叨）。后觉着这么个大缸就供着个龟大爷，浪费至极。于是我之后又陆陆续续往里丢过虾（包含着龙虾）、泥鳅，可几日后往往就不见其踪影，只有可怜的残骸在水中无目的晃荡。我不甘心，10 月份左右又进购了一批草金苗，大约五六十只。直到今日，12 月中旬，还剩下 7 只幸运儿，不知是否因为这气温影响了龟爷，还是幸运儿的过人闪躲之处，或是他们惺惺相惜，已成为了朋友？我不得知，我只知三天两头给它喂食鸡肉，应该是饿不着它的吧。话说幸运儿草金们，其中有两三条我甚是得意，身上条纹十分漂亮，尾巴又大又长，要是最终也遭遇不幸，我怕是会难过会后悔吧。可是，住所实在是小，我还能做些什么呢？我喜欢各种宠物，本想养猫养狗，一想处境，我便立刻就会打消这种不实际的念头，这也是我选择养龟的原因吧。</p>\n<p>由于换了份工作，该司并非互联网公司，工作强度自然也没有那么大。也正是因为如此，我有了更多的时间能做我自己喜欢做的事情，就比如看书，跑步。独处的日子，看书是最好的项目了。晚上我也有了时间自己随意煮煮蔬菜，煮煮鸡胸，煮煮面条，健康又便宜，因此还与菜场的大爷变得熟知。虽然这种生活长期也不错，但是我是知道的，我是不愿意的。在这段时间里，我有了时间可以巩固基础，有了时间可以学习其他的东西，有了时间可以将之前未完全消化的东西一一吸干。我并没忘给自己充电，虽然也看了不少非专业书籍，但是那也是必要的，那些充实了我的灵魂，渐渐造就了我的气质，每每读完一本书我都有所收获。厚积而薄发，我一直在等待它的到来！</p>\n<p>我在以前的随记中写过：<strong>时间往往在你回顾的时候，才会觉得过得好快。</strong>我也写过：<strong>原来我早已习惯了孤独，只是在孤独的岁月之中穿插了一段不那么孤独的时光，使我暂忘孤独。</strong>一个人的时候，往往会思考更多。虽说人类是群居动物，但是现在正慢慢走向独居世界，与外界网络相连即可。人们经常会畅想未来，畅想未来会变得多么科幻多么神奇多么智能，无可厚非，因为过去几年我们确实是发展可谓“神速”。但是我在想，过去是因为西方的互联网本就比中国发展要快，所以中国可以借鉴西方来避坑，从而快速发展。而如今，中国互联网已是首屈一指，无从可借鉴，只能我们自己一步一脚印来创新推进。畅想固然是好，人们也都想时代发展越快越好，可是我个人觉得还是不能太过于“妄想”，没必要过于急躁，就怕大家都在畅想美好未来的时候，天突然就塌了。当然，这也是我个人想法，<strong>磨刀不误砍柴工</strong>，美好生活人人都想，前提还是应脚踏实地。</p>\n<p>也是在今年，租了服务器，重新注册了域名，搭建了自己的个人博客，开始了持续的记录总结。简书却是我最近才注册的，不为别的，我只想把一些生活感悟、牢骚，在这记录，也只会记录这些。从今年开始，每月我在自己博客都会写上一篇月结记录，初衷是为了让自己觉得过得不会那么虚空，同样更重要的是为了记录我的岁月。为了这些宝贵资料不丢失，我也做了备份。曾经，年少气盛的我丢失过许多美好记忆的书信，使得现在我都后悔不已，这些都是属于我们独一无二的财富。<strong>生活无远虑，只有近忧。</strong>不管如何，我们都要学会记录生活，也许也许，终有一日我也会有个幸福的家庭，子孙后辈也会静静坐在身边听一个糟老头子讲述他的过往。</p>\n<p>犹记得去年 12 月底与朋友们欢聚苏州，共游园林。今年怕是没有机会了，前几日刚好去杭州出差，两位好友在杭州做事，便约出来一同吃了顿饭。这顿饭，我们吃了半小时，等了却将近两小时。那几日刚好是今年雪下得最大的日子，又正值周末，饭点，想想也难免。吃完后各自回府，下了地铁我本想打车，无奈道路积雪严重，天气恶劣。于是在等了十几分钟出租车后，我撑着小黑伞，踩着雪地，走了两三公里回到了宾馆，小黑伞已早成了小白伞了。距离毕业已过去了一年有余，大家身上也都多了一丝成熟稳重，几日前我还翻了下毕业相册，嗯，变化大倒是不大，就是头发好像都少了一些！</p>\n<p>2018，我放慢了工作节奏，给了自己更多的时间去回顾，去务实基础，<strong>博观约取，厚积薄发</strong>！</p>\n<p>2018，我同时也加强了锻炼，没有一个好身体将来又怎么能够撑得起一番事业！</p>\n<p>2018，是积累的一年，寒冬虽冷，却总有见到明媚一天的啊！</p>\n<p>你好，19！</p>\n"},{"title":"你好，贰零","date":"2019-12-27T06:30:49.000Z","_content":"\n> 此篇作为对 2019 整年的简单回顾\n\n---\n\n首先得接上上篇，嘉善半马 PB 比之前快了十分钟哈哈，214.\n\n刚才在准备写这篇的时候，想想我该起个什么标题好，脑海中还在播放去年写年终篇《你好，依旧》时的画面。\n\n延续风格，《你好，贰零》出炉！\n\n今年春节来得早，过完元旦再过个两周就春节了，今年没什么输出，大致看了下去年的一些文章还感觉好像也就不久前写的，一下子过一年了。甚叹。\n\n今年书看得少了，倒是看了不少电视剧，这算不算得上是精神上的一种疲呢。《权力的游戏》、《硅谷》、《绝命毒师》、《越狱》、《风骚律师》……美剧居多。《小欢喜》、《陈情令》以及最近比较火的《庆余年》这类电视，说实话确实是美剧看得更有意味点。\n\n2019，公司旅游去了趟塞班岛，风景绝佳，消费颇高；\n\n2019，又看了几场 live house，孤独者的狂欢；\n\n2019，酒吧喝喝酒，听听音乐，还是没把到妹；\n\n2019，生命不息，运动不停，跑步没拉下；\n\n2019，长了十几斤肉，肥肉？不可能；\n\n2019，两块半马完赛牌，PB 214；\n\n2019，回家次数比去年要多；\n\n2019，我姐终于嫁出去了；\n\n2019，还是没搞到钱！\n\n2019，昆明去了好几趟，把昆医体育馆这个项目给顺利弄完了，吃到了特色小吃去大学城走了走遗憾的是没有足够的时间去周边地区好好逛逛，听说泸沽湖相当美啊。云南的天确实很漂亮，气候也相当不错，只要不在阳光下直射。之前还跟大学室友讨论要不要搞个名宿，大搞一笔，可也只能是口嗨下罢了，一是资金，二来我们也没路子，若是保障每月都有稳定的人流量，那便不在话下，我就是卖血也去干啊。确实像云南四季都是旅游季，独特风景又数不胜数，适合不过了。突然想到之前去乌镇玩，那时候网上定的名宿，其实就是街边的房子一改造。那一条街两旁的房子不是用来住宿就是用来吃喝，真的带动了那一大片。有时我一想，要是真弄了个名宿这种的，刚好爸妈可以去帮忙运作而我继续上班，也不耽误，可这远了也不现实而已。千岛湖？不晓得。\n\n今年科技热潮，5G 也带动了不少行业的热度，单从股价上就可以看出，不少都翻了好几番。老美的经济结构组成上可以看出科技是未来，科技是领头军，而中国经济结构大头还是地产和金融，科技现在也正慢慢上来，未来毋庸置疑，肯定是科技大头。可以看到中国改革还是有很大幅度的同时也藏着许多的机会。最近，小米发布了首款售价低于 2000 的 5G 手机，这一下，小米股价涨得那可不少，距离腾讯乘以苹果的市值又更进了一步！\n\n今年还是在这家公司，事情是越做越杂了，有时候也深深感到内心的疲惫。一张一弛，又快一个年头，又是一个深冬。每每双脚踏出大厦，念及岁月蹉跎，明日生活何许，我又有何长进，苦矣。次次眼望灯火大厦，呆呆看那人来人往，何时何地我又能遇到何人，眼角不觉泛起一丝波动。何曾想，本就因该司基本不加班朝九晚六，可以偷得些许清闲时间为我所用，最近几天却基本弄到凌晨才昏沉回去，第二天又匆匆赶来。\n\n---\n\n> ↓↓ 附上年度总结 ↓↓\n\n&emsp;&emsp;时间一晃而过，转眼间到公司已经一年多了。这是我人生中弥足珍贵的一段经历。在这段时间里各级领导在工作上给予了我极大的帮助，在生活上给予了我极大的关心，让我充分感受到了领导们“海纳百川”的胸襟，感受到了同磊人“不经历风雨，怎能见彩虹”的豪气。在对公司各级领导肃然起敬的同时，也为我有机会成为公司的一份子而自豪。在这一年多的时间里，在领导和同事们的悉心关怀和指导下，通过自身的努力，各方面均取得了一定的进步，现将我的工作情况作如下汇报。\n\n&emsp;&emsp;一、通过培训学习和日常工作积累使我对同磊公司有了一定的新的认识\n\n&emsp;&emsp;在这近一年的时间里，对建筑行业和公司有了更深一步的了解。公司的理念在平时的工作以及项目开发时体现的淋漓尽致，本人对公司的理念非常认同。公司一直在技术更新中健步发展，令人敬佩。公司以人为本、尊重人才的思想在实际工作中贯彻，这是同磊公司能发展壮大的重要原因。现在公司在钢结构建筑监测以及张拉行业起到了举足轻重的地位，今后还将更加辉煌。\n\n&emsp;&emsp;二、遵守各项规章制度，认真工作，使自己素养不断得到提高\n\n&emsp;&emsp;爱岗敬业的职业道德素质是每一项工作顺利开展并最终取得成功的保障。在这一年多的时间里，我能遵守公司的各项规章制度，兢兢业业做好本职业工作，用满腔热情积极、认真地完成好每一项任务，认真履行岗位职责，平时生活中团结同事、不断提升自己的团队合作精神。近期也因公多次出差，在项目现场也需要与业主方等进行有效沟通，这也积极锻炼了我的沟通、交际能力，渴望有所突破的我，将会在以后的工作和生活中时时提醒自己，以便自己以后的人生道路越走越精彩。\n\n&emsp;&emsp;三、认真学习岗位职能，工作能力得到了一定的提高\n\n&emsp;&emsp;根据目前工作分工，我的主要工作任务是：\n\n(1) 负责公司钢结构建筑监测系统的开发；<br>\n(2) 现场采集仪器的调试以及负责监测系统集成；<br>\n(3) 参与 BIM4D 项目的开发。\n\n&emsp;&emsp;四、不足和需改进方面\n\n&emsp;&emsp;虽然加入公司这个大家庭已经一年有余，但可能由于跨行业，对建筑方面的一些知识和了解还是很欠缺的。交际能力也是大多数程序员比较缺乏的当然包括我在内，我也希望能够在今后的工作中更加迅速的提升自己的业务能力以及技术能力。\n\n---\n\n2019，没发生什么改命的事，也没什么废命的事；\n\n2019，还是在上海眼望辉煌，勉强度日；\n\n2019，事无巨细，笑口常开；\n\n你好，20！","source":"_posts/hello-2020.md","raw":"---\ntitle: 你好，贰零\ndate: 2019-12-27 14:30:49\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 此篇作为对 2019 整年的简单回顾\n\n---\n\n首先得接上上篇，嘉善半马 PB 比之前快了十分钟哈哈，214.\n\n刚才在准备写这篇的时候，想想我该起个什么标题好，脑海中还在播放去年写年终篇《你好，依旧》时的画面。\n\n延续风格，《你好，贰零》出炉！\n\n今年春节来得早，过完元旦再过个两周就春节了，今年没什么输出，大致看了下去年的一些文章还感觉好像也就不久前写的，一下子过一年了。甚叹。\n\n今年书看得少了，倒是看了不少电视剧，这算不算得上是精神上的一种疲呢。《权力的游戏》、《硅谷》、《绝命毒师》、《越狱》、《风骚律师》……美剧居多。《小欢喜》、《陈情令》以及最近比较火的《庆余年》这类电视，说实话确实是美剧看得更有意味点。\n\n2019，公司旅游去了趟塞班岛，风景绝佳，消费颇高；\n\n2019，又看了几场 live house，孤独者的狂欢；\n\n2019，酒吧喝喝酒，听听音乐，还是没把到妹；\n\n2019，生命不息，运动不停，跑步没拉下；\n\n2019，长了十几斤肉，肥肉？不可能；\n\n2019，两块半马完赛牌，PB 214；\n\n2019，回家次数比去年要多；\n\n2019，我姐终于嫁出去了；\n\n2019，还是没搞到钱！\n\n2019，昆明去了好几趟，把昆医体育馆这个项目给顺利弄完了，吃到了特色小吃去大学城走了走遗憾的是没有足够的时间去周边地区好好逛逛，听说泸沽湖相当美啊。云南的天确实很漂亮，气候也相当不错，只要不在阳光下直射。之前还跟大学室友讨论要不要搞个名宿，大搞一笔，可也只能是口嗨下罢了，一是资金，二来我们也没路子，若是保障每月都有稳定的人流量，那便不在话下，我就是卖血也去干啊。确实像云南四季都是旅游季，独特风景又数不胜数，适合不过了。突然想到之前去乌镇玩，那时候网上定的名宿，其实就是街边的房子一改造。那一条街两旁的房子不是用来住宿就是用来吃喝，真的带动了那一大片。有时我一想，要是真弄了个名宿这种的，刚好爸妈可以去帮忙运作而我继续上班，也不耽误，可这远了也不现实而已。千岛湖？不晓得。\n\n今年科技热潮，5G 也带动了不少行业的热度，单从股价上就可以看出，不少都翻了好几番。老美的经济结构组成上可以看出科技是未来，科技是领头军，而中国经济结构大头还是地产和金融，科技现在也正慢慢上来，未来毋庸置疑，肯定是科技大头。可以看到中国改革还是有很大幅度的同时也藏着许多的机会。最近，小米发布了首款售价低于 2000 的 5G 手机，这一下，小米股价涨得那可不少，距离腾讯乘以苹果的市值又更进了一步！\n\n今年还是在这家公司，事情是越做越杂了，有时候也深深感到内心的疲惫。一张一弛，又快一个年头，又是一个深冬。每每双脚踏出大厦，念及岁月蹉跎，明日生活何许，我又有何长进，苦矣。次次眼望灯火大厦，呆呆看那人来人往，何时何地我又能遇到何人，眼角不觉泛起一丝波动。何曾想，本就因该司基本不加班朝九晚六，可以偷得些许清闲时间为我所用，最近几天却基本弄到凌晨才昏沉回去，第二天又匆匆赶来。\n\n---\n\n> ↓↓ 附上年度总结 ↓↓\n\n&emsp;&emsp;时间一晃而过，转眼间到公司已经一年多了。这是我人生中弥足珍贵的一段经历。在这段时间里各级领导在工作上给予了我极大的帮助，在生活上给予了我极大的关心，让我充分感受到了领导们“海纳百川”的胸襟，感受到了同磊人“不经历风雨，怎能见彩虹”的豪气。在对公司各级领导肃然起敬的同时，也为我有机会成为公司的一份子而自豪。在这一年多的时间里，在领导和同事们的悉心关怀和指导下，通过自身的努力，各方面均取得了一定的进步，现将我的工作情况作如下汇报。\n\n&emsp;&emsp;一、通过培训学习和日常工作积累使我对同磊公司有了一定的新的认识\n\n&emsp;&emsp;在这近一年的时间里，对建筑行业和公司有了更深一步的了解。公司的理念在平时的工作以及项目开发时体现的淋漓尽致，本人对公司的理念非常认同。公司一直在技术更新中健步发展，令人敬佩。公司以人为本、尊重人才的思想在实际工作中贯彻，这是同磊公司能发展壮大的重要原因。现在公司在钢结构建筑监测以及张拉行业起到了举足轻重的地位，今后还将更加辉煌。\n\n&emsp;&emsp;二、遵守各项规章制度，认真工作，使自己素养不断得到提高\n\n&emsp;&emsp;爱岗敬业的职业道德素质是每一项工作顺利开展并最终取得成功的保障。在这一年多的时间里，我能遵守公司的各项规章制度，兢兢业业做好本职业工作，用满腔热情积极、认真地完成好每一项任务，认真履行岗位职责，平时生活中团结同事、不断提升自己的团队合作精神。近期也因公多次出差，在项目现场也需要与业主方等进行有效沟通，这也积极锻炼了我的沟通、交际能力，渴望有所突破的我，将会在以后的工作和生活中时时提醒自己，以便自己以后的人生道路越走越精彩。\n\n&emsp;&emsp;三、认真学习岗位职能，工作能力得到了一定的提高\n\n&emsp;&emsp;根据目前工作分工，我的主要工作任务是：\n\n(1) 负责公司钢结构建筑监测系统的开发；<br>\n(2) 现场采集仪器的调试以及负责监测系统集成；<br>\n(3) 参与 BIM4D 项目的开发。\n\n&emsp;&emsp;四、不足和需改进方面\n\n&emsp;&emsp;虽然加入公司这个大家庭已经一年有余，但可能由于跨行业，对建筑方面的一些知识和了解还是很欠缺的。交际能力也是大多数程序员比较缺乏的当然包括我在内，我也希望能够在今后的工作中更加迅速的提升自己的业务能力以及技术能力。\n\n---\n\n2019，没发生什么改命的事，也没什么废命的事；\n\n2019，还是在上海眼望辉煌，勉强度日；\n\n2019，事无巨细，笑口常开；\n\n你好，20！","slug":"hello-2020","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf005ck9i15h9vfjqd","content":"<blockquote>\n<p>此篇作为对 2019 整年的简单回顾</p>\n</blockquote>\n<hr>\n<p>首先得接上上篇，嘉善半马 PB 比之前快了十分钟哈哈，214.</p>\n<p>刚才在准备写这篇的时候，想想我该起个什么标题好，脑海中还在播放去年写年终篇《你好，依旧》时的画面。</p>\n<p>延续风格，《你好，贰零》出炉！</p>\n<p>今年春节来得早，过完元旦再过个两周就春节了，今年没什么输出，大致看了下去年的一些文章还感觉好像也就不久前写的，一下子过一年了。甚叹。</p>\n<p>今年书看得少了，倒是看了不少电视剧，这算不算得上是精神上的一种疲呢。《权力的游戏》、《硅谷》、《绝命毒师》、《越狱》、《风骚律师》……美剧居多。《小欢喜》、《陈情令》以及最近比较火的《庆余年》这类电视，说实话确实是美剧看得更有意味点。</p>\n<p>2019，公司旅游去了趟塞班岛，风景绝佳，消费颇高；</p>\n<p>2019，又看了几场 live house，孤独者的狂欢；</p>\n<p>2019，酒吧喝喝酒，听听音乐，还是没把到妹；</p>\n<p>2019，生命不息，运动不停，跑步没拉下；</p>\n<p>2019，长了十几斤肉，肥肉？不可能；</p>\n<p>2019，两块半马完赛牌，PB 214；</p>\n<p>2019，回家次数比去年要多；</p>\n<p>2019，我姐终于嫁出去了；</p>\n<p>2019，还是没搞到钱！</p>\n<p>2019，昆明去了好几趟，把昆医体育馆这个项目给顺利弄完了，吃到了特色小吃去大学城走了走遗憾的是没有足够的时间去周边地区好好逛逛，听说泸沽湖相当美啊。云南的天确实很漂亮，气候也相当不错，只要不在阳光下直射。之前还跟大学室友讨论要不要搞个名宿，大搞一笔，可也只能是口嗨下罢了，一是资金，二来我们也没路子，若是保障每月都有稳定的人流量，那便不在话下，我就是卖血也去干啊。确实像云南四季都是旅游季，独特风景又数不胜数，适合不过了。突然想到之前去乌镇玩，那时候网上定的名宿，其实就是街边的房子一改造。那一条街两旁的房子不是用来住宿就是用来吃喝，真的带动了那一大片。有时我一想，要是真弄了个名宿这种的，刚好爸妈可以去帮忙运作而我继续上班，也不耽误，可这远了也不现实而已。千岛湖？不晓得。</p>\n<p>今年科技热潮，5G 也带动了不少行业的热度，单从股价上就可以看出，不少都翻了好几番。老美的经济结构组成上可以看出科技是未来，科技是领头军，而中国经济结构大头还是地产和金融，科技现在也正慢慢上来，未来毋庸置疑，肯定是科技大头。可以看到中国改革还是有很大幅度的同时也藏着许多的机会。最近，小米发布了首款售价低于 2000 的 5G 手机，这一下，小米股价涨得那可不少，距离腾讯乘以苹果的市值又更进了一步！</p>\n<p>今年还是在这家公司，事情是越做越杂了，有时候也深深感到内心的疲惫。一张一弛，又快一个年头，又是一个深冬。每每双脚踏出大厦，念及岁月蹉跎，明日生活何许，我又有何长进，苦矣。次次眼望灯火大厦，呆呆看那人来人往，何时何地我又能遇到何人，眼角不觉泛起一丝波动。何曾想，本就因该司基本不加班朝九晚六，可以偷得些许清闲时间为我所用，最近几天却基本弄到凌晨才昏沉回去，第二天又匆匆赶来。</p>\n<hr>\n<blockquote>\n<p>↓↓ 附上年度总结 ↓↓</p>\n</blockquote>\n<p>&emsp;&emsp;时间一晃而过，转眼间到公司已经一年多了。这是我人生中弥足珍贵的一段经历。在这段时间里各级领导在工作上给予了我极大的帮助，在生活上给予了我极大的关心，让我充分感受到了领导们“海纳百川”的胸襟，感受到了同磊人“不经历风雨，怎能见彩虹”的豪气。在对公司各级领导肃然起敬的同时，也为我有机会成为公司的一份子而自豪。在这一年多的时间里，在领导和同事们的悉心关怀和指导下，通过自身的努力，各方面均取得了一定的进步，现将我的工作情况作如下汇报。</p>\n<p>&emsp;&emsp;一、通过培训学习和日常工作积累使我对同磊公司有了一定的新的认识</p>\n<p>&emsp;&emsp;在这近一年的时间里，对建筑行业和公司有了更深一步的了解。公司的理念在平时的工作以及项目开发时体现的淋漓尽致，本人对公司的理念非常认同。公司一直在技术更新中健步发展，令人敬佩。公司以人为本、尊重人才的思想在实际工作中贯彻，这是同磊公司能发展壮大的重要原因。现在公司在钢结构建筑监测以及张拉行业起到了举足轻重的地位，今后还将更加辉煌。</p>\n<p>&emsp;&emsp;二、遵守各项规章制度，认真工作，使自己素养不断得到提高</p>\n<p>&emsp;&emsp;爱岗敬业的职业道德素质是每一项工作顺利开展并最终取得成功的保障。在这一年多的时间里，我能遵守公司的各项规章制度，兢兢业业做好本职业工作，用满腔热情积极、认真地完成好每一项任务，认真履行岗位职责，平时生活中团结同事、不断提升自己的团队合作精神。近期也因公多次出差，在项目现场也需要与业主方等进行有效沟通，这也积极锻炼了我的沟通、交际能力，渴望有所突破的我，将会在以后的工作和生活中时时提醒自己，以便自己以后的人生道路越走越精彩。</p>\n<p>&emsp;&emsp;三、认真学习岗位职能，工作能力得到了一定的提高</p>\n<p>&emsp;&emsp;根据目前工作分工，我的主要工作任务是：</p>\n<p>(1) 负责公司钢结构建筑监测系统的开发；<br><br>(2) 现场采集仪器的调试以及负责监测系统集成；<br><br>(3) 参与 BIM4D 项目的开发。</p>\n<p>&emsp;&emsp;四、不足和需改进方面</p>\n<p>&emsp;&emsp;虽然加入公司这个大家庭已经一年有余，但可能由于跨行业，对建筑方面的一些知识和了解还是很欠缺的。交际能力也是大多数程序员比较缺乏的当然包括我在内，我也希望能够在今后的工作中更加迅速的提升自己的业务能力以及技术能力。</p>\n<hr>\n<p>2019，没发生什么改命的事，也没什么废命的事；</p>\n<p>2019，还是在上海眼望辉煌，勉强度日；</p>\n<p>2019，事无巨细，笑口常开；</p>\n<p>你好，20！</p>\n","excerpt":"","more":"<blockquote>\n<p>此篇作为对 2019 整年的简单回顾</p>\n</blockquote>\n<hr>\n<p>首先得接上上篇，嘉善半马 PB 比之前快了十分钟哈哈，214.</p>\n<p>刚才在准备写这篇的时候，想想我该起个什么标题好，脑海中还在播放去年写年终篇《你好，依旧》时的画面。</p>\n<p>延续风格，《你好，贰零》出炉！</p>\n<p>今年春节来得早，过完元旦再过个两周就春节了，今年没什么输出，大致看了下去年的一些文章还感觉好像也就不久前写的，一下子过一年了。甚叹。</p>\n<p>今年书看得少了，倒是看了不少电视剧，这算不算得上是精神上的一种疲呢。《权力的游戏》、《硅谷》、《绝命毒师》、《越狱》、《风骚律师》……美剧居多。《小欢喜》、《陈情令》以及最近比较火的《庆余年》这类电视，说实话确实是美剧看得更有意味点。</p>\n<p>2019，公司旅游去了趟塞班岛，风景绝佳，消费颇高；</p>\n<p>2019，又看了几场 live house，孤独者的狂欢；</p>\n<p>2019，酒吧喝喝酒，听听音乐，还是没把到妹；</p>\n<p>2019，生命不息，运动不停，跑步没拉下；</p>\n<p>2019，长了十几斤肉，肥肉？不可能；</p>\n<p>2019，两块半马完赛牌，PB 214；</p>\n<p>2019，回家次数比去年要多；</p>\n<p>2019，我姐终于嫁出去了；</p>\n<p>2019，还是没搞到钱！</p>\n<p>2019，昆明去了好几趟，把昆医体育馆这个项目给顺利弄完了，吃到了特色小吃去大学城走了走遗憾的是没有足够的时间去周边地区好好逛逛，听说泸沽湖相当美啊。云南的天确实很漂亮，气候也相当不错，只要不在阳光下直射。之前还跟大学室友讨论要不要搞个名宿，大搞一笔，可也只能是口嗨下罢了，一是资金，二来我们也没路子，若是保障每月都有稳定的人流量，那便不在话下，我就是卖血也去干啊。确实像云南四季都是旅游季，独特风景又数不胜数，适合不过了。突然想到之前去乌镇玩，那时候网上定的名宿，其实就是街边的房子一改造。那一条街两旁的房子不是用来住宿就是用来吃喝，真的带动了那一大片。有时我一想，要是真弄了个名宿这种的，刚好爸妈可以去帮忙运作而我继续上班，也不耽误，可这远了也不现实而已。千岛湖？不晓得。</p>\n<p>今年科技热潮，5G 也带动了不少行业的热度，单从股价上就可以看出，不少都翻了好几番。老美的经济结构组成上可以看出科技是未来，科技是领头军，而中国经济结构大头还是地产和金融，科技现在也正慢慢上来，未来毋庸置疑，肯定是科技大头。可以看到中国改革还是有很大幅度的同时也藏着许多的机会。最近，小米发布了首款售价低于 2000 的 5G 手机，这一下，小米股价涨得那可不少，距离腾讯乘以苹果的市值又更进了一步！</p>\n<p>今年还是在这家公司，事情是越做越杂了，有时候也深深感到内心的疲惫。一张一弛，又快一个年头，又是一个深冬。每每双脚踏出大厦，念及岁月蹉跎，明日生活何许，我又有何长进，苦矣。次次眼望灯火大厦，呆呆看那人来人往，何时何地我又能遇到何人，眼角不觉泛起一丝波动。何曾想，本就因该司基本不加班朝九晚六，可以偷得些许清闲时间为我所用，最近几天却基本弄到凌晨才昏沉回去，第二天又匆匆赶来。</p>\n<hr>\n<blockquote>\n<p>↓↓ 附上年度总结 ↓↓</p>\n</blockquote>\n<p>&emsp;&emsp;时间一晃而过，转眼间到公司已经一年多了。这是我人生中弥足珍贵的一段经历。在这段时间里各级领导在工作上给予了我极大的帮助，在生活上给予了我极大的关心，让我充分感受到了领导们“海纳百川”的胸襟，感受到了同磊人“不经历风雨，怎能见彩虹”的豪气。在对公司各级领导肃然起敬的同时，也为我有机会成为公司的一份子而自豪。在这一年多的时间里，在领导和同事们的悉心关怀和指导下，通过自身的努力，各方面均取得了一定的进步，现将我的工作情况作如下汇报。</p>\n<p>&emsp;&emsp;一、通过培训学习和日常工作积累使我对同磊公司有了一定的新的认识</p>\n<p>&emsp;&emsp;在这近一年的时间里，对建筑行业和公司有了更深一步的了解。公司的理念在平时的工作以及项目开发时体现的淋漓尽致，本人对公司的理念非常认同。公司一直在技术更新中健步发展，令人敬佩。公司以人为本、尊重人才的思想在实际工作中贯彻，这是同磊公司能发展壮大的重要原因。现在公司在钢结构建筑监测以及张拉行业起到了举足轻重的地位，今后还将更加辉煌。</p>\n<p>&emsp;&emsp;二、遵守各项规章制度，认真工作，使自己素养不断得到提高</p>\n<p>&emsp;&emsp;爱岗敬业的职业道德素质是每一项工作顺利开展并最终取得成功的保障。在这一年多的时间里，我能遵守公司的各项规章制度，兢兢业业做好本职业工作，用满腔热情积极、认真地完成好每一项任务，认真履行岗位职责，平时生活中团结同事、不断提升自己的团队合作精神。近期也因公多次出差，在项目现场也需要与业主方等进行有效沟通，这也积极锻炼了我的沟通、交际能力，渴望有所突破的我，将会在以后的工作和生活中时时提醒自己，以便自己以后的人生道路越走越精彩。</p>\n<p>&emsp;&emsp;三、认真学习岗位职能，工作能力得到了一定的提高</p>\n<p>&emsp;&emsp;根据目前工作分工，我的主要工作任务是：</p>\n<p>(1) 负责公司钢结构建筑监测系统的开发；<br><br>(2) 现场采集仪器的调试以及负责监测系统集成；<br><br>(3) 参与 BIM4D 项目的开发。</p>\n<p>&emsp;&emsp;四、不足和需改进方面</p>\n<p>&emsp;&emsp;虽然加入公司这个大家庭已经一年有余，但可能由于跨行业，对建筑方面的一些知识和了解还是很欠缺的。交际能力也是大多数程序员比较缺乏的当然包括我在内，我也希望能够在今后的工作中更加迅速的提升自己的业务能力以及技术能力。</p>\n<hr>\n<p>2019，没发生什么改命的事，也没什么废命的事；</p>\n<p>2019，还是在上海眼望辉煌，勉强度日；</p>\n<p>2019，事无巨细，笑口常开；</p>\n<p>你好，20！</p>\n"},{"title":"你好，而已","date":"2020-12-29T10:04:55.000Z","_content":"\n> 你好，贰壹。  我也不过二五而已。\n\n2020 年是非常特殊的一年，这一年，想必后人们想起都会觉得不可思议。\n\n多灾的世界，多难的中国。\n\n---\n\n当人们在尽情畅想未来科技的时候，却对病毒无计奈何；\n\n当人们在深信自我足够强大的时候，却被现实无情折磨；\n\n当人们在赌场世界满心欢喜的时候，转身却变成了他人镰刀下的绿韭。\n\n---\n\n年初，人心惶惶，外面世界纷扰，国人祈祷，愿早日安康。\n\n那时，每日早起睁眼第一件事就是查看疫情动态，由于无法自由出门，在家一待就是两个月。\n\n这一年，也算是过了一个最长的寒假。\n\n而就在 1 月 26 日，黑曼巴遇难的消息传开，随后各大媒体开始证实，朋友圈也迅速扩开这个噩耗。享年 41 岁，科比·比恩·布莱恩特，黑曼巴精神影响了许许多多的人，不说再见。\n\n疫情还未控制，东非地区蝗灾肆虐，数量之多几十年未见，一度导致人们有了当年疯抢粮食的念头。也确实那时候的蔬菜价格涨得很快，再加上非洲猪瘟的发生，猪肉价格直接翻了好几倍，以前的十块左右一斤到了如今的三四十一斤。而到了现在，猪肉价格也没有怎么降下来，人们的消费确实是大头，也难怪这一年的白酒股都疯了。\n\n衣食住行，亘古不变。\n\n喝酒吃药，喝酒开车。\n\n3 月，国际油价暴跌，美国股市熔断了 4 次，巴菲特......\n\n120 天缓冲期过后，美国商务部针对华为及其子公司的芯片升级禁令正式生效。从 9 月 15 日起，台积电、高通、联发科等公司正式“断供”华为。这一天将作为标志性的一天，载入中国芯片及半导体研发历史。\n\n11 月 25 日，国家主席习近平致电约瑟夫·拜登，祝贺他当选美国总统。\n\n---\n\n这一年发生的事情，会改变许许多多人的观念想法。\n\n这一年走到了现在，人性也总归人性，你是不是也忘记了年初自己定下的目标。\n\n人们都是感性生物，会随着伴随场景氛围不同产生不同的激素，而当激素消褪之后一切也慢慢随之变得平静。\n\n年初我呆在家，网络上电视上都是关于疫情防控，看着生命一直是这么脆弱，于是今年只给自己定了一个目标：活下去！\n\n现在，我实现了这个目标，并可以说完成得很好。\n\n--- \n\n2020，我给自己新添置了几双鞋；\n\n2020，我给自己新添置了几本书；\n\n2020，我给自己新添置了几件衣服；\n\n2020，我给自己新添置了几个手办；\n\n2020，还新加入了两个麝香宝宝生命。\n\n年初的漫长开篇，现在也要走到了结尾。\n\n没有过不去的坎，没有迈不过的沟，年年都有烦心事，就让那些烦心事在此刻都滚蛋吧！\n\n你好，21！\n","source":"_posts/hello-2021.md","raw":"---\ntitle: 你好，而已\ndate: 2020-12-29 18:04:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 你好，贰壹。  我也不过二五而已。\n\n2020 年是非常特殊的一年，这一年，想必后人们想起都会觉得不可思议。\n\n多灾的世界，多难的中国。\n\n---\n\n当人们在尽情畅想未来科技的时候，却对病毒无计奈何；\n\n当人们在深信自我足够强大的时候，却被现实无情折磨；\n\n当人们在赌场世界满心欢喜的时候，转身却变成了他人镰刀下的绿韭。\n\n---\n\n年初，人心惶惶，外面世界纷扰，国人祈祷，愿早日安康。\n\n那时，每日早起睁眼第一件事就是查看疫情动态，由于无法自由出门，在家一待就是两个月。\n\n这一年，也算是过了一个最长的寒假。\n\n而就在 1 月 26 日，黑曼巴遇难的消息传开，随后各大媒体开始证实，朋友圈也迅速扩开这个噩耗。享年 41 岁，科比·比恩·布莱恩特，黑曼巴精神影响了许许多多的人，不说再见。\n\n疫情还未控制，东非地区蝗灾肆虐，数量之多几十年未见，一度导致人们有了当年疯抢粮食的念头。也确实那时候的蔬菜价格涨得很快，再加上非洲猪瘟的发生，猪肉价格直接翻了好几倍，以前的十块左右一斤到了如今的三四十一斤。而到了现在，猪肉价格也没有怎么降下来，人们的消费确实是大头，也难怪这一年的白酒股都疯了。\n\n衣食住行，亘古不变。\n\n喝酒吃药，喝酒开车。\n\n3 月，国际油价暴跌，美国股市熔断了 4 次，巴菲特......\n\n120 天缓冲期过后，美国商务部针对华为及其子公司的芯片升级禁令正式生效。从 9 月 15 日起，台积电、高通、联发科等公司正式“断供”华为。这一天将作为标志性的一天，载入中国芯片及半导体研发历史。\n\n11 月 25 日，国家主席习近平致电约瑟夫·拜登，祝贺他当选美国总统。\n\n---\n\n这一年发生的事情，会改变许许多多人的观念想法。\n\n这一年走到了现在，人性也总归人性，你是不是也忘记了年初自己定下的目标。\n\n人们都是感性生物，会随着伴随场景氛围不同产生不同的激素，而当激素消褪之后一切也慢慢随之变得平静。\n\n年初我呆在家，网络上电视上都是关于疫情防控，看着生命一直是这么脆弱，于是今年只给自己定了一个目标：活下去！\n\n现在，我实现了这个目标，并可以说完成得很好。\n\n--- \n\n2020，我给自己新添置了几双鞋；\n\n2020，我给自己新添置了几本书；\n\n2020，我给自己新添置了几件衣服；\n\n2020，我给自己新添置了几个手办；\n\n2020，还新加入了两个麝香宝宝生命。\n\n年初的漫长开篇，现在也要走到了结尾。\n\n没有过不去的坎，没有迈不过的沟，年年都有烦心事，就让那些烦心事在此刻都滚蛋吧！\n\n你好，21！\n","slug":"hello-2021","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhf005fk9i13yaydbc4","content":"<blockquote>\n<p>你好，贰壹。  我也不过二五而已。</p>\n</blockquote>\n<p>2020 年是非常特殊的一年，这一年，想必后人们想起都会觉得不可思议。</p>\n<p>多灾的世界，多难的中国。</p>\n<hr>\n<p>当人们在尽情畅想未来科技的时候，却对病毒无计奈何；</p>\n<p>当人们在深信自我足够强大的时候，却被现实无情折磨；</p>\n<p>当人们在赌场世界满心欢喜的时候，转身却变成了他人镰刀下的绿韭。</p>\n<hr>\n<p>年初，人心惶惶，外面世界纷扰，国人祈祷，愿早日安康。</p>\n<p>那时，每日早起睁眼第一件事就是查看疫情动态，由于无法自由出门，在家一待就是两个月。</p>\n<p>这一年，也算是过了一个最长的寒假。</p>\n<p>而就在 1 月 26 日，黑曼巴遇难的消息传开，随后各大媒体开始证实，朋友圈也迅速扩开这个噩耗。享年 41 岁，科比·比恩·布莱恩特，黑曼巴精神影响了许许多多的人，不说再见。</p>\n<p>疫情还未控制，东非地区蝗灾肆虐，数量之多几十年未见，一度导致人们有了当年疯抢粮食的念头。也确实那时候的蔬菜价格涨得很快，再加上非洲猪瘟的发生，猪肉价格直接翻了好几倍，以前的十块左右一斤到了如今的三四十一斤。而到了现在，猪肉价格也没有怎么降下来，人们的消费确实是大头，也难怪这一年的白酒股都疯了。</p>\n<p>衣食住行，亘古不变。</p>\n<p>喝酒吃药，喝酒开车。</p>\n<p>3 月，国际油价暴跌，美国股市熔断了 4 次，巴菲特……</p>\n<p>120 天缓冲期过后，美国商务部针对华为及其子公司的芯片升级禁令正式生效。从 9 月 15 日起，台积电、高通、联发科等公司正式“断供”华为。这一天将作为标志性的一天，载入中国芯片及半导体研发历史。</p>\n<p>11 月 25 日，国家主席习近平致电约瑟夫·拜登，祝贺他当选美国总统。</p>\n<hr>\n<p>这一年发生的事情，会改变许许多多人的观念想法。</p>\n<p>这一年走到了现在，人性也总归人性，你是不是也忘记了年初自己定下的目标。</p>\n<p>人们都是感性生物，会随着伴随场景氛围不同产生不同的激素，而当激素消褪之后一切也慢慢随之变得平静。</p>\n<p>年初我呆在家，网络上电视上都是关于疫情防控，看着生命一直是这么脆弱，于是今年只给自己定了一个目标：活下去！</p>\n<p>现在，我实现了这个目标，并可以说完成得很好。</p>\n<hr>\n<p>2020，我给自己新添置了几双鞋；</p>\n<p>2020，我给自己新添置了几本书；</p>\n<p>2020，我给自己新添置了几件衣服；</p>\n<p>2020，我给自己新添置了几个手办；</p>\n<p>2020，还新加入了两个麝香宝宝生命。</p>\n<p>年初的漫长开篇，现在也要走到了结尾。</p>\n<p>没有过不去的坎，没有迈不过的沟，年年都有烦心事，就让那些烦心事在此刻都滚蛋吧！</p>\n<p>你好，21！</p>\n","excerpt":"","more":"<blockquote>\n<p>你好，贰壹。  我也不过二五而已。</p>\n</blockquote>\n<p>2020 年是非常特殊的一年，这一年，想必后人们想起都会觉得不可思议。</p>\n<p>多灾的世界，多难的中国。</p>\n<hr>\n<p>当人们在尽情畅想未来科技的时候，却对病毒无计奈何；</p>\n<p>当人们在深信自我足够强大的时候，却被现实无情折磨；</p>\n<p>当人们在赌场世界满心欢喜的时候，转身却变成了他人镰刀下的绿韭。</p>\n<hr>\n<p>年初，人心惶惶，外面世界纷扰，国人祈祷，愿早日安康。</p>\n<p>那时，每日早起睁眼第一件事就是查看疫情动态，由于无法自由出门，在家一待就是两个月。</p>\n<p>这一年，也算是过了一个最长的寒假。</p>\n<p>而就在 1 月 26 日，黑曼巴遇难的消息传开，随后各大媒体开始证实，朋友圈也迅速扩开这个噩耗。享年 41 岁，科比·比恩·布莱恩特，黑曼巴精神影响了许许多多的人，不说再见。</p>\n<p>疫情还未控制，东非地区蝗灾肆虐，数量之多几十年未见，一度导致人们有了当年疯抢粮食的念头。也确实那时候的蔬菜价格涨得很快，再加上非洲猪瘟的发生，猪肉价格直接翻了好几倍，以前的十块左右一斤到了如今的三四十一斤。而到了现在，猪肉价格也没有怎么降下来，人们的消费确实是大头，也难怪这一年的白酒股都疯了。</p>\n<p>衣食住行，亘古不变。</p>\n<p>喝酒吃药，喝酒开车。</p>\n<p>3 月，国际油价暴跌，美国股市熔断了 4 次，巴菲特……</p>\n<p>120 天缓冲期过后，美国商务部针对华为及其子公司的芯片升级禁令正式生效。从 9 月 15 日起，台积电、高通、联发科等公司正式“断供”华为。这一天将作为标志性的一天，载入中国芯片及半导体研发历史。</p>\n<p>11 月 25 日，国家主席习近平致电约瑟夫·拜登，祝贺他当选美国总统。</p>\n<hr>\n<p>这一年发生的事情，会改变许许多多人的观念想法。</p>\n<p>这一年走到了现在，人性也总归人性，你是不是也忘记了年初自己定下的目标。</p>\n<p>人们都是感性生物，会随着伴随场景氛围不同产生不同的激素，而当激素消褪之后一切也慢慢随之变得平静。</p>\n<p>年初我呆在家，网络上电视上都是关于疫情防控，看着生命一直是这么脆弱，于是今年只给自己定了一个目标：活下去！</p>\n<p>现在，我实现了这个目标，并可以说完成得很好。</p>\n<hr>\n<p>2020，我给自己新添置了几双鞋；</p>\n<p>2020，我给自己新添置了几本书；</p>\n<p>2020，我给自己新添置了几件衣服；</p>\n<p>2020，我给自己新添置了几个手办；</p>\n<p>2020，还新加入了两个麝香宝宝生命。</p>\n<p>年初的漫长开篇，现在也要走到了结尾。</p>\n<p>没有过不去的坎，没有迈不过的沟，年年都有烦心事，就让那些烦心事在此刻都滚蛋吧！</p>\n<p>你好，21！</p>\n"},{"title":"你好，尔尔","date":"2021-12-30T12:10:55.000Z","_content":"\n\n> 而已已逝，二六尔尔\n\n这个年度总结来得好像迟了点，一方面感觉真是如白驹过隙，另一方面确实也是近段时间过于懒惰，无法静静地沉下心来……\n\n今年好像没有完整看完一本技术书，只是看了一些电子文档。当时花了小两张毛爷爷买来的 k8s 技术书甚至没有正儿八经打开翻阅。\n\n---\n\n年初托别人介绍，遇到了现在的小邱。现在两人在一起快 275 天了，胖了将近十斤，过几天就是小邱的生日，没什么好送的，就送上我炽热的内心吧。\n\n今年遇到教育行业大整顿，然后我就离开了原先的公司，换了一家初创型的，中间没什么大波折，目前为止一切感觉也都还不错。\n\n今年两人在一起花销最多的应该就是吃的了，光光自助就去了不止十回了吧，吃进去的是自己的，不亏。\n\n今年养了一只猫，小时可爱，大了点后皮。手上时不时出现几道划痕。\n\n今年也没攒什么钱，理财还给理没了一点。\n\n今年疫情还是伴随在我们身边，时不时搞点大动静。\n\n今年回家次数明显变少了，好多个节假日也没能回去。\n\n今年没有写技术文章，已经快废了…… 没有输出\n\n今年在公司用 python 写了不少代码，学习了 clickhouse、kafka、es…… 还开始自学大数据相关东西，还是得学新东西，能省很多业务操作\n\n今年收货了很多东西，也开始对未来的规划更加得清晰，有很多种生活的方式，我们只要选择那种适合我们的就行\n\n---\n\n最近为了用户行为分析头疼不已，找了一圈也没有什么特别好的方式，只能自己摸着石头过河了。","source":"_posts/hello-2022.md","raw":"---\ntitle: 你好，尔尔\ndate: 2021-12-30 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n\n> 而已已逝，二六尔尔\n\n这个年度总结来得好像迟了点，一方面感觉真是如白驹过隙，另一方面确实也是近段时间过于懒惰，无法静静地沉下心来……\n\n今年好像没有完整看完一本技术书，只是看了一些电子文档。当时花了小两张毛爷爷买来的 k8s 技术书甚至没有正儿八经打开翻阅。\n\n---\n\n年初托别人介绍，遇到了现在的小邱。现在两人在一起快 275 天了，胖了将近十斤，过几天就是小邱的生日，没什么好送的，就送上我炽热的内心吧。\n\n今年遇到教育行业大整顿，然后我就离开了原先的公司，换了一家初创型的，中间没什么大波折，目前为止一切感觉也都还不错。\n\n今年两人在一起花销最多的应该就是吃的了，光光自助就去了不止十回了吧，吃进去的是自己的，不亏。\n\n今年养了一只猫，小时可爱，大了点后皮。手上时不时出现几道划痕。\n\n今年也没攒什么钱，理财还给理没了一点。\n\n今年疫情还是伴随在我们身边，时不时搞点大动静。\n\n今年回家次数明显变少了，好多个节假日也没能回去。\n\n今年没有写技术文章，已经快废了…… 没有输出\n\n今年在公司用 python 写了不少代码，学习了 clickhouse、kafka、es…… 还开始自学大数据相关东西，还是得学新东西，能省很多业务操作\n\n今年收货了很多东西，也开始对未来的规划更加得清晰，有很多种生活的方式，我们只要选择那种适合我们的就行\n\n---\n\n最近为了用户行为分析头疼不已，找了一圈也没有什么特别好的方式，只能自己摸着石头过河了。","slug":"hello-2022","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhg005jk9i172xd5ckk","content":"<blockquote>\n<p>而已已逝，二六尔尔</p>\n</blockquote>\n<p>这个年度总结来得好像迟了点，一方面感觉真是如白驹过隙，另一方面确实也是近段时间过于懒惰，无法静静地沉下心来……</p>\n<p>今年好像没有完整看完一本技术书，只是看了一些电子文档。当时花了小两张毛爷爷买来的 k8s 技术书甚至没有正儿八经打开翻阅。</p>\n<hr>\n<p>年初托别人介绍，遇到了现在的小邱。现在两人在一起快 275 天了，胖了将近十斤，过几天就是小邱的生日，没什么好送的，就送上我炽热的内心吧。</p>\n<p>今年遇到教育行业大整顿，然后我就离开了原先的公司，换了一家初创型的，中间没什么大波折，目前为止一切感觉也都还不错。</p>\n<p>今年两人在一起花销最多的应该就是吃的了，光光自助就去了不止十回了吧，吃进去的是自己的，不亏。</p>\n<p>今年养了一只猫，小时可爱，大了点后皮。手上时不时出现几道划痕。</p>\n<p>今年也没攒什么钱，理财还给理没了一点。</p>\n<p>今年疫情还是伴随在我们身边，时不时搞点大动静。</p>\n<p>今年回家次数明显变少了，好多个节假日也没能回去。</p>\n<p>今年没有写技术文章，已经快废了…… 没有输出</p>\n<p>今年在公司用 python 写了不少代码，学习了 clickhouse、kafka、es…… 还开始自学大数据相关东西，还是得学新东西，能省很多业务操作</p>\n<p>今年收货了很多东西，也开始对未来的规划更加得清晰，有很多种生活的方式，我们只要选择那种适合我们的就行</p>\n<hr>\n<p>最近为了用户行为分析头疼不已，找了一圈也没有什么特别好的方式，只能自己摸着石头过河了。</p>\n","excerpt":"","more":"<blockquote>\n<p>而已已逝，二六尔尔</p>\n</blockquote>\n<p>这个年度总结来得好像迟了点，一方面感觉真是如白驹过隙，另一方面确实也是近段时间过于懒惰，无法静静地沉下心来……</p>\n<p>今年好像没有完整看完一本技术书，只是看了一些电子文档。当时花了小两张毛爷爷买来的 k8s 技术书甚至没有正儿八经打开翻阅。</p>\n<hr>\n<p>年初托别人介绍，遇到了现在的小邱。现在两人在一起快 275 天了，胖了将近十斤，过几天就是小邱的生日，没什么好送的，就送上我炽热的内心吧。</p>\n<p>今年遇到教育行业大整顿，然后我就离开了原先的公司，换了一家初创型的，中间没什么大波折，目前为止一切感觉也都还不错。</p>\n<p>今年两人在一起花销最多的应该就是吃的了，光光自助就去了不止十回了吧，吃进去的是自己的，不亏。</p>\n<p>今年养了一只猫，小时可爱，大了点后皮。手上时不时出现几道划痕。</p>\n<p>今年也没攒什么钱，理财还给理没了一点。</p>\n<p>今年疫情还是伴随在我们身边，时不时搞点大动静。</p>\n<p>今年回家次数明显变少了，好多个节假日也没能回去。</p>\n<p>今年没有写技术文章，已经快废了…… 没有输出</p>\n<p>今年在公司用 python 写了不少代码，学习了 clickhouse、kafka、es…… 还开始自学大数据相关东西，还是得学新东西，能省很多业务操作</p>\n<p>今年收货了很多东西，也开始对未来的规划更加得清晰，有很多种生活的方式，我们只要选择那种适合我们的就行</p>\n<hr>\n<p>最近为了用户行为分析头疼不已，找了一圈也没有什么特别好的方式，只能自己摸着石头过河了。</p>\n"},{"title":"你好，贰叁","date":"2023-01-10T13:10:55.000Z","_content":"\n> 人生不过三两事，如意一天，不如意也是一天。\n\n二二年已然成了过往，美好展望新一年。疫情影响生活三年，各种习性成了习惯，思维也发生了变化。现在随着政策放开，终给这黑天鹅落下了笔。\n\n随着大家逐渐阳康后，新年第一天，同事也差不多都回来了，只是伴随的咳嗽还是不断。我也在元旦前两天中了招，发了两天烧之后身体也开始了快速恢复。这样也好，过年回家就不用再担心感染上躺着过年了。\n\n---\n\n二二年，因为疫情，居家办公过一段不少的日子，也在公司度过了一个三天两晚。由于期间疫情的疯狂介入，导致感觉这一年过得有点迷幻，抗疫抗疫着，半年过去了，再过着过着，就一年了。\n\n这一年，在不确定因素下，我也终于算完成了一件大事。\n\n接下来二三年，会是我的一个大年，这一年要计划完成的事很多，且都不小，希望我能完美完成这些，给自己一个顺意的二三年。\n\n二三年需要做很多抉择，这些抉择很大可能直接或间接得影响到我之后的一个发展道路。工作是为了更好的生活，生活还是要放在第一位，基于现实。\n\n---\n\n总结一年一年写，年纪也随之一年一年长。终到了一个快要突破自我，踏入新身份的节点。当然，伴随着新身份来的同时也定会加大肩上的责任。\n\n\n\n人生匆匆无处寻，仰望星空无人问；\n\n水天一线镜中月，飞鸟过 或圆或缺？\n\n\n\n---\n\n未来会逐渐变好的预期已经出来，各行各业饱受疫情折磨的时候就要过去。对于美好生活的向往是大家的共性，步调一致，方向一致，未来就会一致！二三年，希望是自己的一个大年，拥抱二三！\n\n\n\n你好，贰叁！\n\n\n\n","source":"_posts/hello-2023.md","raw":"---\ntitle: 你好，贰叁\ndate: 2023-01-10 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 人生不过三两事，如意一天，不如意也是一天。\n\n二二年已然成了过往，美好展望新一年。疫情影响生活三年，各种习性成了习惯，思维也发生了变化。现在随着政策放开，终给这黑天鹅落下了笔。\n\n随着大家逐渐阳康后，新年第一天，同事也差不多都回来了，只是伴随的咳嗽还是不断。我也在元旦前两天中了招，发了两天烧之后身体也开始了快速恢复。这样也好，过年回家就不用再担心感染上躺着过年了。\n\n---\n\n二二年，因为疫情，居家办公过一段不少的日子，也在公司度过了一个三天两晚。由于期间疫情的疯狂介入，导致感觉这一年过得有点迷幻，抗疫抗疫着，半年过去了，再过着过着，就一年了。\n\n这一年，在不确定因素下，我也终于算完成了一件大事。\n\n接下来二三年，会是我的一个大年，这一年要计划完成的事很多，且都不小，希望我能完美完成这些，给自己一个顺意的二三年。\n\n二三年需要做很多抉择，这些抉择很大可能直接或间接得影响到我之后的一个发展道路。工作是为了更好的生活，生活还是要放在第一位，基于现实。\n\n---\n\n总结一年一年写，年纪也随之一年一年长。终到了一个快要突破自我，踏入新身份的节点。当然，伴随着新身份来的同时也定会加大肩上的责任。\n\n\n\n人生匆匆无处寻，仰望星空无人问；\n\n水天一线镜中月，飞鸟过 或圆或缺？\n\n\n\n---\n\n未来会逐渐变好的预期已经出来，各行各业饱受疫情折磨的时候就要过去。对于美好生活的向往是大家的共性，步调一致，方向一致，未来就会一致！二三年，希望是自己的一个大年，拥抱二三！\n\n\n\n你好，贰叁！\n\n\n\n","slug":"hello-2023","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhg005lk9i1f7sjhzhm","content":"<blockquote>\n<p>人生不过三两事，如意一天，不如意也是一天。</p>\n</blockquote>\n<p>二二年已然成了过往，美好展望新一年。疫情影响生活三年，各种习性成了习惯，思维也发生了变化。现在随着政策放开，终给这黑天鹅落下了笔。</p>\n<p>随着大家逐渐阳康后，新年第一天，同事也差不多都回来了，只是伴随的咳嗽还是不断。我也在元旦前两天中了招，发了两天烧之后身体也开始了快速恢复。这样也好，过年回家就不用再担心感染上躺着过年了。</p>\n<hr>\n<p>二二年，因为疫情，居家办公过一段不少的日子，也在公司度过了一个三天两晚。由于期间疫情的疯狂介入，导致感觉这一年过得有点迷幻，抗疫抗疫着，半年过去了，再过着过着，就一年了。</p>\n<p>这一年，在不确定因素下，我也终于算完成了一件大事。</p>\n<p>接下来二三年，会是我的一个大年，这一年要计划完成的事很多，且都不小，希望我能完美完成这些，给自己一个顺意的二三年。</p>\n<p>二三年需要做很多抉择，这些抉择很大可能直接或间接得影响到我之后的一个发展道路。工作是为了更好的生活，生活还是要放在第一位，基于现实。</p>\n<hr>\n<p>总结一年一年写，年纪也随之一年一年长。终到了一个快要突破自我，踏入新身份的节点。当然，伴随着新身份来的同时也定会加大肩上的责任。</p>\n<p>人生匆匆无处寻，仰望星空无人问；</p>\n<p>水天一线镜中月，飞鸟过 或圆或缺？</p>\n<hr>\n<p>未来会逐渐变好的预期已经出来，各行各业饱受疫情折磨的时候就要过去。对于美好生活的向往是大家的共性，步调一致，方向一致，未来就会一致！二三年，希望是自己的一个大年，拥抱二三！</p>\n<p>你好，贰叁！</p>\n","excerpt":"","more":"<blockquote>\n<p>人生不过三两事，如意一天，不如意也是一天。</p>\n</blockquote>\n<p>二二年已然成了过往，美好展望新一年。疫情影响生活三年，各种习性成了习惯，思维也发生了变化。现在随着政策放开，终给这黑天鹅落下了笔。</p>\n<p>随着大家逐渐阳康后，新年第一天，同事也差不多都回来了，只是伴随的咳嗽还是不断。我也在元旦前两天中了招，发了两天烧之后身体也开始了快速恢复。这样也好，过年回家就不用再担心感染上躺着过年了。</p>\n<hr>\n<p>二二年，因为疫情，居家办公过一段不少的日子，也在公司度过了一个三天两晚。由于期间疫情的疯狂介入，导致感觉这一年过得有点迷幻，抗疫抗疫着，半年过去了，再过着过着，就一年了。</p>\n<p>这一年，在不确定因素下，我也终于算完成了一件大事。</p>\n<p>接下来二三年，会是我的一个大年，这一年要计划完成的事很多，且都不小，希望我能完美完成这些，给自己一个顺意的二三年。</p>\n<p>二三年需要做很多抉择，这些抉择很大可能直接或间接得影响到我之后的一个发展道路。工作是为了更好的生活，生活还是要放在第一位，基于现实。</p>\n<hr>\n<p>总结一年一年写，年纪也随之一年一年长。终到了一个快要突破自我，踏入新身份的节点。当然，伴随着新身份来的同时也定会加大肩上的责任。</p>\n<p>人生匆匆无处寻，仰望星空无人问；</p>\n<p>水天一线镜中月，飞鸟过 或圆或缺？</p>\n<hr>\n<p>未来会逐渐变好的预期已经出来，各行各业饱受疫情折磨的时候就要过去。对于美好生活的向往是大家的共性，步调一致，方向一致，未来就会一致！二三年，希望是自己的一个大年，拥抱二三！</p>\n<p>你好，贰叁！</p>\n"},{"title":"Hello World","date":"2018-05-21T08:41:51.000Z","_content":"## This is a Test Page ...\n<br>\n## 这是hexo的一个测试","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-05-21 16:41:51\n---\n## This is a Test Page ...\n<br>\n## 这是hexo的一个测试","slug":"hello-world","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhg005pk9i1hilg7ich","content":"<h2 id=\"This-is-a-Test-Page-…\"><a href=\"#This-is-a-Test-Page-…\" class=\"headerlink\" title=\"This is a Test Page …\"></a>This is a Test Page …</h2><br>\n## 这是hexo的一个测试","excerpt":"","more":"<h2 id=\"This-is-a-Test-Page-…\"><a href=\"#This-is-a-Test-Page-…\" class=\"headerlink\" title=\"This is a Test Page …\"></a>This is a Test Page …</h2><br>\n## 这是hexo的一个测试"},{"title":"居家四月（2022）","date":"2022-05-01T13:10:55.000Z","_content":"\n> 从三月到四月，在好转。\n\n\n已经居家办公一月有余，上海这疫情还是没有止住的趋势。前几天新增确诊人数刚有所下降这几天又有继续往上的势头，若股市像这般该有多好。\n\n一眨眼就要到五月份了，一个小长假开始了，然而还是无法出门，只能在这个几十平米的空间自由活动。最近上海的快递开始恢复了，一切看似都在往好的方向发展了。\n\n吃吃喝喝躺躺过五一！","source":"_posts/home-april.md","raw":"\n---\ntitle: 居家四月（2022）\ndate: 2022-05-01 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 从三月到四月，在好转。\n\n\n已经居家办公一月有余，上海这疫情还是没有止住的趋势。前几天新增确诊人数刚有所下降这几天又有继续往上的势头，若股市像这般该有多好。\n\n一眨眼就要到五月份了，一个小长假开始了，然而还是无法出门，只能在这个几十平米的空间自由活动。最近上海的快递开始恢复了，一切看似都在往好的方向发展了。\n\n吃吃喝喝躺躺过五一！","slug":"home-april","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhg005sk9i1g01ue2xz","content":"<blockquote>\n<p>从三月到四月，在好转。</p>\n</blockquote>\n<p>已经居家办公一月有余，上海这疫情还是没有止住的趋势。前几天新增确诊人数刚有所下降这几天又有继续往上的势头，若股市像这般该有多好。</p>\n<p>一眨眼就要到五月份了，一个小长假开始了，然而还是无法出门，只能在这个几十平米的空间自由活动。最近上海的快递开始恢复了，一切看似都在往好的方向发展了。</p>\n<p>吃吃喝喝躺躺过五一！</p>\n","excerpt":"","more":"<blockquote>\n<p>从三月到四月，在好转。</p>\n</blockquote>\n<p>已经居家办公一月有余，上海这疫情还是没有止住的趋势。前几天新增确诊人数刚有所下降这几天又有继续往上的势头，若股市像这般该有多好。</p>\n<p>一眨眼就要到五月份了，一个小长假开始了，然而还是无法出门，只能在这个几十平米的空间自由活动。最近上海的快递开始恢复了，一切看似都在往好的方向发展了。</p>\n<p>吃吃喝喝躺躺过五一！</p>\n"},{"title":"烈日七月（2022）","date":"2022-07-30T13:10:55.000Z","_content":"\n\n二十多年前七月的某一天，我，一个平平无奇的帅小伙，从妈妈的肚子里跑了出来。\n\n今年的上海感觉格外得热，不止上海，周边城市除了高温预警也还是高温预警。甚至都有记者蹲在路边用铁锅炒鸡蛋，纯天然，眼球足够吸引。\n\n前几天回了趟家，约了个顺风车，这也是我第一次从上海回去做顺风车的。本以为是不可能约到的，结果还是个老乡接的单，很巧很巧。路上，很颠很颠，三个小时，时常想吐，回来也是顺风车，一样。三小时的高速路程，看似距离也不是很远，但足够让人感到疲惫。\n\n还好回家了，不然又不知道什么时候才能回去。","source":"_posts/hot-july-2022.md","raw":"---\ntitle: 烈日七月（2022）\ndate: 2022-07-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n\n二十多年前七月的某一天，我，一个平平无奇的帅小伙，从妈妈的肚子里跑了出来。\n\n今年的上海感觉格外得热，不止上海，周边城市除了高温预警也还是高温预警。甚至都有记者蹲在路边用铁锅炒鸡蛋，纯天然，眼球足够吸引。\n\n前几天回了趟家，约了个顺风车，这也是我第一次从上海回去做顺风车的。本以为是不可能约到的，结果还是个老乡接的单，很巧很巧。路上，很颠很颠，三个小时，时常想吐，回来也是顺风车，一样。三小时的高速路程，看似距离也不是很远，但足够让人感到疲惫。\n\n还好回家了，不然又不知道什么时候才能回去。","slug":"hot-july-2022","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhg005wk9i18kroga95","content":"<p>二十多年前七月的某一天，我，一个平平无奇的帅小伙，从妈妈的肚子里跑了出来。</p>\n<p>今年的上海感觉格外得热，不止上海，周边城市除了高温预警也还是高温预警。甚至都有记者蹲在路边用铁锅炒鸡蛋，纯天然，眼球足够吸引。</p>\n<p>前几天回了趟家，约了个顺风车，这也是我第一次从上海回去做顺风车的。本以为是不可能约到的，结果还是个老乡接的单，很巧很巧。路上，很颠很颠，三个小时，时常想吐，回来也是顺风车，一样。三小时的高速路程，看似距离也不是很远，但足够让人感到疲惫。</p>\n<p>还好回家了，不然又不知道什么时候才能回去。</p>\n","excerpt":"","more":"<p>二十多年前七月的某一天，我，一个平平无奇的帅小伙，从妈妈的肚子里跑了出来。</p>\n<p>今年的上海感觉格外得热，不止上海，周边城市除了高温预警也还是高温预警。甚至都有记者蹲在路边用铁锅炒鸡蛋，纯天然，眼球足够吸引。</p>\n<p>前几天回了趟家，约了个顺风车，这也是我第一次从上海回去做顺风车的。本以为是不可能约到的，结果还是个老乡接的单，很巧很巧。路上，很颠很颠，三个小时，时常想吐，回来也是顺风车，一样。三小时的高速路程，看似距离也不是很远，但足够让人感到疲惫。</p>\n<p>还好回家了，不然又不知道什么时候才能回去。</p>\n"},{"title":"热气七月（2023）","date":"2023-08-08T13:10:55.000Z","_content":"\n无它，唯有热。","source":"_posts/hot-july.md","raw":"---\ntitle: 热气七月（2023）\ndate: 2023-08-08 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n无它，唯有热。","slug":"hot-july","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhg0060k9i17zi443lr","content":"<p>无它，唯有热。</p>\n","excerpt":"","more":"<p>无它，唯有热。</p>\n"},{"title":"炎热九月（2021）","date":"2021-09-25T12:10:55.000Z","_content":"\n> 现在有点秋老虎的意思了，虽然前段时间吹了几天台风。\n\n上海台风这个月又刮了一阵子，就在即将要登陆上海的时候它拐弯了，不过我们也没有放假或者在家办公。对了，这个月入职了新公司，就快要一个月了。\n\n打工不易啊，差不多同一时刻来的两个小伙都走了，现在就剩我了，也不知道能呆多久，感觉很不好啊。\n\n中秋回了一趟家带着小邱，回家确实也没什么好逛的，天嘛又热，在家呆了三天。\n\n国庆准备去南通，一个长假，现在就在盼着这个假期了，人活在世，悲一时是时，喜一时也是时，自在就行。\n\n现在搞了辆电瓶车，上班不用那么着急了，差不多都是九点出发。想到给电瓶车上牌照的那个周六早上，真是难从心底来啊。周六七点多出门，到车管所差不多八点，结果前面已经有好几十人在排队，他们有些甚至早上六点就在排了。排队也就算了，那天早上还下起了暴雨，没带伞啊。一直到下午一点多，全身湿透的完事回去了。\n\n太难了，还是早起的鸟儿有虫吃！\n\n今天休息一天，然后上 5 天班就国庆了。\n\n期待国庆！","source":"_posts/hot-september.md","raw":"---\ntitle: 炎热九月（2021）\ndate: 2021-09-25 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 现在有点秋老虎的意思了，虽然前段时间吹了几天台风。\n\n上海台风这个月又刮了一阵子，就在即将要登陆上海的时候它拐弯了，不过我们也没有放假或者在家办公。对了，这个月入职了新公司，就快要一个月了。\n\n打工不易啊，差不多同一时刻来的两个小伙都走了，现在就剩我了，也不知道能呆多久，感觉很不好啊。\n\n中秋回了一趟家带着小邱，回家确实也没什么好逛的，天嘛又热，在家呆了三天。\n\n国庆准备去南通，一个长假，现在就在盼着这个假期了，人活在世，悲一时是时，喜一时也是时，自在就行。\n\n现在搞了辆电瓶车，上班不用那么着急了，差不多都是九点出发。想到给电瓶车上牌照的那个周六早上，真是难从心底来啊。周六七点多出门，到车管所差不多八点，结果前面已经有好几十人在排队，他们有些甚至早上六点就在排了。排队也就算了，那天早上还下起了暴雨，没带伞啊。一直到下午一点多，全身湿透的完事回去了。\n\n太难了，还是早起的鸟儿有虫吃！\n\n今天休息一天，然后上 5 天班就国庆了。\n\n期待国庆！","slug":"hot-september","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhh0064k9i18amgdy4b","content":"<blockquote>\n<p>现在有点秋老虎的意思了，虽然前段时间吹了几天台风。</p>\n</blockquote>\n<p>上海台风这个月又刮了一阵子，就在即将要登陆上海的时候它拐弯了，不过我们也没有放假或者在家办公。对了，这个月入职了新公司，就快要一个月了。</p>\n<p>打工不易啊，差不多同一时刻来的两个小伙都走了，现在就剩我了，也不知道能呆多久，感觉很不好啊。</p>\n<p>中秋回了一趟家带着小邱，回家确实也没什么好逛的，天嘛又热，在家呆了三天。</p>\n<p>国庆准备去南通，一个长假，现在就在盼着这个假期了，人活在世，悲一时是时，喜一时也是时，自在就行。</p>\n<p>现在搞了辆电瓶车，上班不用那么着急了，差不多都是九点出发。想到给电瓶车上牌照的那个周六早上，真是难从心底来啊。周六七点多出门，到车管所差不多八点，结果前面已经有好几十人在排队，他们有些甚至早上六点就在排了。排队也就算了，那天早上还下起了暴雨，没带伞啊。一直到下午一点多，全身湿透的完事回去了。</p>\n<p>太难了，还是早起的鸟儿有虫吃！</p>\n<p>今天休息一天，然后上 5 天班就国庆了。</p>\n<p>期待国庆！</p>\n","excerpt":"","more":"<blockquote>\n<p>现在有点秋老虎的意思了，虽然前段时间吹了几天台风。</p>\n</blockquote>\n<p>上海台风这个月又刮了一阵子，就在即将要登陆上海的时候它拐弯了，不过我们也没有放假或者在家办公。对了，这个月入职了新公司，就快要一个月了。</p>\n<p>打工不易啊，差不多同一时刻来的两个小伙都走了，现在就剩我了，也不知道能呆多久，感觉很不好啊。</p>\n<p>中秋回了一趟家带着小邱，回家确实也没什么好逛的，天嘛又热，在家呆了三天。</p>\n<p>国庆准备去南通，一个长假，现在就在盼着这个假期了，人活在世，悲一时是时，喜一时也是时，自在就行。</p>\n<p>现在搞了辆电瓶车，上班不用那么着急了，差不多都是九点出发。想到给电瓶车上牌照的那个周六早上，真是难从心底来啊。周六七点多出门，到车管所差不多八点，结果前面已经有好几十人在排队，他们有些甚至早上六点就在排了。排队也就算了，那天早上还下起了暴雨，没带伞啊。一直到下午一点多，全身湿透的完事回去了。</p>\n<p>太难了，还是早起的鸟儿有虫吃！</p>\n<p>今天休息一天，然后上 5 天班就国庆了。</p>\n<p>期待国庆！</p>\n"},{"title":"匆赶三月（2021）","date":"2021-03-31T12:10:55.000Z","_content":"\n> 刚过完年，组内人员就少了两，即将三……\n\n令人放松、悠闲的二月匆匆过去，转头来便是深夜地铁，沾床就睡的三月。\n\n公司里呆着超过一年的就算老员工了，很快，我就是老员工了……\n\n人员的减少不可避免伴随工作量的增多，再加上项目的紧张，结果就是没有双休的周末和每晚疲惫的身躯。\n\n就这样吧，Q2开始了，Q1又延期了……","source":"_posts/hurry-march.md","raw":"---\ntitle: 匆赶三月（2021）\ndate: 2021-03-31 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 刚过完年，组内人员就少了两，即将三……\n\n令人放松、悠闲的二月匆匆过去，转头来便是深夜地铁，沾床就睡的三月。\n\n公司里呆着超过一年的就算老员工了，很快，我就是老员工了……\n\n人员的减少不可避免伴随工作量的增多，再加上项目的紧张，结果就是没有双休的周末和每晚疲惫的身躯。\n\n就这样吧，Q2开始了，Q1又延期了……","slug":"hurry-march","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhh0067k9i13t9u1x7l","content":"<blockquote>\n<p>刚过完年，组内人员就少了两，即将三……</p>\n</blockquote>\n<p>令人放松、悠闲的二月匆匆过去，转头来便是深夜地铁，沾床就睡的三月。</p>\n<p>公司里呆着超过一年的就算老员工了，很快，我就是老员工了……</p>\n<p>人员的减少不可避免伴随工作量的增多，再加上项目的紧张，结果就是没有双休的周末和每晚疲惫的身躯。</p>\n<p>就这样吧，Q2开始了，Q1又延期了……</p>\n","excerpt":"","more":"<blockquote>\n<p>刚过完年，组内人员就少了两，即将三……</p>\n</blockquote>\n<p>令人放松、悠闲的二月匆匆过去，转头来便是深夜地铁，沾床就睡的三月。</p>\n<p>公司里呆着超过一年的就算老员工了，很快，我就是老员工了……</p>\n<p>人员的减少不可避免伴随工作量的增多，再加上项目的紧张，结果就是没有双休的周末和每晚疲惫的身躯。</p>\n<p>就这样吧，Q2开始了，Q1又延期了……</p>\n"},{"title":"indexedDB数据库使用总结","date":"2018-07-10T05:15:45.000Z","_content":"## indexedDB简介\nindexedDB是一个前端存储数据库，之前也没有什么了解，这次项目中需要用到，然后就去找了相关资料。数据库有两种，一种是关系型数据库，另一种是非关系型数据库。indexedDB是第二种，它是非关系型数据库，它不需要你去写一些特定的sql语句来对数据库进行操作，数据形式使用的是json。\n\n## 与其他前端存储方式对比\n>\n也许熟悉前端存储的会说，不是有了LocalStorage和Cookies吗？为什么还要推出indexedDB呢？其实对于在浏览器里存储数据，你可以使用cookies或local storage，但它们都是比较简单的技术，而IndexedDB提供了类似数据库风格的数据存储和使用方式。\n\n>首先说说Cookies，英文直接翻译过来就是小甜点，听起来很好吃，实际上并不是，每次HTTP接受和发送都会传递Cookies数据，它会占用额外的流量。例如，如果你有一个10KB的Cookies数据，发送10次请求，那么，总计就会有100KB的数据在网络上传输。Cookies只能是字符串。浏览器里存储Cookies的空间有限，很多用户禁止浏览器使用Cookies。所以，Cookies只能用来存储小量的非关键的数据。\n\n>其次说说LocalStorage，LocalStorage是用key-value键值模式存储数据，但跟IndexedDB不一样的是，它的数据并不是按对象形式存储。它存储的数据都是字符串形式。如果你想让LocalStorage存储对象，你需要借助JSON.stringify()能将对象变成字符串形式，再用JSON.parse()将字符串还原成对象。但如果要存储大量的复杂的数据，这并不是一种很好的方案。毕竟，localstorage就是专门为小数量数据设计的，所以它的api设计为同步的。而IndexedDB很适合存储大量数据，它的API是异步调用的。IndexedDB使用索引存储数据，各种数据库操作放在事务中执行。IndexedDB甚至还支持简单的数据类型。IndexedDB比localstorage强大得多，但它的API也相对复杂。对于简单的数据，你应该继续使用localstorage，但当你希望存储大量数据时，IndexedDB会明显的更适合，IndexedDB能提供你更为复杂的查询数据的方式。\n\n## indexedDB特性\n- 对象仓库\nindexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。我们可以使用每条记录中的某个指定字段作为键值（keyPath），也可以使用自动生成的递增数字作为键值（keyGenerator），也可以不指定。选择键的类型不同，objectStore可以存储的数据结构也有差异。\n<table>\n<thead>\n<tr class=\"header\">\n<th>键类型</th>\n<th>存储数据</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>不使用</td>\n<td>任意值，但是每添加一条数据的时候，需指定键参数</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath</td>\n<td>对象，eg: {keyPath: 'id'}</td>\n</tr>\n<tr class=\"odd\">\n<td>keyGenerator</td>\n<td>任意值 eg: {autoincrement: true}</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath and KeyGenerator 都使用</td>\n<td>对象，如果对象中有keyPath指定的属性则不生成新的键值，如果没有自动生成递增键值，填充keyPath指定的属性</td>\n</tr>\n</tbody>\n</table>\n\n- 事务性\n在indexedDB中，每一个对数据库操作是在一个事务的上下文中执行的。事务范围一次影响一个或多个object stores，你通过传入一个object store名字的数组到创建事务范围的函数来定义。例如：db.transaction(storeName, 'readwrite')，创建事务的第二个参数是事务模式。当请求一个事务时,必须决定是按照只读还是读写模式请求访问。\n\n- 基于请求\n对indexedDB数据库的每次操作，描述为通过一个请求打开数据库,访问一个object store，再继续。IndexedDB API天生是基于请求的,这也是API异步本性指示。对于你在数据库执行的每次操作,你必须首先为这个操作创建一个请求。当请求完成,你可以响应由请求结果产生的事件和错误。\n\n- 异步\n在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求—响应的模式，所谓异步API是指并不是这条指令执行完毕，我们就可以使用request.result来获取indexedDB对象了，就像使用ajax一样，语句执行完并不代表已经获取到了对象，所以我们一般在其回调函数中处理。\n\n## 使用示例\n### 打开数据库\n- 判断浏览器是否支持indexedDB数据库\n```\nvar indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;\nif(!indexedDB)\n{\n    console.log(\"你的浏览器不支持IndexedDB\");\n}\n```\n- 创建请求打开indexedDB,IndexedDB需要你创建一个请求来打开它。<br>\n```\nvar request = indexedDB.open(name, version);\n```\n第一个参数是数据库的名称，第二个参数是数据库的版本号。版本号可以在升级数据库时用来调整数据库结构和数据。但你增加数据库版本号时，会触发onupgradeneeded事件，这时可能会出现成功、失败和阻止事件三种情况：\n```\nrequest.onerror = function(e) { // 失败\n        console.log(e.currentTarget.error.message);\n    };\n\n    request.onsuccess = function(e) {   // 成功\n        myDB.db = e.target.result;\n        console.log('成功打开DB');\n    };\n\n    request.onupgradeneeded = function(e) {\n        var db = e.target.result;\n        if (!db.objectStoreNames.contains('person')) {\n            console.log(\"我需要创建一个新的存储对象\");\n            //如果表格不存在，创建一个新的表格（keyPath，主键 ； autoIncrement,是否自增），会返回一个对象（objectStore）\n            var objectStore = db.createObjectStore('person', {\n                keyPath: \"id\",\n                autoIncrement: true\n            });\n\n            //指定可以被索引的字段，unique字段是否唯一\n\n            objectStore.createIndex(\"name\", \"name\", {\n                unique: false\n            });\n\n            objectStore.createIndex(\"phone\", \"phone\", {\n                unique: false\n            });\n\n        }\n        console.log('数据库版本更改为： ' + version);\n};\n```\nonupgradeneeded事件在第一次打开页面初始化数据库时会被调用，或在当有版本号变化时。所以，你应该在onupgradeneeded函数里创建你的存储数据。如果没有版本号变化，而且页面之前被打开过，你会获得一个onsuccess事件。\n\n### 添加数据\n- 创建一个事务，并要求具有读写权限\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n```\n- 获取objectStore，调用add方法添加数据\n```\nvar store = transaction.objectStore(storeName); //访问事务中的objectStore\n        data.forEach(function (item) {\n            store.add(item);//保存数据\n        });\n```\n\n### 删除数据\n- 创建事务，然后调用删除接口，通过key删除对象\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n\nvar store = transaction.objectStore(storeName);\n\nstore.delete(key);\n```\n\n### 查找数据\n- 按key查找 开启事务，获取objectStore，调用往get()方法，往方法里传入对象的key值，取出相应的对象\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n\n    var store = transaction.objectStore(storeName);\n\n    var request = store.get(key);\n\n    request.onsuccess = function(e) {\n\n        data = e.target.result;\n\n        console.log(student.name);\n\n};\n```\n- 使用索引查找\n```\nvar transaction = db.transaction(storeName);\n\n    var store = transaction.objectStore(storeName);\n\n    var index = store.index(search_index);\n\n    index.get(value).onsuccess = function(e) {\n\n        data = e.target.result;\n\n        console.log(student.id);\n\n}\n```\n- 游标遍历数据\n```\nvar transaction = db.transaction(storeName);\n\n    var store = transaction.objectStore(storeName);\n\n    var request = store.openCursor();//打开游标\n\n    var dataList = new Array();\n\n    var i = 0;\n\n    request.onsuccess = function(e) {\n\n        var cursor = e.target.result;\n\n        if (cursor) {\n\n            console.log(cursor.key);\n\n            dataList[i] = cursor.value;\n\n            console.log(dataList[i].name);\n\n            i++;\n\n            cursor.continue();\n\n        }\n\n        data = dataList;\n\n};\n```\n\n### 更新对象\n    更新对象，首先要把它取出来，修改，然后再放回去。\n\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n\n    var store = transaction.objectStore(storeName);\n\n    var request = store.get(key);\n\n    request.onsuccess = function(e) {\n\n        var data = e.target.result;\n\n        for (a in newData) {\n\n            //除了keypath之外\n\n \n\n            data.a = newData.a;\n\n        }\n\n        store.put(data);\n\n};\n```\n\n### 关闭与删除数据库\n    关闭数据库可以直接调用数据库对象的close方法\n```\nfunction closeDB(db) {\n\n    db.close();\n\n}\n```\n\n    删除数据库使用数据库对象的deleteDatabase方法\n```\nfunction deleteDB(name) {\n\n    indexedDB.deleteDatabase(name);\n\n}\n```\n\n## 参考资料\n- [前端存储之indexedDB](https://www.cnblogs.com/dengyulinBlog/p/6141636.html)\n- [客户端持久化解决方案：indexedDB](https://www.cnblogs.com/stephenykk/p/6080720.html)","source":"_posts/indexedDB.md","raw":"---\ntitle: indexedDB数据库使用总结\ndate: 2018-07-10 13:15:45\ncategories: [开发,总结]\ntags: [indexedDB]\n---\n## indexedDB简介\nindexedDB是一个前端存储数据库，之前也没有什么了解，这次项目中需要用到，然后就去找了相关资料。数据库有两种，一种是关系型数据库，另一种是非关系型数据库。indexedDB是第二种，它是非关系型数据库，它不需要你去写一些特定的sql语句来对数据库进行操作，数据形式使用的是json。\n\n## 与其他前端存储方式对比\n>\n也许熟悉前端存储的会说，不是有了LocalStorage和Cookies吗？为什么还要推出indexedDB呢？其实对于在浏览器里存储数据，你可以使用cookies或local storage，但它们都是比较简单的技术，而IndexedDB提供了类似数据库风格的数据存储和使用方式。\n\n>首先说说Cookies，英文直接翻译过来就是小甜点，听起来很好吃，实际上并不是，每次HTTP接受和发送都会传递Cookies数据，它会占用额外的流量。例如，如果你有一个10KB的Cookies数据，发送10次请求，那么，总计就会有100KB的数据在网络上传输。Cookies只能是字符串。浏览器里存储Cookies的空间有限，很多用户禁止浏览器使用Cookies。所以，Cookies只能用来存储小量的非关键的数据。\n\n>其次说说LocalStorage，LocalStorage是用key-value键值模式存储数据，但跟IndexedDB不一样的是，它的数据并不是按对象形式存储。它存储的数据都是字符串形式。如果你想让LocalStorage存储对象，你需要借助JSON.stringify()能将对象变成字符串形式，再用JSON.parse()将字符串还原成对象。但如果要存储大量的复杂的数据，这并不是一种很好的方案。毕竟，localstorage就是专门为小数量数据设计的，所以它的api设计为同步的。而IndexedDB很适合存储大量数据，它的API是异步调用的。IndexedDB使用索引存储数据，各种数据库操作放在事务中执行。IndexedDB甚至还支持简单的数据类型。IndexedDB比localstorage强大得多，但它的API也相对复杂。对于简单的数据，你应该继续使用localstorage，但当你希望存储大量数据时，IndexedDB会明显的更适合，IndexedDB能提供你更为复杂的查询数据的方式。\n\n## indexedDB特性\n- 对象仓库\nindexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。我们可以使用每条记录中的某个指定字段作为键值（keyPath），也可以使用自动生成的递增数字作为键值（keyGenerator），也可以不指定。选择键的类型不同，objectStore可以存储的数据结构也有差异。\n<table>\n<thead>\n<tr class=\"header\">\n<th>键类型</th>\n<th>存储数据</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>不使用</td>\n<td>任意值，但是每添加一条数据的时候，需指定键参数</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath</td>\n<td>对象，eg: {keyPath: 'id'}</td>\n</tr>\n<tr class=\"odd\">\n<td>keyGenerator</td>\n<td>任意值 eg: {autoincrement: true}</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath and KeyGenerator 都使用</td>\n<td>对象，如果对象中有keyPath指定的属性则不生成新的键值，如果没有自动生成递增键值，填充keyPath指定的属性</td>\n</tr>\n</tbody>\n</table>\n\n- 事务性\n在indexedDB中，每一个对数据库操作是在一个事务的上下文中执行的。事务范围一次影响一个或多个object stores，你通过传入一个object store名字的数组到创建事务范围的函数来定义。例如：db.transaction(storeName, 'readwrite')，创建事务的第二个参数是事务模式。当请求一个事务时,必须决定是按照只读还是读写模式请求访问。\n\n- 基于请求\n对indexedDB数据库的每次操作，描述为通过一个请求打开数据库,访问一个object store，再继续。IndexedDB API天生是基于请求的,这也是API异步本性指示。对于你在数据库执行的每次操作,你必须首先为这个操作创建一个请求。当请求完成,你可以响应由请求结果产生的事件和错误。\n\n- 异步\n在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求—响应的模式，所谓异步API是指并不是这条指令执行完毕，我们就可以使用request.result来获取indexedDB对象了，就像使用ajax一样，语句执行完并不代表已经获取到了对象，所以我们一般在其回调函数中处理。\n\n## 使用示例\n### 打开数据库\n- 判断浏览器是否支持indexedDB数据库\n```\nvar indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;\nif(!indexedDB)\n{\n    console.log(\"你的浏览器不支持IndexedDB\");\n}\n```\n- 创建请求打开indexedDB,IndexedDB需要你创建一个请求来打开它。<br>\n```\nvar request = indexedDB.open(name, version);\n```\n第一个参数是数据库的名称，第二个参数是数据库的版本号。版本号可以在升级数据库时用来调整数据库结构和数据。但你增加数据库版本号时，会触发onupgradeneeded事件，这时可能会出现成功、失败和阻止事件三种情况：\n```\nrequest.onerror = function(e) { // 失败\n        console.log(e.currentTarget.error.message);\n    };\n\n    request.onsuccess = function(e) {   // 成功\n        myDB.db = e.target.result;\n        console.log('成功打开DB');\n    };\n\n    request.onupgradeneeded = function(e) {\n        var db = e.target.result;\n        if (!db.objectStoreNames.contains('person')) {\n            console.log(\"我需要创建一个新的存储对象\");\n            //如果表格不存在，创建一个新的表格（keyPath，主键 ； autoIncrement,是否自增），会返回一个对象（objectStore）\n            var objectStore = db.createObjectStore('person', {\n                keyPath: \"id\",\n                autoIncrement: true\n            });\n\n            //指定可以被索引的字段，unique字段是否唯一\n\n            objectStore.createIndex(\"name\", \"name\", {\n                unique: false\n            });\n\n            objectStore.createIndex(\"phone\", \"phone\", {\n                unique: false\n            });\n\n        }\n        console.log('数据库版本更改为： ' + version);\n};\n```\nonupgradeneeded事件在第一次打开页面初始化数据库时会被调用，或在当有版本号变化时。所以，你应该在onupgradeneeded函数里创建你的存储数据。如果没有版本号变化，而且页面之前被打开过，你会获得一个onsuccess事件。\n\n### 添加数据\n- 创建一个事务，并要求具有读写权限\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n```\n- 获取objectStore，调用add方法添加数据\n```\nvar store = transaction.objectStore(storeName); //访问事务中的objectStore\n        data.forEach(function (item) {\n            store.add(item);//保存数据\n        });\n```\n\n### 删除数据\n- 创建事务，然后调用删除接口，通过key删除对象\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n\nvar store = transaction.objectStore(storeName);\n\nstore.delete(key);\n```\n\n### 查找数据\n- 按key查找 开启事务，获取objectStore，调用往get()方法，往方法里传入对象的key值，取出相应的对象\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n\n    var store = transaction.objectStore(storeName);\n\n    var request = store.get(key);\n\n    request.onsuccess = function(e) {\n\n        data = e.target.result;\n\n        console.log(student.name);\n\n};\n```\n- 使用索引查找\n```\nvar transaction = db.transaction(storeName);\n\n    var store = transaction.objectStore(storeName);\n\n    var index = store.index(search_index);\n\n    index.get(value).onsuccess = function(e) {\n\n        data = e.target.result;\n\n        console.log(student.id);\n\n}\n```\n- 游标遍历数据\n```\nvar transaction = db.transaction(storeName);\n\n    var store = transaction.objectStore(storeName);\n\n    var request = store.openCursor();//打开游标\n\n    var dataList = new Array();\n\n    var i = 0;\n\n    request.onsuccess = function(e) {\n\n        var cursor = e.target.result;\n\n        if (cursor) {\n\n            console.log(cursor.key);\n\n            dataList[i] = cursor.value;\n\n            console.log(dataList[i].name);\n\n            i++;\n\n            cursor.continue();\n\n        }\n\n        data = dataList;\n\n};\n```\n\n### 更新对象\n    更新对象，首先要把它取出来，修改，然后再放回去。\n\n```\nvar transaction = db.transaction(storeName, 'readwrite');\n\n    var store = transaction.objectStore(storeName);\n\n    var request = store.get(key);\n\n    request.onsuccess = function(e) {\n\n        var data = e.target.result;\n\n        for (a in newData) {\n\n            //除了keypath之外\n\n \n\n            data.a = newData.a;\n\n        }\n\n        store.put(data);\n\n};\n```\n\n### 关闭与删除数据库\n    关闭数据库可以直接调用数据库对象的close方法\n```\nfunction closeDB(db) {\n\n    db.close();\n\n}\n```\n\n    删除数据库使用数据库对象的deleteDatabase方法\n```\nfunction deleteDB(name) {\n\n    indexedDB.deleteDatabase(name);\n\n}\n```\n\n## 参考资料\n- [前端存储之indexedDB](https://www.cnblogs.com/dengyulinBlog/p/6141636.html)\n- [客户端持久化解决方案：indexedDB](https://www.cnblogs.com/stephenykk/p/6080720.html)","slug":"indexedDB","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhh006ak9i19d8ug2kz","content":"<h2 id=\"indexedDB简介\"><a href=\"#indexedDB简介\" class=\"headerlink\" title=\"indexedDB简介\"></a>indexedDB简介</h2><p>indexedDB是一个前端存储数据库，之前也没有什么了解，这次项目中需要用到，然后就去找了相关资料。数据库有两种，一种是关系型数据库，另一种是非关系型数据库。indexedDB是第二种，它是非关系型数据库，它不需要你去写一些特定的sql语句来对数据库进行操作，数据形式使用的是json。</p>\n<h2 id=\"与其他前端存储方式对比\"><a href=\"#与其他前端存储方式对比\" class=\"headerlink\" title=\"与其他前端存储方式对比\"></a>与其他前端存储方式对比</h2><blockquote>\n</blockquote>\n<p>也许熟悉前端存储的会说，不是有了LocalStorage和Cookies吗？为什么还要推出indexedDB呢？其实对于在浏览器里存储数据，你可以使用cookies或local storage，但它们都是比较简单的技术，而IndexedDB提供了类似数据库风格的数据存储和使用方式。</p>\n<blockquote>\n<p>首先说说Cookies，英文直接翻译过来就是小甜点，听起来很好吃，实际上并不是，每次HTTP接受和发送都会传递Cookies数据，它会占用额外的流量。例如，如果你有一个10KB的Cookies数据，发送10次请求，那么，总计就会有100KB的数据在网络上传输。Cookies只能是字符串。浏览器里存储Cookies的空间有限，很多用户禁止浏览器使用Cookies。所以，Cookies只能用来存储小量的非关键的数据。</p>\n</blockquote>\n<blockquote>\n<p>其次说说LocalStorage，LocalStorage是用key-value键值模式存储数据，但跟IndexedDB不一样的是，它的数据并不是按对象形式存储。它存储的数据都是字符串形式。如果你想让LocalStorage存储对象，你需要借助JSON.stringify()能将对象变成字符串形式，再用JSON.parse()将字符串还原成对象。但如果要存储大量的复杂的数据，这并不是一种很好的方案。毕竟，localstorage就是专门为小数量数据设计的，所以它的api设计为同步的。而IndexedDB很适合存储大量数据，它的API是异步调用的。IndexedDB使用索引存储数据，各种数据库操作放在事务中执行。IndexedDB甚至还支持简单的数据类型。IndexedDB比localstorage强大得多，但它的API也相对复杂。对于简单的数据，你应该继续使用localstorage，但当你希望存储大量数据时，IndexedDB会明显的更适合，IndexedDB能提供你更为复杂的查询数据的方式。</p>\n</blockquote>\n<h2 id=\"indexedDB特性\"><a href=\"#indexedDB特性\" class=\"headerlink\" title=\"indexedDB特性\"></a>indexedDB特性</h2><ul>\n<li><p>对象仓库<br>indexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。我们可以使用每条记录中的某个指定字段作为键值（keyPath），也可以使用自动生成的递增数字作为键值（keyGenerator），也可以不指定。选择键的类型不同，objectStore可以存储的数据结构也有差异。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>键类型</th>\n<th>存储数据</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>不使用</td>\n<td>任意值，但是每添加一条数据的时候，需指定键参数</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath</td>\n<td>对象，eg: {keyPath: 'id'}</td>\n</tr>\n<tr class=\"odd\">\n<td>keyGenerator</td>\n<td>任意值 eg: {autoincrement: true}</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath and KeyGenerator 都使用</td>\n<td>对象，如果对象中有keyPath指定的属性则不生成新的键值，如果没有自动生成递增键值，填充keyPath指定的属性</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li><p>事务性<br>在indexedDB中，每一个对数据库操作是在一个事务的上下文中执行的。事务范围一次影响一个或多个object stores，你通过传入一个object store名字的数组到创建事务范围的函数来定义。例如：db.transaction(storeName, ‘readwrite’)，创建事务的第二个参数是事务模式。当请求一个事务时,必须决定是按照只读还是读写模式请求访问。</p>\n</li>\n<li><p>基于请求<br>对indexedDB数据库的每次操作，描述为通过一个请求打开数据库,访问一个object store，再继续。IndexedDB API天生是基于请求的,这也是API异步本性指示。对于你在数据库执行的每次操作,你必须首先为这个操作创建一个请求。当请求完成,你可以响应由请求结果产生的事件和错误。</p>\n</li>\n<li><p>异步<br>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求—响应的模式，所谓异步API是指并不是这条指令执行完毕，我们就可以使用request.result来获取indexedDB对象了，就像使用ajax一样，语句执行完并不代表已经获取到了对象，所以我们一般在其回调函数中处理。</p>\n</li>\n</ul>\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><h3 id=\"打开数据库\"><a href=\"#打开数据库\" class=\"headerlink\" title=\"打开数据库\"></a>打开数据库</h3><ul>\n<li>判断浏览器是否支持indexedDB数据库<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;</span><br><span class=\"line\">if(!indexedDB)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    console.log(&quot;你的浏览器不支持IndexedDB&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>创建请求打开indexedDB,IndexedDB需要你创建一个请求来打开它。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = indexedDB.open(name, version);</span><br></pre></td></tr></table></figure>\n第一个参数是数据库的名称，第二个参数是数据库的版本号。版本号可以在升级数据库时用来调整数据库结构和数据。但你增加数据库版本号时，会触发onupgradeneeded事件，这时可能会出现成功、失败和阻止事件三种情况：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onerror = function(e) &#123; // 失败</span><br><span class=\"line\">        console.log(e.currentTarget.error.message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;   // 成功</span><br><span class=\"line\">        myDB.db = e.target.result;</span><br><span class=\"line\">        console.log(&#x27;成功打开DB&#x27;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onupgradeneeded = function(e) &#123;</span><br><span class=\"line\">        var db = e.target.result;</span><br><span class=\"line\">        if (!db.objectStoreNames.contains(&#x27;person&#x27;)) &#123;</span><br><span class=\"line\">            console.log(&quot;我需要创建一个新的存储对象&quot;);</span><br><span class=\"line\">            //如果表格不存在，创建一个新的表格（keyPath，主键 ； autoIncrement,是否自增），会返回一个对象（objectStore）</span><br><span class=\"line\">            var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;</span><br><span class=\"line\">                keyPath: &quot;id&quot;,</span><br><span class=\"line\">                autoIncrement: true</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            //指定可以被索引的字段，unique字段是否唯一</span><br><span class=\"line\"></span><br><span class=\"line\">            objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123;</span><br><span class=\"line\">                unique: false</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            objectStore.createIndex(&quot;phone&quot;, &quot;phone&quot;, &#123;</span><br><span class=\"line\">                unique: false</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&#x27;数据库版本更改为： &#x27; + version);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\nonupgradeneeded事件在第一次打开页面初始化数据库时会被调用，或在当有版本号变化时。所以，你应该在onupgradeneeded函数里创建你的存储数据。如果没有版本号变化，而且页面之前被打开过，你会获得一个onsuccess事件。</li>\n</ul>\n<h3 id=\"添加数据\"><a href=\"#添加数据\" class=\"headerlink\" title=\"添加数据\"></a>添加数据</h3><ul>\n<li>创建一个事务，并要求具有读写权限<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br></pre></td></tr></table></figure></li>\n<li>获取objectStore，调用add方法添加数据<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var store = transaction.objectStore(storeName); //访问事务中的objectStore</span><br><span class=\"line\">        data.forEach(function (item) &#123;</span><br><span class=\"line\">            store.add(item);//保存数据</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><ul>\n<li>创建事务，然后调用删除接口，通过key删除对象<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">store.delete(key);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h3><ul>\n<li>按key查找 开启事务，获取objectStore，调用往get()方法，往方法里传入对象的key值，取出相应的对象<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var request = store.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log(student.name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>使用索引查找<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var index = store.index(search_index);</span><br><span class=\"line\"></span><br><span class=\"line\">    index.get(value).onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log(student.id);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>游标遍历数据<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var request = store.openCursor();//打开游标</span><br><span class=\"line\"></span><br><span class=\"line\">    var dataList = new Array();</span><br><span class=\"line\"></span><br><span class=\"line\">    var i = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        var cursor = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (cursor) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            console.log(cursor.key);</span><br><span class=\"line\"></span><br><span class=\"line\">            dataList[i] = cursor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">            console.log(dataList[i].name);</span><br><span class=\"line\"></span><br><span class=\"line\">            i++;</span><br><span class=\"line\"></span><br><span class=\"line\">            cursor.continue();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = dataList;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"更新对象\"><a href=\"#更新对象\" class=\"headerlink\" title=\"更新对象\"></a>更新对象</h3><pre><code>更新对象，首先要把它取出来，修改，然后再放回去。\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var request = store.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        var data = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (a in newData) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            //除了keypath之外</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">            data.a = newData.a;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        store.put(data);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭与删除数据库\"><a href=\"#关闭与删除数据库\" class=\"headerlink\" title=\"关闭与删除数据库\"></a>关闭与删除数据库</h3><pre><code>关闭数据库可以直接调用数据库对象的close方法\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function closeDB(db) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    db.close();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>删除数据库使用数据库对象的deleteDatabase方法\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deleteDB(name) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    indexedDB.deleteDatabase(name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.cnblogs.com/dengyulinBlog/p/6141636.html\">前端存储之indexedDB</a></li>\n<li><a href=\"https://www.cnblogs.com/stephenykk/p/6080720.html\">客户端持久化解决方案：indexedDB</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"indexedDB简介\"><a href=\"#indexedDB简介\" class=\"headerlink\" title=\"indexedDB简介\"></a>indexedDB简介</h2><p>indexedDB是一个前端存储数据库，之前也没有什么了解，这次项目中需要用到，然后就去找了相关资料。数据库有两种，一种是关系型数据库，另一种是非关系型数据库。indexedDB是第二种，它是非关系型数据库，它不需要你去写一些特定的sql语句来对数据库进行操作，数据形式使用的是json。</p>\n<h2 id=\"与其他前端存储方式对比\"><a href=\"#与其他前端存储方式对比\" class=\"headerlink\" title=\"与其他前端存储方式对比\"></a>与其他前端存储方式对比</h2><blockquote>\n</blockquote>\n<p>也许熟悉前端存储的会说，不是有了LocalStorage和Cookies吗？为什么还要推出indexedDB呢？其实对于在浏览器里存储数据，你可以使用cookies或local storage，但它们都是比较简单的技术，而IndexedDB提供了类似数据库风格的数据存储和使用方式。</p>\n<blockquote>\n<p>首先说说Cookies，英文直接翻译过来就是小甜点，听起来很好吃，实际上并不是，每次HTTP接受和发送都会传递Cookies数据，它会占用额外的流量。例如，如果你有一个10KB的Cookies数据，发送10次请求，那么，总计就会有100KB的数据在网络上传输。Cookies只能是字符串。浏览器里存储Cookies的空间有限，很多用户禁止浏览器使用Cookies。所以，Cookies只能用来存储小量的非关键的数据。</p>\n</blockquote>\n<blockquote>\n<p>其次说说LocalStorage，LocalStorage是用key-value键值模式存储数据，但跟IndexedDB不一样的是，它的数据并不是按对象形式存储。它存储的数据都是字符串形式。如果你想让LocalStorage存储对象，你需要借助JSON.stringify()能将对象变成字符串形式，再用JSON.parse()将字符串还原成对象。但如果要存储大量的复杂的数据，这并不是一种很好的方案。毕竟，localstorage就是专门为小数量数据设计的，所以它的api设计为同步的。而IndexedDB很适合存储大量数据，它的API是异步调用的。IndexedDB使用索引存储数据，各种数据库操作放在事务中执行。IndexedDB甚至还支持简单的数据类型。IndexedDB比localstorage强大得多，但它的API也相对复杂。对于简单的数据，你应该继续使用localstorage，但当你希望存储大量数据时，IndexedDB会明显的更适合，IndexedDB能提供你更为复杂的查询数据的方式。</p>\n</blockquote>\n<h2 id=\"indexedDB特性\"><a href=\"#indexedDB特性\" class=\"headerlink\" title=\"indexedDB特性\"></a>indexedDB特性</h2><ul>\n<li><p>对象仓库<br>indexedDB中没有表的概念，而是objectStore，一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。也就是说一个objectStore相当于一张表，里面存储的每条数据和一个键相关联。我们可以使用每条记录中的某个指定字段作为键值（keyPath），也可以使用自动生成的递增数字作为键值（keyGenerator），也可以不指定。选择键的类型不同，objectStore可以存储的数据结构也有差异。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>键类型</th>\n<th>存储数据</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>不使用</td>\n<td>任意值，但是每添加一条数据的时候，需指定键参数</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath</td>\n<td>对象，eg: {keyPath: 'id'}</td>\n</tr>\n<tr class=\"odd\">\n<td>keyGenerator</td>\n<td>任意值 eg: {autoincrement: true}</td>\n</tr>\n<tr class=\"even\">\n<td>keyPath and KeyGenerator 都使用</td>\n<td>对象，如果对象中有keyPath指定的属性则不生成新的键值，如果没有自动生成递增键值，填充keyPath指定的属性</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li><p>事务性<br>在indexedDB中，每一个对数据库操作是在一个事务的上下文中执行的。事务范围一次影响一个或多个object stores，你通过传入一个object store名字的数组到创建事务范围的函数来定义。例如：db.transaction(storeName, ‘readwrite’)，创建事务的第二个参数是事务模式。当请求一个事务时,必须决定是按照只读还是读写模式请求访问。</p>\n</li>\n<li><p>基于请求<br>对indexedDB数据库的每次操作，描述为通过一个请求打开数据库,访问一个object store，再继续。IndexedDB API天生是基于请求的,这也是API异步本性指示。对于你在数据库执行的每次操作,你必须首先为这个操作创建一个请求。当请求完成,你可以响应由请求结果产生的事件和错误。</p>\n</li>\n<li><p>异步<br>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求—响应的模式，所谓异步API是指并不是这条指令执行完毕，我们就可以使用request.result来获取indexedDB对象了，就像使用ajax一样，语句执行完并不代表已经获取到了对象，所以我们一般在其回调函数中处理。</p>\n</li>\n</ul>\n<h2 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h2><h3 id=\"打开数据库\"><a href=\"#打开数据库\" class=\"headerlink\" title=\"打开数据库\"></a>打开数据库</h3><ul>\n<li>判断浏览器是否支持indexedDB数据库<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;</span><br><span class=\"line\">if(!indexedDB)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    console.log(&quot;你的浏览器不支持IndexedDB&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>创建请求打开indexedDB,IndexedDB需要你创建一个请求来打开它。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var request = indexedDB.open(name, version);</span><br></pre></td></tr></table></figure>\n第一个参数是数据库的名称，第二个参数是数据库的版本号。版本号可以在升级数据库时用来调整数据库结构和数据。但你增加数据库版本号时，会触发onupgradeneeded事件，这时可能会出现成功、失败和阻止事件三种情况：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.onerror = function(e) &#123; // 失败</span><br><span class=\"line\">        console.log(e.currentTarget.error.message);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;   // 成功</span><br><span class=\"line\">        myDB.db = e.target.result;</span><br><span class=\"line\">        console.log(&#x27;成功打开DB&#x27;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onupgradeneeded = function(e) &#123;</span><br><span class=\"line\">        var db = e.target.result;</span><br><span class=\"line\">        if (!db.objectStoreNames.contains(&#x27;person&#x27;)) &#123;</span><br><span class=\"line\">            console.log(&quot;我需要创建一个新的存储对象&quot;);</span><br><span class=\"line\">            //如果表格不存在，创建一个新的表格（keyPath，主键 ； autoIncrement,是否自增），会返回一个对象（objectStore）</span><br><span class=\"line\">            var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;</span><br><span class=\"line\">                keyPath: &quot;id&quot;,</span><br><span class=\"line\">                autoIncrement: true</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            //指定可以被索引的字段，unique字段是否唯一</span><br><span class=\"line\"></span><br><span class=\"line\">            objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123;</span><br><span class=\"line\">                unique: false</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            objectStore.createIndex(&quot;phone&quot;, &quot;phone&quot;, &#123;</span><br><span class=\"line\">                unique: false</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        console.log(&#x27;数据库版本更改为： &#x27; + version);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\nonupgradeneeded事件在第一次打开页面初始化数据库时会被调用，或在当有版本号变化时。所以，你应该在onupgradeneeded函数里创建你的存储数据。如果没有版本号变化，而且页面之前被打开过，你会获得一个onsuccess事件。</li>\n</ul>\n<h3 id=\"添加数据\"><a href=\"#添加数据\" class=\"headerlink\" title=\"添加数据\"></a>添加数据</h3><ul>\n<li>创建一个事务，并要求具有读写权限<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br></pre></td></tr></table></figure></li>\n<li>获取objectStore，调用add方法添加数据<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var store = transaction.objectStore(storeName); //访问事务中的objectStore</span><br><span class=\"line\">        data.forEach(function (item) &#123;</span><br><span class=\"line\">            store.add(item);//保存数据</span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><ul>\n<li>创建事务，然后调用删除接口，通过key删除对象<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">store.delete(key);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"查找数据\"><a href=\"#查找数据\" class=\"headerlink\" title=\"查找数据\"></a>查找数据</h3><ul>\n<li>按key查找 开启事务，获取objectStore，调用往get()方法，往方法里传入对象的key值，取出相应的对象<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var request = store.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log(student.name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>使用索引查找<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var index = store.index(search_index);</span><br><span class=\"line\"></span><br><span class=\"line\">    index.get(value).onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        console.log(student.id);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>游标遍历数据<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var request = store.openCursor();//打开游标</span><br><span class=\"line\"></span><br><span class=\"line\">    var dataList = new Array();</span><br><span class=\"line\"></span><br><span class=\"line\">    var i = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        var cursor = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (cursor) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            console.log(cursor.key);</span><br><span class=\"line\"></span><br><span class=\"line\">            dataList[i] = cursor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">            console.log(dataList[i].name);</span><br><span class=\"line\"></span><br><span class=\"line\">            i++;</span><br><span class=\"line\"></span><br><span class=\"line\">            cursor.continue();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        data = dataList;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"更新对象\"><a href=\"#更新对象\" class=\"headerlink\" title=\"更新对象\"></a>更新对象</h3><pre><code>更新对象，首先要把它取出来，修改，然后再放回去。\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var transaction = db.transaction(storeName, &#x27;readwrite&#x27;);</span><br><span class=\"line\"></span><br><span class=\"line\">    var store = transaction.objectStore(storeName);</span><br><span class=\"line\"></span><br><span class=\"line\">    var request = store.get(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onsuccess = function(e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        var data = e.target.result;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (a in newData) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            //除了keypath之外</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">            data.a = newData.a;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        store.put(data);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭与删除数据库\"><a href=\"#关闭与删除数据库\" class=\"headerlink\" title=\"关闭与删除数据库\"></a>关闭与删除数据库</h3><pre><code>关闭数据库可以直接调用数据库对象的close方法\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function closeDB(db) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    db.close();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>删除数据库使用数据库对象的deleteDatabase方法\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deleteDB(name) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    indexedDB.deleteDatabase(name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.cnblogs.com/dengyulinBlog/p/6141636.html\">前端存储之indexedDB</a></li>\n<li><a href=\"https://www.cnblogs.com/stephenykk/p/6080720.html\">客户端持久化解决方案：indexedDB</a></li>\n</ul>\n"},{"title":"纵欲二月（2019）","date":"2019-02-27T07:02:06.000Z","_content":"\n> 欲望使我痛苦不堪。\n\n春节来到，饮食不当，肠胃坏掉，噩梦来撩。\n\n去年没赚什么钱，自然没多少物质回馈父母，所以我得在家多呆几天，陪陪他们。\n\n可是啊可是，我就一周的假期，不上班我就没有钱，没有钱我怎么有脸在家鬼混啊。\n\n假期结束，我就又回到大上海开始两点一线的生活了。\n\n---\n\n## 聚会\n年前参加了初中同学聚会，距离初中毕业已然过了九个春夏。上一次聚会我还在读大学呢，这次都工作一年多了。\n\n大多同学许多年未见，一些更是自毕业后再无接触。人生能再有几个九年，不过这个九年大家似乎外貌变化不太大，一些女生就例外了，女大十八变啊。\n\n大家各行各业的都有，交谈起来不免觉得自己同学都好优秀，我怎么混成了这样，哭唧唧。同学中有护士、医生、律师、海龟、警察等等。还有自己开舞蹈工作室的，有在清迈开民宿的，有自己开厂当老板的，我的天啊。还有北航读书的、北邮读研的，卧槽还有清华大学本硕的，真是个女学霸，厉害！\n\n当然，也找到了几个同行。顿时觉得，我要是在老家发展，那这资源岂不丰富！不行啊，我还得赚钱买房娶媳妇啊。\n\n这么聚聚挺好的，再过几年都成家后怕是抽不出空来咯。\n\n聚餐后 KTV 喝酒喝多了，一个个真特么能喝！\n\n## 过年\n年三十一家人吃了年夜饭，后又去爬了个小山消食，一家人走走挺好的。\n\n接着就是去亲戚家拜年咯，一家一天，吃吃喝喝，基本就没有米饭什么事了。\n\n我家顶楼是个阳光棚，买了烧烤架以及一些简单的东西，在自家楼上也可以吃吃烧烤，看看阴天，或者是听听滴水声。\n\n春节在中国这么重要的节日，我竟然不知道要写些什么，光在家嗑核桃嗑傻了吧。\n\n说到嗑核桃，核桃是不是吃多上火？嘴角后来长了好大一个疮，都多久没长过了，现在都还有印子。\n\n## 痛苦\n太痛苦了，一回到上海肠胃就出问题了，不知道是冻着了还是之前吃狠了，急性肠胃炎啊。\n\n真是吃什么拉什么，都到了什么程度你晓得不，我晚上回去怕自己虚脱，直接拿细盐冲开水往嘴里怼。\n\n后来喝了一星期的藿香正气水，吃了一星期的消炎药，早上一杯燕麦，中午基本不吃，晚上吃水煮小馄饨，慢慢好转。\n\n为什么我不去医院？去医院不得要花大钱啊，哭唧唧。我相信自己的身体，它能抗！\n\n抗完肠胃抗流感。\n\n什么情况啊，真是屋漏偏逢连夜雨！\n\n对不起可爱的室友们了，空调我已经偷摸着开了好几个晚上了，哈哈。\n\n> 船到桥头自然直 彩虹总在风雨后","source":"_posts/indulgence-february.md","raw":"---\ntitle: 纵欲二月（2019）\ndate: 2019-2-27 15:02:06\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 欲望使我痛苦不堪。\n\n春节来到，饮食不当，肠胃坏掉，噩梦来撩。\n\n去年没赚什么钱，自然没多少物质回馈父母，所以我得在家多呆几天，陪陪他们。\n\n可是啊可是，我就一周的假期，不上班我就没有钱，没有钱我怎么有脸在家鬼混啊。\n\n假期结束，我就又回到大上海开始两点一线的生活了。\n\n---\n\n## 聚会\n年前参加了初中同学聚会，距离初中毕业已然过了九个春夏。上一次聚会我还在读大学呢，这次都工作一年多了。\n\n大多同学许多年未见，一些更是自毕业后再无接触。人生能再有几个九年，不过这个九年大家似乎外貌变化不太大，一些女生就例外了，女大十八变啊。\n\n大家各行各业的都有，交谈起来不免觉得自己同学都好优秀，我怎么混成了这样，哭唧唧。同学中有护士、医生、律师、海龟、警察等等。还有自己开舞蹈工作室的，有在清迈开民宿的，有自己开厂当老板的，我的天啊。还有北航读书的、北邮读研的，卧槽还有清华大学本硕的，真是个女学霸，厉害！\n\n当然，也找到了几个同行。顿时觉得，我要是在老家发展，那这资源岂不丰富！不行啊，我还得赚钱买房娶媳妇啊。\n\n这么聚聚挺好的，再过几年都成家后怕是抽不出空来咯。\n\n聚餐后 KTV 喝酒喝多了，一个个真特么能喝！\n\n## 过年\n年三十一家人吃了年夜饭，后又去爬了个小山消食，一家人走走挺好的。\n\n接着就是去亲戚家拜年咯，一家一天，吃吃喝喝，基本就没有米饭什么事了。\n\n我家顶楼是个阳光棚，买了烧烤架以及一些简单的东西，在自家楼上也可以吃吃烧烤，看看阴天，或者是听听滴水声。\n\n春节在中国这么重要的节日，我竟然不知道要写些什么，光在家嗑核桃嗑傻了吧。\n\n说到嗑核桃，核桃是不是吃多上火？嘴角后来长了好大一个疮，都多久没长过了，现在都还有印子。\n\n## 痛苦\n太痛苦了，一回到上海肠胃就出问题了，不知道是冻着了还是之前吃狠了，急性肠胃炎啊。\n\n真是吃什么拉什么，都到了什么程度你晓得不，我晚上回去怕自己虚脱，直接拿细盐冲开水往嘴里怼。\n\n后来喝了一星期的藿香正气水，吃了一星期的消炎药，早上一杯燕麦，中午基本不吃，晚上吃水煮小馄饨，慢慢好转。\n\n为什么我不去医院？去医院不得要花大钱啊，哭唧唧。我相信自己的身体，它能抗！\n\n抗完肠胃抗流感。\n\n什么情况啊，真是屋漏偏逢连夜雨！\n\n对不起可爱的室友们了，空调我已经偷摸着开了好几个晚上了，哈哈。\n\n> 船到桥头自然直 彩虹总在风雨后","slug":"indulgence-february","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhh006dk9i1arvce6hi","content":"<blockquote>\n<p>欲望使我痛苦不堪。</p>\n</blockquote>\n<p>春节来到，饮食不当，肠胃坏掉，噩梦来撩。</p>\n<p>去年没赚什么钱，自然没多少物质回馈父母，所以我得在家多呆几天，陪陪他们。</p>\n<p>可是啊可是，我就一周的假期，不上班我就没有钱，没有钱我怎么有脸在家鬼混啊。</p>\n<p>假期结束，我就又回到大上海开始两点一线的生活了。</p>\n<hr>\n<h2 id=\"聚会\"><a href=\"#聚会\" class=\"headerlink\" title=\"聚会\"></a>聚会</h2><p>年前参加了初中同学聚会，距离初中毕业已然过了九个春夏。上一次聚会我还在读大学呢，这次都工作一年多了。</p>\n<p>大多同学许多年未见，一些更是自毕业后再无接触。人生能再有几个九年，不过这个九年大家似乎外貌变化不太大，一些女生就例外了，女大十八变啊。</p>\n<p>大家各行各业的都有，交谈起来不免觉得自己同学都好优秀，我怎么混成了这样，哭唧唧。同学中有护士、医生、律师、海龟、警察等等。还有自己开舞蹈工作室的，有在清迈开民宿的，有自己开厂当老板的，我的天啊。还有北航读书的、北邮读研的，卧槽还有清华大学本硕的，真是个女学霸，厉害！</p>\n<p>当然，也找到了几个同行。顿时觉得，我要是在老家发展，那这资源岂不丰富！不行啊，我还得赚钱买房娶媳妇啊。</p>\n<p>这么聚聚挺好的，再过几年都成家后怕是抽不出空来咯。</p>\n<p>聚餐后 KTV 喝酒喝多了，一个个真特么能喝！</p>\n<h2 id=\"过年\"><a href=\"#过年\" class=\"headerlink\" title=\"过年\"></a>过年</h2><p>年三十一家人吃了年夜饭，后又去爬了个小山消食，一家人走走挺好的。</p>\n<p>接着就是去亲戚家拜年咯，一家一天，吃吃喝喝，基本就没有米饭什么事了。</p>\n<p>我家顶楼是个阳光棚，买了烧烤架以及一些简单的东西，在自家楼上也可以吃吃烧烤，看看阴天，或者是听听滴水声。</p>\n<p>春节在中国这么重要的节日，我竟然不知道要写些什么，光在家嗑核桃嗑傻了吧。</p>\n<p>说到嗑核桃，核桃是不是吃多上火？嘴角后来长了好大一个疮，都多久没长过了，现在都还有印子。</p>\n<h2 id=\"痛苦\"><a href=\"#痛苦\" class=\"headerlink\" title=\"痛苦\"></a>痛苦</h2><p>太痛苦了，一回到上海肠胃就出问题了，不知道是冻着了还是之前吃狠了，急性肠胃炎啊。</p>\n<p>真是吃什么拉什么，都到了什么程度你晓得不，我晚上回去怕自己虚脱，直接拿细盐冲开水往嘴里怼。</p>\n<p>后来喝了一星期的藿香正气水，吃了一星期的消炎药，早上一杯燕麦，中午基本不吃，晚上吃水煮小馄饨，慢慢好转。</p>\n<p>为什么我不去医院？去医院不得要花大钱啊，哭唧唧。我相信自己的身体，它能抗！</p>\n<p>抗完肠胃抗流感。</p>\n<p>什么情况啊，真是屋漏偏逢连夜雨！</p>\n<p>对不起可爱的室友们了，空调我已经偷摸着开了好几个晚上了，哈哈。</p>\n<blockquote>\n<p>船到桥头自然直 彩虹总在风雨后</p>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>欲望使我痛苦不堪。</p>\n</blockquote>\n<p>春节来到，饮食不当，肠胃坏掉，噩梦来撩。</p>\n<p>去年没赚什么钱，自然没多少物质回馈父母，所以我得在家多呆几天，陪陪他们。</p>\n<p>可是啊可是，我就一周的假期，不上班我就没有钱，没有钱我怎么有脸在家鬼混啊。</p>\n<p>假期结束，我就又回到大上海开始两点一线的生活了。</p>\n<hr>\n<h2 id=\"聚会\"><a href=\"#聚会\" class=\"headerlink\" title=\"聚会\"></a>聚会</h2><p>年前参加了初中同学聚会，距离初中毕业已然过了九个春夏。上一次聚会我还在读大学呢，这次都工作一年多了。</p>\n<p>大多同学许多年未见，一些更是自毕业后再无接触。人生能再有几个九年，不过这个九年大家似乎外貌变化不太大，一些女生就例外了，女大十八变啊。</p>\n<p>大家各行各业的都有，交谈起来不免觉得自己同学都好优秀，我怎么混成了这样，哭唧唧。同学中有护士、医生、律师、海龟、警察等等。还有自己开舞蹈工作室的，有在清迈开民宿的，有自己开厂当老板的，我的天啊。还有北航读书的、北邮读研的，卧槽还有清华大学本硕的，真是个女学霸，厉害！</p>\n<p>当然，也找到了几个同行。顿时觉得，我要是在老家发展，那这资源岂不丰富！不行啊，我还得赚钱买房娶媳妇啊。</p>\n<p>这么聚聚挺好的，再过几年都成家后怕是抽不出空来咯。</p>\n<p>聚餐后 KTV 喝酒喝多了，一个个真特么能喝！</p>\n<h2 id=\"过年\"><a href=\"#过年\" class=\"headerlink\" title=\"过年\"></a>过年</h2><p>年三十一家人吃了年夜饭，后又去爬了个小山消食，一家人走走挺好的。</p>\n<p>接着就是去亲戚家拜年咯，一家一天，吃吃喝喝，基本就没有米饭什么事了。</p>\n<p>我家顶楼是个阳光棚，买了烧烤架以及一些简单的东西，在自家楼上也可以吃吃烧烤，看看阴天，或者是听听滴水声。</p>\n<p>春节在中国这么重要的节日，我竟然不知道要写些什么，光在家嗑核桃嗑傻了吧。</p>\n<p>说到嗑核桃，核桃是不是吃多上火？嘴角后来长了好大一个疮，都多久没长过了，现在都还有印子。</p>\n<h2 id=\"痛苦\"><a href=\"#痛苦\" class=\"headerlink\" title=\"痛苦\"></a>痛苦</h2><p>太痛苦了，一回到上海肠胃就出问题了，不知道是冻着了还是之前吃狠了，急性肠胃炎啊。</p>\n<p>真是吃什么拉什么，都到了什么程度你晓得不，我晚上回去怕自己虚脱，直接拿细盐冲开水往嘴里怼。</p>\n<p>后来喝了一星期的藿香正气水，吃了一星期的消炎药，早上一杯燕麦，中午基本不吃，晚上吃水煮小馄饨，慢慢好转。</p>\n<p>为什么我不去医院？去医院不得要花大钱啊，哭唧唧。我相信自己的身体，它能抗！</p>\n<p>抗完肠胃抗流感。</p>\n<p>什么情况啊，真是屋漏偏逢连夜雨！</p>\n<p>对不起可爱的室友们了，空调我已经偷摸着开了好几个晚上了，哈哈。</p>\n<blockquote>\n<p>船到桥头自然直 彩虹总在风雨后</p>\n</blockquote>\n"},{"title":"Kong 自定义插件编写详解","date":"2023-06-10T13:10:55.000Z","_content":"\n\n\n最近在研究 Kong，如果你跟我一样之前对 Kong 不了解可以看他们的[官网](https://docs.konghq.com/gateway/3.3.x/)，我就不在这多说废话了。\n\n调研了几天，Kong 的功能蛮多的，对我们也有很大的帮助，引入也很有意义，能减少我们很多操作。Kong 也比较成熟，只是网上的资料都比较零散，很多也已经随着改版而变得过时。\n\n官网的 [quickstart](https://docs.konghq.com/gateway/3.3.x/get-started/) 也算是详细了，跟着走一遍基本就能知道个大概，有哪些功能。\n\n我想要尝试通过自定义编写插件来更好得对数据做一些处理，就各种找资料。终于经过一段时间的冲浪后，我开始掌握了一些门道。\n\n首先，Apache 的 [skywalking-kong](https://github.com/apache/skywalking-kong) 帮我理清了绝大部分道路，只是不知道是因为 Kong 版本的更迭还是因为我本地环境的原因，跟 README 上描述的步骤还是有一点点的差别：\n\n- `luarocks install kong-skywalking --local` 用 `luarocks` 安装 kong-plugin-skywalking，你也可以用 `--tree` 指定目录位置\n- 然后是 `kong.conf`，一般在 `/etc/kong`下，如果没有就 `cp kong.conf.default kong.conf` 然后对应配置加上，`lua_package_path` 注意一下写上你实际的位置，可能与 README 上的会有偏差，我的就是\n- 关键的还有一步没有写上，`/usr/local/share/lua/5.1/kong/constants.lua` 里记录了所有插件的名字，如果不加上的话你新加的插件也不会显示出来，需要特别注意。最后最好 kong restart\n\n---\n\n这一个走通后，就会对自定义的插件有个概念了。下面我们来自己手写一个试试，很简单的一个 Demo，主要是对 Response 的修改（只要走通了一个 其他的也就差不多了 看看官方 [API](https://docs.konghq.com/gateway/latest/plugin-development/pdk/)）。\n\n其实别看这里我只是轻描淡写，实际却是踩了很多坑，网上太多都是不负责任的文章，也不清楚是纯粹的 copy 还是因为版本更迭导致的失效。\n\n我先说下网上找资料然后最终发现的几个问题：\n\n- `local BasePlugin = require \"kong.plugins.base_plugin\"`  这个 BasePlugin 在 [2.7.x](https://docs.konghq.com/gateway/2.7.x/plugin-development/custom-logic/#migrating-from-baseplugin-module) 已经废弃了，害得我还在那抓头，ChatGPT 资料库不够新，问了半天跟个傻子一样\n- `kong.service.response` 和`kong.response` ，网上找到的资料都是用 `kong.service.response` 来改变响应体的内容，也害得我只抓头，纳闷了怎么也不行，直到我在官网 [kong.response](https://docs.konghq.com/gateway/latest/plugin-development/pdk/kong.response/) 找到了这么一句 `Unlike kong.service.response, this module allows mutating the response before sending it back to the client.` 我丢\n\n然后其他的就是 Lua 脚本的编写了。\n\n1. 先在之前 `skywalking` 同级新建一个 `response-handler` 目录（当然也可以在 Kong 自己的插件目录中添加自定义的插件）\n2. 再进入 `response-handler` 目录，新建两个 Lua 脚本，插件主要也就是这两个文件 `handler.lua` 和 `schema.lua`。至于你说这两个是什么作用，我只能说业务逻辑在 handler 中，所用到的一些可变参数在 schema 中，具体的可以自行去冲浪哈，在这我就不赘述了。下面是我写的 Demo 脚本内容：\n\n> 官网资料：[Plugin Configuration](https://docs.konghq.com/gateway/latest/plugin-development/configuration/)\n\n**handler.lua** \n\n```\nlocal cjson = require(\"cjson\")\n\nlocal MyPluginHandler = {\n\tVERSION = \"0.1.0\", -- 版本\n\tPRIORITY = 10 -- 脚本执行优先值\n}\n\nfunction MyPluginHandler:header_filter(config)\n  -- 修改响应头\n  kong.response.set_header(\"Handle-Response-Header\", \"Response-Handler\")\nend\n\nfunction MyPluginHandler:access(conf)\nend\n\nfunction MyPluginHandler:body_filter(config)\n  -- 修改响应体\n  local response_body = kong.response.get_raw_body()\n  if response_body then\n     local response_json = cjson.decode(response_body)\n     response_json.data.num = config.num -- 我这里修改了 response.data.num 的值 （config.num 对应 schema.lua 中的 config.num）\n     local modified_body = cjson.encode(response_json)\n     kong.response.set_raw_body(modified_body)\n  end\nend\n\nreturn MyPluginHandler\n```\n\n\n\n**schema.lua**\n\n```\nlocal typedefs = require \"kong.db.schema.typedefs\"\n\nlocal PLUGIN_NAME = \"myplugin\"\n\nlocal schema = {\n  name = PLUGIN_NAME,\n  fields = {\n    { consumer = typedefs.no_consumer }, -- 该插件不能设置为 consumer\n    { protocols = typedefs.protocols_http },\n    { config = {\n        type = \"record\",\n        fields = { -- 可配置参数\n          { num = {\n              type = \"integer\",\n              default = 10,\n              required = false,\n              gt = 0, }}, \n        },\n        entity_checks = {\n          -- 可以写一些校验 at_least_one_of distinct\n        },\n      },\n    },\n  },\n}\n\nreturn schema\n```\n\n\n\n3. 脚本写好后在 `kong.conf`  中的 `plugins = bundled, skywalking, response-handler` 加上\n4. 在 `/usr/local/share/lua/5.1/kong/constants.lua` 中的 `local plugins = {....}` 加上新写的 `response-handler`\n5. kong restart\n\n\n\n到这里，自定义的插件算是可以了。要还不行，那就可能是版本更迭了哈哈","source":"_posts/kong-custom-plugin.md","raw":"---\ntitle: Kong 自定义插件编写详解\ndate: 2023-06-10 21:10:55\ncategories: [开发,总结]\ntags: [Kong]\n---\n\n\n\n最近在研究 Kong，如果你跟我一样之前对 Kong 不了解可以看他们的[官网](https://docs.konghq.com/gateway/3.3.x/)，我就不在这多说废话了。\n\n调研了几天，Kong 的功能蛮多的，对我们也有很大的帮助，引入也很有意义，能减少我们很多操作。Kong 也比较成熟，只是网上的资料都比较零散，很多也已经随着改版而变得过时。\n\n官网的 [quickstart](https://docs.konghq.com/gateway/3.3.x/get-started/) 也算是详细了，跟着走一遍基本就能知道个大概，有哪些功能。\n\n我想要尝试通过自定义编写插件来更好得对数据做一些处理，就各种找资料。终于经过一段时间的冲浪后，我开始掌握了一些门道。\n\n首先，Apache 的 [skywalking-kong](https://github.com/apache/skywalking-kong) 帮我理清了绝大部分道路，只是不知道是因为 Kong 版本的更迭还是因为我本地环境的原因，跟 README 上描述的步骤还是有一点点的差别：\n\n- `luarocks install kong-skywalking --local` 用 `luarocks` 安装 kong-plugin-skywalking，你也可以用 `--tree` 指定目录位置\n- 然后是 `kong.conf`，一般在 `/etc/kong`下，如果没有就 `cp kong.conf.default kong.conf` 然后对应配置加上，`lua_package_path` 注意一下写上你实际的位置，可能与 README 上的会有偏差，我的就是\n- 关键的还有一步没有写上，`/usr/local/share/lua/5.1/kong/constants.lua` 里记录了所有插件的名字，如果不加上的话你新加的插件也不会显示出来，需要特别注意。最后最好 kong restart\n\n---\n\n这一个走通后，就会对自定义的插件有个概念了。下面我们来自己手写一个试试，很简单的一个 Demo，主要是对 Response 的修改（只要走通了一个 其他的也就差不多了 看看官方 [API](https://docs.konghq.com/gateway/latest/plugin-development/pdk/)）。\n\n其实别看这里我只是轻描淡写，实际却是踩了很多坑，网上太多都是不负责任的文章，也不清楚是纯粹的 copy 还是因为版本更迭导致的失效。\n\n我先说下网上找资料然后最终发现的几个问题：\n\n- `local BasePlugin = require \"kong.plugins.base_plugin\"`  这个 BasePlugin 在 [2.7.x](https://docs.konghq.com/gateway/2.7.x/plugin-development/custom-logic/#migrating-from-baseplugin-module) 已经废弃了，害得我还在那抓头，ChatGPT 资料库不够新，问了半天跟个傻子一样\n- `kong.service.response` 和`kong.response` ，网上找到的资料都是用 `kong.service.response` 来改变响应体的内容，也害得我只抓头，纳闷了怎么也不行，直到我在官网 [kong.response](https://docs.konghq.com/gateway/latest/plugin-development/pdk/kong.response/) 找到了这么一句 `Unlike kong.service.response, this module allows mutating the response before sending it back to the client.` 我丢\n\n然后其他的就是 Lua 脚本的编写了。\n\n1. 先在之前 `skywalking` 同级新建一个 `response-handler` 目录（当然也可以在 Kong 自己的插件目录中添加自定义的插件）\n2. 再进入 `response-handler` 目录，新建两个 Lua 脚本，插件主要也就是这两个文件 `handler.lua` 和 `schema.lua`。至于你说这两个是什么作用，我只能说业务逻辑在 handler 中，所用到的一些可变参数在 schema 中，具体的可以自行去冲浪哈，在这我就不赘述了。下面是我写的 Demo 脚本内容：\n\n> 官网资料：[Plugin Configuration](https://docs.konghq.com/gateway/latest/plugin-development/configuration/)\n\n**handler.lua** \n\n```\nlocal cjson = require(\"cjson\")\n\nlocal MyPluginHandler = {\n\tVERSION = \"0.1.0\", -- 版本\n\tPRIORITY = 10 -- 脚本执行优先值\n}\n\nfunction MyPluginHandler:header_filter(config)\n  -- 修改响应头\n  kong.response.set_header(\"Handle-Response-Header\", \"Response-Handler\")\nend\n\nfunction MyPluginHandler:access(conf)\nend\n\nfunction MyPluginHandler:body_filter(config)\n  -- 修改响应体\n  local response_body = kong.response.get_raw_body()\n  if response_body then\n     local response_json = cjson.decode(response_body)\n     response_json.data.num = config.num -- 我这里修改了 response.data.num 的值 （config.num 对应 schema.lua 中的 config.num）\n     local modified_body = cjson.encode(response_json)\n     kong.response.set_raw_body(modified_body)\n  end\nend\n\nreturn MyPluginHandler\n```\n\n\n\n**schema.lua**\n\n```\nlocal typedefs = require \"kong.db.schema.typedefs\"\n\nlocal PLUGIN_NAME = \"myplugin\"\n\nlocal schema = {\n  name = PLUGIN_NAME,\n  fields = {\n    { consumer = typedefs.no_consumer }, -- 该插件不能设置为 consumer\n    { protocols = typedefs.protocols_http },\n    { config = {\n        type = \"record\",\n        fields = { -- 可配置参数\n          { num = {\n              type = \"integer\",\n              default = 10,\n              required = false,\n              gt = 0, }}, \n        },\n        entity_checks = {\n          -- 可以写一些校验 at_least_one_of distinct\n        },\n      },\n    },\n  },\n}\n\nreturn schema\n```\n\n\n\n3. 脚本写好后在 `kong.conf`  中的 `plugins = bundled, skywalking, response-handler` 加上\n4. 在 `/usr/local/share/lua/5.1/kong/constants.lua` 中的 `local plugins = {....}` 加上新写的 `response-handler`\n5. kong restart\n\n\n\n到这里，自定义的插件算是可以了。要还不行，那就可能是版本更迭了哈哈","slug":"kong-custom-plugin","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhh006gk9i1c9sqdjbq","content":"<p>最近在研究 Kong，如果你跟我一样之前对 Kong 不了解可以看他们的<a href=\"https://docs.konghq.com/gateway/3.3.x/\">官网</a>，我就不在这多说废话了。</p>\n<p>调研了几天，Kong 的功能蛮多的，对我们也有很大的帮助，引入也很有意义，能减少我们很多操作。Kong 也比较成熟，只是网上的资料都比较零散，很多也已经随着改版而变得过时。</p>\n<p>官网的 <a href=\"https://docs.konghq.com/gateway/3.3.x/get-started/\">quickstart</a> 也算是详细了，跟着走一遍基本就能知道个大概，有哪些功能。</p>\n<p>我想要尝试通过自定义编写插件来更好得对数据做一些处理，就各种找资料。终于经过一段时间的冲浪后，我开始掌握了一些门道。</p>\n<p>首先，Apache 的 <a href=\"https://github.com/apache/skywalking-kong\">skywalking-kong</a> 帮我理清了绝大部分道路，只是不知道是因为 Kong 版本的更迭还是因为我本地环境的原因，跟 README 上描述的步骤还是有一点点的差别：</p>\n<ul>\n<li><code>luarocks install kong-skywalking --local</code> 用 <code>luarocks</code> 安装 kong-plugin-skywalking，你也可以用 <code>--tree</code> 指定目录位置</li>\n<li>然后是 <code>kong.conf</code>，一般在 <code>/etc/kong</code>下，如果没有就 <code>cp kong.conf.default kong.conf</code> 然后对应配置加上，<code>lua_package_path</code> 注意一下写上你实际的位置，可能与 README 上的会有偏差，我的就是</li>\n<li>关键的还有一步没有写上，<code>/usr/local/share/lua/5.1/kong/constants.lua</code> 里记录了所有插件的名字，如果不加上的话你新加的插件也不会显示出来，需要特别注意。最后最好 kong restart</li>\n</ul>\n<hr>\n<p>这一个走通后，就会对自定义的插件有个概念了。下面我们来自己手写一个试试，很简单的一个 Demo，主要是对 Response 的修改（只要走通了一个 其他的也就差不多了 看看官方 <a href=\"https://docs.konghq.com/gateway/latest/plugin-development/pdk/\">API</a>）。</p>\n<p>其实别看这里我只是轻描淡写，实际却是踩了很多坑，网上太多都是不负责任的文章，也不清楚是纯粹的 copy 还是因为版本更迭导致的失效。</p>\n<p>我先说下网上找资料然后最终发现的几个问题：</p>\n<ul>\n<li><code>local BasePlugin = require &quot;kong.plugins.base_plugin&quot;</code>  这个 BasePlugin 在 <a href=\"https://docs.konghq.com/gateway/2.7.x/plugin-development/custom-logic/#migrating-from-baseplugin-module\">2.7.x</a> 已经废弃了，害得我还在那抓头，ChatGPT 资料库不够新，问了半天跟个傻子一样</li>\n<li><code>kong.service.response</code> 和<code>kong.response</code> ，网上找到的资料都是用 <code>kong.service.response</code> 来改变响应体的内容，也害得我只抓头，纳闷了怎么也不行，直到我在官网 <a href=\"https://docs.konghq.com/gateway/latest/plugin-development/pdk/kong.response/\">kong.response</a> 找到了这么一句 <code>Unlike kong.service.response, this module allows mutating the response before sending it back to the client.</code> 我丢</li>\n</ul>\n<p>然后其他的就是 Lua 脚本的编写了。</p>\n<ol>\n<li>先在之前 <code>skywalking</code> 同级新建一个 <code>response-handler</code> 目录（当然也可以在 Kong 自己的插件目录中添加自定义的插件）</li>\n<li>再进入 <code>response-handler</code> 目录，新建两个 Lua 脚本，插件主要也就是这两个文件 <code>handler.lua</code> 和 <code>schema.lua</code>。至于你说这两个是什么作用，我只能说业务逻辑在 handler 中，所用到的一些可变参数在 schema 中，具体的可以自行去冲浪哈，在这我就不赘述了。下面是我写的 Demo 脚本内容：</li>\n</ol>\n<blockquote>\n<p>官网资料：<a href=\"https://docs.konghq.com/gateway/latest/plugin-development/configuration/\">Plugin Configuration</a></p>\n</blockquote>\n<p><strong>handler.lua</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local cjson = require(&quot;cjson&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">local MyPluginHandler = &#123;</span><br><span class=\"line\">\tVERSION = &quot;0.1.0&quot;, -- 版本</span><br><span class=\"line\">\tPRIORITY = 10 -- 脚本执行优先值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function MyPluginHandler:header_filter(config)</span><br><span class=\"line\">  -- 修改响应头</span><br><span class=\"line\">  kong.response.set_header(&quot;Handle-Response-Header&quot;, &quot;Response-Handler&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">function MyPluginHandler:access(conf)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">function MyPluginHandler:body_filter(config)</span><br><span class=\"line\">  -- 修改响应体</span><br><span class=\"line\">  local response_body = kong.response.get_raw_body()</span><br><span class=\"line\">  if response_body then</span><br><span class=\"line\">     local response_json = cjson.decode(response_body)</span><br><span class=\"line\">     response_json.data.num = config.num -- 我这里修改了 response.data.num 的值 （config.num 对应 schema.lua 中的 config.num）</span><br><span class=\"line\">     local modified_body = cjson.encode(response_json)</span><br><span class=\"line\">     kong.response.set_raw_body(modified_body)</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">return MyPluginHandler</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>schema.lua</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local typedefs = require &quot;kong.db.schema.typedefs&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">local PLUGIN_NAME = &quot;myplugin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">local schema = &#123;</span><br><span class=\"line\">  name = PLUGIN_NAME,</span><br><span class=\"line\">  fields = &#123;</span><br><span class=\"line\">    &#123; consumer = typedefs.no_consumer &#125;, -- 该插件不能设置为 consumer</span><br><span class=\"line\">    &#123; protocols = typedefs.protocols_http &#125;,</span><br><span class=\"line\">    &#123; config = &#123;</span><br><span class=\"line\">        type = &quot;record&quot;,</span><br><span class=\"line\">        fields = &#123; -- 可配置参数</span><br><span class=\"line\">          &#123; num = &#123;</span><br><span class=\"line\">              type = &quot;integer&quot;,</span><br><span class=\"line\">              default = 10,</span><br><span class=\"line\">              required = false,</span><br><span class=\"line\">              gt = 0, &#125;&#125;, </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        entity_checks = &#123;</span><br><span class=\"line\">          -- 可以写一些校验 at_least_one_of distinct</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">return schema</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>脚本写好后在 <code>kong.conf</code>  中的 <code>plugins = bundled, skywalking, response-handler</code> 加上</li>\n<li>在 <code>/usr/local/share/lua/5.1/kong/constants.lua</code> 中的 <code>local plugins = &#123;....&#125;</code> 加上新写的 <code>response-handler</code></li>\n<li>kong restart</li>\n</ol>\n<p>到这里，自定义的插件算是可以了。要还不行，那就可能是版本更迭了哈哈</p>\n","excerpt":"","more":"<p>最近在研究 Kong，如果你跟我一样之前对 Kong 不了解可以看他们的<a href=\"https://docs.konghq.com/gateway/3.3.x/\">官网</a>，我就不在这多说废话了。</p>\n<p>调研了几天，Kong 的功能蛮多的，对我们也有很大的帮助，引入也很有意义，能减少我们很多操作。Kong 也比较成熟，只是网上的资料都比较零散，很多也已经随着改版而变得过时。</p>\n<p>官网的 <a href=\"https://docs.konghq.com/gateway/3.3.x/get-started/\">quickstart</a> 也算是详细了，跟着走一遍基本就能知道个大概，有哪些功能。</p>\n<p>我想要尝试通过自定义编写插件来更好得对数据做一些处理，就各种找资料。终于经过一段时间的冲浪后，我开始掌握了一些门道。</p>\n<p>首先，Apache 的 <a href=\"https://github.com/apache/skywalking-kong\">skywalking-kong</a> 帮我理清了绝大部分道路，只是不知道是因为 Kong 版本的更迭还是因为我本地环境的原因，跟 README 上描述的步骤还是有一点点的差别：</p>\n<ul>\n<li><code>luarocks install kong-skywalking --local</code> 用 <code>luarocks</code> 安装 kong-plugin-skywalking，你也可以用 <code>--tree</code> 指定目录位置</li>\n<li>然后是 <code>kong.conf</code>，一般在 <code>/etc/kong</code>下，如果没有就 <code>cp kong.conf.default kong.conf</code> 然后对应配置加上，<code>lua_package_path</code> 注意一下写上你实际的位置，可能与 README 上的会有偏差，我的就是</li>\n<li>关键的还有一步没有写上，<code>/usr/local/share/lua/5.1/kong/constants.lua</code> 里记录了所有插件的名字，如果不加上的话你新加的插件也不会显示出来，需要特别注意。最后最好 kong restart</li>\n</ul>\n<hr>\n<p>这一个走通后，就会对自定义的插件有个概念了。下面我们来自己手写一个试试，很简单的一个 Demo，主要是对 Response 的修改（只要走通了一个 其他的也就差不多了 看看官方 <a href=\"https://docs.konghq.com/gateway/latest/plugin-development/pdk/\">API</a>）。</p>\n<p>其实别看这里我只是轻描淡写，实际却是踩了很多坑，网上太多都是不负责任的文章，也不清楚是纯粹的 copy 还是因为版本更迭导致的失效。</p>\n<p>我先说下网上找资料然后最终发现的几个问题：</p>\n<ul>\n<li><code>local BasePlugin = require &quot;kong.plugins.base_plugin&quot;</code>  这个 BasePlugin 在 <a href=\"https://docs.konghq.com/gateway/2.7.x/plugin-development/custom-logic/#migrating-from-baseplugin-module\">2.7.x</a> 已经废弃了，害得我还在那抓头，ChatGPT 资料库不够新，问了半天跟个傻子一样</li>\n<li><code>kong.service.response</code> 和<code>kong.response</code> ，网上找到的资料都是用 <code>kong.service.response</code> 来改变响应体的内容，也害得我只抓头，纳闷了怎么也不行，直到我在官网 <a href=\"https://docs.konghq.com/gateway/latest/plugin-development/pdk/kong.response/\">kong.response</a> 找到了这么一句 <code>Unlike kong.service.response, this module allows mutating the response before sending it back to the client.</code> 我丢</li>\n</ul>\n<p>然后其他的就是 Lua 脚本的编写了。</p>\n<ol>\n<li>先在之前 <code>skywalking</code> 同级新建一个 <code>response-handler</code> 目录（当然也可以在 Kong 自己的插件目录中添加自定义的插件）</li>\n<li>再进入 <code>response-handler</code> 目录，新建两个 Lua 脚本，插件主要也就是这两个文件 <code>handler.lua</code> 和 <code>schema.lua</code>。至于你说这两个是什么作用，我只能说业务逻辑在 handler 中，所用到的一些可变参数在 schema 中，具体的可以自行去冲浪哈，在这我就不赘述了。下面是我写的 Demo 脚本内容：</li>\n</ol>\n<blockquote>\n<p>官网资料：<a href=\"https://docs.konghq.com/gateway/latest/plugin-development/configuration/\">Plugin Configuration</a></p>\n</blockquote>\n<p><strong>handler.lua</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local cjson = require(&quot;cjson&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">local MyPluginHandler = &#123;</span><br><span class=\"line\">\tVERSION = &quot;0.1.0&quot;, -- 版本</span><br><span class=\"line\">\tPRIORITY = 10 -- 脚本执行优先值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function MyPluginHandler:header_filter(config)</span><br><span class=\"line\">  -- 修改响应头</span><br><span class=\"line\">  kong.response.set_header(&quot;Handle-Response-Header&quot;, &quot;Response-Handler&quot;)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">function MyPluginHandler:access(conf)</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">function MyPluginHandler:body_filter(config)</span><br><span class=\"line\">  -- 修改响应体</span><br><span class=\"line\">  local response_body = kong.response.get_raw_body()</span><br><span class=\"line\">  if response_body then</span><br><span class=\"line\">     local response_json = cjson.decode(response_body)</span><br><span class=\"line\">     response_json.data.num = config.num -- 我这里修改了 response.data.num 的值 （config.num 对应 schema.lua 中的 config.num）</span><br><span class=\"line\">     local modified_body = cjson.encode(response_json)</span><br><span class=\"line\">     kong.response.set_raw_body(modified_body)</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">return MyPluginHandler</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>schema.lua</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local typedefs = require &quot;kong.db.schema.typedefs&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">local PLUGIN_NAME = &quot;myplugin&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">local schema = &#123;</span><br><span class=\"line\">  name = PLUGIN_NAME,</span><br><span class=\"line\">  fields = &#123;</span><br><span class=\"line\">    &#123; consumer = typedefs.no_consumer &#125;, -- 该插件不能设置为 consumer</span><br><span class=\"line\">    &#123; protocols = typedefs.protocols_http &#125;,</span><br><span class=\"line\">    &#123; config = &#123;</span><br><span class=\"line\">        type = &quot;record&quot;,</span><br><span class=\"line\">        fields = &#123; -- 可配置参数</span><br><span class=\"line\">          &#123; num = &#123;</span><br><span class=\"line\">              type = &quot;integer&quot;,</span><br><span class=\"line\">              default = 10,</span><br><span class=\"line\">              required = false,</span><br><span class=\"line\">              gt = 0, &#125;&#125;, </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        entity_checks = &#123;</span><br><span class=\"line\">          -- 可以写一些校验 at_least_one_of distinct</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">return schema</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>脚本写好后在 <code>kong.conf</code>  中的 <code>plugins = bundled, skywalking, response-handler</code> 加上</li>\n<li>在 <code>/usr/local/share/lua/5.1/kong/constants.lua</code> 中的 <code>local plugins = &#123;....&#125;</code> 加上新写的 <code>response-handler</code></li>\n<li>kong restart</li>\n</ol>\n<p>到这里，自定义的插件算是可以了。要还不行，那就可能是版本更迭了哈哈</p>\n"},{"title":"笑口常开","date":"2018-09-13T08:14:50.000Z","_content":"\n> 摘录自贾平凹先生散文集《自在独行》中的《笑口常开》。在生活中找寻乐而开笑之事。\n\n\n著作得以出版，殷切切送某人一册，扉页上恭正题写：“赠 xxx 先生存正。”一月过罢，偶尔去废旧书报收购店见到此册，遂折价买回，于扉页上那条提款下又恭正题写：“再赠 xxx 先生存正。”写毕邮走，踅进一家酒馆坐喝，不禁乐而开笑。\n\n\n\n大学毕业，年届三十，婚姻难就，累得三朋四友八方搭线，但一次一次介绍终未能成就。忽一日，又有人送来游票，郑重讲明已物色着一位姑娘，同意明日去公园 xx 桥第三根栏杆下见面。黎明早起，赶去约会，等候的姑娘竟是两年前曾经别人介绍见过面的。姑娘说：“怎么又是你？”掉身而去。木木在桥上立了半晌，不禁乐而开笑。\n\n\n\n好友 x 君，编辑十五年杂志，清苦贫困，英年早逝。保存下那一支笔和一副深度近视镜。租三轮车送亡友去火葬场火化，待化的队列冗长，忽见墙上张贴有“本场优待知识分子”，立即返回取来编辑证书，果然火化提前，免受尸体臭烂，不禁乐而开笑。\n\n\n\n入厕所大便完毕，发现未带手纸，见旁边有被揩过的一片脏纸，应急欲用，缺进来一个人蹲坑，只好等着那人便后先走。但那人也是没手纸，为难半天，也发现那片脏纸，企图我走后应急。如此相持许久，均心照不宣，后同时欲先下手为强，偏又进来一人，背一篓，拄一铁条，为捡废纸者，铁条一点，扎去脏纸入篓走了。两人对视，不禁乐而开笑。\n\n\n\n居住于 A 城的伯父，沉沦于二十年右派生涯，早妻离子散，平反后已垂垂暮老，多回忆早年英武及故友。我以他大学的一位女生名义去信慰藉，不想他立即复信，只好信来信往，谈当年的友情，谈数十年的思念，谈现在鳏寡人的处境，及至发展到黄昏恋。我半月一封，连续四年不断，且信中一再说要去见他，每次日期将至又以患病推延。伯父终老弱病倒，我去看他，临咽气说：“我等不及她来了。她来了，你把这个箱子交她。”又说一句：“我总没白活。”安详瞑目。掩埋了伯父，打开箱子，竟是我写给他的近百封信，得意为他在爱的幸福中度过晚年，不禁乐而开笑。\n\n\n\n陪领导去某地开会，讨论席上，领导突然脖子发痒，用手去摸，摸出一个肉肉的小东西，脸色微红旋又若无其事说：“我还以为是个虱子哩！”随手丢到地上。我低头往地上瞅，说：“噢，我还以为不是个虱子哩！”会后领导去风景区旅游，而我被命令返回，列车上买一个鸡爪边嚼边想，不禁乐而开笑。\n\n\n\n有了妻子便有了孩子，仍住在那不足十平方米的单间里。出差马上就要走了，一走又是一月，夫妻想亲热一下，孩子偏死不离家。妻说：“小宝，爸爸要走了，你去商店打些酱油，给你爸爸做一顿好吃的吧！”孩子提了酱油瓶出门，我说：“拿这个去，”给了一大口浅底盘子，“别洒了啊！”孩子走了，关门立即行动。毕，赶忙去车站，于巷口远远看见孩子双手捧盘，一步一小心地回来，不禁乐而开笑。\n\n\n\n夜里正在床上半醒半睡，有人影推门闪进来，在立柜里翻，翻出一堆破衣服和书报，扔了；再往架板上翻，翻出各类米袋子、面袋子和书报，扔了；在桌斗里又翻，是一堆读书卡片，凑眼前看了看，扔了。咕哝了一句顺门便走，我在床上说：“朋友，把门拉上，夜里有风的。”小偷把门拉上了。天明起来整理房间，一地乱书乱报，竟发现找了好久未找着的一份资料，不禁乐而开笑。\n\n\n\n上大街回来，挤了一身臭汗，牢骚道：“用枪得在街十字路口扫一通！”回家一杯茶未喝尽，楼梯上步声杂乱，巷中有人呼：“大街上有人用枪打死几十个人了！”遂也往街上跑，街上人山人海，弯腰往里挤，问：“尸体在哪儿？”一熟人说：“不是说是你讲的吗？”忽记得那一句顺口的牢骚，不禁乐而开笑。\n\n\n\n剧场里正巧和一位官太太邻座，太太把持不住放一屁，四周骚哗；骂问：“谁放的？不文明！”太太窘极不语，骂问声更甚。我站起说：“我放的！”众人骚哗即息，却以手作扇风状，太太也扇，畏我如臭物，回望她不禁乐而开笑。\n\n\n\n出外突然有人迎面过来打招呼，立即停下，作疑惑状。“你不认识我了？”“怎不认识？”于是握手，互问哪儿来，到哪儿去，互问老人康健孩子可乖，互说又胖了，又瘦了，半天的淡而无味的话。分手了，终想不起这是谁，不禁乐而开笑。\n\n\n\n弄文学的穷朋友来家侃山，酒瘾发而酒瓶仅能空出一杯酒，取马鬃四根，各人蘸吮，却大声划拳：“八匹马，五魁手……你一盅（鬃）！我一盅（鬃）！”窗外卖茶蛋的老妪对老翁说：“怪不得咱出钱让人家写文章宣传咱不干，人家钱多酒量也大，喝了整晌也未醉！”听着不禁乐而开笑。\n\n\n\n路过一条小巷，忽见有长队排出，以为又在出售紧俏物件了，急忙列入其中，排到跟前，方见是巷口唯一的厕所，居民等候出恭，不禁乐而开笑。\n\n\n\n去给孩子买一双袜子，昨日看时价是一元，今日是一元二角，怏怏出店门，打响一个喷嚏，喷带出一口痰。正想是售货员在嘲笑我，我方有喷嚏打出，一位戴“卫管员”袖章的人却责斥我吐了痰要罚五角钱。掏出那一元钱，卫管员没零钱找，遂再当地吐一口，愤愤而走，走过十步，不禁乐而开笑。\n\n\n\n出差去旅社住宿，服务员开发票将“作协”写成“做鞋”，不禁乐而开笑。\n\n\n\n夏月偏停电，爬十二层楼梯去办公室，气喘吁吁到门口了，门钥匙却和自行车钥匙系在一起，遗忘在车子锁孔了，不禁乐而开笑。\n\n\n\n路遇一女子，回望我嫣然一笑，极感幸福，即趋而前去搭话，女子闪进一家商店，尾随入店，玻璃上映出自己衣服纽扣错位，不禁乐而开笑。\n\n\n\n名字是自己的，别人却用得最多，不禁乐而开笑。\n\n\n\n写完《笑口常开》草稿，去吸一根烟，返身要眷写时，草稿不见了，妻说：“是不是一大页写过的纸，我上厕所用了。”惊呼：“那是一篇散文！”妻说：“白纸舍不得用，我只说写过的纸就没用了。”急奔厕所，幸而已臭但未全湿，捂鼻子抄出此份，不禁乐而开笑。","source":"_posts/laught-often.md","raw":"---\ntitle: 笑口常开\ndate: 2018-9-13 16:14:50\ncategories: [文学,散文鉴赏]\ntags: [文学,散文]\n---\n\n> 摘录自贾平凹先生散文集《自在独行》中的《笑口常开》。在生活中找寻乐而开笑之事。\n\n\n著作得以出版，殷切切送某人一册，扉页上恭正题写：“赠 xxx 先生存正。”一月过罢，偶尔去废旧书报收购店见到此册，遂折价买回，于扉页上那条提款下又恭正题写：“再赠 xxx 先生存正。”写毕邮走，踅进一家酒馆坐喝，不禁乐而开笑。\n\n\n\n大学毕业，年届三十，婚姻难就，累得三朋四友八方搭线，但一次一次介绍终未能成就。忽一日，又有人送来游票，郑重讲明已物色着一位姑娘，同意明日去公园 xx 桥第三根栏杆下见面。黎明早起，赶去约会，等候的姑娘竟是两年前曾经别人介绍见过面的。姑娘说：“怎么又是你？”掉身而去。木木在桥上立了半晌，不禁乐而开笑。\n\n\n\n好友 x 君，编辑十五年杂志，清苦贫困，英年早逝。保存下那一支笔和一副深度近视镜。租三轮车送亡友去火葬场火化，待化的队列冗长，忽见墙上张贴有“本场优待知识分子”，立即返回取来编辑证书，果然火化提前，免受尸体臭烂，不禁乐而开笑。\n\n\n\n入厕所大便完毕，发现未带手纸，见旁边有被揩过的一片脏纸，应急欲用，缺进来一个人蹲坑，只好等着那人便后先走。但那人也是没手纸，为难半天，也发现那片脏纸，企图我走后应急。如此相持许久，均心照不宣，后同时欲先下手为强，偏又进来一人，背一篓，拄一铁条，为捡废纸者，铁条一点，扎去脏纸入篓走了。两人对视，不禁乐而开笑。\n\n\n\n居住于 A 城的伯父，沉沦于二十年右派生涯，早妻离子散，平反后已垂垂暮老，多回忆早年英武及故友。我以他大学的一位女生名义去信慰藉，不想他立即复信，只好信来信往，谈当年的友情，谈数十年的思念，谈现在鳏寡人的处境，及至发展到黄昏恋。我半月一封，连续四年不断，且信中一再说要去见他，每次日期将至又以患病推延。伯父终老弱病倒，我去看他，临咽气说：“我等不及她来了。她来了，你把这个箱子交她。”又说一句：“我总没白活。”安详瞑目。掩埋了伯父，打开箱子，竟是我写给他的近百封信，得意为他在爱的幸福中度过晚年，不禁乐而开笑。\n\n\n\n陪领导去某地开会，讨论席上，领导突然脖子发痒，用手去摸，摸出一个肉肉的小东西，脸色微红旋又若无其事说：“我还以为是个虱子哩！”随手丢到地上。我低头往地上瞅，说：“噢，我还以为不是个虱子哩！”会后领导去风景区旅游，而我被命令返回，列车上买一个鸡爪边嚼边想，不禁乐而开笑。\n\n\n\n有了妻子便有了孩子，仍住在那不足十平方米的单间里。出差马上就要走了，一走又是一月，夫妻想亲热一下，孩子偏死不离家。妻说：“小宝，爸爸要走了，你去商店打些酱油，给你爸爸做一顿好吃的吧！”孩子提了酱油瓶出门，我说：“拿这个去，”给了一大口浅底盘子，“别洒了啊！”孩子走了，关门立即行动。毕，赶忙去车站，于巷口远远看见孩子双手捧盘，一步一小心地回来，不禁乐而开笑。\n\n\n\n夜里正在床上半醒半睡，有人影推门闪进来，在立柜里翻，翻出一堆破衣服和书报，扔了；再往架板上翻，翻出各类米袋子、面袋子和书报，扔了；在桌斗里又翻，是一堆读书卡片，凑眼前看了看，扔了。咕哝了一句顺门便走，我在床上说：“朋友，把门拉上，夜里有风的。”小偷把门拉上了。天明起来整理房间，一地乱书乱报，竟发现找了好久未找着的一份资料，不禁乐而开笑。\n\n\n\n上大街回来，挤了一身臭汗，牢骚道：“用枪得在街十字路口扫一通！”回家一杯茶未喝尽，楼梯上步声杂乱，巷中有人呼：“大街上有人用枪打死几十个人了！”遂也往街上跑，街上人山人海，弯腰往里挤，问：“尸体在哪儿？”一熟人说：“不是说是你讲的吗？”忽记得那一句顺口的牢骚，不禁乐而开笑。\n\n\n\n剧场里正巧和一位官太太邻座，太太把持不住放一屁，四周骚哗；骂问：“谁放的？不文明！”太太窘极不语，骂问声更甚。我站起说：“我放的！”众人骚哗即息，却以手作扇风状，太太也扇，畏我如臭物，回望她不禁乐而开笑。\n\n\n\n出外突然有人迎面过来打招呼，立即停下，作疑惑状。“你不认识我了？”“怎不认识？”于是握手，互问哪儿来，到哪儿去，互问老人康健孩子可乖，互说又胖了，又瘦了，半天的淡而无味的话。分手了，终想不起这是谁，不禁乐而开笑。\n\n\n\n弄文学的穷朋友来家侃山，酒瘾发而酒瓶仅能空出一杯酒，取马鬃四根，各人蘸吮，却大声划拳：“八匹马，五魁手……你一盅（鬃）！我一盅（鬃）！”窗外卖茶蛋的老妪对老翁说：“怪不得咱出钱让人家写文章宣传咱不干，人家钱多酒量也大，喝了整晌也未醉！”听着不禁乐而开笑。\n\n\n\n路过一条小巷，忽见有长队排出，以为又在出售紧俏物件了，急忙列入其中，排到跟前，方见是巷口唯一的厕所，居民等候出恭，不禁乐而开笑。\n\n\n\n去给孩子买一双袜子，昨日看时价是一元，今日是一元二角，怏怏出店门，打响一个喷嚏，喷带出一口痰。正想是售货员在嘲笑我，我方有喷嚏打出，一位戴“卫管员”袖章的人却责斥我吐了痰要罚五角钱。掏出那一元钱，卫管员没零钱找，遂再当地吐一口，愤愤而走，走过十步，不禁乐而开笑。\n\n\n\n出差去旅社住宿，服务员开发票将“作协”写成“做鞋”，不禁乐而开笑。\n\n\n\n夏月偏停电，爬十二层楼梯去办公室，气喘吁吁到门口了，门钥匙却和自行车钥匙系在一起，遗忘在车子锁孔了，不禁乐而开笑。\n\n\n\n路遇一女子，回望我嫣然一笑，极感幸福，即趋而前去搭话，女子闪进一家商店，尾随入店，玻璃上映出自己衣服纽扣错位，不禁乐而开笑。\n\n\n\n名字是自己的，别人却用得最多，不禁乐而开笑。\n\n\n\n写完《笑口常开》草稿，去吸一根烟，返身要眷写时，草稿不见了，妻说：“是不是一大页写过的纸，我上厕所用了。”惊呼：“那是一篇散文！”妻说：“白纸舍不得用，我只说写过的纸就没用了。”急奔厕所，幸而已臭但未全湿，捂鼻子抄出此份，不禁乐而开笑。","slug":"laught-often","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhi006jk9i1cmhh1gjj","content":"<blockquote>\n<p>摘录自贾平凹先生散文集《自在独行》中的《笑口常开》。在生活中找寻乐而开笑之事。</p>\n</blockquote>\n<p>著作得以出版，殷切切送某人一册，扉页上恭正题写：“赠 xxx 先生存正。”一月过罢，偶尔去废旧书报收购店见到此册，遂折价买回，于扉页上那条提款下又恭正题写：“再赠 xxx 先生存正。”写毕邮走，踅进一家酒馆坐喝，不禁乐而开笑。</p>\n<p>大学毕业，年届三十，婚姻难就，累得三朋四友八方搭线，但一次一次介绍终未能成就。忽一日，又有人送来游票，郑重讲明已物色着一位姑娘，同意明日去公园 xx 桥第三根栏杆下见面。黎明早起，赶去约会，等候的姑娘竟是两年前曾经别人介绍见过面的。姑娘说：“怎么又是你？”掉身而去。木木在桥上立了半晌，不禁乐而开笑。</p>\n<p>好友 x 君，编辑十五年杂志，清苦贫困，英年早逝。保存下那一支笔和一副深度近视镜。租三轮车送亡友去火葬场火化，待化的队列冗长，忽见墙上张贴有“本场优待知识分子”，立即返回取来编辑证书，果然火化提前，免受尸体臭烂，不禁乐而开笑。</p>\n<p>入厕所大便完毕，发现未带手纸，见旁边有被揩过的一片脏纸，应急欲用，缺进来一个人蹲坑，只好等着那人便后先走。但那人也是没手纸，为难半天，也发现那片脏纸，企图我走后应急。如此相持许久，均心照不宣，后同时欲先下手为强，偏又进来一人，背一篓，拄一铁条，为捡废纸者，铁条一点，扎去脏纸入篓走了。两人对视，不禁乐而开笑。</p>\n<p>居住于 A 城的伯父，沉沦于二十年右派生涯，早妻离子散，平反后已垂垂暮老，多回忆早年英武及故友。我以他大学的一位女生名义去信慰藉，不想他立即复信，只好信来信往，谈当年的友情，谈数十年的思念，谈现在鳏寡人的处境，及至发展到黄昏恋。我半月一封，连续四年不断，且信中一再说要去见他，每次日期将至又以患病推延。伯父终老弱病倒，我去看他，临咽气说：“我等不及她来了。她来了，你把这个箱子交她。”又说一句：“我总没白活。”安详瞑目。掩埋了伯父，打开箱子，竟是我写给他的近百封信，得意为他在爱的幸福中度过晚年，不禁乐而开笑。</p>\n<p>陪领导去某地开会，讨论席上，领导突然脖子发痒，用手去摸，摸出一个肉肉的小东西，脸色微红旋又若无其事说：“我还以为是个虱子哩！”随手丢到地上。我低头往地上瞅，说：“噢，我还以为不是个虱子哩！”会后领导去风景区旅游，而我被命令返回，列车上买一个鸡爪边嚼边想，不禁乐而开笑。</p>\n<p>有了妻子便有了孩子，仍住在那不足十平方米的单间里。出差马上就要走了，一走又是一月，夫妻想亲热一下，孩子偏死不离家。妻说：“小宝，爸爸要走了，你去商店打些酱油，给你爸爸做一顿好吃的吧！”孩子提了酱油瓶出门，我说：“拿这个去，”给了一大口浅底盘子，“别洒了啊！”孩子走了，关门立即行动。毕，赶忙去车站，于巷口远远看见孩子双手捧盘，一步一小心地回来，不禁乐而开笑。</p>\n<p>夜里正在床上半醒半睡，有人影推门闪进来，在立柜里翻，翻出一堆破衣服和书报，扔了；再往架板上翻，翻出各类米袋子、面袋子和书报，扔了；在桌斗里又翻，是一堆读书卡片，凑眼前看了看，扔了。咕哝了一句顺门便走，我在床上说：“朋友，把门拉上，夜里有风的。”小偷把门拉上了。天明起来整理房间，一地乱书乱报，竟发现找了好久未找着的一份资料，不禁乐而开笑。</p>\n<p>上大街回来，挤了一身臭汗，牢骚道：“用枪得在街十字路口扫一通！”回家一杯茶未喝尽，楼梯上步声杂乱，巷中有人呼：“大街上有人用枪打死几十个人了！”遂也往街上跑，街上人山人海，弯腰往里挤，问：“尸体在哪儿？”一熟人说：“不是说是你讲的吗？”忽记得那一句顺口的牢骚，不禁乐而开笑。</p>\n<p>剧场里正巧和一位官太太邻座，太太把持不住放一屁，四周骚哗；骂问：“谁放的？不文明！”太太窘极不语，骂问声更甚。我站起说：“我放的！”众人骚哗即息，却以手作扇风状，太太也扇，畏我如臭物，回望她不禁乐而开笑。</p>\n<p>出外突然有人迎面过来打招呼，立即停下，作疑惑状。“你不认识我了？”“怎不认识？”于是握手，互问哪儿来，到哪儿去，互问老人康健孩子可乖，互说又胖了，又瘦了，半天的淡而无味的话。分手了，终想不起这是谁，不禁乐而开笑。</p>\n<p>弄文学的穷朋友来家侃山，酒瘾发而酒瓶仅能空出一杯酒，取马鬃四根，各人蘸吮，却大声划拳：“八匹马，五魁手……你一盅（鬃）！我一盅（鬃）！”窗外卖茶蛋的老妪对老翁说：“怪不得咱出钱让人家写文章宣传咱不干，人家钱多酒量也大，喝了整晌也未醉！”听着不禁乐而开笑。</p>\n<p>路过一条小巷，忽见有长队排出，以为又在出售紧俏物件了，急忙列入其中，排到跟前，方见是巷口唯一的厕所，居民等候出恭，不禁乐而开笑。</p>\n<p>去给孩子买一双袜子，昨日看时价是一元，今日是一元二角，怏怏出店门，打响一个喷嚏，喷带出一口痰。正想是售货员在嘲笑我，我方有喷嚏打出，一位戴“卫管员”袖章的人却责斥我吐了痰要罚五角钱。掏出那一元钱，卫管员没零钱找，遂再当地吐一口，愤愤而走，走过十步，不禁乐而开笑。</p>\n<p>出差去旅社住宿，服务员开发票将“作协”写成“做鞋”，不禁乐而开笑。</p>\n<p>夏月偏停电，爬十二层楼梯去办公室，气喘吁吁到门口了，门钥匙却和自行车钥匙系在一起，遗忘在车子锁孔了，不禁乐而开笑。</p>\n<p>路遇一女子，回望我嫣然一笑，极感幸福，即趋而前去搭话，女子闪进一家商店，尾随入店，玻璃上映出自己衣服纽扣错位，不禁乐而开笑。</p>\n<p>名字是自己的，别人却用得最多，不禁乐而开笑。</p>\n<p>写完《笑口常开》草稿，去吸一根烟，返身要眷写时，草稿不见了，妻说：“是不是一大页写过的纸，我上厕所用了。”惊呼：“那是一篇散文！”妻说：“白纸舍不得用，我只说写过的纸就没用了。”急奔厕所，幸而已臭但未全湿，捂鼻子抄出此份，不禁乐而开笑。</p>\n","excerpt":"","more":"<blockquote>\n<p>摘录自贾平凹先生散文集《自在独行》中的《笑口常开》。在生活中找寻乐而开笑之事。</p>\n</blockquote>\n<p>著作得以出版，殷切切送某人一册，扉页上恭正题写：“赠 xxx 先生存正。”一月过罢，偶尔去废旧书报收购店见到此册，遂折价买回，于扉页上那条提款下又恭正题写：“再赠 xxx 先生存正。”写毕邮走，踅进一家酒馆坐喝，不禁乐而开笑。</p>\n<p>大学毕业，年届三十，婚姻难就，累得三朋四友八方搭线，但一次一次介绍终未能成就。忽一日，又有人送来游票，郑重讲明已物色着一位姑娘，同意明日去公园 xx 桥第三根栏杆下见面。黎明早起，赶去约会，等候的姑娘竟是两年前曾经别人介绍见过面的。姑娘说：“怎么又是你？”掉身而去。木木在桥上立了半晌，不禁乐而开笑。</p>\n<p>好友 x 君，编辑十五年杂志，清苦贫困，英年早逝。保存下那一支笔和一副深度近视镜。租三轮车送亡友去火葬场火化，待化的队列冗长，忽见墙上张贴有“本场优待知识分子”，立即返回取来编辑证书，果然火化提前，免受尸体臭烂，不禁乐而开笑。</p>\n<p>入厕所大便完毕，发现未带手纸，见旁边有被揩过的一片脏纸，应急欲用，缺进来一个人蹲坑，只好等着那人便后先走。但那人也是没手纸，为难半天，也发现那片脏纸，企图我走后应急。如此相持许久，均心照不宣，后同时欲先下手为强，偏又进来一人，背一篓，拄一铁条，为捡废纸者，铁条一点，扎去脏纸入篓走了。两人对视，不禁乐而开笑。</p>\n<p>居住于 A 城的伯父，沉沦于二十年右派生涯，早妻离子散，平反后已垂垂暮老，多回忆早年英武及故友。我以他大学的一位女生名义去信慰藉，不想他立即复信，只好信来信往，谈当年的友情，谈数十年的思念，谈现在鳏寡人的处境，及至发展到黄昏恋。我半月一封，连续四年不断，且信中一再说要去见他，每次日期将至又以患病推延。伯父终老弱病倒，我去看他，临咽气说：“我等不及她来了。她来了，你把这个箱子交她。”又说一句：“我总没白活。”安详瞑目。掩埋了伯父，打开箱子，竟是我写给他的近百封信，得意为他在爱的幸福中度过晚年，不禁乐而开笑。</p>\n<p>陪领导去某地开会，讨论席上，领导突然脖子发痒，用手去摸，摸出一个肉肉的小东西，脸色微红旋又若无其事说：“我还以为是个虱子哩！”随手丢到地上。我低头往地上瞅，说：“噢，我还以为不是个虱子哩！”会后领导去风景区旅游，而我被命令返回，列车上买一个鸡爪边嚼边想，不禁乐而开笑。</p>\n<p>有了妻子便有了孩子，仍住在那不足十平方米的单间里。出差马上就要走了，一走又是一月，夫妻想亲热一下，孩子偏死不离家。妻说：“小宝，爸爸要走了，你去商店打些酱油，给你爸爸做一顿好吃的吧！”孩子提了酱油瓶出门，我说：“拿这个去，”给了一大口浅底盘子，“别洒了啊！”孩子走了，关门立即行动。毕，赶忙去车站，于巷口远远看见孩子双手捧盘，一步一小心地回来，不禁乐而开笑。</p>\n<p>夜里正在床上半醒半睡，有人影推门闪进来，在立柜里翻，翻出一堆破衣服和书报，扔了；再往架板上翻，翻出各类米袋子、面袋子和书报，扔了；在桌斗里又翻，是一堆读书卡片，凑眼前看了看，扔了。咕哝了一句顺门便走，我在床上说：“朋友，把门拉上，夜里有风的。”小偷把门拉上了。天明起来整理房间，一地乱书乱报，竟发现找了好久未找着的一份资料，不禁乐而开笑。</p>\n<p>上大街回来，挤了一身臭汗，牢骚道：“用枪得在街十字路口扫一通！”回家一杯茶未喝尽，楼梯上步声杂乱，巷中有人呼：“大街上有人用枪打死几十个人了！”遂也往街上跑，街上人山人海，弯腰往里挤，问：“尸体在哪儿？”一熟人说：“不是说是你讲的吗？”忽记得那一句顺口的牢骚，不禁乐而开笑。</p>\n<p>剧场里正巧和一位官太太邻座，太太把持不住放一屁，四周骚哗；骂问：“谁放的？不文明！”太太窘极不语，骂问声更甚。我站起说：“我放的！”众人骚哗即息，却以手作扇风状，太太也扇，畏我如臭物，回望她不禁乐而开笑。</p>\n<p>出外突然有人迎面过来打招呼，立即停下，作疑惑状。“你不认识我了？”“怎不认识？”于是握手，互问哪儿来，到哪儿去，互问老人康健孩子可乖，互说又胖了，又瘦了，半天的淡而无味的话。分手了，终想不起这是谁，不禁乐而开笑。</p>\n<p>弄文学的穷朋友来家侃山，酒瘾发而酒瓶仅能空出一杯酒，取马鬃四根，各人蘸吮，却大声划拳：“八匹马，五魁手……你一盅（鬃）！我一盅（鬃）！”窗外卖茶蛋的老妪对老翁说：“怪不得咱出钱让人家写文章宣传咱不干，人家钱多酒量也大，喝了整晌也未醉！”听着不禁乐而开笑。</p>\n<p>路过一条小巷，忽见有长队排出，以为又在出售紧俏物件了，急忙列入其中，排到跟前，方见是巷口唯一的厕所，居民等候出恭，不禁乐而开笑。</p>\n<p>去给孩子买一双袜子，昨日看时价是一元，今日是一元二角，怏怏出店门，打响一个喷嚏，喷带出一口痰。正想是售货员在嘲笑我，我方有喷嚏打出，一位戴“卫管员”袖章的人却责斥我吐了痰要罚五角钱。掏出那一元钱，卫管员没零钱找，遂再当地吐一口，愤愤而走，走过十步，不禁乐而开笑。</p>\n<p>出差去旅社住宿，服务员开发票将“作协”写成“做鞋”，不禁乐而开笑。</p>\n<p>夏月偏停电，爬十二层楼梯去办公室，气喘吁吁到门口了，门钥匙却和自行车钥匙系在一起，遗忘在车子锁孔了，不禁乐而开笑。</p>\n<p>路遇一女子，回望我嫣然一笑，极感幸福，即趋而前去搭话，女子闪进一家商店，尾随入店，玻璃上映出自己衣服纽扣错位，不禁乐而开笑。</p>\n<p>名字是自己的，别人却用得最多，不禁乐而开笑。</p>\n<p>写完《笑口常开》草稿，去吸一根烟，返身要眷写时，草稿不见了，妻说：“是不是一大页写过的纸，我上厕所用了。”惊呼：“那是一篇散文！”妻说：“白纸舍不得用，我只说写过的纸就没用了。”急奔厕所，幸而已臭但未全湿，捂鼻子抄出此份，不禁乐而开笑。</p>\n"},{"title":"LeetCode 之二叉树的各种遍历（Binary Tree Traversal）","date":"2018-11-27T02:35:34.000Z","_content":"\n在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。\n\n想必大家对二叉树也不陌生，被各种二叉树面试题支配的恐惧仍记忆犹新……\n\n这篇就总结一下二叉树的各种遍历，包括前、中、后序遍历还有层次遍历。\n\n让我们来想象，大脑是个无底洞，这个栈它没有深度，所以我们要时而把栈底那些强行挖上来，以防痴呆！你不想痴呆吧！go go go.\n\n## 层次遍历\n先来这个层次遍历，二叉树一层又一层，它有深度。既然是一层接着一层，那很清楚了，我们逐层遍历就行。\n\n题目描述：\n```\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n清晰得不能再清晰了。递归调用 + 循环节点。代码如下：\n```\npublic class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n\n    public List<List<Integer>> levelOrder(TreeNode root) {\n\n        List<List<Integer>> list = new ArrayList<>();\n        List<TreeNode> l = new ArrayList<>();\n        l.add(root);\n        helper(list, l);\n        return list;\n\n    }\n\n    /**\n     * 递归 层层遍历\n     * \n     * @param list\n     * @param treeList\n     */\n    private void helper(List<List<Integer>> list, List<TreeNode> treeList) {\n        if (treeList.size() == 0)\n            return;\n        List<Integer> listInt = new ArrayList<>();\n        List<TreeNode> treeL = new ArrayList<>();\n        // 逐层添值\n        for (TreeNode node : treeList) {\n            if (node != null) {\n                listInt.add(node.val);\n                treeL.add(node.left);\n                treeL.add(node.right);\n            }\n        }\n        if (listInt.size() > 0)\n            list.add(listInt);\n\n        helper(list, treeL);\n    }\n```\n\n或者是使用队列 + while 循环搞定：\n```\n/**\n     * 使用队列 queue\n     * \n     * @param root\n     * @return\n     */\n    public List<List<Integer>> levelOrder1(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        List<List<Integer>> wrapList = new LinkedList<List<Integer>>();\n\n        if (root == null)\n            return wrapList;\n\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            // 有值就塞入集合 同时将其左右子节点添加到队列中\n            int levelNum = queue.size();\n            List<Integer> subList = new LinkedList<Integer>();\n            for (int i = 0; i < levelNum; i++) {\n                if (queue.peek().left != null)\n                    queue.offer(queue.peek().left);\n                if (queue.peek().right != null)\n                    queue.offer(queue.peek().right);\n                subList.add(queue.poll().val);\n            }\n            wrapList.add(subList);\n        }\n        return wrapList;\n    }\n```\n\n这个问题不大。\n\n## 中序遍历\n中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。\n\n也就是根结点遍历位置在中间： 左 -> 根 -> 右\n\n题目描述：\n```\n给定一个二叉树，返回它的中序 遍历。\n\n示例:\n\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n```\n\n既然都说了递归算法很简单，确实也很简单，先上递归算法：\n```\npublic class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n\n    /**\n     * 递归\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        helper(list, root);\n        return list;\n    }\n\n    private void helper(List<Integer> list, TreeNode node) {\n        if (node != null) {\n            if (node.left != null)\n                helper(list, node.left);\n            list.add(node.val);\n            if (node.right != null)\n                helper(list, node.right);\n        }\n    }\n```\n\n**这个递归算法在前、中、后序遍历都可以套用的，着实好用也好记。下面就不重复该代码了，无非就是结点的顺序换一换。**\n\n迭代算法，这里我们思考一下，我们需要先读其左结点，读完之后再读其根结点，左结点若是存在，那它不就是下一层的根结点吗？然后我们再一层层往上读。此时脑壳一抖，栈！\n\nStack 来解决：\n```\n    /**\n     * 栈 stack 来解决\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> inorderTraversal1(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                // 将其左节点依次放入 因为先读左节点\n                stack.push(curr);\n                curr = curr.left;\n            }\n            // 将栈顶弹出\n            curr = stack.pop();\n            // 塞值\n            res.add(curr.val);\n            // 将右节点赋值给它 完美呈现了中序遍历 ： 左 -> 根 -> 右\n            curr = curr.right;\n        }\n        return res;\n    }\n```\n\n代码也不长，该过程可以用大脑无底栈来走一遍。闭上眼睛，冥想。\n\n## 前序遍历\n前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。\n\n即根结点遍历位置在前面： 根 -> 左 -> 右\n\n题目描述：\n```\n给定一个二叉树，返回它的 前序 遍历。\n\n 示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [1,2,3]\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n```\n\n递归算法不说了，见上。\n\n迭代这里用双向链表 LinkedList，数据量大时存取数据性能好点。\n\n代码如下：\n```\n    /**\n     * 双向队列\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> preorderTraversal1(TreeNode root) {\n        LinkedList<TreeNode> stack = new LinkedList<>();\n        LinkedList<Integer> output = new LinkedList<>();\n        if (root == null) {\n            return output;\n        }\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            // 弹出队列中最后一个\n            TreeNode node = stack.pollLast();\n            output.add(node.val);\n            if (node.right != null) {\n                stack.add(node.right);\n            }\n            if (node.left != null) {\n                // 该节点就是下一个要读的根节点\n                stack.add(node.left);\n            }\n        }\n        return output;\n    }\n```\n\n这里需要注意的就是 `stack.add()` 先添加右结点在添加左结点，因为 `stack.pollLast()` 取出的是最后一个数据，这样就是左结点先弹出，满足前序遍历的顺序。\n\n## 后序遍历\n后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。\n\n即根结点遍历位置在前面： 左 -> 右 -> 根\n\n题目描述：\n```\n给定一个二叉树，返回它的 后序 遍历。\n\n示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n```\n\n同样，递归算法不重复，见上。\n\n这里的迭代算法我是看了官网的解法。秒。利用双向链表每次在起始位置添加值，顺序为根 -> 右 -> 左，然后遍历完后整个顺序从前往后就是左 -> 右 -> 根，后序遍历。\n\n双向链表 LinkedList + 栈 Stack，代码如下：\n```\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n\n    /**\n     * 根 -> 右 -> 左 存入，遍历完全后从前往后即是 左 -> 右 -> 根\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        if (root == null)\n            return ans;\n\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode cur = stack.pop();\n            // 将值塞到最前面\n            ans.addFirst(cur.val);\n            // 先左结点入栈\n            if (cur.left != null) {\n                stack.push(cur.left);\n            }\n            // 再是右结点入栈\n            if (cur.right != null) {\n                stack.push(cur.right);\n            }\n        }\n        return ans;\n    }\n```\n\n从后往前推，一气呵成。\n\n---\n其实，还是递归最好使……","source":"_posts/leetcode-binary-tree-traversal.md","raw":"---\ntitle: LeetCode 之二叉树的各种遍历（Binary Tree Traversal）\ndate: 2018-11-27 10:35:34\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。\n\n想必大家对二叉树也不陌生，被各种二叉树面试题支配的恐惧仍记忆犹新……\n\n这篇就总结一下二叉树的各种遍历，包括前、中、后序遍历还有层次遍历。\n\n让我们来想象，大脑是个无底洞，这个栈它没有深度，所以我们要时而把栈底那些强行挖上来，以防痴呆！你不想痴呆吧！go go go.\n\n## 层次遍历\n先来这个层次遍历，二叉树一层又一层，它有深度。既然是一层接着一层，那很清楚了，我们逐层遍历就行。\n\n题目描述：\n```\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n```\n\n清晰得不能再清晰了。递归调用 + 循环节点。代码如下：\n```\npublic class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n\n    public List<List<Integer>> levelOrder(TreeNode root) {\n\n        List<List<Integer>> list = new ArrayList<>();\n        List<TreeNode> l = new ArrayList<>();\n        l.add(root);\n        helper(list, l);\n        return list;\n\n    }\n\n    /**\n     * 递归 层层遍历\n     * \n     * @param list\n     * @param treeList\n     */\n    private void helper(List<List<Integer>> list, List<TreeNode> treeList) {\n        if (treeList.size() == 0)\n            return;\n        List<Integer> listInt = new ArrayList<>();\n        List<TreeNode> treeL = new ArrayList<>();\n        // 逐层添值\n        for (TreeNode node : treeList) {\n            if (node != null) {\n                listInt.add(node.val);\n                treeL.add(node.left);\n                treeL.add(node.right);\n            }\n        }\n        if (listInt.size() > 0)\n            list.add(listInt);\n\n        helper(list, treeL);\n    }\n```\n\n或者是使用队列 + while 循环搞定：\n```\n/**\n     * 使用队列 queue\n     * \n     * @param root\n     * @return\n     */\n    public List<List<Integer>> levelOrder1(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        List<List<Integer>> wrapList = new LinkedList<List<Integer>>();\n\n        if (root == null)\n            return wrapList;\n\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            // 有值就塞入集合 同时将其左右子节点添加到队列中\n            int levelNum = queue.size();\n            List<Integer> subList = new LinkedList<Integer>();\n            for (int i = 0; i < levelNum; i++) {\n                if (queue.peek().left != null)\n                    queue.offer(queue.peek().left);\n                if (queue.peek().right != null)\n                    queue.offer(queue.peek().right);\n                subList.add(queue.poll().val);\n            }\n            wrapList.add(subList);\n        }\n        return wrapList;\n    }\n```\n\n这个问题不大。\n\n## 中序遍历\n中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。\n\n也就是根结点遍历位置在中间： 左 -> 根 -> 右\n\n题目描述：\n```\n给定一个二叉树，返回它的中序 遍历。\n\n示例:\n\n输入: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n输出: [1,3,2]\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n```\n\n既然都说了递归算法很简单，确实也很简单，先上递归算法：\n```\npublic class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n\n    /**\n     * 递归\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        helper(list, root);\n        return list;\n    }\n\n    private void helper(List<Integer> list, TreeNode node) {\n        if (node != null) {\n            if (node.left != null)\n                helper(list, node.left);\n            list.add(node.val);\n            if (node.right != null)\n                helper(list, node.right);\n        }\n    }\n```\n\n**这个递归算法在前、中、后序遍历都可以套用的，着实好用也好记。下面就不重复该代码了，无非就是结点的顺序换一换。**\n\n迭代算法，这里我们思考一下，我们需要先读其左结点，读完之后再读其根结点，左结点若是存在，那它不就是下一层的根结点吗？然后我们再一层层往上读。此时脑壳一抖，栈！\n\nStack 来解决：\n```\n    /**\n     * 栈 stack 来解决\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> inorderTraversal1(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                // 将其左节点依次放入 因为先读左节点\n                stack.push(curr);\n                curr = curr.left;\n            }\n            // 将栈顶弹出\n            curr = stack.pop();\n            // 塞值\n            res.add(curr.val);\n            // 将右节点赋值给它 完美呈现了中序遍历 ： 左 -> 根 -> 右\n            curr = curr.right;\n        }\n        return res;\n    }\n```\n\n代码也不长，该过程可以用大脑无底栈来走一遍。闭上眼睛，冥想。\n\n## 前序遍历\n前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。\n\n即根结点遍历位置在前面： 根 -> 左 -> 右\n\n题目描述：\n```\n给定一个二叉树，返回它的 前序 遍历。\n\n 示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [1,2,3]\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n```\n\n递归算法不说了，见上。\n\n迭代这里用双向链表 LinkedList，数据量大时存取数据性能好点。\n\n代码如下：\n```\n    /**\n     * 双向队列\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> preorderTraversal1(TreeNode root) {\n        LinkedList<TreeNode> stack = new LinkedList<>();\n        LinkedList<Integer> output = new LinkedList<>();\n        if (root == null) {\n            return output;\n        }\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            // 弹出队列中最后一个\n            TreeNode node = stack.pollLast();\n            output.add(node.val);\n            if (node.right != null) {\n                stack.add(node.right);\n            }\n            if (node.left != null) {\n                // 该节点就是下一个要读的根节点\n                stack.add(node.left);\n            }\n        }\n        return output;\n    }\n```\n\n这里需要注意的就是 `stack.add()` 先添加右结点在添加左结点，因为 `stack.pollLast()` 取出的是最后一个数据，这样就是左结点先弹出，满足前序遍历的顺序。\n\n## 后序遍历\n后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。\n\n即根结点遍历位置在前面： 左 -> 右 -> 根\n\n题目描述：\n```\n给定一个二叉树，返回它的 后序 遍历。\n\n示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n```\n\n同样，递归算法不重复，见上。\n\n这里的迭代算法我是看了官网的解法。秒。利用双向链表每次在起始位置添加值，顺序为根 -> 右 -> 左，然后遍历完后整个顺序从前往后就是左 -> 右 -> 根，后序遍历。\n\n双向链表 LinkedList + 栈 Stack，代码如下：\n```\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        TreeNode(int x) {\n            val = x;\n        }\n    }\n\n    /**\n     * 根 -> 右 -> 左 存入，遍历完全后从前往后即是 左 -> 右 -> 根\n     * \n     * @param root\n     * @return\n     */\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        if (root == null)\n            return ans;\n\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode cur = stack.pop();\n            // 将值塞到最前面\n            ans.addFirst(cur.val);\n            // 先左结点入栈\n            if (cur.left != null) {\n                stack.push(cur.left);\n            }\n            // 再是右结点入栈\n            if (cur.right != null) {\n                stack.push(cur.right);\n            }\n        }\n        return ans;\n    }\n```\n\n从后往前推，一气呵成。\n\n---\n其实，还是递归最好使……","slug":"leetcode-binary-tree-traversal","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhi006mk9i1b9awby77","content":"<p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>\n<p>想必大家对二叉树也不陌生，被各种二叉树面试题支配的恐惧仍记忆犹新……</p>\n<p>这篇就总结一下二叉树的各种遍历，包括前、中、后序遍历还有层次遍历。</p>\n<p>让我们来想象，大脑是个无底洞，这个栈它没有深度，所以我们要时而把栈底那些强行挖上来，以防痴呆！你不想痴呆吧！go go go.</p>\n<h2 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h2><p>先来这个层次遍历，二叉树一层又一层，它有深度。既然是一层接着一层，那很清楚了，我们逐层遍历就行。</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</span><br><span class=\"line\"></span><br><span class=\"line\">例如:</span><br><span class=\"line\">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回其层次遍历结果：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  [15,7]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>清晰得不能再清晰了。递归调用 + 循环节点。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        TreeNode left;</span><br><span class=\"line\">        TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; l = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        l.add(root);</span><br><span class=\"line\">        helper(list, l);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 递归 层层遍历</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     * @param treeList</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void helper(List&lt;List&lt;Integer&gt;&gt; list, List&lt;TreeNode&gt; treeList) &#123;</span><br><span class=\"line\">        if (treeList.size() == 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        List&lt;Integer&gt; listInt = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; treeL = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // 逐层添值</span><br><span class=\"line\">        for (TreeNode node : treeList) &#123;</span><br><span class=\"line\">            if (node != null) &#123;</span><br><span class=\"line\">                listInt.add(node.val);</span><br><span class=\"line\">                treeL.add(node.left);</span><br><span class=\"line\">                treeL.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (listInt.size() &gt; 0)</span><br><span class=\"line\">            list.add(listInt);</span><br><span class=\"line\"></span><br><span class=\"line\">        helper(list, treeL);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者是使用队列 + while 循环搞定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 使用队列 queue</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param root</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder1(TreeNode root) &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (root == null)</span><br><span class=\"line\">            return wrapList;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            // 有值就塞入集合 同时将其左右子节点添加到队列中</span><br><span class=\"line\">            int levelNum = queue.size();</span><br><span class=\"line\">            List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">            for (int i = 0; i &lt; levelNum; i++) &#123;</span><br><span class=\"line\">                if (queue.peek().left != null)</span><br><span class=\"line\">                    queue.offer(queue.peek().left);</span><br><span class=\"line\">                if (queue.peek().right != null)</span><br><span class=\"line\">                    queue.offer(queue.peek().right);</span><br><span class=\"line\">                subList.add(queue.poll().val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            wrapList.add(subList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return wrapList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个问题不大。</p>\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><p>中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p>\n<p>也就是根结点遍历位置在中间： 左 -&gt; 根 -&gt; 右</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回它的中序 遍历。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,null,2,3]</span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3</span><br><span class=\"line\"></span><br><span class=\"line\">输出: [1,3,2]</span><br><span class=\"line\">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>\n\n<p>既然都说了递归算法很简单，确实也很简单，先上递归算法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        TreeNode left;</span><br><span class=\"line\">        TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 递归</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param root</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        helper(list, root);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void helper(List&lt;Integer&gt; list, TreeNode node) &#123;</span><br><span class=\"line\">        if (node != null) &#123;</span><br><span class=\"line\">            if (node.left != null)</span><br><span class=\"line\">                helper(list, node.left);</span><br><span class=\"line\">            list.add(node.val);</span><br><span class=\"line\">            if (node.right != null)</span><br><span class=\"line\">                helper(list, node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这个递归算法在前、中、后序遍历都可以套用的，着实好用也好记。下面就不重复该代码了，无非就是结点的顺序换一换。</strong></p>\n<p>迭代算法，这里我们思考一下，我们需要先读其左结点，读完之后再读其根结点，左结点若是存在，那它不就是下一层的根结点吗？然后我们再一层层往上读。此时脑壳一抖，栈！</p>\n<p>Stack 来解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 栈 stack 来解决</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param root</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;Integer&gt; inorderTraversal1(TreeNode root) &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">    TreeNode curr = root;</span><br><span class=\"line\">    while (curr != null || !stack.isEmpty()) &#123;</span><br><span class=\"line\">        while (curr != null) &#123;</span><br><span class=\"line\">            // 将其左节点依次放入 因为先读左节点</span><br><span class=\"line\">            stack.push(curr);</span><br><span class=\"line\">            curr = curr.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将栈顶弹出</span><br><span class=\"line\">        curr = stack.pop();</span><br><span class=\"line\">        // 塞值</span><br><span class=\"line\">        res.add(curr.val);</span><br><span class=\"line\">        // 将右节点赋值给它 完美呈现了中序遍历 ： 左 -&gt; 根 -&gt; 右</span><br><span class=\"line\">        curr = curr.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码也不长，该过程可以用大脑无底栈来走一遍。闭上眼睛，冥想。</p>\n<h2 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h2><p>前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。</p>\n<p>即根结点遍历位置在前面： 根 -&gt; 左 -&gt; 右</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回它的 前序 遍历。</span><br><span class=\"line\"></span><br><span class=\"line\"> 示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [1,2,3]</span><br><span class=\"line\">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>\n\n<p>递归算法不说了，见上。</p>\n<p>迭代这里用双向链表 LinkedList，数据量大时存取数据性能好点。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 双向队列</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param root</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;Integer&gt; preorderTraversal1(TreeNode root) &#123;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    if (root == null) &#123;</span><br><span class=\"line\">        return output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack.add(root);</span><br><span class=\"line\">    while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        // 弹出队列中最后一个</span><br><span class=\"line\">        TreeNode node = stack.pollLast();</span><br><span class=\"line\">        output.add(node.val);</span><br><span class=\"line\">        if (node.right != null) &#123;</span><br><span class=\"line\">            stack.add(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (node.left != null) &#123;</span><br><span class=\"line\">            // 该节点就是下一个要读的根节点</span><br><span class=\"line\">            stack.add(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的就是 <code>stack.add()</code> 先添加右结点在添加左结点，因为 <code>stack.pollLast()</code> 取出的是最后一个数据，这样就是左结点先弹出，满足前序遍历的顺序。</p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><p>后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。</p>\n<p>即根结点遍历位置在前面： 左 -&gt; 右 -&gt; 根</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回它的 后序 遍历。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [3,2,1]</span><br><span class=\"line\">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>\n\n<p>同样，递归算法不重复，见上。</p>\n<p>这里的迭代算法我是看了官网的解法。秒。利用双向链表每次在起始位置添加值，顺序为根 -&gt; 右 -&gt; 左，然后遍历完后整个顺序从前往后就是左 -&gt; 右 -&gt; 根，后序遍历。</p>\n<p>双向链表 LinkedList + 栈 Stack，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode(int x) &#123;</span><br><span class=\"line\">        val = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 根 -&gt; 右 -&gt; 左 存入，遍历完全后从前往后即是 左 -&gt; 右 -&gt; 根</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param root</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">    if (root == null)</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode cur = stack.pop();</span><br><span class=\"line\">        // 将值塞到最前面</span><br><span class=\"line\">        ans.addFirst(cur.val);</span><br><span class=\"line\">        // 先左结点入栈</span><br><span class=\"line\">        if (cur.left != null) &#123;</span><br><span class=\"line\">            stack.push(cur.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 再是右结点入栈</span><br><span class=\"line\">        if (cur.right != null) &#123;</span><br><span class=\"line\">            stack.push(cur.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从后往前推，一气呵成。</p>\n<hr>\n<p>其实，还是递归最好使……</p>\n","excerpt":"","more":"<p>在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p>\n<p>想必大家对二叉树也不陌生，被各种二叉树面试题支配的恐惧仍记忆犹新……</p>\n<p>这篇就总结一下二叉树的各种遍历，包括前、中、后序遍历还有层次遍历。</p>\n<p>让我们来想象，大脑是个无底洞，这个栈它没有深度，所以我们要时而把栈底那些强行挖上来，以防痴呆！你不想痴呆吧！go go go.</p>\n<h2 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h2><p>先来这个层次遍历，二叉树一层又一层，它有深度。既然是一层接着一层，那很清楚了，我们逐层遍历就行。</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</span><br><span class=\"line\"></span><br><span class=\"line\">例如:</span><br><span class=\"line\">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回其层次遍历结果：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  [15,7]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>清晰得不能再清晰了。递归调用 + 循环节点。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        TreeNode left;</span><br><span class=\"line\">        TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; l = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        l.add(root);</span><br><span class=\"line\">        helper(list, l);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 递归 层层遍历</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     * @param treeList</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void helper(List&lt;List&lt;Integer&gt;&gt; list, List&lt;TreeNode&gt; treeList) &#123;</span><br><span class=\"line\">        if (treeList.size() == 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        List&lt;Integer&gt; listInt = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        List&lt;TreeNode&gt; treeL = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // 逐层添值</span><br><span class=\"line\">        for (TreeNode node : treeList) &#123;</span><br><span class=\"line\">            if (node != null) &#123;</span><br><span class=\"line\">                listInt.add(node.val);</span><br><span class=\"line\">                treeL.add(node.left);</span><br><span class=\"line\">                treeL.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (listInt.size() &gt; 0)</span><br><span class=\"line\">            list.add(listInt);</span><br><span class=\"line\"></span><br><span class=\"line\">        helper(list, treeL);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者是使用队列 + while 循环搞定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 使用队列 queue</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param root</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; levelOrder1(TreeNode root) &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        if (root == null)</span><br><span class=\"line\">            return wrapList;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            // 有值就塞入集合 同时将其左右子节点添加到队列中</span><br><span class=\"line\">            int levelNum = queue.size();</span><br><span class=\"line\">            List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">            for (int i = 0; i &lt; levelNum; i++) &#123;</span><br><span class=\"line\">                if (queue.peek().left != null)</span><br><span class=\"line\">                    queue.offer(queue.peek().left);</span><br><span class=\"line\">                if (queue.peek().right != null)</span><br><span class=\"line\">                    queue.offer(queue.peek().right);</span><br><span class=\"line\">                subList.add(queue.poll().val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            wrapList.add(subList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return wrapList;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个问题不大。</p>\n<h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2><p>中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p>\n<p>也就是根结点遍历位置在中间： 左 -&gt; 根 -&gt; 右</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回它的中序 遍历。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,null,2,3]</span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3</span><br><span class=\"line\"></span><br><span class=\"line\">输出: [1,3,2]</span><br><span class=\"line\">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>\n\n<p>既然都说了递归算法很简单，确实也很简单，先上递归算法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        TreeNode left;</span><br><span class=\"line\">        TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 递归</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param root</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        helper(list, root);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void helper(List&lt;Integer&gt; list, TreeNode node) &#123;</span><br><span class=\"line\">        if (node != null) &#123;</span><br><span class=\"line\">            if (node.left != null)</span><br><span class=\"line\">                helper(list, node.left);</span><br><span class=\"line\">            list.add(node.val);</span><br><span class=\"line\">            if (node.right != null)</span><br><span class=\"line\">                helper(list, node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这个递归算法在前、中、后序遍历都可以套用的，着实好用也好记。下面就不重复该代码了，无非就是结点的顺序换一换。</strong></p>\n<p>迭代算法，这里我们思考一下，我们需要先读其左结点，读完之后再读其根结点，左结点若是存在，那它不就是下一层的根结点吗？然后我们再一层层往上读。此时脑壳一抖，栈！</p>\n<p>Stack 来解决：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 栈 stack 来解决</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param root</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;Integer&gt; inorderTraversal1(TreeNode root) &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">    TreeNode curr = root;</span><br><span class=\"line\">    while (curr != null || !stack.isEmpty()) &#123;</span><br><span class=\"line\">        while (curr != null) &#123;</span><br><span class=\"line\">            // 将其左节点依次放入 因为先读左节点</span><br><span class=\"line\">            stack.push(curr);</span><br><span class=\"line\">            curr = curr.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 将栈顶弹出</span><br><span class=\"line\">        curr = stack.pop();</span><br><span class=\"line\">        // 塞值</span><br><span class=\"line\">        res.add(curr.val);</span><br><span class=\"line\">        // 将右节点赋值给它 完美呈现了中序遍历 ： 左 -&gt; 根 -&gt; 右</span><br><span class=\"line\">        curr = curr.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码也不长，该过程可以用大脑无底栈来走一遍。闭上眼睛，冥想。</p>\n<h2 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h2><p>前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。</p>\n<p>即根结点遍历位置在前面： 根 -&gt; 左 -&gt; 右</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回它的 前序 遍历。</span><br><span class=\"line\"></span><br><span class=\"line\"> 示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [1,2,3]</span><br><span class=\"line\">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>\n\n<p>递归算法不说了，见上。</p>\n<p>迭代这里用双向链表 LinkedList，数据量大时存取数据性能好点。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 双向队列</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param root</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;Integer&gt; preorderTraversal1(TreeNode root) &#123;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    if (root == null) &#123;</span><br><span class=\"line\">        return output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack.add(root);</span><br><span class=\"line\">    while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        // 弹出队列中最后一个</span><br><span class=\"line\">        TreeNode node = stack.pollLast();</span><br><span class=\"line\">        output.add(node.val);</span><br><span class=\"line\">        if (node.right != null) &#123;</span><br><span class=\"line\">            stack.add(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (node.left != null) &#123;</span><br><span class=\"line\">            // 该节点就是下一个要读的根节点</span><br><span class=\"line\">            stack.add(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return output;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的就是 <code>stack.add()</code> 先添加右结点在添加左结点，因为 <code>stack.pollLast()</code> 取出的是最后一个数据，这样就是左结点先弹出，满足前序遍历的顺序。</p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><p>后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。</p>\n<p>即根结点遍历位置在前面： 左 -&gt; 右 -&gt; 根</p>\n<p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个二叉树，返回它的 后序 遍历。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [3,2,1]</span><br><span class=\"line\">进阶: 递归算法很简单，你可以通过迭代算法完成吗？</span><br></pre></td></tr></table></figure>\n\n<p>同样，递归算法不重复，见上。</p>\n<p>这里的迭代算法我是看了官网的解法。秒。利用双向链表每次在起始位置添加值，顺序为根 -&gt; 右 -&gt; 左，然后遍历完后整个顺序从前往后就是左 -&gt; 右 -&gt; 根，后序遍历。</p>\n<p>双向链表 LinkedList + 栈 Stack，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TreeNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\"></span><br><span class=\"line\">    TreeNode(int x) &#123;</span><br><span class=\"line\">        val = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 根 -&gt; 右 -&gt; 左 存入，遍历完全后从前往后即是 左 -&gt; 右 -&gt; 根</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param root</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class=\"line\">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">    if (root == null)</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack.push(root);</span><br><span class=\"line\">    while (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        TreeNode cur = stack.pop();</span><br><span class=\"line\">        // 将值塞到最前面</span><br><span class=\"line\">        ans.addFirst(cur.val);</span><br><span class=\"line\">        // 先左结点入栈</span><br><span class=\"line\">        if (cur.left != null) &#123;</span><br><span class=\"line\">            stack.push(cur.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 再是右结点入栈</span><br><span class=\"line\">        if (cur.right != null) &#123;</span><br><span class=\"line\">            stack.push(cur.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从后往前推，一气呵成。</p>\n<hr>\n<p>其实，还是递归最好使……</p>\n"},{"title":"LeetCode 之组合总和系列（Combination Sum）","date":"2018-11-14T03:29:02.000Z","_content":"\nLeetCode 中有多道组合总和（Combination Sum）的题，这些题目都是比较经典的，面试很可能会问到。我这一想，还真是。今天就来简单总结下这一系列题目，总结很重要，还要时而回顾！\n\n## Combination Sum I\n\n第一道题的描述如下：\n```\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n示例 2:\n\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n**注意点：**\n\n- **candidates 中的数字可以无限制重复被选取。**\n- **解集不能包含重复的组合。**\n\n这时候头脑里很快就会产生一个思路：无限遍历该数组，直到其元素之和满足条件，然后塞入集合中。\n\n这个想法没问题，不过在这过程中我们怎么才能满足`解集不能包含重复的组合。`这个条件呢？\n\n对对对，那就是确定一个 index，我们要保证数组不往回找就是了。\n\n解题代码如下：\n```\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> list = new ArrayList<>();\n        Arrays.sort(candidates);\n        recursive(list, new ArrayList<>(), candidates, target, 0);\n        return list;\n    }\n\n    /**\n     * \n     * @param list\n     *            总的输出 list\n     * @param tempList\n     *            存放的 list\n     * @param nums\n     *            数组\n     * @param remain\n     *            剩余值\n     * @param index\n     *            数组下标\n     */\n    private void recursive(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int index) {\n\n        if (remain < 0) // return 或者进行 add 操作后就开始执行弹出尾部元素 塞入下个元素\n            return;\n        else if (remain == 0)\n            list.add(new ArrayList<>(tempList)); // 这里需要注意不能直接 list.add(tempList),最终 tempList 所指向的对象是空的,\n                                                    // 所以需要 new 一个新对象，将值复制进去\n        else {\n            for (int i = index; i < nums.length; i++) {\n                tempList.add(nums[i]); // 挨个塞入\n                recursive(list, tempList, nums, remain - nums[i], i); // 由于元素可重复 所以是 i\n                tempList.remove(tempList.size() - 1); // 挨个弹出\n            }\n        }\n    }\n```\n\n我这注释什么的都有，理解起来不成问题吧。这里需要注意的就是两个点：`list.add(new ArrayList<>(tempList));` 和 ` recursive(list, tempList, nums, remain - nums[i], i);`。\n\n这里先对数组进行排序可以使计算更快，当然你也可以不排序。\n\n## Combination Sum II\n\n第二道对第一道稍微加工了一下，描述如下：\n```\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n所有数字（包括目标数）都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n```\n\n**注意点：**\n\n- **candidates 中的每个数字在每个组合中只能使用一次。**\n- **解集不能包含重复的组合。**\n\n是的，这里把条件改了，数组中的每个元素在每个组合中只能使用一次！\n\n这就意味着每次递归操作时其下标都需要往后移一位了！\n\n代码如下：\n```\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> list = new ArrayList<>();\n        Arrays.sort(candidates);\n        recursive(list, new ArrayList<>(), candidates, target, 0);\n        return list;\n\n    }\n\n    /**\n     * DFS 添加每个满足条件的集合\n     * \n     * @param list\n     *            最终返回集合\n     * @param tempList\n     *            每个满足条件的子集合\n     * @param candidates\n     *            数组\n     * @param remain\n     *            剩余值\n     * @param index\n     *            数组下标\n     */\n    private void recursive(List<List<Integer>> list, List<Integer> tempList, int[] candidates, int remain, int index) {\n        if (remain < 0)\n            return;\n        else if (remain == 0)\n            list.add(new ArrayList<>(tempList));\n        else {\n            for (int i = index; i < candidates.length; i++) {\n                if (i > index && candidates[i] == candidates[i - 1]) // 说明两个值相等且之前一个值已经返回\n                    continue;\n                tempList.add(candidates[i]);\n                recursive(list, tempList, candidates, remain - candidates[i], i + 1); // 规定数组中每个数字在每个组合中只能使用一次\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n```\n\n相比较上一题的代码，这次只是加了一个条件判断以及递归中元素下标加了一。\n\n这里就要对数组先进行排序操作了，新增的条件判断也是为了优化代码执行速度。\n\n## Combination Sum III\n\n再来看第三道变形，描述如下：\n```\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n说明：\n\n所有数字都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n```\n\n这次不给出数组了，而是规定了数组中元素的取值范围。\n\n双手一摊，这还不是一样吗，不给我就自己造就是了！\n\n**注意点：**\n\n- **解集不能包含重复的组合。**\n\n解题代码如下：\n```\npublic List<List<Integer>> combinationSum3(int k, int n) {\n        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        List<List<Integer>> list = new ArrayList<>();\n        dfs(list, new ArrayList<>(), nums, k, n, 0);\n        return list;\n\n    }\n\n    /**\n     * \n     * @param list\n     *            最终返回的 list\n     * @param tempList\n     *            作为寻求满足条件的暂存 list\n     * @param nums\n     *            数组\n     * @param reNum\n     *            剩余的元素个数\n     * @param reSum\n     *            剩余的总和\n     * @param index\n     *            数组下标\n     */\n    private void dfs(List<List<Integer>> list, List<Integer> tempList, int[] nums, int reNum, int reSum, int index) {\n        if (reNum < 0 || reSum < 0) // 两者有其一小于 0 就是不满足条件\n            return;\n        if (reNum == 0 && reSum == 0) // 两者都为 0 时满足条件，塞入\n            list.add(new ArrayList<>(tempList));\n        else if (reNum == 0 || reSum == 0) // 两者中有且只有一者等于 0 就不满足条件\n            return;\n        else {\n            for (int i = index; i < nums.length; i++) {\n                tempList.add(nums[i]);\n                dfs(list, tempList, nums, reNum - 1, reSum - nums[i], i + 1); // 不能重复元素 所以 i + 1\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n```\n\n真不愧为机智小少年……\n\n## Combination Sum IV\n\n第四道变形就复杂了一些了，描述如下：\n```\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n示例:\n\nnums = [1, 2, 3]\ntarget = 4\n\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n```\n\n这里数组的元素可以重复，且组合的元素也能相同，但是顺序要不同。\n\n一开始当然就是无脑循环了，然后满足条件就加上一，结果就是超时……\n\n说明这么暴力不行的……\n\n后来一想，无脑循环就相当于每一次都从头进行循环算了一遍，很多都是重复的计算。\n\n对了，DP 浮现在了脑中，在那飘啊飘。\n\n代码如下：\n```\nprivate int[] dp;\n\n    /**\n     * DP\n     * \n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationSum4(int[] nums, int target) {\n        dp = new int[target + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 1;\n        return helper(nums, target);\n    }\n\n    private int helper(int[] nums, int target) {\n        if (dp[target] != -1) {\n            return dp[target]; // 若是之前的已经计算过了 直接返回\n        }\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (target >= nums[i]) { // 所有组合的种数相加\n                res += helper(nums, target - nums[i]);\n            }\n        }\n        dp[target] = res; // 计算后赋值用于之后的数字使用\n        return res;\n    }\n```\n\n用空间换取时间的操作，DP + 递归稍微费点脑。\n\n还有一种解法：\n```\n/**\n     * DP\n     * \n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationSum4(int[] nums, int target) {\n        int[] comb = new int[target + 1];\n        comb[0] = 1;\n        for (int i = 1; i < comb.length; i++) {\n            for (int j = 0; j < nums.length; j++) {\n                if (i - nums[j] >= 0) {\n                    comb[i] += comb[i - nums[j]];\n                }\n            }\n        }\n        return comb[target];\n    }\n```\n\n好了，组合总和系列（Combination Sum）的题目总结完了。记住了**回溯**。","source":"_posts/leetcode-combination-sum.md","raw":"---\ntitle: LeetCode 之组合总和系列（Combination Sum）\ndate: 2018-11-14 11:29:02\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\nLeetCode 中有多道组合总和（Combination Sum）的题，这些题目都是比较经典的，面试很可能会问到。我这一想，还真是。今天就来简单总结下这一系列题目，总结很重要，还要时而回顾！\n\n## Combination Sum I\n\n第一道题的描述如下：\n```\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的数字可以无限制重复被选取。\n\n说明：\n\n所有数字（包括 target）都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n示例 2:\n\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n**注意点：**\n\n- **candidates 中的数字可以无限制重复被选取。**\n- **解集不能包含重复的组合。**\n\n这时候头脑里很快就会产生一个思路：无限遍历该数组，直到其元素之和满足条件，然后塞入集合中。\n\n这个想法没问题，不过在这过程中我们怎么才能满足`解集不能包含重复的组合。`这个条件呢？\n\n对对对，那就是确定一个 index，我们要保证数组不往回找就是了。\n\n解题代码如下：\n```\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> list = new ArrayList<>();\n        Arrays.sort(candidates);\n        recursive(list, new ArrayList<>(), candidates, target, 0);\n        return list;\n    }\n\n    /**\n     * \n     * @param list\n     *            总的输出 list\n     * @param tempList\n     *            存放的 list\n     * @param nums\n     *            数组\n     * @param remain\n     *            剩余值\n     * @param index\n     *            数组下标\n     */\n    private void recursive(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int index) {\n\n        if (remain < 0) // return 或者进行 add 操作后就开始执行弹出尾部元素 塞入下个元素\n            return;\n        else if (remain == 0)\n            list.add(new ArrayList<>(tempList)); // 这里需要注意不能直接 list.add(tempList),最终 tempList 所指向的对象是空的,\n                                                    // 所以需要 new 一个新对象，将值复制进去\n        else {\n            for (int i = index; i < nums.length; i++) {\n                tempList.add(nums[i]); // 挨个塞入\n                recursive(list, tempList, nums, remain - nums[i], i); // 由于元素可重复 所以是 i\n                tempList.remove(tempList.size() - 1); // 挨个弹出\n            }\n        }\n    }\n```\n\n我这注释什么的都有，理解起来不成问题吧。这里需要注意的就是两个点：`list.add(new ArrayList<>(tempList));` 和 ` recursive(list, tempList, nums, remain - nums[i], i);`。\n\n这里先对数组进行排序可以使计算更快，当然你也可以不排序。\n\n## Combination Sum II\n\n第二道对第一道稍微加工了一下，描述如下：\n```\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n所有数字（包括目标数）都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n```\n\n**注意点：**\n\n- **candidates 中的每个数字在每个组合中只能使用一次。**\n- **解集不能包含重复的组合。**\n\n是的，这里把条件改了，数组中的每个元素在每个组合中只能使用一次！\n\n这就意味着每次递归操作时其下标都需要往后移一位了！\n\n代码如下：\n```\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> list = new ArrayList<>();\n        Arrays.sort(candidates);\n        recursive(list, new ArrayList<>(), candidates, target, 0);\n        return list;\n\n    }\n\n    /**\n     * DFS 添加每个满足条件的集合\n     * \n     * @param list\n     *            最终返回集合\n     * @param tempList\n     *            每个满足条件的子集合\n     * @param candidates\n     *            数组\n     * @param remain\n     *            剩余值\n     * @param index\n     *            数组下标\n     */\n    private void recursive(List<List<Integer>> list, List<Integer> tempList, int[] candidates, int remain, int index) {\n        if (remain < 0)\n            return;\n        else if (remain == 0)\n            list.add(new ArrayList<>(tempList));\n        else {\n            for (int i = index; i < candidates.length; i++) {\n                if (i > index && candidates[i] == candidates[i - 1]) // 说明两个值相等且之前一个值已经返回\n                    continue;\n                tempList.add(candidates[i]);\n                recursive(list, tempList, candidates, remain - candidates[i], i + 1); // 规定数组中每个数字在每个组合中只能使用一次\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n```\n\n相比较上一题的代码，这次只是加了一个条件判断以及递归中元素下标加了一。\n\n这里就要对数组先进行排序操作了，新增的条件判断也是为了优化代码执行速度。\n\n## Combination Sum III\n\n再来看第三道变形，描述如下：\n```\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n说明：\n\n所有数字都是正整数。\n解集不能包含重复的组合。 \n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n```\n\n这次不给出数组了，而是规定了数组中元素的取值范围。\n\n双手一摊，这还不是一样吗，不给我就自己造就是了！\n\n**注意点：**\n\n- **解集不能包含重复的组合。**\n\n解题代码如下：\n```\npublic List<List<Integer>> combinationSum3(int k, int n) {\n        int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        List<List<Integer>> list = new ArrayList<>();\n        dfs(list, new ArrayList<>(), nums, k, n, 0);\n        return list;\n\n    }\n\n    /**\n     * \n     * @param list\n     *            最终返回的 list\n     * @param tempList\n     *            作为寻求满足条件的暂存 list\n     * @param nums\n     *            数组\n     * @param reNum\n     *            剩余的元素个数\n     * @param reSum\n     *            剩余的总和\n     * @param index\n     *            数组下标\n     */\n    private void dfs(List<List<Integer>> list, List<Integer> tempList, int[] nums, int reNum, int reSum, int index) {\n        if (reNum < 0 || reSum < 0) // 两者有其一小于 0 就是不满足条件\n            return;\n        if (reNum == 0 && reSum == 0) // 两者都为 0 时满足条件，塞入\n            list.add(new ArrayList<>(tempList));\n        else if (reNum == 0 || reSum == 0) // 两者中有且只有一者等于 0 就不满足条件\n            return;\n        else {\n            for (int i = index; i < nums.length; i++) {\n                tempList.add(nums[i]);\n                dfs(list, tempList, nums, reNum - 1, reSum - nums[i], i + 1); // 不能重复元素 所以 i + 1\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n```\n\n真不愧为机智小少年……\n\n## Combination Sum IV\n\n第四道变形就复杂了一些了，描述如下：\n```\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n示例:\n\nnums = [1, 2, 3]\ntarget = 4\n\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n```\n\n这里数组的元素可以重复，且组合的元素也能相同，但是顺序要不同。\n\n一开始当然就是无脑循环了，然后满足条件就加上一，结果就是超时……\n\n说明这么暴力不行的……\n\n后来一想，无脑循环就相当于每一次都从头进行循环算了一遍，很多都是重复的计算。\n\n对了，DP 浮现在了脑中，在那飘啊飘。\n\n代码如下：\n```\nprivate int[] dp;\n\n    /**\n     * DP\n     * \n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationSum4(int[] nums, int target) {\n        dp = new int[target + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 1;\n        return helper(nums, target);\n    }\n\n    private int helper(int[] nums, int target) {\n        if (dp[target] != -1) {\n            return dp[target]; // 若是之前的已经计算过了 直接返回\n        }\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (target >= nums[i]) { // 所有组合的种数相加\n                res += helper(nums, target - nums[i]);\n            }\n        }\n        dp[target] = res; // 计算后赋值用于之后的数字使用\n        return res;\n    }\n```\n\n用空间换取时间的操作，DP + 递归稍微费点脑。\n\n还有一种解法：\n```\n/**\n     * DP\n     * \n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationSum4(int[] nums, int target) {\n        int[] comb = new int[target + 1];\n        comb[0] = 1;\n        for (int i = 1; i < comb.length; i++) {\n            for (int j = 0; j < nums.length; j++) {\n                if (i - nums[j] >= 0) {\n                    comb[i] += comb[i - nums[j]];\n                }\n            }\n        }\n        return comb[target];\n    }\n```\n\n好了，组合总和系列（Combination Sum）的题目总结完了。记住了**回溯**。","slug":"leetcode-combination-sum","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhi006ok9i1f5305ufb","content":"<p>LeetCode 中有多道组合总和（Combination Sum）的题，这些题目都是比较经典的，面试很可能会问到。我这一想，还真是。今天就来简单总结下这一系列题目，总结很重要，还要时而回顾！</p>\n<h2 id=\"Combination-Sum-I\"><a href=\"#Combination-Sum-I\" class=\"headerlink\" title=\"Combination Sum I\"></a>Combination Sum I</h2><p>第一道题的描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">candidates 中的数字可以无限制重复被选取。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">所有数字（包括 target）都是正整数。</span><br><span class=\"line\">解集不能包含重复的组合。 </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,3,6,7], target = 7,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7],</span><br><span class=\"line\">  [2,2,3]</span><br><span class=\"line\">]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,3,5], target = 8,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,2,2,2],</span><br><span class=\"line\">  [2,3,3],</span><br><span class=\"line\">  [3,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong></p>\n<ul>\n<li><strong>candidates 中的数字可以无限制重复被选取。</strong></li>\n<li><strong>解集不能包含重复的组合。</strong></li>\n</ul>\n<p>这时候头脑里很快就会产生一个思路：无限遍历该数组，直到其元素之和满足条件，然后塞入集合中。</p>\n<p>这个想法没问题，不过在这过程中我们怎么才能满足<code>解集不能包含重复的组合。</code>这个条件呢？</p>\n<p>对对对，那就是确定一个 index，我们要保证数组不往回找就是了。</p>\n<p>解题代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        recursive(list, new ArrayList&lt;&gt;(), candidates, target, 0);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     *            总的输出 list</span><br><span class=\"line\">     * @param tempList</span><br><span class=\"line\">     *            存放的 list</span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     *            数组</span><br><span class=\"line\">     * @param remain</span><br><span class=\"line\">     *            剩余值</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     *            数组下标</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void recursive(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int remain, int index) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (remain &lt; 0) // return 或者进行 add 操作后就开始执行弹出尾部元素 塞入下个元素</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        else if (remain == 0)</span><br><span class=\"line\">            list.add(new ArrayList&lt;&gt;(tempList)); // 这里需要注意不能直接 list.add(tempList),最终 tempList 所指向的对象是空的,</span><br><span class=\"line\">                                                    // 所以需要 new 一个新对象，将值复制进去</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int i = index; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                tempList.add(nums[i]); // 挨个塞入</span><br><span class=\"line\">                recursive(list, tempList, nums, remain - nums[i], i); // 由于元素可重复 所以是 i</span><br><span class=\"line\">                tempList.remove(tempList.size() - 1); // 挨个弹出</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我这注释什么的都有，理解起来不成问题吧。这里需要注意的就是两个点：<code>list.add(new ArrayList&lt;&gt;(tempList));</code> 和 <code> recursive(list, tempList, nums, remain - nums[i], i);</code>。</p>\n<p>这里先对数组进行排序可以使计算更快，当然你也可以不排序。</p>\n<h2 id=\"Combination-Sum-II\"><a href=\"#Combination-Sum-II\" class=\"headerlink\" title=\"Combination Sum II\"></a>Combination Sum II</h2><p>第二道对第一道稍微加工了一下，描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">candidates 中的每个数字在每个组合中只能使用一次。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">所有数字（包括目标数）都是正整数。</span><br><span class=\"line\">解集不能包含重复的组合。 </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1, 7],</span><br><span class=\"line\">  [1, 2, 5],</span><br><span class=\"line\">  [2, 6],</span><br><span class=\"line\">  [1, 1, 6]</span><br><span class=\"line\">]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,2],</span><br><span class=\"line\">  [5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong></p>\n<ul>\n<li><strong>candidates 中的每个数字在每个组合中只能使用一次。</strong></li>\n<li><strong>解集不能包含重复的组合。</strong></li>\n</ul>\n<p>是的，这里把条件改了，数组中的每个元素在每个组合中只能使用一次！</p>\n<p>这就意味着每次递归操作时其下标都需要往后移一位了！</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        recursive(list, new ArrayList&lt;&gt;(), candidates, target, 0);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * DFS 添加每个满足条件的集合</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     *            最终返回集合</span><br><span class=\"line\">     * @param tempList</span><br><span class=\"line\">     *            每个满足条件的子集合</span><br><span class=\"line\">     * @param candidates</span><br><span class=\"line\">     *            数组</span><br><span class=\"line\">     * @param remain</span><br><span class=\"line\">     *            剩余值</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     *            数组下标</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void recursive(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] candidates, int remain, int index) &#123;</span><br><span class=\"line\">        if (remain &lt; 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        else if (remain == 0)</span><br><span class=\"line\">            list.add(new ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int i = index; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">                if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) // 说明两个值相等且之前一个值已经返回</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                tempList.add(candidates[i]);</span><br><span class=\"line\">                recursive(list, tempList, candidates, remain - candidates[i], i + 1); // 规定数组中每个数字在每个组合中只能使用一次</span><br><span class=\"line\">                tempList.remove(tempList.size() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比较上一题的代码，这次只是加了一个条件判断以及递归中元素下标加了一。</p>\n<p>这里就要对数组先进行排序操作了，新增的条件判断也是为了优化代码执行速度。</p>\n<h2 id=\"Combination-Sum-III\"><a href=\"#Combination-Sum-III\" class=\"headerlink\" title=\"Combination Sum III\"></a>Combination Sum III</h2><p>再来看第三道变形，描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">所有数字都是正整数。</span><br><span class=\"line\">解集不能包含重复的组合。 </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: k = 3, n = 7</span><br><span class=\"line\">输出: [[1,2,4]]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: k = 3, n = 9</span><br><span class=\"line\">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>\n\n<p>这次不给出数组了，而是规定了数组中元素的取值范围。</p>\n<p>双手一摊，这还不是一样吗，不给我就自己造就是了！</p>\n<p><strong>注意点：</strong></p>\n<ul>\n<li><strong>解集不能包含重复的组合。</strong></li>\n</ul>\n<p>解题代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class=\"line\">        int[] nums = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        dfs(list, new ArrayList&lt;&gt;(), nums, k, n, 0);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     *            最终返回的 list</span><br><span class=\"line\">     * @param tempList</span><br><span class=\"line\">     *            作为寻求满足条件的暂存 list</span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     *            数组</span><br><span class=\"line\">     * @param reNum</span><br><span class=\"line\">     *            剩余的元素个数</span><br><span class=\"line\">     * @param reSum</span><br><span class=\"line\">     *            剩余的总和</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     *            数组下标</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void dfs(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int reNum, int reSum, int index) &#123;</span><br><span class=\"line\">        if (reNum &lt; 0 || reSum &lt; 0) // 两者有其一小于 0 就是不满足条件</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        if (reNum == 0 &amp;&amp; reSum == 0) // 两者都为 0 时满足条件，塞入</span><br><span class=\"line\">            list.add(new ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">        else if (reNum == 0 || reSum == 0) // 两者中有且只有一者等于 0 就不满足条件</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int i = index; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                tempList.add(nums[i]);</span><br><span class=\"line\">                dfs(list, tempList, nums, reNum - 1, reSum - nums[i], i + 1); // 不能重复元素 所以 i + 1</span><br><span class=\"line\">                tempList.remove(tempList.size() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>真不愧为机智小少年……</p>\n<h2 id=\"Combination-Sum-IV\"><a href=\"#Combination-Sum-IV\" class=\"headerlink\" title=\"Combination Sum IV\"></a>Combination Sum IV</h2><p>第四道变形就复杂了一些了，描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">nums = [1, 2, 3]</span><br><span class=\"line\">target = 4</span><br><span class=\"line\"></span><br><span class=\"line\">所有可能的组合为：</span><br><span class=\"line\">(1, 1, 1, 1)</span><br><span class=\"line\">(1, 1, 2)</span><br><span class=\"line\">(1, 2, 1)</span><br><span class=\"line\">(1, 3)</span><br><span class=\"line\">(2, 1, 1)</span><br><span class=\"line\">(2, 2)</span><br><span class=\"line\">(3, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">请注意，顺序不同的序列被视作不同的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">因此输出为 7。</span><br></pre></td></tr></table></figure>\n\n<p>这里数组的元素可以重复，且组合的元素也能相同，但是顺序要不同。</p>\n<p>一开始当然就是无脑循环了，然后满足条件就加上一，结果就是超时……</p>\n<p>说明这么暴力不行的……</p>\n<p>后来一想，无脑循环就相当于每一次都从头进行循环算了一遍，很多都是重复的计算。</p>\n<p>对了，DP 浮现在了脑中，在那飘啊飘。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int[] dp;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * DP</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     * @param target</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class=\"line\">        dp = new int[target + 1];</span><br><span class=\"line\">        Arrays.fill(dp, -1);</span><br><span class=\"line\">        dp[0] = 1;</span><br><span class=\"line\">        return helper(nums, target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int helper(int[] nums, int target) &#123;</span><br><span class=\"line\">        if (dp[target] != -1) &#123;</span><br><span class=\"line\">            return dp[target]; // 若是之前的已经计算过了 直接返回</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int res = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            if (target &gt;= nums[i]) &#123; // 所有组合的种数相加</span><br><span class=\"line\">                res += helper(nums, target - nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[target] = res; // 计算后赋值用于之后的数字使用</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>用空间换取时间的操作，DP + 递归稍微费点脑。</p>\n<p>还有一种解法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * DP</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     * @param target</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class=\"line\">        int[] comb = new int[target + 1];</span><br><span class=\"line\">        comb[0] = 1;</span><br><span class=\"line\">        for (int i = 1; i &lt; comb.length; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                if (i - nums[j] &gt;= 0) &#123;</span><br><span class=\"line\">                    comb[i] += comb[i - nums[j]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return comb[target];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，组合总和系列（Combination Sum）的题目总结完了。记住了<strong>回溯</strong>。</p>\n","excerpt":"","more":"<p>LeetCode 中有多道组合总和（Combination Sum）的题，这些题目都是比较经典的，面试很可能会问到。我这一想，还真是。今天就来简单总结下这一系列题目，总结很重要，还要时而回顾！</p>\n<h2 id=\"Combination-Sum-I\"><a href=\"#Combination-Sum-I\" class=\"headerlink\" title=\"Combination Sum I\"></a>Combination Sum I</h2><p>第一道题的描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">candidates 中的数字可以无限制重复被选取。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">所有数字（包括 target）都是正整数。</span><br><span class=\"line\">解集不能包含重复的组合。 </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,3,6,7], target = 7,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7],</span><br><span class=\"line\">  [2,2,3]</span><br><span class=\"line\">]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,3,5], target = 8,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [2,2,2,2],</span><br><span class=\"line\">  [2,3,3],</span><br><span class=\"line\">  [3,5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong></p>\n<ul>\n<li><strong>candidates 中的数字可以无限制重复被选取。</strong></li>\n<li><strong>解集不能包含重复的组合。</strong></li>\n</ul>\n<p>这时候头脑里很快就会产生一个思路：无限遍历该数组，直到其元素之和满足条件，然后塞入集合中。</p>\n<p>这个想法没问题，不过在这过程中我们怎么才能满足<code>解集不能包含重复的组合。</code>这个条件呢？</p>\n<p>对对对，那就是确定一个 index，我们要保证数组不往回找就是了。</p>\n<p>解题代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        recursive(list, new ArrayList&lt;&gt;(), candidates, target, 0);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     *            总的输出 list</span><br><span class=\"line\">     * @param tempList</span><br><span class=\"line\">     *            存放的 list</span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     *            数组</span><br><span class=\"line\">     * @param remain</span><br><span class=\"line\">     *            剩余值</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     *            数组下标</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void recursive(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int remain, int index) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (remain &lt; 0) // return 或者进行 add 操作后就开始执行弹出尾部元素 塞入下个元素</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        else if (remain == 0)</span><br><span class=\"line\">            list.add(new ArrayList&lt;&gt;(tempList)); // 这里需要注意不能直接 list.add(tempList),最终 tempList 所指向的对象是空的,</span><br><span class=\"line\">                                                    // 所以需要 new 一个新对象，将值复制进去</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int i = index; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                tempList.add(nums[i]); // 挨个塞入</span><br><span class=\"line\">                recursive(list, tempList, nums, remain - nums[i], i); // 由于元素可重复 所以是 i</span><br><span class=\"line\">                tempList.remove(tempList.size() - 1); // 挨个弹出</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我这注释什么的都有，理解起来不成问题吧。这里需要注意的就是两个点：<code>list.add(new ArrayList&lt;&gt;(tempList));</code> 和 <code> recursive(list, tempList, nums, remain - nums[i], i);</code>。</p>\n<p>这里先对数组进行排序可以使计算更快，当然你也可以不排序。</p>\n<h2 id=\"Combination-Sum-II\"><a href=\"#Combination-Sum-II\" class=\"headerlink\" title=\"Combination Sum II\"></a>Combination Sum II</h2><p>第二道对第一道稍微加工了一下，描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">candidates 中的每个数字在每个组合中只能使用一次。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">所有数字（包括目标数）都是正整数。</span><br><span class=\"line\">解集不能包含重复的组合。 </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1, 7],</span><br><span class=\"line\">  [1, 2, 5],</span><br><span class=\"line\">  [2, 6],</span><br><span class=\"line\">  [1, 1, 6]</span><br><span class=\"line\">]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class=\"line\">所求解集为:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,2],</span><br><span class=\"line\">  [5]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意点：</strong></p>\n<ul>\n<li><strong>candidates 中的每个数字在每个组合中只能使用一次。</strong></li>\n<li><strong>解集不能包含重复的组合。</strong></li>\n</ul>\n<p>是的，这里把条件改了，数组中的每个元素在每个组合中只能使用一次！</p>\n<p>这就意味着每次递归操作时其下标都需要往后移一位了！</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        recursive(list, new ArrayList&lt;&gt;(), candidates, target, 0);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * DFS 添加每个满足条件的集合</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     *            最终返回集合</span><br><span class=\"line\">     * @param tempList</span><br><span class=\"line\">     *            每个满足条件的子集合</span><br><span class=\"line\">     * @param candidates</span><br><span class=\"line\">     *            数组</span><br><span class=\"line\">     * @param remain</span><br><span class=\"line\">     *            剩余值</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     *            数组下标</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void recursive(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] candidates, int remain, int index) &#123;</span><br><span class=\"line\">        if (remain &lt; 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        else if (remain == 0)</span><br><span class=\"line\">            list.add(new ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int i = index; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">                if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) // 说明两个值相等且之前一个值已经返回</span><br><span class=\"line\">                    continue;</span><br><span class=\"line\">                tempList.add(candidates[i]);</span><br><span class=\"line\">                recursive(list, tempList, candidates, remain - candidates[i], i + 1); // 规定数组中每个数字在每个组合中只能使用一次</span><br><span class=\"line\">                tempList.remove(tempList.size() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比较上一题的代码，这次只是加了一个条件判断以及递归中元素下标加了一。</p>\n<p>这里就要对数组先进行排序操作了，新增的条件判断也是为了优化代码执行速度。</p>\n<h2 id=\"Combination-Sum-III\"><a href=\"#Combination-Sum-III\" class=\"headerlink\" title=\"Combination Sum III\"></a>Combination Sum III</h2><p>再来看第三道变形，描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">所有数字都是正整数。</span><br><span class=\"line\">解集不能包含重复的组合。 </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: k = 3, n = 7</span><br><span class=\"line\">输出: [[1,2,4]]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: k = 3, n = 9</span><br><span class=\"line\">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>\n\n<p>这次不给出数组了，而是规定了数组中元素的取值范围。</p>\n<p>双手一摊，这还不是一样吗，不给我就自己造就是了！</p>\n<p><strong>注意点：</strong></p>\n<ul>\n<li><strong>解集不能包含重复的组合。</strong></li>\n</ul>\n<p>解题代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class=\"line\">        int[] nums = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        dfs(list, new ArrayList&lt;&gt;(), nums, k, n, 0);</span><br><span class=\"line\">        return list;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param list</span><br><span class=\"line\">     *            最终返回的 list</span><br><span class=\"line\">     * @param tempList</span><br><span class=\"line\">     *            作为寻求满足条件的暂存 list</span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     *            数组</span><br><span class=\"line\">     * @param reNum</span><br><span class=\"line\">     *            剩余的元素个数</span><br><span class=\"line\">     * @param reSum</span><br><span class=\"line\">     *            剩余的总和</span><br><span class=\"line\">     * @param index</span><br><span class=\"line\">     *            数组下标</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void dfs(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int reNum, int reSum, int index) &#123;</span><br><span class=\"line\">        if (reNum &lt; 0 || reSum &lt; 0) // 两者有其一小于 0 就是不满足条件</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        if (reNum == 0 &amp;&amp; reSum == 0) // 两者都为 0 时满足条件，塞入</span><br><span class=\"line\">            list.add(new ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">        else if (reNum == 0 || reSum == 0) // 两者中有且只有一者等于 0 就不满足条件</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            for (int i = index; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                tempList.add(nums[i]);</span><br><span class=\"line\">                dfs(list, tempList, nums, reNum - 1, reSum - nums[i], i + 1); // 不能重复元素 所以 i + 1</span><br><span class=\"line\">                tempList.remove(tempList.size() - 1);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>真不愧为机智小少年……</p>\n<h2 id=\"Combination-Sum-IV\"><a href=\"#Combination-Sum-IV\" class=\"headerlink\" title=\"Combination Sum IV\"></a>Combination Sum IV</h2><p>第四道变形就复杂了一些了，描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">nums = [1, 2, 3]</span><br><span class=\"line\">target = 4</span><br><span class=\"line\"></span><br><span class=\"line\">所有可能的组合为：</span><br><span class=\"line\">(1, 1, 1, 1)</span><br><span class=\"line\">(1, 1, 2)</span><br><span class=\"line\">(1, 2, 1)</span><br><span class=\"line\">(1, 3)</span><br><span class=\"line\">(2, 1, 1)</span><br><span class=\"line\">(2, 2)</span><br><span class=\"line\">(3, 1)</span><br><span class=\"line\"></span><br><span class=\"line\">请注意，顺序不同的序列被视作不同的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">因此输出为 7。</span><br></pre></td></tr></table></figure>\n\n<p>这里数组的元素可以重复，且组合的元素也能相同，但是顺序要不同。</p>\n<p>一开始当然就是无脑循环了，然后满足条件就加上一，结果就是超时……</p>\n<p>说明这么暴力不行的……</p>\n<p>后来一想，无脑循环就相当于每一次都从头进行循环算了一遍，很多都是重复的计算。</p>\n<p>对了，DP 浮现在了脑中，在那飘啊飘。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private int[] dp;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * DP</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     * @param target</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class=\"line\">        dp = new int[target + 1];</span><br><span class=\"line\">        Arrays.fill(dp, -1);</span><br><span class=\"line\">        dp[0] = 1;</span><br><span class=\"line\">        return helper(nums, target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private int helper(int[] nums, int target) &#123;</span><br><span class=\"line\">        if (dp[target] != -1) &#123;</span><br><span class=\"line\">            return dp[target]; // 若是之前的已经计算过了 直接返回</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int res = 0;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            if (target &gt;= nums[i]) &#123; // 所有组合的种数相加</span><br><span class=\"line\">                res += helper(nums, target - nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[target] = res; // 计算后赋值用于之后的数字使用</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>用空间换取时间的操作，DP + 递归稍微费点脑。</p>\n<p>还有一种解法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * DP</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param nums</span><br><span class=\"line\">     * @param target</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class=\"line\">        int[] comb = new int[target + 1];</span><br><span class=\"line\">        comb[0] = 1;</span><br><span class=\"line\">        for (int i = 1; i &lt; comb.length; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                if (i - nums[j] &gt;= 0) &#123;</span><br><span class=\"line\">                    comb[i] += comb[i - nums[j]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return comb[target];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>好了，组合总和系列（Combination Sum）的题目总结完了。记住了<strong>回溯</strong>。</p>\n"},{"title":"LeetCode 之检测大写字母（Detect Capital）","date":"2020-05-12T03:08:12.000Z","_content":"\n## 前言\n这是一道难度为简单的题，确实常规去解决一点也不难，但当我看到有大神在评论区发解题思路的时候，脑壳就突然有一种被敲开往里灌清凉油的感觉……让我们来走进清凉世界！\n\n## 正文\n题目描述：\n```\n给定一个单词，你需要判断单词的大写使用是否正确。\n\n我们定义，在以下情况时，单词的大写用法是正确的：\n\n全部字母都是大写，比如\"USA\"。\n单词中所有字母都不是大写，比如\"leetcode\"。\n如果单词不只含有一个字母，只有首字母大写， 比如 \"Google\"。\n否则，我们定义这个单词没有正确使用大写字母。\n\n示例 1:\n输入: \"USA\"\n输出: True\n\n示例 2:\n输入: \"FlaG\"\n输出: False\n注意: 输入是由大写和小写拉丁字母组成的非空单词。\n```\n\n猛男一看，此题共有三种条件（单词字母全为大写、单词只有首字母大写、单词全小写），若满足其中之一则返回 true，否则都返回 false.\n\n看完题目，大笔一挥，洋洋洒洒写下解题方法：\n```\npublic boolean detectCapitalUse(String word) {\n\n        // 全大写\n        if (word.toUpperCase().equals(word))\n            return true;\n        // 只有首字母大写 | 全小写（只需要判断除了首字母其余是否都为小写，因为首字母不管大写小写都不影响都满足要求）\n        if (word.substring(1).toLowerCase().equals(word.substring(1)))\n            return true;\n        return false;\n\n    }\n```\n\n写完眉眼舒展嘴角微扬，好久没有写过这么舒坦的题了。三种条件，我还把两种归并一起写了，实乃天才是也！\n\n写完提交，不出意外通过，不过一看这耗时 2ms，只击败了 30% . 我不服！遂翻其余人上传的解题思路，看到其中一条，突觉四肢麻木，天灵盖犹如被灌了风油精一般……\n\n代码如下：\n```\npublic boolean detectCapitalUse1(String word) {\n        int l = word.length();\n        // 统计大写字母出现次数\n        int count = 0;\n        for(int i = 0; i < l; i++) {\n            // 是大写字母且数量是否一致\n            if(word.charAt(i) < 91  && count++ < i) {\n                return false;\n            }\n        }\n        // count\n        // 0:全是小写字母 1:只有首字母大写 l:都是大写\n        return count <= 1 || count == l;\n    }\n```\n\n**思路：从单词第一个字符开始遍历，遍历过程中统计出现的大写字母并与当前字符下标进行比较，即若是出现大写字母，则要么只有第一个是大写字母，要么全都是大写字母，其余情况都直接返回 false.**\n\n```\nSystem.out.println((int)'A'); // 65\nSystem.out.println((int)'Z'); // 90\nSystem.out.println((int)'a'); // 97\nSystem.out.println((int)'z'); // 122\n```\n\n若是大写字母则满足 [65,90].\n\n妙不可言，平时工具用多了难免第一反应就是去利用现成封装好的方法去做，脑子经常换一换会发现世界好清晰。","source":"_posts/leetcode-detect-capital.md","raw":"---\ntitle: LeetCode 之检测大写字母（Detect Capital）\ndate: 2020-5-12 11:08:12\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n## 前言\n这是一道难度为简单的题，确实常规去解决一点也不难，但当我看到有大神在评论区发解题思路的时候，脑壳就突然有一种被敲开往里灌清凉油的感觉……让我们来走进清凉世界！\n\n## 正文\n题目描述：\n```\n给定一个单词，你需要判断单词的大写使用是否正确。\n\n我们定义，在以下情况时，单词的大写用法是正确的：\n\n全部字母都是大写，比如\"USA\"。\n单词中所有字母都不是大写，比如\"leetcode\"。\n如果单词不只含有一个字母，只有首字母大写， 比如 \"Google\"。\n否则，我们定义这个单词没有正确使用大写字母。\n\n示例 1:\n输入: \"USA\"\n输出: True\n\n示例 2:\n输入: \"FlaG\"\n输出: False\n注意: 输入是由大写和小写拉丁字母组成的非空单词。\n```\n\n猛男一看，此题共有三种条件（单词字母全为大写、单词只有首字母大写、单词全小写），若满足其中之一则返回 true，否则都返回 false.\n\n看完题目，大笔一挥，洋洋洒洒写下解题方法：\n```\npublic boolean detectCapitalUse(String word) {\n\n        // 全大写\n        if (word.toUpperCase().equals(word))\n            return true;\n        // 只有首字母大写 | 全小写（只需要判断除了首字母其余是否都为小写，因为首字母不管大写小写都不影响都满足要求）\n        if (word.substring(1).toLowerCase().equals(word.substring(1)))\n            return true;\n        return false;\n\n    }\n```\n\n写完眉眼舒展嘴角微扬，好久没有写过这么舒坦的题了。三种条件，我还把两种归并一起写了，实乃天才是也！\n\n写完提交，不出意外通过，不过一看这耗时 2ms，只击败了 30% . 我不服！遂翻其余人上传的解题思路，看到其中一条，突觉四肢麻木，天灵盖犹如被灌了风油精一般……\n\n代码如下：\n```\npublic boolean detectCapitalUse1(String word) {\n        int l = word.length();\n        // 统计大写字母出现次数\n        int count = 0;\n        for(int i = 0; i < l; i++) {\n            // 是大写字母且数量是否一致\n            if(word.charAt(i) < 91  && count++ < i) {\n                return false;\n            }\n        }\n        // count\n        // 0:全是小写字母 1:只有首字母大写 l:都是大写\n        return count <= 1 || count == l;\n    }\n```\n\n**思路：从单词第一个字符开始遍历，遍历过程中统计出现的大写字母并与当前字符下标进行比较，即若是出现大写字母，则要么只有第一个是大写字母，要么全都是大写字母，其余情况都直接返回 false.**\n\n```\nSystem.out.println((int)'A'); // 65\nSystem.out.println((int)'Z'); // 90\nSystem.out.println((int)'a'); // 97\nSystem.out.println((int)'z'); // 122\n```\n\n若是大写字母则满足 [65,90].\n\n妙不可言，平时工具用多了难免第一反应就是去利用现成封装好的方法去做，脑子经常换一换会发现世界好清晰。","slug":"leetcode-detect-capital","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhi006sk9i16m49axag","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这是一道难度为简单的题，确实常规去解决一点也不难，但当我看到有大神在评论区发解题思路的时候，脑壳就突然有一种被敲开往里灌清凉油的感觉……让我们来走进清凉世界！</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个单词，你需要判断单词的大写使用是否正确。</span><br><span class=\"line\"></span><br><span class=\"line\">我们定义，在以下情况时，单词的大写用法是正确的：</span><br><span class=\"line\"></span><br><span class=\"line\">全部字母都是大写，比如&quot;USA&quot;。</span><br><span class=\"line\">单词中所有字母都不是大写，比如&quot;leetcode&quot;。</span><br><span class=\"line\">如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。</span><br><span class=\"line\">否则，我们定义这个单词没有正确使用大写字母。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: &quot;USA&quot;</span><br><span class=\"line\">输出: True</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: &quot;FlaG&quot;</span><br><span class=\"line\">输出: False</span><br><span class=\"line\">注意: 输入是由大写和小写拉丁字母组成的非空单词。</span><br></pre></td></tr></table></figure>\n\n<p>猛男一看，此题共有三种条件（单词字母全为大写、单词只有首字母大写、单词全小写），若满足其中之一则返回 true，否则都返回 false.</p>\n<p>看完题目，大笔一挥，洋洋洒洒写下解题方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean detectCapitalUse(String word) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 全大写</span><br><span class=\"line\">        if (word.toUpperCase().equals(word))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        // 只有首字母大写 | 全小写（只需要判断除了首字母其余是否都为小写，因为首字母不管大写小写都不影响都满足要求）</span><br><span class=\"line\">        if (word.substring(1).toLowerCase().equals(word.substring(1)))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>写完眉眼舒展嘴角微扬，好久没有写过这么舒坦的题了。三种条件，我还把两种归并一起写了，实乃天才是也！</p>\n<p>写完提交，不出意外通过，不过一看这耗时 2ms，只击败了 30% . 我不服！遂翻其余人上传的解题思路，看到其中一条，突觉四肢麻木，天灵盖犹如被灌了风油精一般……</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean detectCapitalUse1(String word) &#123;</span><br><span class=\"line\">        int l = word.length();</span><br><span class=\"line\">        // 统计大写字母出现次数</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        for(int i = 0; i &lt; l; i++) &#123;</span><br><span class=\"line\">            // 是大写字母且数量是否一致</span><br><span class=\"line\">            if(word.charAt(i) &lt; 91  &amp;&amp; count++ &lt; i) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // count</span><br><span class=\"line\">        // 0:全是小写字母 1:只有首字母大写 l:都是大写</span><br><span class=\"line\">        return count &lt;= 1 || count == l;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>思路：从单词第一个字符开始遍历，遍历过程中统计出现的大写字母并与当前字符下标进行比较，即若是出现大写字母，则要么只有第一个是大写字母，要么全都是大写字母，其余情况都直接返回 false.</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println((int)&#x27;A&#x27;); // 65</span><br><span class=\"line\">System.out.println((int)&#x27;Z&#x27;); // 90</span><br><span class=\"line\">System.out.println((int)&#x27;a&#x27;); // 97</span><br><span class=\"line\">System.out.println((int)&#x27;z&#x27;); // 122</span><br></pre></td></tr></table></figure>\n\n<p>若是大写字母则满足 [65,90].</p>\n<p>妙不可言，平时工具用多了难免第一反应就是去利用现成封装好的方法去做，脑子经常换一换会发现世界好清晰。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这是一道难度为简单的题，确实常规去解决一点也不难，但当我看到有大神在评论区发解题思路的时候，脑壳就突然有一种被敲开往里灌清凉油的感觉……让我们来走进清凉世界！</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个单词，你需要判断单词的大写使用是否正确。</span><br><span class=\"line\"></span><br><span class=\"line\">我们定义，在以下情况时，单词的大写用法是正确的：</span><br><span class=\"line\"></span><br><span class=\"line\">全部字母都是大写，比如&quot;USA&quot;。</span><br><span class=\"line\">单词中所有字母都不是大写，比如&quot;leetcode&quot;。</span><br><span class=\"line\">如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。</span><br><span class=\"line\">否则，我们定义这个单词没有正确使用大写字母。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: &quot;USA&quot;</span><br><span class=\"line\">输出: True</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: &quot;FlaG&quot;</span><br><span class=\"line\">输出: False</span><br><span class=\"line\">注意: 输入是由大写和小写拉丁字母组成的非空单词。</span><br></pre></td></tr></table></figure>\n\n<p>猛男一看，此题共有三种条件（单词字母全为大写、单词只有首字母大写、单词全小写），若满足其中之一则返回 true，否则都返回 false.</p>\n<p>看完题目，大笔一挥，洋洋洒洒写下解题方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean detectCapitalUse(String word) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 全大写</span><br><span class=\"line\">        if (word.toUpperCase().equals(word))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        // 只有首字母大写 | 全小写（只需要判断除了首字母其余是否都为小写，因为首字母不管大写小写都不影响都满足要求）</span><br><span class=\"line\">        if (word.substring(1).toLowerCase().equals(word.substring(1)))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>写完眉眼舒展嘴角微扬，好久没有写过这么舒坦的题了。三种条件，我还把两种归并一起写了，实乃天才是也！</p>\n<p>写完提交，不出意外通过，不过一看这耗时 2ms，只击败了 30% . 我不服！遂翻其余人上传的解题思路，看到其中一条，突觉四肢麻木，天灵盖犹如被灌了风油精一般……</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean detectCapitalUse1(String word) &#123;</span><br><span class=\"line\">        int l = word.length();</span><br><span class=\"line\">        // 统计大写字母出现次数</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        for(int i = 0; i &lt; l; i++) &#123;</span><br><span class=\"line\">            // 是大写字母且数量是否一致</span><br><span class=\"line\">            if(word.charAt(i) &lt; 91  &amp;&amp; count++ &lt; i) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // count</span><br><span class=\"line\">        // 0:全是小写字母 1:只有首字母大写 l:都是大写</span><br><span class=\"line\">        return count &lt;= 1 || count == l;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>思路：从单词第一个字符开始遍历，遍历过程中统计出现的大写字母并与当前字符下标进行比较，即若是出现大写字母，则要么只有第一个是大写字母，要么全都是大写字母，其余情况都直接返回 false.</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println((int)&#x27;A&#x27;); // 65</span><br><span class=\"line\">System.out.println((int)&#x27;Z&#x27;); // 90</span><br><span class=\"line\">System.out.println((int)&#x27;a&#x27;); // 97</span><br><span class=\"line\">System.out.println((int)&#x27;z&#x27;); // 122</span><br></pre></td></tr></table></figure>\n\n<p>若是大写字母则满足 [65,90].</p>\n<p>妙不可言，平时工具用多了难免第一反应就是去利用现成封装好的方法去做，脑子经常换一换会发现世界好清晰。</p>\n"},{"title":"LeetCode 之最长公共前缀（Longest Common Prefix）","date":"2018-11-14T05:23:51.000Z","_content":"\n潜意识还没养成的我在思考问题方面总会出点岔子，老是走一些弯路。虽说结果可能是一样的，过程却是复杂许多，这也是我为什么决定要好好刷一遍 leetcode 中的题目的原因。数学就在于简单之美，一些看似异常复杂的问题可以巧妙地通过分治从而完美解决，很能锻炼人的逻辑思维能力，这也是我想要的。\n\n下面来看问题的描述：\n```\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 \"\"。\n\n示例 1:\n\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n示例 2:\n\n输入: [\"dog\",\"racecar\",\"car\"]\n输出: \"\"\n解释: 输入不存在公共前缀。\n说明:\n\n所有输入只包含小写字母 a-z 。\n```\n\n问题看似很简单，查找字符串数组中每个元素的最长公共前缀。\n\n确实简单，我这个莽夫的第一想法就是遍历暴力分析。两个循环能解决，问题是不大，但是很不优雅，看着就难受。\n\n虽说“黑猫白猫，能抓老鼠的就是好猫”，但是两猫都能抓老鼠，那我当然还是喜欢高颜值猫了！\n\n随后我就去官网找到了我要的答案：\n```\n    /**\n     * 官网解法\n     * \n     * @param strs\n     * @return\n     */\n    public static String longestCommonPrefix1(String[] strs) {\n        if (strs.length == 0)\n            return \"\";\n        String prefix = strs[0]; // 以第一个字符串为基准\n        for (int i = 1; i < strs.length; i++)\n            while (strs[i].indexOf(prefix) != 0) { // 依次找到均满足的相同起始字符\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty())\n                    return \"\";\n            }\n        return prefix;\n    }\n```\n\n这一种是我觉得最好理解最满意的一种解法。\n\n这里以第一个元素为基准值，挨个与其它元素进行比较。while 循环里面就是为了使基准值成为比较元素的起始字符串，故它不满足就每次截掉最后一位。若是全部截完了那就是无公共前缀了。\n\n这完美体现了分而治之，将所有元素的比较变成了两个元素之间的比较，可以节省其运行时间同时也使得代码更好理解更加优雅。\n\n学习了，牢记。","source":"_posts/leetcode-longest-common-prefix.md","raw":"---\ntitle: LeetCode 之最长公共前缀（Longest Common Prefix）\ndate: 2018-11-14 13:23:51\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n潜意识还没养成的我在思考问题方面总会出点岔子，老是走一些弯路。虽说结果可能是一样的，过程却是复杂许多，这也是我为什么决定要好好刷一遍 leetcode 中的题目的原因。数学就在于简单之美，一些看似异常复杂的问题可以巧妙地通过分治从而完美解决，很能锻炼人的逻辑思维能力，这也是我想要的。\n\n下面来看问题的描述：\n```\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 \"\"。\n\n示例 1:\n\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n示例 2:\n\n输入: [\"dog\",\"racecar\",\"car\"]\n输出: \"\"\n解释: 输入不存在公共前缀。\n说明:\n\n所有输入只包含小写字母 a-z 。\n```\n\n问题看似很简单，查找字符串数组中每个元素的最长公共前缀。\n\n确实简单，我这个莽夫的第一想法就是遍历暴力分析。两个循环能解决，问题是不大，但是很不优雅，看着就难受。\n\n虽说“黑猫白猫，能抓老鼠的就是好猫”，但是两猫都能抓老鼠，那我当然还是喜欢高颜值猫了！\n\n随后我就去官网找到了我要的答案：\n```\n    /**\n     * 官网解法\n     * \n     * @param strs\n     * @return\n     */\n    public static String longestCommonPrefix1(String[] strs) {\n        if (strs.length == 0)\n            return \"\";\n        String prefix = strs[0]; // 以第一个字符串为基准\n        for (int i = 1; i < strs.length; i++)\n            while (strs[i].indexOf(prefix) != 0) { // 依次找到均满足的相同起始字符\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty())\n                    return \"\";\n            }\n        return prefix;\n    }\n```\n\n这一种是我觉得最好理解最满意的一种解法。\n\n这里以第一个元素为基准值，挨个与其它元素进行比较。while 循环里面就是为了使基准值成为比较元素的起始字符串，故它不满足就每次截掉最后一位。若是全部截完了那就是无公共前缀了。\n\n这完美体现了分而治之，将所有元素的比较变成了两个元素之间的比较，可以节省其运行时间同时也使得代码更好理解更加优雅。\n\n学习了，牢记。","slug":"leetcode-longest-common-prefix","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhi006uk9i17ueh6qap","content":"<p>潜意识还没养成的我在思考问题方面总会出点岔子，老是走一些弯路。虽说结果可能是一样的，过程却是复杂许多，这也是我为什么决定要好好刷一遍 leetcode 中的题目的原因。数学就在于简单之美，一些看似异常复杂的问题可以巧妙地通过分治从而完美解决，很能锻炼人的逻辑思维能力，这也是我想要的。</p>\n<p>下面来看问题的描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class=\"line\"></span><br><span class=\"line\">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">输出: &quot;fl&quot;</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class=\"line\">输出: &quot;&quot;</span><br><span class=\"line\">解释: 输入不存在公共前缀。</span><br><span class=\"line\">说明:</span><br><span class=\"line\"></span><br><span class=\"line\">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure>\n\n<p>问题看似很简单，查找字符串数组中每个元素的最长公共前缀。</p>\n<p>确实简单，我这个莽夫的第一想法就是遍历暴力分析。两个循环能解决，问题是不大，但是很不优雅，看着就难受。</p>\n<p>虽说“黑猫白猫，能抓老鼠的就是好猫”，但是两猫都能抓老鼠，那我当然还是喜欢高颜值猫了！</p>\n<p>随后我就去官网找到了我要的答案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 官网解法</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param strs</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static String longestCommonPrefix1(String[] strs) &#123;</span><br><span class=\"line\">    if (strs.length == 0)</span><br><span class=\"line\">        return &quot;&quot;;</span><br><span class=\"line\">    String prefix = strs[0]; // 以第一个字符串为基准</span><br><span class=\"line\">    for (int i = 1; i &lt; strs.length; i++)</span><br><span class=\"line\">        while (strs[i].indexOf(prefix) != 0) &#123; // 依次找到均满足的相同起始字符</span><br><span class=\"line\">            prefix = prefix.substring(0, prefix.length() - 1);</span><br><span class=\"line\">            if (prefix.isEmpty())</span><br><span class=\"line\">                return &quot;&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    return prefix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一种是我觉得最好理解最满意的一种解法。</p>\n<p>这里以第一个元素为基准值，挨个与其它元素进行比较。while 循环里面就是为了使基准值成为比较元素的起始字符串，故它不满足就每次截掉最后一位。若是全部截完了那就是无公共前缀了。</p>\n<p>这完美体现了分而治之，将所有元素的比较变成了两个元素之间的比较，可以节省其运行时间同时也使得代码更好理解更加优雅。</p>\n<p>学习了，牢记。</p>\n","excerpt":"","more":"<p>潜意识还没养成的我在思考问题方面总会出点岔子，老是走一些弯路。虽说结果可能是一样的，过程却是复杂许多，这也是我为什么决定要好好刷一遍 leetcode 中的题目的原因。数学就在于简单之美，一些看似异常复杂的问题可以巧妙地通过分治从而完美解决，很能锻炼人的逻辑思维能力，这也是我想要的。</p>\n<p>下面来看问题的描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class=\"line\"></span><br><span class=\"line\">如果不存在公共前缀，返回空字符串 &quot;&quot;。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class=\"line\">输出: &quot;fl&quot;</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class=\"line\">输出: &quot;&quot;</span><br><span class=\"line\">解释: 输入不存在公共前缀。</span><br><span class=\"line\">说明:</span><br><span class=\"line\"></span><br><span class=\"line\">所有输入只包含小写字母 a-z 。</span><br></pre></td></tr></table></figure>\n\n<p>问题看似很简单，查找字符串数组中每个元素的最长公共前缀。</p>\n<p>确实简单，我这个莽夫的第一想法就是遍历暴力分析。两个循环能解决，问题是不大，但是很不优雅，看着就难受。</p>\n<p>虽说“黑猫白猫，能抓老鼠的就是好猫”，但是两猫都能抓老鼠，那我当然还是喜欢高颜值猫了！</p>\n<p>随后我就去官网找到了我要的答案：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 官网解法</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param strs</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static String longestCommonPrefix1(String[] strs) &#123;</span><br><span class=\"line\">    if (strs.length == 0)</span><br><span class=\"line\">        return &quot;&quot;;</span><br><span class=\"line\">    String prefix = strs[0]; // 以第一个字符串为基准</span><br><span class=\"line\">    for (int i = 1; i &lt; strs.length; i++)</span><br><span class=\"line\">        while (strs[i].indexOf(prefix) != 0) &#123; // 依次找到均满足的相同起始字符</span><br><span class=\"line\">            prefix = prefix.substring(0, prefix.length() - 1);</span><br><span class=\"line\">            if (prefix.isEmpty())</span><br><span class=\"line\">                return &quot;&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    return prefix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一种是我觉得最好理解最满意的一种解法。</p>\n<p>这里以第一个元素为基准值，挨个与其它元素进行比较。while 循环里面就是为了使基准值成为比较元素的起始字符串，故它不满足就每次截掉最后一位。若是全部截完了那就是无公共前缀了。</p>\n<p>这完美体现了分而治之，将所有元素的比较变成了两个元素之间的比较，可以节省其运行时间同时也使得代码更好理解更加优雅。</p>\n<p>学习了，牢记。</p>\n"},{"title":"LeetCode 之 n 个数之和（Sum n）","date":"2018-11-19T08:52:20.000Z","_content":"\nLeetCode 中有好几道题是求数字之和的，有 `Sum 2`、`Sum 3` 和 `Sum 4` 等。求和这种情况在我们实际开发中也是经常会遇到的，在这不妨拿出来我们把这归并到一起来说说。\n\n无非就是数组中几个数字求和比较是否为目标值。且大多结果中是不能有重复的值。\n\n大致我说下这个题意：\n```\n给定一个包含 m 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在 n 个元素，使得这 n 个元素相加的值与 target 相等？找出所有满足条件且不重复的组。\n\n注意：\n答案中不可以包含重复的组。\n\n示例：\n给定数组 nums = [1, 0, -1, 0, -2, 2]， target = 0，n = 4\n\n满足要求的四元组集合为：\n[ [-1, 0, 0, 1],\n[-2, -1, 1, 2],\n[-2, 0, 0, 2] ]\n```\n\n两数之和好办，循环遍历去除重复结果。三数之和也类似。\n\n那要是许多许多数之和呢，遍历就不好使了，那就要采用 BFS 或者 DFS。\n\n`答案中不可以包含重复的组`从这我们知道，首先，我们需要将数组排个序。\n\n由大化小的思想，我们可以采用 DFS + 回溯来解决这一系列问题。\n\n苦恼不已，别挠头了，我们还是需要好好爱护自己的青青草地！\n\n旨在锻炼逻辑思维，思想对了很重要，请上代码：\n```\n    /**\n     * \n     * @param nums\n     *            排序后目标数组\n     * @param target\n     *            累加目标数值\n     * @param k\n     *            个数\n     * @param index\n     *            起始下标\n     * @return\n     */\n    private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\n\n        ArrayList<List<Integer>> res = new ArrayList<>();\n\n        if (index >= len)\n            return res;\n        if (k == 2) { // 两数取和\n            int i = index, j = len - 1;\n            while (i < j) {\n                // 满足条件塞入集合\n                if (target - nums[i] == nums[j]) {\n                    List<Integer> temp = new ArrayList<>();\n                    temp.add(nums[i]);\n                    temp.add(nums[j]);\n                    res.add(temp);\n                    while (i < j && nums[i] == nums[i + 1]) // 跳过重复数值\n                        i++;\n                    while (i < j && nums[j] == nums[j - 1]) // 跳过重复数值\n                        j--;\n                    i++;\n                    j--;\n                } else if (target - nums[i] > nums[j])\n                    i++;\n                else\n                    j--;\n            }\n        } else {\n            for (int i = index; i < len - k + 1; i++) {\n                // 调用递归 DFS\n                ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k - 1, i + 1);\n                // 若是有值返回则将该数塞入，无则不进行任何操作\n                if (temp != null && temp.size() > 0) {\n                    for (List<Integer> list : temp) {\n                        list.add(nums[i]); // 将满足条件数值塞入\n                    }\n                    res.addAll(temp);\n                }\n                while (i < len - 1 && nums[i] == nums[i + 1]) // 跳过重复数值\n                    i++;\n            }\n        }\n        return res;\n    }\n```\n\n**注意：这里 `len` 定义的是个全局变量，初始值为 0**\n\n若 n 为 4，那程序应该是这样的：\n```\nint len = 0;\npublic List<List<Integer>> fourSum(int[] nums, int target) {\n        len = nums.length;\n        Arrays.sort(nums); // 先排序\n        return kSum(nums, target, 4, 0); // 递归调用\n\n    }\n```\n\n这下只要满足 `n > 1` 条件的都可以套用这个方法了。\n\n要注意栈的深度。时间换空间。","source":"_posts/leetcode-n-sum.md","raw":"---\ntitle: LeetCode 之 n 个数之和（Sum n）\ndate: 2018-11-19 16:52:20\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\nLeetCode 中有好几道题是求数字之和的，有 `Sum 2`、`Sum 3` 和 `Sum 4` 等。求和这种情况在我们实际开发中也是经常会遇到的，在这不妨拿出来我们把这归并到一起来说说。\n\n无非就是数组中几个数字求和比较是否为目标值。且大多结果中是不能有重复的值。\n\n大致我说下这个题意：\n```\n给定一个包含 m 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在 n 个元素，使得这 n 个元素相加的值与 target 相等？找出所有满足条件且不重复的组。\n\n注意：\n答案中不可以包含重复的组。\n\n示例：\n给定数组 nums = [1, 0, -1, 0, -2, 2]， target = 0，n = 4\n\n满足要求的四元组集合为：\n[ [-1, 0, 0, 1],\n[-2, -1, 1, 2],\n[-2, 0, 0, 2] ]\n```\n\n两数之和好办，循环遍历去除重复结果。三数之和也类似。\n\n那要是许多许多数之和呢，遍历就不好使了，那就要采用 BFS 或者 DFS。\n\n`答案中不可以包含重复的组`从这我们知道，首先，我们需要将数组排个序。\n\n由大化小的思想，我们可以采用 DFS + 回溯来解决这一系列问题。\n\n苦恼不已，别挠头了，我们还是需要好好爱护自己的青青草地！\n\n旨在锻炼逻辑思维，思想对了很重要，请上代码：\n```\n    /**\n     * \n     * @param nums\n     *            排序后目标数组\n     * @param target\n     *            累加目标数值\n     * @param k\n     *            个数\n     * @param index\n     *            起始下标\n     * @return\n     */\n    private ArrayList<List<Integer>> kSum(int[] nums, int target, int k, int index) {\n\n        ArrayList<List<Integer>> res = new ArrayList<>();\n\n        if (index >= len)\n            return res;\n        if (k == 2) { // 两数取和\n            int i = index, j = len - 1;\n            while (i < j) {\n                // 满足条件塞入集合\n                if (target - nums[i] == nums[j]) {\n                    List<Integer> temp = new ArrayList<>();\n                    temp.add(nums[i]);\n                    temp.add(nums[j]);\n                    res.add(temp);\n                    while (i < j && nums[i] == nums[i + 1]) // 跳过重复数值\n                        i++;\n                    while (i < j && nums[j] == nums[j - 1]) // 跳过重复数值\n                        j--;\n                    i++;\n                    j--;\n                } else if (target - nums[i] > nums[j])\n                    i++;\n                else\n                    j--;\n            }\n        } else {\n            for (int i = index; i < len - k + 1; i++) {\n                // 调用递归 DFS\n                ArrayList<List<Integer>> temp = kSum(nums, target - nums[i], k - 1, i + 1);\n                // 若是有值返回则将该数塞入，无则不进行任何操作\n                if (temp != null && temp.size() > 0) {\n                    for (List<Integer> list : temp) {\n                        list.add(nums[i]); // 将满足条件数值塞入\n                    }\n                    res.addAll(temp);\n                }\n                while (i < len - 1 && nums[i] == nums[i + 1]) // 跳过重复数值\n                    i++;\n            }\n        }\n        return res;\n    }\n```\n\n**注意：这里 `len` 定义的是个全局变量，初始值为 0**\n\n若 n 为 4，那程序应该是这样的：\n```\nint len = 0;\npublic List<List<Integer>> fourSum(int[] nums, int target) {\n        len = nums.length;\n        Arrays.sort(nums); // 先排序\n        return kSum(nums, target, 4, 0); // 递归调用\n\n    }\n```\n\n这下只要满足 `n > 1` 条件的都可以套用这个方法了。\n\n要注意栈的深度。时间换空间。","slug":"leetcode-n-sum","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhi006yk9i1d64heyhk","content":"<p>LeetCode 中有好几道题是求数字之和的，有 <code>Sum 2</code>、<code>Sum 3</code> 和 <code>Sum 4</code> 等。求和这种情况在我们实际开发中也是经常会遇到的，在这不妨拿出来我们把这归并到一起来说说。</p>\n<p>无非就是数组中几个数字求和比较是否为目标值。且大多结果中是不能有重复的值。</p>\n<p>大致我说下这个题意：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个包含 m 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在 n 个元素，使得这 n 个元素相加的值与 target 相等？找出所有满足条件且不重复的组。</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\">答案中不可以包含重复的组。</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">给定数组 nums = [1, 0, -1, 0, -2, 2]， target = 0，n = 4</span><br><span class=\"line\"></span><br><span class=\"line\">满足要求的四元组集合为：</span><br><span class=\"line\">[ [-1, 0, 0, 1],</span><br><span class=\"line\">[-2, -1, 1, 2],</span><br><span class=\"line\">[-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>\n\n<p>两数之和好办，循环遍历去除重复结果。三数之和也类似。</p>\n<p>那要是许多许多数之和呢，遍历就不好使了，那就要采用 BFS 或者 DFS。</p>\n<p><code>答案中不可以包含重复的组</code>从这我们知道，首先，我们需要将数组排个序。</p>\n<p>由大化小的思想，我们可以采用 DFS + 回溯来解决这一系列问题。</p>\n<p>苦恼不已，别挠头了，我们还是需要好好爱护自己的青青草地！</p>\n<p>旨在锻炼逻辑思维，思想对了很重要，请上代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            排序后目标数组</span><br><span class=\"line\"> * @param target</span><br><span class=\"line\"> *            累加目标数值</span><br><span class=\"line\"> * @param k</span><br><span class=\"line\"> *            个数</span><br><span class=\"line\"> * @param index</span><br><span class=\"line\"> *            起始下标</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">private ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k, int index) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (index &gt;= len)</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    if (k == 2) &#123; // 两数取和</span><br><span class=\"line\">        int i = index, j = len - 1;</span><br><span class=\"line\">        while (i &lt; j) &#123;</span><br><span class=\"line\">            // 满足条件塞入集合</span><br><span class=\"line\">            if (target - nums[i] == nums[j]) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                temp.add(nums[i]);</span><br><span class=\"line\">                temp.add(nums[j]);</span><br><span class=\"line\">                res.add(temp);</span><br><span class=\"line\">                while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) // 跳过重复数值</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) // 跳过重复数值</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; else if (target - nums[i] &gt; nums[j])</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        for (int i = index; i &lt; len - k + 1; i++) &#123;</span><br><span class=\"line\">            // 调用递归 DFS</span><br><span class=\"line\">            ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k - 1, i + 1);</span><br><span class=\"line\">            // 若是有值返回则将该数塞入，无则不进行任何操作</span><br><span class=\"line\">            if (temp != null &amp;&amp; temp.size() &gt; 0) &#123;</span><br><span class=\"line\">                for (List&lt;Integer&gt; list : temp) &#123;</span><br><span class=\"line\">                    list.add(nums[i]); // 将满足条件数值塞入</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                res.addAll(temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (i &lt; len - 1 &amp;&amp; nums[i] == nums[i + 1]) // 跳过重复数值</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：这里 <code>len</code> 定义的是个全局变量，初始值为 0</strong></p>\n<p>若 n 为 4，那程序应该是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int len = 0;</span><br><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        len = nums.length;</span><br><span class=\"line\">        Arrays.sort(nums); // 先排序</span><br><span class=\"line\">        return kSum(nums, target, 4, 0); // 递归调用</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这下只要满足 <code>n &gt; 1</code> 条件的都可以套用这个方法了。</p>\n<p>要注意栈的深度。时间换空间。</p>\n","excerpt":"","more":"<p>LeetCode 中有好几道题是求数字之和的，有 <code>Sum 2</code>、<code>Sum 3</code> 和 <code>Sum 4</code> 等。求和这种情况在我们实际开发中也是经常会遇到的，在这不妨拿出来我们把这归并到一起来说说。</p>\n<p>无非就是数组中几个数字求和比较是否为目标值。且大多结果中是不能有重复的值。</p>\n<p>大致我说下这个题意：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个包含 m 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在 n 个元素，使得这 n 个元素相加的值与 target 相等？找出所有满足条件且不重复的组。</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\">答案中不可以包含重复的组。</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">给定数组 nums = [1, 0, -1, 0, -2, 2]， target = 0，n = 4</span><br><span class=\"line\"></span><br><span class=\"line\">满足要求的四元组集合为：</span><br><span class=\"line\">[ [-1, 0, 0, 1],</span><br><span class=\"line\">[-2, -1, 1, 2],</span><br><span class=\"line\">[-2, 0, 0, 2] ]</span><br></pre></td></tr></table></figure>\n\n<p>两数之和好办，循环遍历去除重复结果。三数之和也类似。</p>\n<p>那要是许多许多数之和呢，遍历就不好使了，那就要采用 BFS 或者 DFS。</p>\n<p><code>答案中不可以包含重复的组</code>从这我们知道，首先，我们需要将数组排个序。</p>\n<p>由大化小的思想，我们可以采用 DFS + 回溯来解决这一系列问题。</p>\n<p>苦恼不已，别挠头了，我们还是需要好好爱护自己的青青草地！</p>\n<p>旨在锻炼逻辑思维，思想对了很重要，请上代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            排序后目标数组</span><br><span class=\"line\"> * @param target</span><br><span class=\"line\"> *            累加目标数值</span><br><span class=\"line\"> * @param k</span><br><span class=\"line\"> *            个数</span><br><span class=\"line\"> * @param index</span><br><span class=\"line\"> *            起始下标</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">private ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k, int index) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (index &gt;= len)</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    if (k == 2) &#123; // 两数取和</span><br><span class=\"line\">        int i = index, j = len - 1;</span><br><span class=\"line\">        while (i &lt; j) &#123;</span><br><span class=\"line\">            // 满足条件塞入集合</span><br><span class=\"line\">            if (target - nums[i] == nums[j]) &#123;</span><br><span class=\"line\">                List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();</span><br><span class=\"line\">                temp.add(nums[i]);</span><br><span class=\"line\">                temp.add(nums[j]);</span><br><span class=\"line\">                res.add(temp);</span><br><span class=\"line\">                while (i &lt; j &amp;&amp; nums[i] == nums[i + 1]) // 跳过重复数值</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                while (i &lt; j &amp;&amp; nums[j] == nums[j - 1]) // 跳过重复数值</span><br><span class=\"line\">                    j--;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; else if (target - nums[i] &gt; nums[j])</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            else</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        for (int i = index; i &lt; len - k + 1; i++) &#123;</span><br><span class=\"line\">            // 调用递归 DFS</span><br><span class=\"line\">            ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k - 1, i + 1);</span><br><span class=\"line\">            // 若是有值返回则将该数塞入，无则不进行任何操作</span><br><span class=\"line\">            if (temp != null &amp;&amp; temp.size() &gt; 0) &#123;</span><br><span class=\"line\">                for (List&lt;Integer&gt; list : temp) &#123;</span><br><span class=\"line\">                    list.add(nums[i]); // 将满足条件数值塞入</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                res.addAll(temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            while (i &lt; len - 1 &amp;&amp; nums[i] == nums[i + 1]) // 跳过重复数值</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：这里 <code>len</code> 定义的是个全局变量，初始值为 0</strong></p>\n<p>若 n 为 4，那程序应该是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int len = 0;</span><br><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        len = nums.length;</span><br><span class=\"line\">        Arrays.sort(nums); // 先排序</span><br><span class=\"line\">        return kSum(nums, target, 4, 0); // 递归调用</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这下只要满足 <code>n &gt; 1</code> 条件的都可以套用这个方法了。</p>\n<p>要注意栈的深度。时间换空间。</p>\n"},{"title":"LeetCode 之总持续时间可被 60 整除的歌曲（Pairs of Songs With Total Durations Divisible by 60）","date":"2019-04-19T08:59:27.000Z","_content":"\n题目虽然有点长，不过可以化简为同一个类型的，就是两两配对其和是某个数的倍数。\n\n原题描述如下：\n```\n在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。\n\n返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。\n\n示例 1：\n输入：[30,20,150,100,40]\n输出：3\n解释：这三对的总持续时间可被 60 整数：\n(time[0] = 30, time[2] = 150): 总持续时间 180\n(time[1] = 20, time[3] = 100): 总持续时间 120\n(time[1] = 20, time[4] = 40): 总持续时间 60\n\n示例 2：\n输入：[60,60,60]\n输出：3\n解释：所有三对的总持续时间都是 120，可以被 60 整数。\n \n提示：\n\n1 <= time.length <= 60000\n1 <= time[i] <= 500\n```\n\n初看题目，脑子都不要动，我相信大多人也是和我一样，两个 for 搞定：\n\n```\n    /**\n     * 超时\n     * \n     * @param time\n     * @return\n     */\n    public int numPairsDivisibleBy60(int[] time) {\n        int result = 0;\n        for (int i = 0; i < time.length - 1; i++) {\n            for (int j = i + 1; j < time.length; j++) {\n                int value = (time[i] + time[j]) % 60;\n                if (value == 0)\n                    result++;\n            }\n        }\n        return result;\n    }\n```\n\n果然不意外，提交显示超时了。\n\n我们静下心来想想，两数之和是某个数的倍数。既然这样循环查找过于繁琐，那有什么方式可以快速精准查找呢？\n\n哐...当然有了。\n\n首先我们会想到数组，还有键值对形式存储的 Map\n\n这里我使用的是数组，那要怎么使用它呢，再细想。\n\n数组精准查找，那得要根据下标，两数之和为某数，自然，那就将数字作为下标存储到对应块中，值就是其对应的个数。\n\n思路有了，代码如行云流水，请看：\n```\n    public int numPairsDivisibleBy601(int[] time) {\n        // 每个元素取60余\n        time = Arrays.stream(time).map(x -> x % 60).toArray();\n        int[] arrCount = new int[60];\n        // 统计对应下标数\n        Arrays.stream(time).forEach(x -> {\n            arrCount[x]++;\n        });\n        // 余数是 0 或 30 的两两配对\n        int result = qiuhe(arrCount[0]) + qiuhe(arrCount[30]);\n        // 其余互相配对\n        for (int i = 1; i < 30; i++) {\n            int count1 = arrCount[i];\n            int count2 = arrCount[60 - i];\n            result += count1 * count2;\n        }\n        return result;\n    }\n\n    /**\n     * 求两两配对数\n     * \n     * @param num\n     * @return\n     */\n    private int qiuhe(int num) {\n        if (num < 2)\n            return 0;\n        // (num-1)!\n        return num * (num - 1) / 2;\n    }\n```\n\n很好理解，不过速度还是慢，通过阅读其它人的代码后发现了另一种 O(n) 解法，cool~\n\n```\n    public int numPairsDivisibleBy602(int[] time) {\n        int result = 0;\n        int[] arrCount = new int[60];\n        for (int t : time) {\n            // 对应的下标\n            int index = t == 0 ? 0 : 60 - t % 60;\n            // 与已经统计的数进行匹配 可防止两两重复匹配\n            result += arrCount[index];\n            // 对应数字加一\n            arrCount[t % 60]++;\n        }\n        return result;\n    }\n```\n\n一个 for 完美解决问题，想必这就是算法的魅力吧。","source":"_posts/leetcode-pairsofsongswithtotaldurationsdivisibleby60.md","raw":"---\ntitle: LeetCode 之总持续时间可被 60 整除的歌曲（Pairs of Songs With Total Durations Divisible by 60）\ndate: 2019-4-19 16:59:27\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n题目虽然有点长，不过可以化简为同一个类型的，就是两两配对其和是某个数的倍数。\n\n原题描述如下：\n```\n在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。\n\n返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。\n\n示例 1：\n输入：[30,20,150,100,40]\n输出：3\n解释：这三对的总持续时间可被 60 整数：\n(time[0] = 30, time[2] = 150): 总持续时间 180\n(time[1] = 20, time[3] = 100): 总持续时间 120\n(time[1] = 20, time[4] = 40): 总持续时间 60\n\n示例 2：\n输入：[60,60,60]\n输出：3\n解释：所有三对的总持续时间都是 120，可以被 60 整数。\n \n提示：\n\n1 <= time.length <= 60000\n1 <= time[i] <= 500\n```\n\n初看题目，脑子都不要动，我相信大多人也是和我一样，两个 for 搞定：\n\n```\n    /**\n     * 超时\n     * \n     * @param time\n     * @return\n     */\n    public int numPairsDivisibleBy60(int[] time) {\n        int result = 0;\n        for (int i = 0; i < time.length - 1; i++) {\n            for (int j = i + 1; j < time.length; j++) {\n                int value = (time[i] + time[j]) % 60;\n                if (value == 0)\n                    result++;\n            }\n        }\n        return result;\n    }\n```\n\n果然不意外，提交显示超时了。\n\n我们静下心来想想，两数之和是某个数的倍数。既然这样循环查找过于繁琐，那有什么方式可以快速精准查找呢？\n\n哐...当然有了。\n\n首先我们会想到数组，还有键值对形式存储的 Map\n\n这里我使用的是数组，那要怎么使用它呢，再细想。\n\n数组精准查找，那得要根据下标，两数之和为某数，自然，那就将数字作为下标存储到对应块中，值就是其对应的个数。\n\n思路有了，代码如行云流水，请看：\n```\n    public int numPairsDivisibleBy601(int[] time) {\n        // 每个元素取60余\n        time = Arrays.stream(time).map(x -> x % 60).toArray();\n        int[] arrCount = new int[60];\n        // 统计对应下标数\n        Arrays.stream(time).forEach(x -> {\n            arrCount[x]++;\n        });\n        // 余数是 0 或 30 的两两配对\n        int result = qiuhe(arrCount[0]) + qiuhe(arrCount[30]);\n        // 其余互相配对\n        for (int i = 1; i < 30; i++) {\n            int count1 = arrCount[i];\n            int count2 = arrCount[60 - i];\n            result += count1 * count2;\n        }\n        return result;\n    }\n\n    /**\n     * 求两两配对数\n     * \n     * @param num\n     * @return\n     */\n    private int qiuhe(int num) {\n        if (num < 2)\n            return 0;\n        // (num-1)!\n        return num * (num - 1) / 2;\n    }\n```\n\n很好理解，不过速度还是慢，通过阅读其它人的代码后发现了另一种 O(n) 解法，cool~\n\n```\n    public int numPairsDivisibleBy602(int[] time) {\n        int result = 0;\n        int[] arrCount = new int[60];\n        for (int t : time) {\n            // 对应的下标\n            int index = t == 0 ? 0 : 60 - t % 60;\n            // 与已经统计的数进行匹配 可防止两两重复匹配\n            result += arrCount[index];\n            // 对应数字加一\n            arrCount[t % 60]++;\n        }\n        return result;\n    }\n```\n\n一个 for 完美解决问题，想必这就是算法的魅力吧。","slug":"leetcode-pairsofsongswithtotaldurationsdivisibleby60","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhj0070k9i10a83fekm","content":"<p>题目虽然有点长，不过可以化简为同一个类型的，就是两两配对其和是某个数的倍数。</p>\n<p>原题描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。</span><br><span class=\"line\"></span><br><span class=\"line\">返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i &lt; j 且有 (time[i] + time[j]) % 60 == 0。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[30,20,150,100,40]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：这三对的总持续时间可被 60 整数：</span><br><span class=\"line\">(time[0] = 30, time[2] = 150): 总持续时间 180</span><br><span class=\"line\">(time[1] = 20, time[3] = 100): 总持续时间 120</span><br><span class=\"line\">(time[1] = 20, time[4] = 40): 总持续时间 60</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[60,60,60]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：所有三对的总持续时间都是 120，可以被 60 整数。</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\"></span><br><span class=\"line\">1 &lt;= time.length &lt;= 60000</span><br><span class=\"line\">1 &lt;= time[i] &lt;= 500</span><br></pre></td></tr></table></figure>\n\n<p>初看题目，脑子都不要动，我相信大多人也是和我一样，两个 for 搞定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 超时</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param time</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public int numPairsDivisibleBy60(int[] time) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    for (int i = 0; i &lt; time.length - 1; i++) &#123;</span><br><span class=\"line\">        for (int j = i + 1; j &lt; time.length; j++) &#123;</span><br><span class=\"line\">            int value = (time[i] + time[j]) % 60;</span><br><span class=\"line\">            if (value == 0)</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>果然不意外，提交显示超时了。</p>\n<p>我们静下心来想想，两数之和是某个数的倍数。既然这样循环查找过于繁琐，那有什么方式可以快速精准查找呢？</p>\n<p>哐…当然有了。</p>\n<p>首先我们会想到数组，还有键值对形式存储的 Map</p>\n<p>这里我使用的是数组，那要怎么使用它呢，再细想。</p>\n<p>数组精准查找，那得要根据下标，两数之和为某数，自然，那就将数字作为下标存储到对应块中，值就是其对应的个数。</p>\n<p>思路有了，代码如行云流水，请看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int numPairsDivisibleBy601(int[] time) &#123;</span><br><span class=\"line\">    // 每个元素取60余</span><br><span class=\"line\">    time = Arrays.stream(time).map(x -&gt; x % 60).toArray();</span><br><span class=\"line\">    int[] arrCount = new int[60];</span><br><span class=\"line\">    // 统计对应下标数</span><br><span class=\"line\">    Arrays.stream(time).forEach(x -&gt; &#123;</span><br><span class=\"line\">        arrCount[x]++;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 余数是 0 或 30 的两两配对</span><br><span class=\"line\">    int result = qiuhe(arrCount[0]) + qiuhe(arrCount[30]);</span><br><span class=\"line\">    // 其余互相配对</span><br><span class=\"line\">    for (int i = 1; i &lt; 30; i++) &#123;</span><br><span class=\"line\">        int count1 = arrCount[i];</span><br><span class=\"line\">        int count2 = arrCount[60 - i];</span><br><span class=\"line\">        result += count1 * count2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 求两两配对数</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param num</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">private int qiuhe(int num) &#123;</span><br><span class=\"line\">    if (num &lt; 2)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    // (num-1)!</span><br><span class=\"line\">    return num * (num - 1) / 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很好理解，不过速度还是慢，通过阅读其它人的代码后发现了另一种 O(n) 解法，cool~</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int numPairsDivisibleBy602(int[] time) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    int[] arrCount = new int[60];</span><br><span class=\"line\">    for (int t : time) &#123;</span><br><span class=\"line\">        // 对应的下标</span><br><span class=\"line\">        int index = t == 0 ? 0 : 60 - t % 60;</span><br><span class=\"line\">        // 与已经统计的数进行匹配 可防止两两重复匹配</span><br><span class=\"line\">        result += arrCount[index];</span><br><span class=\"line\">        // 对应数字加一</span><br><span class=\"line\">        arrCount[t % 60]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个 for 完美解决问题，想必这就是算法的魅力吧。</p>\n","excerpt":"","more":"<p>题目虽然有点长，不过可以化简为同一个类型的，就是两两配对其和是某个数的倍数。</p>\n<p>原题描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。</span><br><span class=\"line\"></span><br><span class=\"line\">返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i &lt; j 且有 (time[i] + time[j]) % 60 == 0。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[30,20,150,100,40]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：这三对的总持续时间可被 60 整数：</span><br><span class=\"line\">(time[0] = 30, time[2] = 150): 总持续时间 180</span><br><span class=\"line\">(time[1] = 20, time[3] = 100): 总持续时间 120</span><br><span class=\"line\">(time[1] = 20, time[4] = 40): 总持续时间 60</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[60,60,60]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：所有三对的总持续时间都是 120，可以被 60 整数。</span><br><span class=\"line\"> </span><br><span class=\"line\">提示：</span><br><span class=\"line\"></span><br><span class=\"line\">1 &lt;= time.length &lt;= 60000</span><br><span class=\"line\">1 &lt;= time[i] &lt;= 500</span><br></pre></td></tr></table></figure>\n\n<p>初看题目，脑子都不要动，我相信大多人也是和我一样，两个 for 搞定：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 超时</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param time</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public int numPairsDivisibleBy60(int[] time) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    for (int i = 0; i &lt; time.length - 1; i++) &#123;</span><br><span class=\"line\">        for (int j = i + 1; j &lt; time.length; j++) &#123;</span><br><span class=\"line\">            int value = (time[i] + time[j]) % 60;</span><br><span class=\"line\">            if (value == 0)</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>果然不意外，提交显示超时了。</p>\n<p>我们静下心来想想，两数之和是某个数的倍数。既然这样循环查找过于繁琐，那有什么方式可以快速精准查找呢？</p>\n<p>哐…当然有了。</p>\n<p>首先我们会想到数组，还有键值对形式存储的 Map</p>\n<p>这里我使用的是数组，那要怎么使用它呢，再细想。</p>\n<p>数组精准查找，那得要根据下标，两数之和为某数，自然，那就将数字作为下标存储到对应块中，值就是其对应的个数。</p>\n<p>思路有了，代码如行云流水，请看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int numPairsDivisibleBy601(int[] time) &#123;</span><br><span class=\"line\">    // 每个元素取60余</span><br><span class=\"line\">    time = Arrays.stream(time).map(x -&gt; x % 60).toArray();</span><br><span class=\"line\">    int[] arrCount = new int[60];</span><br><span class=\"line\">    // 统计对应下标数</span><br><span class=\"line\">    Arrays.stream(time).forEach(x -&gt; &#123;</span><br><span class=\"line\">        arrCount[x]++;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 余数是 0 或 30 的两两配对</span><br><span class=\"line\">    int result = qiuhe(arrCount[0]) + qiuhe(arrCount[30]);</span><br><span class=\"line\">    // 其余互相配对</span><br><span class=\"line\">    for (int i = 1; i &lt; 30; i++) &#123;</span><br><span class=\"line\">        int count1 = arrCount[i];</span><br><span class=\"line\">        int count2 = arrCount[60 - i];</span><br><span class=\"line\">        result += count1 * count2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 求两两配对数</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param num</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">private int qiuhe(int num) &#123;</span><br><span class=\"line\">    if (num &lt; 2)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    // (num-1)!</span><br><span class=\"line\">    return num * (num - 1) / 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很好理解，不过速度还是慢，通过阅读其它人的代码后发现了另一种 O(n) 解法，cool~</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int numPairsDivisibleBy602(int[] time) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    int[] arrCount = new int[60];</span><br><span class=\"line\">    for (int t : time) &#123;</span><br><span class=\"line\">        // 对应的下标</span><br><span class=\"line\">        int index = t == 0 ? 0 : 60 - t % 60;</span><br><span class=\"line\">        // 与已经统计的数进行匹配 可防止两两重复匹配</span><br><span class=\"line\">        result += arrCount[index];</span><br><span class=\"line\">        // 对应数字加一</span><br><span class=\"line\">        arrCount[t % 60]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个 for 完美解决问题，想必这就是算法的魅力吧。</p>\n"},{"title":"LeetCode 之回文数（Palindrome Number）","date":"2018-11-19T07:52:35.000Z","_content":"\n回文数想必大家都不陌生吧。什么？你居然不知道何谓“回文数”？\n\n回文数：“回文”是指正读反读都能读通的句子，它是古今中外都有的一种修辞方式和文字游戏，如“我为人人，人人为我”等。在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number）。\n\nOK，来看题：\n```\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n  \n示例 1:\n输入: 121 输出: true\n \n示例 2:\n输入: -121 输出: false \n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3:\n输入: 10 输出: false  \n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n你能不将整数转为字符串来解决这个问题吗？\n```\n\n这道题看到第一眼就能想到`字符串反转`可以解决。\n\n当然，StringBuilder 就可以实现，如下：\n```\n    /**\n     * 通过字符串反转判断\n     * \n     * @param x\n     * @return\n     */\n    public static boolean isPalindrome(int x) {\n\n        if (x == 0)\n            return true;\n\n        String s = String.valueOf(x);\n\n        StringBuilder sb1 = new StringBuilder(s);\n        sb1.reverse();\n\n        return sb1.toString().equals(s) ? true : false;\n\n    }\n```\n\n代码很简短，功能也能实现。但是这并不是我们所追求的！来看进阶:`你能不将整数转为字符串来解决这个问题吗？`\n\n不转成字符串来解决这个问题，挠一挠头。当然，这肯定难不倒聪明才智的你！\n\n不就是反着来吗，问题不大，请看：\n\n```\npublic static boolean isPalindrome1(int x) {\n\n        if (x == 0 || (x > 0 && x < 10))\n            return true;\n        if (x < 0 || (x % 10 == 0 && x != 0))\n            return false;\n\n        int result = 0, num = x;\n\n        while (num != 0) {\n            int i = num % 10;\n            result = result * 10 + i;\n            num /= 10;\n            System.out.println(\"num :\" + num + \" result :\" + result);\n        }\n\n        return result == x ? true : false;\n\n    }\n```\n\n**取余，上个余数乘 10 再加上这个余数，数字每次除 10 取整。**\n\n```\nif (x == 0 || (x > 0 && x < 10))\n            return true;\n```\n当 `x == 0` 或者 `x > 0 && x < 10` 时，该数肯定是个回文数，这不用多说。\n\n```\nif (x < 0 || (x % 10 == 0 && x != 0))\n            return false;\n```\n当 `x < 0` 时，该数肯定不是个回文数，这也不用多说。`x % 10 == 0 && x != 0` 这个条件的意思是 x 的末数是个 0，也就是它是个 10 的倍数，同时 x 不是 0。这也可以想象，满足这个条件的也肯定不是个回文数，因为 0 开头的只能是 0。\n\n乍一看，这么写稳稳的，堪称完美。满意的端起键盘旁的红枣枸杞水，美滋滋嘬了一口。\n\n其实上述代码还可以优化，运行时间能减少一半。滚烫的红枣枸杞水烫着了舌头，忙用口水润润。\n\n```\n    /**\n     * 反转一半数字进行比较 比上面方法速度快一倍\n     * \n     * @param x\n     * @return\n     */\n    public static boolean isPalindrome2(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n```\n\n妙哉妙哉，满意地捋着下巴小胡子，眯眼色道。","source":"_posts/leetcode-palindrome-number.md","raw":"---\ntitle: LeetCode 之回文数（Palindrome Number）\ndate: 2018-11-19 15:52:35\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n回文数想必大家都不陌生吧。什么？你居然不知道何谓“回文数”？\n\n回文数：“回文”是指正读反读都能读通的句子，它是古今中外都有的一种修辞方式和文字游戏，如“我为人人，人人为我”等。在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number）。\n\nOK，来看题：\n```\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n  \n示例 1:\n输入: 121 输出: true\n \n示例 2:\n输入: -121 输出: false \n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3:\n输入: 10 输出: false  \n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n进阶:\n你能不将整数转为字符串来解决这个问题吗？\n```\n\n这道题看到第一眼就能想到`字符串反转`可以解决。\n\n当然，StringBuilder 就可以实现，如下：\n```\n    /**\n     * 通过字符串反转判断\n     * \n     * @param x\n     * @return\n     */\n    public static boolean isPalindrome(int x) {\n\n        if (x == 0)\n            return true;\n\n        String s = String.valueOf(x);\n\n        StringBuilder sb1 = new StringBuilder(s);\n        sb1.reverse();\n\n        return sb1.toString().equals(s) ? true : false;\n\n    }\n```\n\n代码很简短，功能也能实现。但是这并不是我们所追求的！来看进阶:`你能不将整数转为字符串来解决这个问题吗？`\n\n不转成字符串来解决这个问题，挠一挠头。当然，这肯定难不倒聪明才智的你！\n\n不就是反着来吗，问题不大，请看：\n\n```\npublic static boolean isPalindrome1(int x) {\n\n        if (x == 0 || (x > 0 && x < 10))\n            return true;\n        if (x < 0 || (x % 10 == 0 && x != 0))\n            return false;\n\n        int result = 0, num = x;\n\n        while (num != 0) {\n            int i = num % 10;\n            result = result * 10 + i;\n            num /= 10;\n            System.out.println(\"num :\" + num + \" result :\" + result);\n        }\n\n        return result == x ? true : false;\n\n    }\n```\n\n**取余，上个余数乘 10 再加上这个余数，数字每次除 10 取整。**\n\n```\nif (x == 0 || (x > 0 && x < 10))\n            return true;\n```\n当 `x == 0` 或者 `x > 0 && x < 10` 时，该数肯定是个回文数，这不用多说。\n\n```\nif (x < 0 || (x % 10 == 0 && x != 0))\n            return false;\n```\n当 `x < 0` 时，该数肯定不是个回文数，这也不用多说。`x % 10 == 0 && x != 0` 这个条件的意思是 x 的末数是个 0，也就是它是个 10 的倍数，同时 x 不是 0。这也可以想象，满足这个条件的也肯定不是个回文数，因为 0 开头的只能是 0。\n\n乍一看，这么写稳稳的，堪称完美。满意的端起键盘旁的红枣枸杞水，美滋滋嘬了一口。\n\n其实上述代码还可以优化，运行时间能减少一半。滚烫的红枣枸杞水烫着了舌头，忙用口水润润。\n\n```\n    /**\n     * 反转一半数字进行比较 比上面方法速度快一倍\n     * \n     * @param x\n     * @return\n     */\n    public static boolean isPalindrome2(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n```\n\n妙哉妙哉，满意地捋着下巴小胡子，眯眼色道。","slug":"leetcode-palindrome-number","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhj0074k9i14kkmcr4e","content":"<p>回文数想必大家都不陌生吧。什么？你居然不知道何谓“回文数”？</p>\n<p>回文数：“回文”是指正读反读都能读通的句子，它是古今中外都有的一种修辞方式和文字游戏，如“我为人人，人人为我”等。在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number）。</p>\n<p>OK，来看题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class=\"line\">  </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: 121 输出: true</span><br><span class=\"line\"> </span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: -121 输出: false </span><br><span class=\"line\">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3:</span><br><span class=\"line\">输入: 10 输出: false  </span><br><span class=\"line\">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class=\"line\"></span><br><span class=\"line\">进阶:</span><br><span class=\"line\">你能不将整数转为字符串来解决这个问题吗？</span><br></pre></td></tr></table></figure>\n\n<p>这道题看到第一眼就能想到<code>字符串反转</code>可以解决。</p>\n<p>当然，StringBuilder 就可以实现，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 通过字符串反转判断</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param x</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static boolean isPalindrome(int x) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (x == 0)</span><br><span class=\"line\">        return true;</span><br><span class=\"line\"></span><br><span class=\"line\">    String s = String.valueOf(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuilder sb1 = new StringBuilder(s);</span><br><span class=\"line\">    sb1.reverse();</span><br><span class=\"line\"></span><br><span class=\"line\">    return sb1.toString().equals(s) ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简短，功能也能实现。但是这并不是我们所追求的！来看进阶:<code>你能不将整数转为字符串来解决这个问题吗？</code></p>\n<p>不转成字符串来解决这个问题，挠一挠头。当然，这肯定难不倒聪明才智的你！</p>\n<p>不就是反着来吗，问题不大，请看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean isPalindrome1(int x) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (x == 0 || (x &gt; 0 &amp;&amp; x &lt; 10))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\"></span><br><span class=\"line\">        int result = 0, num = x;</span><br><span class=\"line\"></span><br><span class=\"line\">        while (num != 0) &#123;</span><br><span class=\"line\">            int i = num % 10;</span><br><span class=\"line\">            result = result * 10 + i;</span><br><span class=\"line\">            num /= 10;</span><br><span class=\"line\">            System.out.println(&quot;num :&quot; + num + &quot; result :&quot; + result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return result == x ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>取余，上个余数乘 10 再加上这个余数，数字每次除 10 取整。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (x == 0 || (x &gt; 0 &amp;&amp; x &lt; 10))</span><br><span class=\"line\">            return true;</span><br></pre></td></tr></table></figure>\n<p>当 <code>x == 0</code> 或者 <code>x &gt; 0 &amp;&amp; x &lt; 10</code> 时，该数肯定是个回文数，这不用多说。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))</span><br><span class=\"line\">            return false;</span><br></pre></td></tr></table></figure>\n<p>当 <code>x &lt; 0</code> 时，该数肯定不是个回文数，这也不用多说。<code>x % 10 == 0 &amp;&amp; x != 0</code> 这个条件的意思是 x 的末数是个 0，也就是它是个 10 的倍数，同时 x 不是 0。这也可以想象，满足这个条件的也肯定不是个回文数，因为 0 开头的只能是 0。</p>\n<p>乍一看，这么写稳稳的，堪称完美。满意的端起键盘旁的红枣枸杞水，美滋滋嘬了一口。</p>\n<p>其实上述代码还可以优化，运行时间能减少一半。滚烫的红枣枸杞水烫着了舌头，忙用口水润润。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 反转一半数字进行比较 比上面方法速度快一倍</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param x</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static boolean isPalindrome2(int x) &#123;</span><br><span class=\"line\">    // 特殊情况：</span><br><span class=\"line\">    // 如上所述，当 x &lt; 0 时，x 不是回文数。</span><br><span class=\"line\">    // 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span><br><span class=\"line\">    // 则其第一位数字也应该是 0</span><br><span class=\"line\">    // 只有 0 满足这一属性</span><br><span class=\"line\">    if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int revertedNumber = 0;</span><br><span class=\"line\">    while (x &gt; revertedNumber) &#123;</span><br><span class=\"line\">        revertedNumber = revertedNumber * 10 + x % 10;</span><br><span class=\"line\">        x /= 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span><br><span class=\"line\">    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span><br><span class=\"line\">    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span><br><span class=\"line\">    return x == revertedNumber || x == revertedNumber / 10;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>妙哉妙哉，满意地捋着下巴小胡子，眯眼色道。</p>\n","excerpt":"","more":"<p>回文数想必大家都不陌生吧。什么？你居然不知道何谓“回文数”？</p>\n<p>回文数：“回文”是指正读反读都能读通的句子，它是古今中外都有的一种修辞方式和文字游戏，如“我为人人，人人为我”等。在数学中也有这样一类数字有这样的特征，成为回文数（palindrome number）。</p>\n<p>OK，来看题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class=\"line\">  </span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: 121 输出: true</span><br><span class=\"line\"> </span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: -121 输出: false </span><br><span class=\"line\">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3:</span><br><span class=\"line\">输入: 10 输出: false  </span><br><span class=\"line\">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class=\"line\"></span><br><span class=\"line\">进阶:</span><br><span class=\"line\">你能不将整数转为字符串来解决这个问题吗？</span><br></pre></td></tr></table></figure>\n\n<p>这道题看到第一眼就能想到<code>字符串反转</code>可以解决。</p>\n<p>当然，StringBuilder 就可以实现，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 通过字符串反转判断</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param x</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static boolean isPalindrome(int x) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (x == 0)</span><br><span class=\"line\">        return true;</span><br><span class=\"line\"></span><br><span class=\"line\">    String s = String.valueOf(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    StringBuilder sb1 = new StringBuilder(s);</span><br><span class=\"line\">    sb1.reverse();</span><br><span class=\"line\"></span><br><span class=\"line\">    return sb1.toString().equals(s) ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码很简短，功能也能实现。但是这并不是我们所追求的！来看进阶:<code>你能不将整数转为字符串来解决这个问题吗？</code></p>\n<p>不转成字符串来解决这个问题，挠一挠头。当然，这肯定难不倒聪明才智的你！</p>\n<p>不就是反着来吗，问题不大，请看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static boolean isPalindrome1(int x) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (x == 0 || (x &gt; 0 &amp;&amp; x &lt; 10))</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))</span><br><span class=\"line\">            return false;</span><br><span class=\"line\"></span><br><span class=\"line\">        int result = 0, num = x;</span><br><span class=\"line\"></span><br><span class=\"line\">        while (num != 0) &#123;</span><br><span class=\"line\">            int i = num % 10;</span><br><span class=\"line\">            result = result * 10 + i;</span><br><span class=\"line\">            num /= 10;</span><br><span class=\"line\">            System.out.println(&quot;num :&quot; + num + &quot; result :&quot; + result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return result == x ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>取余，上个余数乘 10 再加上这个余数，数字每次除 10 取整。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (x == 0 || (x &gt; 0 &amp;&amp; x &lt; 10))</span><br><span class=\"line\">            return true;</span><br></pre></td></tr></table></figure>\n<p>当 <code>x == 0</code> 或者 <code>x &gt; 0 &amp;&amp; x &lt; 10</code> 时，该数肯定是个回文数，这不用多说。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))</span><br><span class=\"line\">            return false;</span><br></pre></td></tr></table></figure>\n<p>当 <code>x &lt; 0</code> 时，该数肯定不是个回文数，这也不用多说。<code>x % 10 == 0 &amp;&amp; x != 0</code> 这个条件的意思是 x 的末数是个 0，也就是它是个 10 的倍数，同时 x 不是 0。这也可以想象，满足这个条件的也肯定不是个回文数，因为 0 开头的只能是 0。</p>\n<p>乍一看，这么写稳稳的，堪称完美。满意的端起键盘旁的红枣枸杞水，美滋滋嘬了一口。</p>\n<p>其实上述代码还可以优化，运行时间能减少一半。滚烫的红枣枸杞水烫着了舌头，忙用口水润润。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 反转一半数字进行比较 比上面方法速度快一倍</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param x</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static boolean isPalindrome2(int x) &#123;</span><br><span class=\"line\">    // 特殊情况：</span><br><span class=\"line\">    // 如上所述，当 x &lt; 0 时，x 不是回文数。</span><br><span class=\"line\">    // 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span><br><span class=\"line\">    // 则其第一位数字也应该是 0</span><br><span class=\"line\">    // 只有 0 满足这一属性</span><br><span class=\"line\">    if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int revertedNumber = 0;</span><br><span class=\"line\">    while (x &gt; revertedNumber) &#123;</span><br><span class=\"line\">        revertedNumber = revertedNumber * 10 + x % 10;</span><br><span class=\"line\">        x /= 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span><br><span class=\"line\">    // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span><br><span class=\"line\">    // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span><br><span class=\"line\">    return x == revertedNumber || x == revertedNumber / 10;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>妙哉妙哉，满意地捋着下巴小胡子，眯眼色道。</p>\n"},{"title":"LeetCode 之全排列（Permutations）","date":"2018-12-29T07:29:47.000Z","_content":"\n全排列问题在这里有两个版本，其中略有差异。看完就会感觉似曾相识，一种莫名的熟悉感从心底喷涌上来。\n\n第一个版本：\n```\n给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n```\n有什么感觉？\n\n这不就是暗箱摸球，箱子里有不同颜色的球 n 个，列出你可能会摸出球的所有顺序，不放回。\n\n先贴上大神的详细解析：[链接](https://leetcode.com/problems/permutations/discuss/18436/Java-Clean-Code-Two-recursive-solutions)\n\n利用 List.add(int index, E element) 方法可以将元素插入指定的位置，可以满足题意。\n\n**整体分析：根据可插入的地方不同从而展开不同的分支，典型的树形结构。**\n\n代码如下：\n```\n    public List<List<Integer>> permute(int[] nums) {\n\n        List<List<Integer>> permutations = new ArrayList<>();\n        if (nums.length == 0)\n            return permutations;\n        helper(nums, 0, new ArrayList<>(), permutations);\n        return permutations;\n\n    }\n\n    /**\n     * \n     * @param nums\n     *            原数组\n     * @param start\n     *            选择填充数字下标\n     * @param permutation\n     *            单个集合\n     * @param permutations\n     *            目标返回集合\n     */\n    private void helper(int[] nums, int start, List<Integer> permutation, List<List<Integer>> permutations) {\n\n        // 满足条件添加 返回\n        if (permutation.size() == nums.length) {\n            permutations.add(permutation);\n            return;\n        }\n        // 分别插入不同的位置\n        for (int i = 0; i <= permutation.size(); i++) {\n            // 避免在原集合上操作 需新集合\n            List<Integer> newPermutation = new ArrayList<>(permutation);\n            newPermutation.add(i, nums[start]);\n            helper(nums, start + 1, newPermutation, permutations);\n        }\n    }\n```\n\n**注意每次插入前要 new 一个新集合对象，不能在原集合对象上操作。**\n\n第二个版本：\n```\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n示例:\n\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n与第一个版本区别是：**该版本数组中可以有重复元素，且返回的集合中不能有重复的元素（即重复的集合排列顺序）。**\n\n> 去重，我首先想到的是这样：不管你序列中有没有重复的数字，我就当满足条件的时候判断下是否已经存过了该排列顺序不就行了。\n\n然后我就将使用过的数字全都按顺序拼接成字符串，too young ...\n\n指定位置插入元素，List 很好实现，可是 String 怎么办。方法肯定有啊，比如每个元素之间用自定义分隔符拼接，再转成数组找到指定的位置插入，再转。只要功夫深，铁杵磨成针。可是麻烦啊，算暴力解法，遂弃之。\n\n解题代码如下：\n```\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> permuteUniques = new ArrayList<>();\n        if (nums == null || nums.length == 0)\n            return permuteUniques;\n        // 要去重 先排序\n        Arrays.sort(nums);\n        boolean[] used = new boolean[nums.length];\n        dfs(nums, used, permuteUniques, new ArrayList<>());\n        return permuteUniques;\n    }\n\n    /**\n     * \n     * @param nums\n     *            原数组\n     * @param used\n     *            标记数字使用状态\n     * @param permuteUniques\n     *            目标集合\n     * @param permuteUnique\n     *            单个集合\n     */\n    private void dfs(int[] nums, boolean[] used, List<List<Integer>> permuteUniques, List<Integer> permuteUnique) {\n        if (permuteUnique.size() == nums.length) {\n            permuteUniques.add(new ArrayList<>(permuteUnique));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (used[i]) // 已经标记过的略过\n                continue;\n            // 数字有重复的 说明刚释放的值与该值一样 略过\n            if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1])\n                continue;\n            used[i] = true; // 标记使用\n            permuteUnique.add(nums[i]); // 该数字加入集合\n            // 重复操作 选择剩余数字\n            dfs(nums, used, permuteUniques, permuteUnique);\n            // 当出栈时将最后一个数从集合中删除 同时该数恢复未使用状态 继续操作\n            used[i] = false;\n            permuteUnique.remove(permuteUnique.size() - 1);\n        }\n\n    }\n```\n\n由于要去重，所以先将数组排序。与第一版本的大致思路一样，遍历数组将未标记的值插入。\n\n```\nif (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) // 数字有重复的 说明刚释放的值与该值一样 略过\n    continue;\n```\n这行代码至关重要，与出栈时候的 `used[i] = false;` 相对应，实现了重复操作不执行的功能。\n\n同样，`permuteUniques.add(new ArrayList<>(permuteUnique));` 也是需要 new 一个新对象塞入。","source":"_posts/leetcode-permutations.md","raw":"---\ntitle: LeetCode 之全排列（Permutations）\ndate: 2018-12-29 15:29:47\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n全排列问题在这里有两个版本，其中略有差异。看完就会感觉似曾相识，一种莫名的熟悉感从心底喷涌上来。\n\n第一个版本：\n```\n给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n```\n有什么感觉？\n\n这不就是暗箱摸球，箱子里有不同颜色的球 n 个，列出你可能会摸出球的所有顺序，不放回。\n\n先贴上大神的详细解析：[链接](https://leetcode.com/problems/permutations/discuss/18436/Java-Clean-Code-Two-recursive-solutions)\n\n利用 List.add(int index, E element) 方法可以将元素插入指定的位置，可以满足题意。\n\n**整体分析：根据可插入的地方不同从而展开不同的分支，典型的树形结构。**\n\n代码如下：\n```\n    public List<List<Integer>> permute(int[] nums) {\n\n        List<List<Integer>> permutations = new ArrayList<>();\n        if (nums.length == 0)\n            return permutations;\n        helper(nums, 0, new ArrayList<>(), permutations);\n        return permutations;\n\n    }\n\n    /**\n     * \n     * @param nums\n     *            原数组\n     * @param start\n     *            选择填充数字下标\n     * @param permutation\n     *            单个集合\n     * @param permutations\n     *            目标返回集合\n     */\n    private void helper(int[] nums, int start, List<Integer> permutation, List<List<Integer>> permutations) {\n\n        // 满足条件添加 返回\n        if (permutation.size() == nums.length) {\n            permutations.add(permutation);\n            return;\n        }\n        // 分别插入不同的位置\n        for (int i = 0; i <= permutation.size(); i++) {\n            // 避免在原集合上操作 需新集合\n            List<Integer> newPermutation = new ArrayList<>(permutation);\n            newPermutation.add(i, nums[start]);\n            helper(nums, start + 1, newPermutation, permutations);\n        }\n    }\n```\n\n**注意每次插入前要 new 一个新集合对象，不能在原集合对象上操作。**\n\n第二个版本：\n```\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n示例:\n\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n与第一个版本区别是：**该版本数组中可以有重复元素，且返回的集合中不能有重复的元素（即重复的集合排列顺序）。**\n\n> 去重，我首先想到的是这样：不管你序列中有没有重复的数字，我就当满足条件的时候判断下是否已经存过了该排列顺序不就行了。\n\n然后我就将使用过的数字全都按顺序拼接成字符串，too young ...\n\n指定位置插入元素，List 很好实现，可是 String 怎么办。方法肯定有啊，比如每个元素之间用自定义分隔符拼接，再转成数组找到指定的位置插入，再转。只要功夫深，铁杵磨成针。可是麻烦啊，算暴力解法，遂弃之。\n\n解题代码如下：\n```\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> permuteUniques = new ArrayList<>();\n        if (nums == null || nums.length == 0)\n            return permuteUniques;\n        // 要去重 先排序\n        Arrays.sort(nums);\n        boolean[] used = new boolean[nums.length];\n        dfs(nums, used, permuteUniques, new ArrayList<>());\n        return permuteUniques;\n    }\n\n    /**\n     * \n     * @param nums\n     *            原数组\n     * @param used\n     *            标记数字使用状态\n     * @param permuteUniques\n     *            目标集合\n     * @param permuteUnique\n     *            单个集合\n     */\n    private void dfs(int[] nums, boolean[] used, List<List<Integer>> permuteUniques, List<Integer> permuteUnique) {\n        if (permuteUnique.size() == nums.length) {\n            permuteUniques.add(new ArrayList<>(permuteUnique));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (used[i]) // 已经标记过的略过\n                continue;\n            // 数字有重复的 说明刚释放的值与该值一样 略过\n            if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1])\n                continue;\n            used[i] = true; // 标记使用\n            permuteUnique.add(nums[i]); // 该数字加入集合\n            // 重复操作 选择剩余数字\n            dfs(nums, used, permuteUniques, permuteUnique);\n            // 当出栈时将最后一个数从集合中删除 同时该数恢复未使用状态 继续操作\n            used[i] = false;\n            permuteUnique.remove(permuteUnique.size() - 1);\n        }\n\n    }\n```\n\n由于要去重，所以先将数组排序。与第一版本的大致思路一样，遍历数组将未标记的值插入。\n\n```\nif (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) // 数字有重复的 说明刚释放的值与该值一样 略过\n    continue;\n```\n这行代码至关重要，与出栈时候的 `used[i] = false;` 相对应，实现了重复操作不执行的功能。\n\n同样，`permuteUniques.add(new ArrayList<>(permuteUnique));` 也是需要 new 一个新对象塞入。","slug":"leetcode-permutations","published":1,"updated":"2023-12-23T15:35:23.829Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhj0077k9i1hvrgbxek","content":"<p>全排列问题在这里有两个版本，其中略有差异。看完就会感觉似曾相识，一种莫名的熟悉感从心底喷涌上来。</p>\n<p>第一个版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个没有重复数字的序列，返回其所有可能的全排列。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,2,3]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>有什么感觉？</p>\n<p>这不就是暗箱摸球，箱子里有不同颜色的球 n 个，列出你可能会摸出球的所有顺序，不放回。</p>\n<p>先贴上大神的详细解析：<a href=\"https://leetcode.com/problems/permutations/discuss/18436/Java-Clean-Code-Two-recursive-solutions\">链接</a></p>\n<p>利用 List.add(int index, E element) 方法可以将元素插入指定的位置，可以满足题意。</p>\n<p><strong>整体分析：根据可插入的地方不同从而展开不同的分支，典型的树形结构。</strong></p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    if (nums.length == 0)</span><br><span class=\"line\">        return permutations;</span><br><span class=\"line\">    helper(nums, 0, new ArrayList&lt;&gt;(), permutations);</span><br><span class=\"line\">    return permutations;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            原数组</span><br><span class=\"line\"> * @param start</span><br><span class=\"line\"> *            选择填充数字下标</span><br><span class=\"line\"> * @param permutation</span><br><span class=\"line\"> *            单个集合</span><br><span class=\"line\"> * @param permutations</span><br><span class=\"line\"> *            目标返回集合</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void helper(int[] nums, int start, List&lt;Integer&gt; permutation, List&lt;List&lt;Integer&gt;&gt; permutations) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 满足条件添加 返回</span><br><span class=\"line\">    if (permutation.size() == nums.length) &#123;</span><br><span class=\"line\">        permutations.add(permutation);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 分别插入不同的位置</span><br><span class=\"line\">    for (int i = 0; i &lt;= permutation.size(); i++) &#123;</span><br><span class=\"line\">        // 避免在原集合上操作 需新集合</span><br><span class=\"line\">        List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation);</span><br><span class=\"line\">        newPermutation.add(i, nums[start]);</span><br><span class=\"line\">        helper(nums, start + 1, newPermutation, permutations);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意每次插入前要 new 一个新集合对象，不能在原集合对象上操作。</strong></p>\n<p>第二个版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个可包含重复数字的序列，返回所有不重复的全排列。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,1,2]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1,2],</span><br><span class=\"line\">  [1,2,1],</span><br><span class=\"line\">  [2,1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>与第一个版本区别是：<strong>该版本数组中可以有重复元素，且返回的集合中不能有重复的元素（即重复的集合排列顺序）。</strong></p>\n<blockquote>\n<p>去重，我首先想到的是这样：不管你序列中有没有重复的数字，我就当满足条件的时候判断下是否已经存过了该排列顺序不就行了。</p>\n</blockquote>\n<p>然后我就将使用过的数字全都按顺序拼接成字符串，too young …</p>\n<p>指定位置插入元素，List 很好实现，可是 String 怎么办。方法肯定有啊，比如每个元素之间用自定义分隔符拼接，再转成数组找到指定的位置插入，再转。只要功夫深，铁杵磨成针。可是麻烦啊，算暴力解法，遂弃之。</p>\n<p>解题代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; permuteUniques = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    if (nums == null || nums.length == 0)</span><br><span class=\"line\">        return permuteUniques;</span><br><span class=\"line\">    // 要去重 先排序</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    boolean[] used = new boolean[nums.length];</span><br><span class=\"line\">    dfs(nums, used, permuteUniques, new ArrayList&lt;&gt;());</span><br><span class=\"line\">    return permuteUniques;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            原数组</span><br><span class=\"line\"> * @param used</span><br><span class=\"line\"> *            标记数字使用状态</span><br><span class=\"line\"> * @param permuteUniques</span><br><span class=\"line\"> *            目标集合</span><br><span class=\"line\"> * @param permuteUnique</span><br><span class=\"line\"> *            单个集合</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void dfs(int[] nums, boolean[] used, List&lt;List&lt;Integer&gt;&gt; permuteUniques, List&lt;Integer&gt; permuteUnique) &#123;</span><br><span class=\"line\">    if (permuteUnique.size() == nums.length) &#123;</span><br><span class=\"line\">        permuteUniques.add(new ArrayList&lt;&gt;(permuteUnique));</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        if (used[i]) // 已经标记过的略过</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        // 数字有重复的 说明刚释放的值与该值一样 略过</span><br><span class=\"line\">        if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1])</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        used[i] = true; // 标记使用</span><br><span class=\"line\">        permuteUnique.add(nums[i]); // 该数字加入集合</span><br><span class=\"line\">        // 重复操作 选择剩余数字</span><br><span class=\"line\">        dfs(nums, used, permuteUniques, permuteUnique);</span><br><span class=\"line\">        // 当出栈时将最后一个数从集合中删除 同时该数恢复未使用状态 继续操作</span><br><span class=\"line\">        used[i] = false;</span><br><span class=\"line\">        permuteUnique.remove(permuteUnique.size() - 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于要去重，所以先将数组排序。与第一版本的大致思路一样，遍历数组将未标记的值插入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1]) // 数字有重复的 说明刚释放的值与该值一样 略过</span><br><span class=\"line\">    continue;</span><br></pre></td></tr></table></figure>\n<p>这行代码至关重要，与出栈时候的 <code>used[i] = false;</code> 相对应，实现了重复操作不执行的功能。</p>\n<p>同样，<code>permuteUniques.add(new ArrayList&lt;&gt;(permuteUnique));</code> 也是需要 new 一个新对象塞入。</p>\n","excerpt":"","more":"<p>全排列问题在这里有两个版本，其中略有差异。看完就会感觉似曾相识，一种莫名的熟悉感从心底喷涌上来。</p>\n<p>第一个版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个没有重复数字的序列，返回其所有可能的全排列。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,2,3]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>有什么感觉？</p>\n<p>这不就是暗箱摸球，箱子里有不同颜色的球 n 个，列出你可能会摸出球的所有顺序，不放回。</p>\n<p>先贴上大神的详细解析：<a href=\"https://leetcode.com/problems/permutations/discuss/18436/Java-Clean-Code-Two-recursive-solutions\">链接</a></p>\n<p>利用 List.add(int index, E element) 方法可以将元素插入指定的位置，可以满足题意。</p>\n<p><strong>整体分析：根据可插入的地方不同从而展开不同的分支，典型的树形结构。</strong></p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    if (nums.length == 0)</span><br><span class=\"line\">        return permutations;</span><br><span class=\"line\">    helper(nums, 0, new ArrayList&lt;&gt;(), permutations);</span><br><span class=\"line\">    return permutations;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            原数组</span><br><span class=\"line\"> * @param start</span><br><span class=\"line\"> *            选择填充数字下标</span><br><span class=\"line\"> * @param permutation</span><br><span class=\"line\"> *            单个集合</span><br><span class=\"line\"> * @param permutations</span><br><span class=\"line\"> *            目标返回集合</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void helper(int[] nums, int start, List&lt;Integer&gt; permutation, List&lt;List&lt;Integer&gt;&gt; permutations) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 满足条件添加 返回</span><br><span class=\"line\">    if (permutation.size() == nums.length) &#123;</span><br><span class=\"line\">        permutations.add(permutation);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 分别插入不同的位置</span><br><span class=\"line\">    for (int i = 0; i &lt;= permutation.size(); i++) &#123;</span><br><span class=\"line\">        // 避免在原集合上操作 需新集合</span><br><span class=\"line\">        List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation);</span><br><span class=\"line\">        newPermutation.add(i, nums[start]);</span><br><span class=\"line\">        helper(nums, start + 1, newPermutation, permutations);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意每次插入前要 new 一个新集合对象，不能在原集合对象上操作。</strong></p>\n<p>第二个版本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个可包含重复数字的序列，返回所有不重复的全排列。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,1,2]</span><br><span class=\"line\">输出:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1,2],</span><br><span class=\"line\">  [1,2,1],</span><br><span class=\"line\">  [2,1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>与第一个版本区别是：<strong>该版本数组中可以有重复元素，且返回的集合中不能有重复的元素（即重复的集合排列顺序）。</strong></p>\n<blockquote>\n<p>去重，我首先想到的是这样：不管你序列中有没有重复的数字，我就当满足条件的时候判断下是否已经存过了该排列顺序不就行了。</p>\n</blockquote>\n<p>然后我就将使用过的数字全都按顺序拼接成字符串，too young …</p>\n<p>指定位置插入元素，List 很好实现，可是 String 怎么办。方法肯定有啊，比如每个元素之间用自定义分隔符拼接，再转成数组找到指定的位置插入，再转。只要功夫深，铁杵磨成针。可是麻烦啊，算暴力解法，遂弃之。</p>\n<p>解题代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; permuteUniques = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    if (nums == null || nums.length == 0)</span><br><span class=\"line\">        return permuteUniques;</span><br><span class=\"line\">    // 要去重 先排序</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    boolean[] used = new boolean[nums.length];</span><br><span class=\"line\">    dfs(nums, used, permuteUniques, new ArrayList&lt;&gt;());</span><br><span class=\"line\">    return permuteUniques;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param nums</span><br><span class=\"line\"> *            原数组</span><br><span class=\"line\"> * @param used</span><br><span class=\"line\"> *            标记数字使用状态</span><br><span class=\"line\"> * @param permuteUniques</span><br><span class=\"line\"> *            目标集合</span><br><span class=\"line\"> * @param permuteUnique</span><br><span class=\"line\"> *            单个集合</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void dfs(int[] nums, boolean[] used, List&lt;List&lt;Integer&gt;&gt; permuteUniques, List&lt;Integer&gt; permuteUnique) &#123;</span><br><span class=\"line\">    if (permuteUnique.size() == nums.length) &#123;</span><br><span class=\"line\">        permuteUniques.add(new ArrayList&lt;&gt;(permuteUnique));</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        if (used[i]) // 已经标记过的略过</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        // 数字有重复的 说明刚释放的值与该值一样 略过</span><br><span class=\"line\">        if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1])</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        used[i] = true; // 标记使用</span><br><span class=\"line\">        permuteUnique.add(nums[i]); // 该数字加入集合</span><br><span class=\"line\">        // 重复操作 选择剩余数字</span><br><span class=\"line\">        dfs(nums, used, permuteUniques, permuteUnique);</span><br><span class=\"line\">        // 当出栈时将最后一个数从集合中删除 同时该数恢复未使用状态 继续操作</span><br><span class=\"line\">        used[i] = false;</span><br><span class=\"line\">        permuteUnique.remove(permuteUnique.size() - 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于要去重，所以先将数组排序。与第一版本的大致思路一样，遍历数组将未标记的值插入。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !used[i - 1]) // 数字有重复的 说明刚释放的值与该值一样 略过</span><br><span class=\"line\">    continue;</span><br></pre></td></tr></table></figure>\n<p>这行代码至关重要，与出栈时候的 <code>used[i] = false;</code> 相对应，实现了重复操作不执行的功能。</p>\n<p>同样，<code>permuteUniques.add(new ArrayList&lt;&gt;(permuteUnique));</code> 也是需要 new 一个新对象塞入。</p>\n"},{"title":"LeetCode 之反转链表（Reverse Linked List）","date":"2019-02-19T02:22:56.000Z","_content":"\n## 前言\n反转链表也是常见的面试算法题了。\n\n何为链表？\n\n    链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。\n\n\n## 正文\n我们先来看下题目描述：\n```\n反转一个单链表。\n\n示例:\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n```\n\n小时候都玩过玩具蛇吧，那种可以一节一节拼接的。\n\n我们可以想象下现在面前就有这么一条“蛇”，我们试着把它重新组装一遍，我们简单地 **边拆边装**。\n\n先把它尾巴拆了放一边，再接着拆它的倒数第二块同时把它安装到拆下来的尾巴那，以此下去……\n\n到最后把“蛇头”也给装好，就完事了。\n\n这道题的解题思路也就是这样，**边拆边装**。\n\n`你可以迭代或递归地反转链表。你能否用两种方法解决这道题？`\n\n贴出两种解决方案代码：\n```\npublic class ReverseLinkedList {\n\n    public class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n        }\n    }\n\n    /**\n     * 递归\n     * \n     * @param head\n     * @return\n     */\n    public ListNode reverseList(ListNode head) {\n        ListNode reverseList = null;\n        return helper(head, reverseList);\n    }\n\n    private ListNode helper(ListNode head, ListNode reverseList) {\n        if (head == null) // 反转结束\n            return reverseList;\n        // 节点指针变换\n        ListNode tempNode = head.next;\n        head.next = reverseList;\n        return helper(tempNode, head);\n    }\n\n    /**\n     * 迭代\n     * \n     * @param head\n     * @return\n     */\n    public ListNode reverseList1(ListNode head) {\n\n        ListNode newHead = null;\n        while (head != null) { // 遍历\n            ListNode next = head.next;\n            head.next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n}\n```\n两者都是先用一个空链表然后再进行一步步得组装。\n\n就是指针指来指去，有点绕，借助实物理解起来会容易很多。\n\n还有一个进阶版本的`反转链表 II`，看题：\n```\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n\n说明:\n1 ≤ m ≤ n ≤ 链表长度。\n\n示例:\n\n输入: 1->2->3->4->5->NULL, m = 2, n = 4\n输出: 1->4->3->2->5->NULL\n```\n区别就是这里不是反转所有的结点了，只需要反转指定位置之间的结点了，重点就是确认反转的指针位置。然后反转的操作还是与上面一样。\n\n代码如下：\n```\npublic class ReverseLinkedListII {\n\n    public class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n        }\n    }\n\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        if (head == null)\n            return null;\n        // 新建一个节点并指向 head\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        // pre 为需要反转的前节点\n        for (int i = 0; i < m - 1; i++)\n            pre = pre.next;\n\n        // 需要反转的节点 双指针\n        ListNode start = pre.next;\n        ListNode then = start.next;\n\n        // 反转节点\n        for (int i = 0; i < n - m; i++) {\n            start.next = then.next;\n            then.next = pre.next;\n            pre.next = then;\n            then = start.next;\n        }\n        return dummy.next;\n    }\n}\n```\n注释齐全，一目了然。","source":"_posts/leetcode-reverse-linkedlist.md","raw":"---\ntitle: LeetCode 之反转链表（Reverse Linked List）\ndate: 2019-2-19 10:22:56\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n## 前言\n反转链表也是常见的面试算法题了。\n\n何为链表？\n\n    链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。\n\n\n## 正文\n我们先来看下题目描述：\n```\n反转一个单链表。\n\n示例:\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n```\n\n小时候都玩过玩具蛇吧，那种可以一节一节拼接的。\n\n我们可以想象下现在面前就有这么一条“蛇”，我们试着把它重新组装一遍，我们简单地 **边拆边装**。\n\n先把它尾巴拆了放一边，再接着拆它的倒数第二块同时把它安装到拆下来的尾巴那，以此下去……\n\n到最后把“蛇头”也给装好，就完事了。\n\n这道题的解题思路也就是这样，**边拆边装**。\n\n`你可以迭代或递归地反转链表。你能否用两种方法解决这道题？`\n\n贴出两种解决方案代码：\n```\npublic class ReverseLinkedList {\n\n    public class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n        }\n    }\n\n    /**\n     * 递归\n     * \n     * @param head\n     * @return\n     */\n    public ListNode reverseList(ListNode head) {\n        ListNode reverseList = null;\n        return helper(head, reverseList);\n    }\n\n    private ListNode helper(ListNode head, ListNode reverseList) {\n        if (head == null) // 反转结束\n            return reverseList;\n        // 节点指针变换\n        ListNode tempNode = head.next;\n        head.next = reverseList;\n        return helper(tempNode, head);\n    }\n\n    /**\n     * 迭代\n     * \n     * @param head\n     * @return\n     */\n    public ListNode reverseList1(ListNode head) {\n\n        ListNode newHead = null;\n        while (head != null) { // 遍历\n            ListNode next = head.next;\n            head.next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n}\n```\n两者都是先用一个空链表然后再进行一步步得组装。\n\n就是指针指来指去，有点绕，借助实物理解起来会容易很多。\n\n还有一个进阶版本的`反转链表 II`，看题：\n```\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n\n说明:\n1 ≤ m ≤ n ≤ 链表长度。\n\n示例:\n\n输入: 1->2->3->4->5->NULL, m = 2, n = 4\n输出: 1->4->3->2->5->NULL\n```\n区别就是这里不是反转所有的结点了，只需要反转指定位置之间的结点了，重点就是确认反转的指针位置。然后反转的操作还是与上面一样。\n\n代码如下：\n```\npublic class ReverseLinkedListII {\n\n    public class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n        }\n    }\n\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        if (head == null)\n            return null;\n        // 新建一个节点并指向 head\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n        // pre 为需要反转的前节点\n        for (int i = 0; i < m - 1; i++)\n            pre = pre.next;\n\n        // 需要反转的节点 双指针\n        ListNode start = pre.next;\n        ListNode then = start.next;\n\n        // 反转节点\n        for (int i = 0; i < n - m; i++) {\n            start.next = then.next;\n            then.next = pre.next;\n            pre.next = then;\n            then = start.next;\n        }\n        return dummy.next;\n    }\n}\n```\n注释齐全，一目了然。","slug":"leetcode-reverse-linkedlist","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhj007ck9i139wa8p18","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>反转链表也是常见的面试算法题了。</p>\n<p>何为链表？</p>\n<pre><code>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。\n</code></pre>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>我们先来看下题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反转一个单链表。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class=\"line\">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class=\"line\"></span><br><span class=\"line\">进阶:</span><br><span class=\"line\">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br></pre></td></tr></table></figure>\n\n<p>小时候都玩过玩具蛇吧，那种可以一节一节拼接的。</p>\n<p>我们可以想象下现在面前就有这么一条“蛇”，我们试着把它重新组装一遍，我们简单地 <strong>边拆边装</strong>。</p>\n<p>先把它尾巴拆了放一边，再接着拆它的倒数第二块同时把它安装到拆下来的尾巴那，以此下去……</p>\n<p>到最后把“蛇头”也给装好，就完事了。</p>\n<p>这道题的解题思路也就是这样，<strong>边拆边装</strong>。</p>\n<p><code>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></p>\n<p>贴出两种解决方案代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReverseLinkedList &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ListNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 递归</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param head</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ListNode reverseList(ListNode head) &#123;</span><br><span class=\"line\">        ListNode reverseList = null;</span><br><span class=\"line\">        return helper(head, reverseList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ListNode helper(ListNode head, ListNode reverseList) &#123;</span><br><span class=\"line\">        if (head == null) // 反转结束</span><br><span class=\"line\">            return reverseList;</span><br><span class=\"line\">        // 节点指针变换</span><br><span class=\"line\">        ListNode tempNode = head.next;</span><br><span class=\"line\">        head.next = reverseList;</span><br><span class=\"line\">        return helper(tempNode, head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 迭代</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param head</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ListNode reverseList1(ListNode head) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode newHead = null;</span><br><span class=\"line\">        while (head != null) &#123; // 遍历</span><br><span class=\"line\">            ListNode next = head.next;</span><br><span class=\"line\">            head.next = newHead;</span><br><span class=\"line\">            newHead = head;</span><br><span class=\"line\">            head = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两者都是先用一个空链表然后再进行一步步得组装。</p>\n<p>就是指针指来指去，有点绕，借助实物理解起来会容易很多。</p>\n<p>还有一个进阶版本的<code>反转链表 II</code>，看题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</span><br><span class=\"line\"></span><br><span class=\"line\">说明:</span><br><span class=\"line\">1 ≤ m ≤ n ≤ 链表长度。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class=\"line\">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>\n<p>区别就是这里不是反转所有的结点了，只需要反转指定位置之间的结点了，重点就是确认反转的指针位置。然后反转的操作还是与上面一样。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReverseLinkedListII &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ListNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class=\"line\">        if (head == null)</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        // 新建一个节点并指向 head</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode pre = dummy;</span><br><span class=\"line\">        // pre 为需要反转的前节点</span><br><span class=\"line\">        for (int i = 0; i &lt; m - 1; i++)</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 需要反转的节点 双指针</span><br><span class=\"line\">        ListNode start = pre.next;</span><br><span class=\"line\">        ListNode then = start.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 反转节点</span><br><span class=\"line\">        for (int i = 0; i &lt; n - m; i++) &#123;</span><br><span class=\"line\">            start.next = then.next;</span><br><span class=\"line\">            then.next = pre.next;</span><br><span class=\"line\">            pre.next = then;</span><br><span class=\"line\">            then = start.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注释齐全，一目了然。</p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>反转链表也是常见的面试算法题了。</p>\n<p>何为链表？</p>\n<pre><code>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。\n</code></pre>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>我们先来看下题目描述：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反转一个单链表。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class=\"line\">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class=\"line\"></span><br><span class=\"line\">进阶:</span><br><span class=\"line\">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br></pre></td></tr></table></figure>\n\n<p>小时候都玩过玩具蛇吧，那种可以一节一节拼接的。</p>\n<p>我们可以想象下现在面前就有这么一条“蛇”，我们试着把它重新组装一遍，我们简单地 <strong>边拆边装</strong>。</p>\n<p>先把它尾巴拆了放一边，再接着拆它的倒数第二块同时把它安装到拆下来的尾巴那，以此下去……</p>\n<p>到最后把“蛇头”也给装好，就完事了。</p>\n<p>这道题的解题思路也就是这样，<strong>边拆边装</strong>。</p>\n<p><code>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></p>\n<p>贴出两种解决方案代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReverseLinkedList &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ListNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 递归</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param head</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ListNode reverseList(ListNode head) &#123;</span><br><span class=\"line\">        ListNode reverseList = null;</span><br><span class=\"line\">        return helper(head, reverseList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private ListNode helper(ListNode head, ListNode reverseList) &#123;</span><br><span class=\"line\">        if (head == null) // 反转结束</span><br><span class=\"line\">            return reverseList;</span><br><span class=\"line\">        // 节点指针变换</span><br><span class=\"line\">        ListNode tempNode = head.next;</span><br><span class=\"line\">        head.next = reverseList;</span><br><span class=\"line\">        return helper(tempNode, head);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 迭代</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param head</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public ListNode reverseList1(ListNode head) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode newHead = null;</span><br><span class=\"line\">        while (head != null) &#123; // 遍历</span><br><span class=\"line\">            ListNode next = head.next;</span><br><span class=\"line\">            head.next = newHead;</span><br><span class=\"line\">            newHead = head;</span><br><span class=\"line\">            head = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return newHead;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两者都是先用一个空链表然后再进行一步步得组装。</p>\n<p>就是指针指来指去，有点绕，借助实物理解起来会容易很多。</p>\n<p>还有一个进阶版本的<code>反转链表 II</code>，看题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</span><br><span class=\"line\"></span><br><span class=\"line\">说明:</span><br><span class=\"line\">1 ≤ m ≤ n ≤ 链表长度。</span><br><span class=\"line\"></span><br><span class=\"line\">示例:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class=\"line\">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>\n<p>区别就是这里不是反转所有的结点了，只需要反转指定位置之间的结点了，重点就是确认反转的指针位置。然后反转的操作还是与上面一样。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ReverseLinkedListII &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public class ListNode &#123;</span><br><span class=\"line\">        int val;</span><br><span class=\"line\">        ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode(int x) &#123;</span><br><span class=\"line\">            val = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ListNode reverseBetween(ListNode head, int m, int n) &#123;</span><br><span class=\"line\">        if (head == null)</span><br><span class=\"line\">            return null;</span><br><span class=\"line\">        // 新建一个节点并指向 head</span><br><span class=\"line\">        ListNode dummy = new ListNode(0);</span><br><span class=\"line\">        dummy.next = head;</span><br><span class=\"line\">        ListNode pre = dummy;</span><br><span class=\"line\">        // pre 为需要反转的前节点</span><br><span class=\"line\">        for (int i = 0; i &lt; m - 1; i++)</span><br><span class=\"line\">            pre = pre.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 需要反转的节点 双指针</span><br><span class=\"line\">        ListNode start = pre.next;</span><br><span class=\"line\">        ListNode then = start.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 反转节点</span><br><span class=\"line\">        for (int i = 0; i &lt; n - m; i++) &#123;</span><br><span class=\"line\">            start.next = then.next;</span><br><span class=\"line\">            then.next = pre.next;</span><br><span class=\"line\">            pre.next = then;</span><br><span class=\"line\">            then = start.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注释齐全，一目了然。</p>\n"},{"title":"LeetCode 之三角形最小路径和（Triangle）","date":"2018-12-03T08:54:48.000Z","_content":"\n看标题不知是否让您想起了有向图中的最短路径，是有些许类似，不过该题比其更简单更加清晰、直观、好理解。相信您看完这个之后，脑回路肯定更加的明亮！\n\n题目描述如下：\n```\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n说明：\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n```\n\n初看题目，上下有关联，有结束点，是个适合用递归的题目。以三角形的“行数”作为递归的结束判断，行数加上下标作为参数来回穿插。可行，可行！\n\n于是大笔一挥：\n```\n    int size = 0;\n    TreeSet<Integer> ts = new TreeSet<>();\n    List<List<Integer>> list;\n\n    /**\n     * 超时\n     * \n     * @param triangle\n     * @return\n     */\n    public int minimumTotal(List<List<Integer>> triangle) {\n        list = triangle;\n        size = triangle.size();\n        if (size == 0)\n            return 0;\n\n        helper(0, 0, 0);\n        return ts.first();\n    }\n\n    /**\n     * \n     * @param row\n     *            行数\n     * @param index\n     *            在该行中下标\n     * @param sum_length\n     *            路径之和\n     */\n    private void helper(int row, int index, int sum_length) {\n        if (row >= size) {\n            ts.add(sum_length);\n            return;\n        }\n        sum_length += list.get(row).get(index);\n        helper(row + 1, index, sum_length);\n        helper(row + 1, index + 1, sum_length);\n    }\n```\n\n是的，代码没有问题，可是拿去跑的时候，数据较大的测试用例却给了一个大红色的 `超出时间限制`。这里将 `TreeSet` 换成一个 MIN_LENGTH 整型变量每次进行比较取较小值，结果一样，都是超时。\n\n本来是满怀欣喜，豪气撸码，结果给撞了个豆腐墙。\n\n墙不硬，问题不大。我们换个思路，再摸摸青青草地。\n\n以往出现这种求最小值、最大值啊，需要数据之间相关联相加减乘除的啊，用的都是 **DP** 居多啊！\n\n脑浆乍现，回路高速擦亮，越擦越亮，越擦越闪，终于“吡”得一身，为数不多的小草又飘下几根，成了！\n\n**我也不用额外的空间了，就在你身上肆虐！**\n\n再回头看下那个“三角形”：\n```\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\n既然是要一个最小值，那我就逐步缩减法，自下而上攻之。\n\n根据题目要求我们知道如果上一行的元素下标为 i，那它只能跟它下一行的下标为 i 和 i+1 两元素相加。当然，我们只需要这两者的较小值。\n\n即：\n```\n [6,5,7]   // i 行\n[4,1,8,3]  // j 行\n\n以这两行为例 （条件：j = i + 1）\n\ni 行中的 6 可以跟 j 行中的 4 或者 1 相加，由于我们结果取的是最小值，所以我们只留较小值\n6 + 4 = 10, 6 + 1 = 7\n因为 10 > 7，所以 i 行中的 6 我们就随之替换为 7\n\n剩余元素同理，i 行最终便成了：\n[7,6,10]\n\n再由此，层层攻上。随着数量越来越少，最终顶上的那位佼佼者便是我们要取的首级！\n```\n\n武器献之：\n```\n    /**\n     * DP\n     * \n     * @param triangle\n     * @return\n     */\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        // 从倒数第二行开始往上走\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            // 从每行的起始下标开始直到 i\n            for (int j = 0; j <= i; j++) {\n                // i 行 j 下标的值\n                int self = triangle.get(i).get(j);\n                // 将 i 行 j 下标的值赋为 ： i 行 j 下标的值 与 i+1 行 j 下标和 j+1 下标值之和的较小值\n                triangle.get(i).set(j,\n                        Math.min(triangle.get(i + 1).get(j) + self, triangle.get(i + 1).get(j + 1) + self));\n            }\n        }\n        // 层层往上 顶层值便是路径最小值\n        return triangle.get(0).get(0);\n    }\n```\n\n这道题容易理解，对 DP（动态规划） 会有一个较为清晰的认知，我认为还是很不错的，故特意整理之。\n\n---\n文笔不好，望见谅！ End.","source":"_posts/leetcode-triangle.md","raw":"---\ntitle: LeetCode 之三角形最小路径和（Triangle）\ndate: 2018-12-3 16:54:48\ncategories: [开发,算法]\ntags: [Java,算法,LeetCode]\n---\n\n看标题不知是否让您想起了有向图中的最短路径，是有些许类似，不过该题比其更简单更加清晰、直观、好理解。相信您看完这个之后，脑回路肯定更加的明亮！\n\n题目描述如下：\n```\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n说明：\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n```\n\n初看题目，上下有关联，有结束点，是个适合用递归的题目。以三角形的“行数”作为递归的结束判断，行数加上下标作为参数来回穿插。可行，可行！\n\n于是大笔一挥：\n```\n    int size = 0;\n    TreeSet<Integer> ts = new TreeSet<>();\n    List<List<Integer>> list;\n\n    /**\n     * 超时\n     * \n     * @param triangle\n     * @return\n     */\n    public int minimumTotal(List<List<Integer>> triangle) {\n        list = triangle;\n        size = triangle.size();\n        if (size == 0)\n            return 0;\n\n        helper(0, 0, 0);\n        return ts.first();\n    }\n\n    /**\n     * \n     * @param row\n     *            行数\n     * @param index\n     *            在该行中下标\n     * @param sum_length\n     *            路径之和\n     */\n    private void helper(int row, int index, int sum_length) {\n        if (row >= size) {\n            ts.add(sum_length);\n            return;\n        }\n        sum_length += list.get(row).get(index);\n        helper(row + 1, index, sum_length);\n        helper(row + 1, index + 1, sum_length);\n    }\n```\n\n是的，代码没有问题，可是拿去跑的时候，数据较大的测试用例却给了一个大红色的 `超出时间限制`。这里将 `TreeSet` 换成一个 MIN_LENGTH 整型变量每次进行比较取较小值，结果一样，都是超时。\n\n本来是满怀欣喜，豪气撸码，结果给撞了个豆腐墙。\n\n墙不硬，问题不大。我们换个思路，再摸摸青青草地。\n\n以往出现这种求最小值、最大值啊，需要数据之间相关联相加减乘除的啊，用的都是 **DP** 居多啊！\n\n脑浆乍现，回路高速擦亮，越擦越亮，越擦越闪，终于“吡”得一身，为数不多的小草又飘下几根，成了！\n\n**我也不用额外的空间了，就在你身上肆虐！**\n\n再回头看下那个“三角形”：\n```\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n```\n\n既然是要一个最小值，那我就逐步缩减法，自下而上攻之。\n\n根据题目要求我们知道如果上一行的元素下标为 i，那它只能跟它下一行的下标为 i 和 i+1 两元素相加。当然，我们只需要这两者的较小值。\n\n即：\n```\n [6,5,7]   // i 行\n[4,1,8,3]  // j 行\n\n以这两行为例 （条件：j = i + 1）\n\ni 行中的 6 可以跟 j 行中的 4 或者 1 相加，由于我们结果取的是最小值，所以我们只留较小值\n6 + 4 = 10, 6 + 1 = 7\n因为 10 > 7，所以 i 行中的 6 我们就随之替换为 7\n\n剩余元素同理，i 行最终便成了：\n[7,6,10]\n\n再由此，层层攻上。随着数量越来越少，最终顶上的那位佼佼者便是我们要取的首级！\n```\n\n武器献之：\n```\n    /**\n     * DP\n     * \n     * @param triangle\n     * @return\n     */\n    public int minimumTotal(List<List<Integer>> triangle) {\n\n        // 从倒数第二行开始往上走\n        for (int i = triangle.size() - 2; i >= 0; i--) {\n            // 从每行的起始下标开始直到 i\n            for (int j = 0; j <= i; j++) {\n                // i 行 j 下标的值\n                int self = triangle.get(i).get(j);\n                // 将 i 行 j 下标的值赋为 ： i 行 j 下标的值 与 i+1 行 j 下标和 j+1 下标值之和的较小值\n                triangle.get(i).set(j,\n                        Math.min(triangle.get(i + 1).get(j) + self, triangle.get(i + 1).get(j + 1) + self));\n            }\n        }\n        // 层层往上 顶层值便是路径最小值\n        return triangle.get(0).get(0);\n    }\n```\n\n这道题容易理解，对 DP（动态规划） 会有一个较为清晰的认知，我认为还是很不错的，故特意整理之。\n\n---\n文笔不好，望见谅！ End.","slug":"leetcode-triangle","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhj007fk9i19namamyg","content":"<p>看标题不知是否让您想起了有向图中的最短路径，是有些许类似，不过该题比其更简单更加清晰、直观、好理解。相信您看完这个之后，脑回路肯定更加的明亮！</p>\n<p>题目描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，给定三角形：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br><span class=\"line\">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</span><br></pre></td></tr></table></figure>\n\n<p>初看题目，上下有关联，有结束点，是个适合用递归的题目。以三角形的“行数”作为递归的结束判断，行数加上下标作为参数来回穿插。可行，可行！</p>\n<p>于是大笔一挥：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int size = 0;</span><br><span class=\"line\">TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();</span><br><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 超时</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param triangle</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class=\"line\">    list = triangle;</span><br><span class=\"line\">    size = triangle.size();</span><br><span class=\"line\">    if (size == 0)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    helper(0, 0, 0);</span><br><span class=\"line\">    return ts.first();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param row</span><br><span class=\"line\"> *            行数</span><br><span class=\"line\"> * @param index</span><br><span class=\"line\"> *            在该行中下标</span><br><span class=\"line\"> * @param sum_length</span><br><span class=\"line\"> *            路径之和</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void helper(int row, int index, int sum_length) &#123;</span><br><span class=\"line\">    if (row &gt;= size) &#123;</span><br><span class=\"line\">        ts.add(sum_length);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum_length += list.get(row).get(index);</span><br><span class=\"line\">    helper(row + 1, index, sum_length);</span><br><span class=\"line\">    helper(row + 1, index + 1, sum_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，代码没有问题，可是拿去跑的时候，数据较大的测试用例却给了一个大红色的 <code>超出时间限制</code>。这里将 <code>TreeSet</code> 换成一个 MIN_LENGTH 整型变量每次进行比较取较小值，结果一样，都是超时。</p>\n<p>本来是满怀欣喜，豪气撸码，结果给撞了个豆腐墙。</p>\n<p>墙不硬，问题不大。我们换个思路，再摸摸青青草地。</p>\n<p>以往出现这种求最小值、最大值啊，需要数据之间相关联相加减乘除的啊，用的都是 <strong>DP</strong> 居多啊！</p>\n<p>脑浆乍现，回路高速擦亮，越擦越亮，越擦越闪，终于“吡”得一身，为数不多的小草又飘下几根，成了！</p>\n<p><strong>我也不用额外的空间了，就在你身上肆虐！</strong></p>\n<p>再回头看下那个“三角形”：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>既然是要一个最小值，那我就逐步缩减法，自下而上攻之。</p>\n<p>根据题目要求我们知道如果上一行的元素下标为 i，那它只能跟它下一行的下标为 i 和 i+1 两元素相加。当然，我们只需要这两者的较小值。</p>\n<p>即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [6,5,7]   // i 行</span><br><span class=\"line\">[4,1,8,3]  // j 行</span><br><span class=\"line\"></span><br><span class=\"line\">以这两行为例 （条件：j = i + 1）</span><br><span class=\"line\"></span><br><span class=\"line\">i 行中的 6 可以跟 j 行中的 4 或者 1 相加，由于我们结果取的是最小值，所以我们只留较小值</span><br><span class=\"line\">6 + 4 = 10, 6 + 1 = 7</span><br><span class=\"line\">因为 10 &gt; 7，所以 i 行中的 6 我们就随之替换为 7</span><br><span class=\"line\"></span><br><span class=\"line\">剩余元素同理，i 行最终便成了：</span><br><span class=\"line\">[7,6,10]</span><br><span class=\"line\"></span><br><span class=\"line\">再由此，层层攻上。随着数量越来越少，最终顶上的那位佼佼者便是我们要取的首级！</span><br></pre></td></tr></table></figure>\n\n<p>武器献之：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * DP</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param triangle</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从倒数第二行开始往上走</span><br><span class=\"line\">    for (int i = triangle.size() - 2; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">        // 从每行的起始下标开始直到 i</span><br><span class=\"line\">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class=\"line\">            // i 行 j 下标的值</span><br><span class=\"line\">            int self = triangle.get(i).get(j);</span><br><span class=\"line\">            // 将 i 行 j 下标的值赋为 ： i 行 j 下标的值 与 i+1 行 j 下标和 j+1 下标值之和的较小值</span><br><span class=\"line\">            triangle.get(i).set(j,</span><br><span class=\"line\">                    Math.min(triangle.get(i + 1).get(j) + self, triangle.get(i + 1).get(j + 1) + self));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 层层往上 顶层值便是路径最小值</span><br><span class=\"line\">    return triangle.get(0).get(0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这道题容易理解，对 DP（动态规划） 会有一个较为清晰的认知，我认为还是很不错的，故特意整理之。</p>\n<hr>\n<p>文笔不好，望见谅！ End.</p>\n","excerpt":"","more":"<p>看标题不知是否让您想起了有向图中的最短路径，是有些许类似，不过该题比其更简单更加清晰、直观、好理解。相信您看完这个之后，脑回路肯定更加的明亮！</p>\n<p>题目描述如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，给定三角形：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br><span class=\"line\">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br><span class=\"line\"></span><br><span class=\"line\">说明：</span><br><span class=\"line\"></span><br><span class=\"line\">如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</span><br></pre></td></tr></table></figure>\n\n<p>初看题目，上下有关联，有结束点，是个适合用递归的题目。以三角形的“行数”作为递归的结束判断，行数加上下标作为参数来回穿插。可行，可行！</p>\n<p>于是大笔一挥：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int size = 0;</span><br><span class=\"line\">TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();</span><br><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 超时</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param triangle</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class=\"line\">    list = triangle;</span><br><span class=\"line\">    size = triangle.size();</span><br><span class=\"line\">    if (size == 0)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    helper(0, 0, 0);</span><br><span class=\"line\">    return ts.first();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param row</span><br><span class=\"line\"> *            行数</span><br><span class=\"line\"> * @param index</span><br><span class=\"line\"> *            在该行中下标</span><br><span class=\"line\"> * @param sum_length</span><br><span class=\"line\"> *            路径之和</span><br><span class=\"line\"> */</span><br><span class=\"line\">private void helper(int row, int index, int sum_length) &#123;</span><br><span class=\"line\">    if (row &gt;= size) &#123;</span><br><span class=\"line\">        ts.add(sum_length);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum_length += list.get(row).get(index);</span><br><span class=\"line\">    helper(row + 1, index, sum_length);</span><br><span class=\"line\">    helper(row + 1, index + 1, sum_length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是的，代码没有问题，可是拿去跑的时候，数据较大的测试用例却给了一个大红色的 <code>超出时间限制</code>。这里将 <code>TreeSet</code> 换成一个 MIN_LENGTH 整型变量每次进行比较取较小值，结果一样，都是超时。</p>\n<p>本来是满怀欣喜，豪气撸码，结果给撞了个豆腐墙。</p>\n<p>墙不硬，问题不大。我们换个思路，再摸摸青青草地。</p>\n<p>以往出现这种求最小值、最大值啊，需要数据之间相关联相加减乘除的啊，用的都是 <strong>DP</strong> 居多啊！</p>\n<p>脑浆乍现，回路高速擦亮，越擦越亮，越擦越闪，终于“吡”得一身，为数不多的小草又飘下几根，成了！</p>\n<p><strong>我也不用额外的空间了，就在你身上肆虐！</strong></p>\n<p>再回头看下那个“三角形”：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">     [2],</span><br><span class=\"line\">    [3,4],</span><br><span class=\"line\">   [6,5,7],</span><br><span class=\"line\">  [4,1,8,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>既然是要一个最小值，那我就逐步缩减法，自下而上攻之。</p>\n<p>根据题目要求我们知道如果上一行的元素下标为 i，那它只能跟它下一行的下标为 i 和 i+1 两元素相加。当然，我们只需要这两者的较小值。</p>\n<p>即：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [6,5,7]   // i 行</span><br><span class=\"line\">[4,1,8,3]  // j 行</span><br><span class=\"line\"></span><br><span class=\"line\">以这两行为例 （条件：j = i + 1）</span><br><span class=\"line\"></span><br><span class=\"line\">i 行中的 6 可以跟 j 行中的 4 或者 1 相加，由于我们结果取的是最小值，所以我们只留较小值</span><br><span class=\"line\">6 + 4 = 10, 6 + 1 = 7</span><br><span class=\"line\">因为 10 &gt; 7，所以 i 行中的 6 我们就随之替换为 7</span><br><span class=\"line\"></span><br><span class=\"line\">剩余元素同理，i 行最终便成了：</span><br><span class=\"line\">[7,6,10]</span><br><span class=\"line\"></span><br><span class=\"line\">再由此，层层攻上。随着数量越来越少，最终顶上的那位佼佼者便是我们要取的首级！</span><br></pre></td></tr></table></figure>\n\n<p>武器献之：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * DP</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param triangle</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从倒数第二行开始往上走</span><br><span class=\"line\">    for (int i = triangle.size() - 2; i &gt;= 0; i--) &#123;</span><br><span class=\"line\">        // 从每行的起始下标开始直到 i</span><br><span class=\"line\">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class=\"line\">            // i 行 j 下标的值</span><br><span class=\"line\">            int self = triangle.get(i).get(j);</span><br><span class=\"line\">            // 将 i 行 j 下标的值赋为 ： i 行 j 下标的值 与 i+1 行 j 下标和 j+1 下标值之和的较小值</span><br><span class=\"line\">            triangle.get(i).set(j,</span><br><span class=\"line\">                    Math.min(triangle.get(i + 1).get(j) + self, triangle.get(i + 1).get(j + 1) + self));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 层层往上 顶层值便是路径最小值</span><br><span class=\"line\">    return triangle.get(0).get(0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这道题容易理解，对 DP（动态规划） 会有一个较为清晰的认知，我认为还是很不错的，故特意整理之。</p>\n<hr>\n<p>文笔不好，望见谅！ End.</p>\n"},{"title":"生活六月（2021）","date":"2021-07-01T12:10:55.000Z","_content":"\n> 六月开始了新的生活环境和节奏\n\n六月的天气还没有那么燥热，虽然梅雨天来了但大多时候还不是闷热，可能也与我们长时间在室内呆着有关系吧。\n\n这月去了南通通州，江苏城市发展还是很不错的尤其是苏南。小河道多，虽周边不像浙江一样都是山但绿化面积也是挺大的。\n\n回了一趟家，家里的葡萄还没有成熟，还只是一串串青颗粒挂在枝头，今年又多了几亩葡萄，老爸老妈在这个繁忙的季节感觉还是有点忙不过来。今年温度都还不怎么高，光照也不多，不知道葡萄会怎么样。不过好在每年都有人上门收购，好有好的价格，不好也有不好的价格，省点心省点力，多赚点少赚点，省点事，人不要搞得那么累，身体最重要。\n\n这月底组内的小韩同志也离职了，破公司留不住人。\n\n细雨绵绵，滋润大地。","source":"_posts/life-june.md","raw":"---\ntitle: 生活六月（2021）\ndate: 2021-06-31 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 六月开始了新的生活环境和节奏\n\n六月的天气还没有那么燥热，虽然梅雨天来了但大多时候还不是闷热，可能也与我们长时间在室内呆着有关系吧。\n\n这月去了南通通州，江苏城市发展还是很不错的尤其是苏南。小河道多，虽周边不像浙江一样都是山但绿化面积也是挺大的。\n\n回了一趟家，家里的葡萄还没有成熟，还只是一串串青颗粒挂在枝头，今年又多了几亩葡萄，老爸老妈在这个繁忙的季节感觉还是有点忙不过来。今年温度都还不怎么高，光照也不多，不知道葡萄会怎么样。不过好在每年都有人上门收购，好有好的价格，不好也有不好的价格，省点心省点力，多赚点少赚点，省点事，人不要搞得那么累，身体最重要。\n\n这月底组内的小韩同志也离职了，破公司留不住人。\n\n细雨绵绵，滋润大地。","slug":"life-june","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhj007jk9i1cz4q2xkp","content":"<blockquote>\n<p>六月开始了新的生活环境和节奏</p>\n</blockquote>\n<p>六月的天气还没有那么燥热，虽然梅雨天来了但大多时候还不是闷热，可能也与我们长时间在室内呆着有关系吧。</p>\n<p>这月去了南通通州，江苏城市发展还是很不错的尤其是苏南。小河道多，虽周边不像浙江一样都是山但绿化面积也是挺大的。</p>\n<p>回了一趟家，家里的葡萄还没有成熟，还只是一串串青颗粒挂在枝头，今年又多了几亩葡萄，老爸老妈在这个繁忙的季节感觉还是有点忙不过来。今年温度都还不怎么高，光照也不多，不知道葡萄会怎么样。不过好在每年都有人上门收购，好有好的价格，不好也有不好的价格，省点心省点力，多赚点少赚点，省点事，人不要搞得那么累，身体最重要。</p>\n<p>这月底组内的小韩同志也离职了，破公司留不住人。</p>\n<p>细雨绵绵，滋润大地。</p>\n","excerpt":"","more":"<blockquote>\n<p>六月开始了新的生活环境和节奏</p>\n</blockquote>\n<p>六月的天气还没有那么燥热，虽然梅雨天来了但大多时候还不是闷热，可能也与我们长时间在室内呆着有关系吧。</p>\n<p>这月去了南通通州，江苏城市发展还是很不错的尤其是苏南。小河道多，虽周边不像浙江一样都是山但绿化面积也是挺大的。</p>\n<p>回了一趟家，家里的葡萄还没有成熟，还只是一串串青颗粒挂在枝头，今年又多了几亩葡萄，老爸老妈在这个繁忙的季节感觉还是有点忙不过来。今年温度都还不怎么高，光照也不多，不知道葡萄会怎么样。不过好在每年都有人上门收购，好有好的价格，不好也有不好的价格，省点心省点力，多赚点少赚点，省点事，人不要搞得那么累，身体最重要。</p>\n<p>这月底组内的小韩同志也离职了，破公司留不住人。</p>\n<p>细雨绵绵，滋润大地。</p>\n"},{"title":"个人博客今日开启","date":"2018-05-22T07:52:34.000Z","_content":"\n> 说说为什么弄了这个博客呢\n\n- 首先最近比较闲 - - 不太忙应该这么说\n- 其次呢前几天终于下狠心买了个一年的云服务器(超低配，搞活动..)，心想，我这资源不能浪费啊，怎么说也是好几张老毛啊\n\n然后决定开搞那就搞，上网开始搜一些博客模板，之前了解过WordPress/Hexo,后来还是决定就Hexo了还能托管在GitHub上也方便。\n<br>\n于是乎就去找适合自己的主题了呗，一个猛子扎下去，我的乖宝贝，这些五花八门的主题还真是炫酷炸宇宙啊。可是，我喜欢简约的。\n<br>\n就在这时，[melody](https://github.com/Molunerfinn/hexo-theme-melody \"melody\")出现在我眼前。还真是确认过眼神，你就是我想要的简约啊...\nso,选定离手，开始操刀了。\n<br>\n前前后后也是弄了一天时间吧，因为之前没有弄过这些类似的静态博客还是一步步看其他兄弟的详细步骤操刀下来的。一路走下来，看自己的博客逐步搭好也是莫名舒坦。\n<br>\n部署到GitHub上/部署到云服务器上\n<br>\n博客搭是搭好了，可惜没有干货啊..( ▼-▼ )","source":"_posts/my-blog-ok.md","raw":"---\ntitle: 个人博客今日开启\ndate: 2018-05-22 15:52:34\ncategories: [生活,杂侃]\ntags: [Hexo,melody,blog]\n---\n\n> 说说为什么弄了这个博客呢\n\n- 首先最近比较闲 - - 不太忙应该这么说\n- 其次呢前几天终于下狠心买了个一年的云服务器(超低配，搞活动..)，心想，我这资源不能浪费啊，怎么说也是好几张老毛啊\n\n然后决定开搞那就搞，上网开始搜一些博客模板，之前了解过WordPress/Hexo,后来还是决定就Hexo了还能托管在GitHub上也方便。\n<br>\n于是乎就去找适合自己的主题了呗，一个猛子扎下去，我的乖宝贝，这些五花八门的主题还真是炫酷炸宇宙啊。可是，我喜欢简约的。\n<br>\n就在这时，[melody](https://github.com/Molunerfinn/hexo-theme-melody \"melody\")出现在我眼前。还真是确认过眼神，你就是我想要的简约啊...\nso,选定离手，开始操刀了。\n<br>\n前前后后也是弄了一天时间吧，因为之前没有弄过这些类似的静态博客还是一步步看其他兄弟的详细步骤操刀下来的。一路走下来，看自己的博客逐步搭好也是莫名舒坦。\n<br>\n部署到GitHub上/部署到云服务器上\n<br>\n博客搭是搭好了，可惜没有干货啊..( ▼-▼ )","slug":"my-blog-ok","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhk007nk9i1h6y06qnf","content":"<blockquote>\n<p>说说为什么弄了这个博客呢</p>\n</blockquote>\n<ul>\n<li>首先最近比较闲 - - 不太忙应该这么说</li>\n<li>其次呢前几天终于下狠心买了个一年的云服务器(超低配，搞活动..)，心想，我这资源不能浪费啊，怎么说也是好几张老毛啊</li>\n</ul>\n<p>然后决定开搞那就搞，上网开始搜一些博客模板，之前了解过WordPress&#x2F;Hexo,后来还是决定就Hexo了还能托管在GitHub上也方便。<br><br><br>于是乎就去找适合自己的主题了呗，一个猛子扎下去，我的乖宝贝，这些五花八门的主题还真是炫酷炸宇宙啊。可是，我喜欢简约的。<br><br><br>就在这时，<a href=\"https://github.com/Molunerfinn/hexo-theme-melody\" title=\"melody\">melody</a>出现在我眼前。还真是确认过眼神，你就是我想要的简约啊…<br>so,选定离手，开始操刀了。<br><br><br>前前后后也是弄了一天时间吧，因为之前没有弄过这些类似的静态博客还是一步步看其他兄弟的详细步骤操刀下来的。一路走下来，看自己的博客逐步搭好也是莫名舒坦。<br><br><br>部署到GitHub上&#x2F;部署到云服务器上<br><br><br>博客搭是搭好了，可惜没有干货啊..( ▼-▼ )</p>\n","excerpt":"","more":"<blockquote>\n<p>说说为什么弄了这个博客呢</p>\n</blockquote>\n<ul>\n<li>首先最近比较闲 - - 不太忙应该这么说</li>\n<li>其次呢前几天终于下狠心买了个一年的云服务器(超低配，搞活动..)，心想，我这资源不能浪费啊，怎么说也是好几张老毛啊</li>\n</ul>\n<p>然后决定开搞那就搞，上网开始搜一些博客模板，之前了解过WordPress&#x2F;Hexo,后来还是决定就Hexo了还能托管在GitHub上也方便。<br><br><br>于是乎就去找适合自己的主题了呗，一个猛子扎下去，我的乖宝贝，这些五花八门的主题还真是炫酷炸宇宙啊。可是，我喜欢简约的。<br><br><br>就在这时，<a href=\"https://github.com/Molunerfinn/hexo-theme-melody\" title=\"melody\">melody</a>出现在我眼前。还真是确认过眼神，你就是我想要的简约啊…<br>so,选定离手，开始操刀了。<br><br><br>前前后后也是弄了一天时间吧，因为之前没有弄过这些类似的静态博客还是一步步看其他兄弟的详细步骤操刀下来的。一路走下来，看自己的博客逐步搭好也是莫名舒坦。<br><br><br>部署到GitHub上&#x2F;部署到云服务器上<br><br><br>博客搭是搭好了，可惜没有干货啊..( ▼-▼ )</p>\n"},{"title":"MySQL 数据库备份脚本","date":"2020-04-11T02:10:55.000Z","_content":"\n> 一个数据库备份小脚本，实现指定数据库数据表的定时备份\n> \n> 完整脚本在 [database-backup](https://github.com/Folgerjun/database-backup)\n\n## 前言\n当然首先是有这个需求才会去想着写这么个脚本来实现。之前使用过阿里的 [otter](https://github.com/alibaba/otter) 来做数据同步，当然软件很好用，官方教程也很详细，但是就觉得有时候条件过于“苛刻”，稍一不小心就使得同步中断。且最关键的是我们不需要数据完全每分每秒时时刻刻都要同步，也多是为了在另一个服务器上做一个备份，能看得到某一个时间段的历史数据就行，所以就想着还是怎么轻量怎么合适。综合利弊，还是写个脚本来比较方便。\n\n## 内容\n- 用 MySQL 的 `mysqldump` 指令去连接数据库，并将数据保存为 SQL 文件到本地。\n- 用 MySQL 的 `mysql` 指令去执行读取保存的 SQL 文件，将其备份还原到本地数据库。\n- 用本地压缩软件指令将本地保存的 SQL 文件进行压缩打包保存以便节省空间，同时删除原来未压缩的文件。\n- 可以保留指定日期内的压缩 SQL 文件，删除其余。\n\n大致内容就是这些，经过线上实验后可行。\n\n只有一个脚本文件，只需要本地有数据库环境，更改几个配置，双击就能跑起来了。\n\n当然，你还可以让脚本定时执行。\n\n> 此方式对数据要求不是特别高的可行，还有就是此方式将指定表中所有数据都进行备份，每次相当于覆盖之前的数据，需注意。\n\n## 运行\n![备份过程中](http://cdn.putop.top/database-backup.png)","source":"_posts/mysql-database-backup.md","raw":"---\ntitle: MySQL 数据库备份脚本\ndate: 2020-04-11 10:10:55\ncategories: [开发,数据库]\ntags: [MySQL]\n---\n\n> 一个数据库备份小脚本，实现指定数据库数据表的定时备份\n> \n> 完整脚本在 [database-backup](https://github.com/Folgerjun/database-backup)\n\n## 前言\n当然首先是有这个需求才会去想着写这么个脚本来实现。之前使用过阿里的 [otter](https://github.com/alibaba/otter) 来做数据同步，当然软件很好用，官方教程也很详细，但是就觉得有时候条件过于“苛刻”，稍一不小心就使得同步中断。且最关键的是我们不需要数据完全每分每秒时时刻刻都要同步，也多是为了在另一个服务器上做一个备份，能看得到某一个时间段的历史数据就行，所以就想着还是怎么轻量怎么合适。综合利弊，还是写个脚本来比较方便。\n\n## 内容\n- 用 MySQL 的 `mysqldump` 指令去连接数据库，并将数据保存为 SQL 文件到本地。\n- 用 MySQL 的 `mysql` 指令去执行读取保存的 SQL 文件，将其备份还原到本地数据库。\n- 用本地压缩软件指令将本地保存的 SQL 文件进行压缩打包保存以便节省空间，同时删除原来未压缩的文件。\n- 可以保留指定日期内的压缩 SQL 文件，删除其余。\n\n大致内容就是这些，经过线上实验后可行。\n\n只有一个脚本文件，只需要本地有数据库环境，更改几个配置，双击就能跑起来了。\n\n当然，你还可以让脚本定时执行。\n\n> 此方式对数据要求不是特别高的可行，还有就是此方式将指定表中所有数据都进行备份，每次相当于覆盖之前的数据，需注意。\n\n## 运行\n![备份过程中](http://cdn.putop.top/database-backup.png)","slug":"mysql-database-backup","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhk007rk9i1hr2thjso","content":"<blockquote>\n<p>一个数据库备份小脚本，实现指定数据库数据表的定时备份</p>\n<p>完整脚本在 <a href=\"https://github.com/Folgerjun/database-backup\">database-backup</a></p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当然首先是有这个需求才会去想着写这么个脚本来实现。之前使用过阿里的 <a href=\"https://github.com/alibaba/otter\">otter</a> 来做数据同步，当然软件很好用，官方教程也很详细，但是就觉得有时候条件过于“苛刻”，稍一不小心就使得同步中断。且最关键的是我们不需要数据完全每分每秒时时刻刻都要同步，也多是为了在另一个服务器上做一个备份，能看得到某一个时间段的历史数据就行，所以就想着还是怎么轻量怎么合适。综合利弊，还是写个脚本来比较方便。</p>\n<h2 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2><ul>\n<li>用 MySQL 的 <code>mysqldump</code> 指令去连接数据库，并将数据保存为 SQL 文件到本地。</li>\n<li>用 MySQL 的 <code>mysql</code> 指令去执行读取保存的 SQL 文件，将其备份还原到本地数据库。</li>\n<li>用本地压缩软件指令将本地保存的 SQL 文件进行压缩打包保存以便节省空间，同时删除原来未压缩的文件。</li>\n<li>可以保留指定日期内的压缩 SQL 文件，删除其余。</li>\n</ul>\n<p>大致内容就是这些，经过线上实验后可行。</p>\n<p>只有一个脚本文件，只需要本地有数据库环境，更改几个配置，双击就能跑起来了。</p>\n<p>当然，你还可以让脚本定时执行。</p>\n<blockquote>\n<p>此方式对数据要求不是特别高的可行，还有就是此方式将指定表中所有数据都进行备份，每次相当于覆盖之前的数据，需注意。</p>\n</blockquote>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p><img src=\"http://cdn.putop.top/database-backup.png\" alt=\"备份过程中\"></p>\n","excerpt":"","more":"<blockquote>\n<p>一个数据库备份小脚本，实现指定数据库数据表的定时备份</p>\n<p>完整脚本在 <a href=\"https://github.com/Folgerjun/database-backup\">database-backup</a></p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当然首先是有这个需求才会去想着写这么个脚本来实现。之前使用过阿里的 <a href=\"https://github.com/alibaba/otter\">otter</a> 来做数据同步，当然软件很好用，官方教程也很详细，但是就觉得有时候条件过于“苛刻”，稍一不小心就使得同步中断。且最关键的是我们不需要数据完全每分每秒时时刻刻都要同步，也多是为了在另一个服务器上做一个备份，能看得到某一个时间段的历史数据就行，所以就想着还是怎么轻量怎么合适。综合利弊，还是写个脚本来比较方便。</p>\n<h2 id=\"内容\"><a href=\"#内容\" class=\"headerlink\" title=\"内容\"></a>内容</h2><ul>\n<li>用 MySQL 的 <code>mysqldump</code> 指令去连接数据库，并将数据保存为 SQL 文件到本地。</li>\n<li>用 MySQL 的 <code>mysql</code> 指令去执行读取保存的 SQL 文件，将其备份还原到本地数据库。</li>\n<li>用本地压缩软件指令将本地保存的 SQL 文件进行压缩打包保存以便节省空间，同时删除原来未压缩的文件。</li>\n<li>可以保留指定日期内的压缩 SQL 文件，删除其余。</li>\n</ul>\n<p>大致内容就是这些，经过线上实验后可行。</p>\n<p>只有一个脚本文件，只需要本地有数据库环境，更改几个配置，双击就能跑起来了。</p>\n<p>当然，你还可以让脚本定时执行。</p>\n<blockquote>\n<p>此方式对数据要求不是特别高的可行，还有就是此方式将指定表中所有数据都进行备份，每次相当于覆盖之前的数据，需注意。</p>\n</blockquote>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p><img src=\"http://cdn.putop.top/database-backup.png\" alt=\"备份过程中\"></p>\n"},{"title":"MySQL 中分布式事务的使用","date":"2019-02-12T02:35:26.000Z","_content":"\n## 前言\nMySQL 从 5.0.3 开始支持分布式事务，当前分布式事务只支持 InnoDB 存储引擎。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。\n\n## 分布式事务的原理\n**在 MySQL 中，使用分布式事务的应用程序涉及一个或多个资源管理器和一个事务管理器。**\n\n- 资源管理器（RM）用于提供通向事务资源的途经。**数据库服务器是一种资源管理器。**该管理器必须可以提交或回滚由 RM 管理的事务。例如，多台 MySQL 数据库作为多台资源管理器或者几台 MySQL 服务器和几台 Oracle 服务器作为资源管理器。\n- 事务管理器（TM）用于协调作为一个分布式事务一部分的事务。**TM 与管理每个事务的 RMs 进行通讯。**一个分布式事务中各个单个事务均是分布式事务的“分支事务”。分布式事务和各分支通过一种命名方法进行标识。\n\nMySQL 执行 XA MySQL 时，MySQL 服务器相当于一个用于管理分布式事务中的 XA 事务的资源管理器。与 MySQL 服务器连接的客户端相当于事务管理器。\n\n**要执行一个分布式事务，必须知道这个分布式事务涉及到了哪些资源管理器，并且把每个资源管理器的事务执行到事务可以被提交或回滚时。**根据每个资源管理器报告的有关执行情况的内容，这些分支事务必须作为一个原子性操作全部提交或回滚。要管理一个分布式事务，必须要考虑任何组件或连接网络可能会故障。\n\n用于执行分布式事务的过程使用两阶段提交，发生时间在由分布式事务的各个分支需要进行的行动已经被执行之后。\n\n- 在第一阶段，所有的分支被预备好。即它们被 TM 告知要准备提交。通常，这意味着用于管理分支的每个 RM 会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做。这些结果被用于第二阶段。\n- 在第二阶段，TM 告知 RMs 是否要提交或回滚。如果在预备分支时，所有的分支指示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能提交，则所有分支被告知回滚。\n\n**在有些情况下，一个分布式事务可能会使用一阶段提交。例如，当一个事务管理器发现，一个分布式事务只由一个事务资源组成（即单一分支），则该资源可以被告知同时进行预备和提交。**\n\n## 分布式事务的语法\n分布式事务（XA 事务）的 SQL 语法主要包括：\n\n`XA {START|BEGIN} xid [JOIN|RESUME]`\n\nXA START xid 用于启动一个带给定 xid 值的 XA 事务。每个 XA 事务必须有一个唯一的 xid 值，因此该值当前不能被其他的 XA 事务使用。\n\nxid 是一个 XA 事务标识符，用来唯一标识一个分布式事务。xid 值由客户端提供，或由 MySQL 服务器生成。xid 值包含 1~3 个部分：\n\n`xid: gtrid [, bqual [, formatID ]]`\n\n- gtrid 是一个分布式事务标识符，相同的分布式事务应该使用相同的 gtrid，这样可以明确知道 xa 事务属于哪个分布式事务。\n- bqual 是一个分支限定符，默认值是空串。对于一个分布式事务中的每个分支事务，bqual 值必须是唯一的。\n- formatID 是一个数字，用于标识由 gtrid 和 bqual 值使用的格式，默认值是 1。\n\n下面其他 XA 语法中用到的 xid 值，都必须和 START 操作使用的 xid 值相同，也就是表示对这个启动的 XA 事务进行操作。\n```\nXA END xid [SUSPEND [FOR MIGRATE]]\nXA PREPARE xid\n```\n使事务进入 PREPARE 状态，也就是两阶段提交的第一个提交阶段。\n```\nXA COMMIT xid [ONE PHASE]\nXA ROLLBACK xid\n```\n这两个命令用来提交或者回滚具体的分支事务。也就是两阶段提交的第二个提交阶段，分支事务被实际的提交或者回滚。\n```\nXA RECOVER  返回当前数据库中处于 PREPARE 状态的分支事务的详细信息。\n```\n\n**分布式的关键在于如何确保分布式事务的完整性，以及在某个分支出现问题时的故障解决。**XA 的相关命令就是提供给应用如何在多个独立的数据库之间进行分布式事务的管理，包括启动一个分支事务、使事务进入准备阶段以及事务的实际提交回滚操作等，如下所示的例子演示了一个简单的分布式事务的执行，事务的内容是在 DB1 中插入一条记录，同时在 DB2 中更新一条记录，两个操作作为同一事务提交或者回滚。\n\n**↓↓分布式事务例子↓↓**\n\n|session_1 in DB1|session_2 in DB2|\n|:-:|:-:|\n|在数据库 DB1 中启动一个分布式事务的一个分支事务，xid 的 gtrid 为“test”，bqual 为“db1”：|在数据库 DB2 中启动分布式事务“test”的另外一个分支事务，xid 的 gtrid 为“test”，bqual 为“db2”：|\n|mysql> xa start 'test','db1';|mysql> xa start 'test','db2';|\n|Query OK,0 rows affected(0.00 sec)| Query OK,0 rows affected(0.00 sec)|\n|分支事务 1 在表 actor 中插入一条记录：|分支事务 2 在表 film_actor 中更新了 23 条记录：|\n|mysql> insert into actor (actor_id, first_name, last_name) values (301, 'Simon', 'Tom');|mysql> update film_actor set last_update = now() where actor_id = 178;|\n|Query OK,1 row affected(0.00 sec)|Query OK,23 rows affected(0.04 sec) Rows matched:23 Changed:23 Warnings:0|\n|对分支事务 1 进行第一阶段提交，进入 prepare 状态：|对分支事务 2 进行第一阶段提交，进入 prepare 状态：|\n|mysql> xa end 'test','db1';|mysql> xa end 'test','db2';|\n|Query OK,0 rows affected(0.00 sec)|Query OK,0 rows affected(0.00 sec)|\n|mysql> xa prepare 'test','db1';|mysql> xa prepare 'test','db2';|\n|Query OK,0 rows affected(0.02 sec)|Query OK,0 rows affected(0.02 sec)|\n|||\n|用 xa recover 命令查看当前分支事务状态：|用 xa recover 命令查看当前分支事务状态：|\n|mysql> xa recover \\G|mysql> xa recover \\G|\n|formatID: 1|formatID: 1|\n|gtrid_length: 4|gtrid_length: 4|\n|bqual_length: 3|bqual_length: 3|\n|data: testdb1|data: testdb2|\n|1 row in set(0.00 sec)|1 row in set(0.00 sec)|\n|两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。|两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。|\n|提交分支事务 1：|提交分支事务 2：|\n|mysql> xa commit 'test','db1';|mysql> xa commit 'test','db2';|\n|Query OK,0 rows affected(0.03 sec)|Query OK,0 rows affected(0.03 sec)|\n|两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。|两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。|\n\n## 存在的问题\n虽然 MySQL 支持分布式事务，但是在测试过程中，还是发现存在一些问题。\n\n如果分支事务在达到 prepare 状态时，数据库异常重新启动，服务器重新启动以后，可以继续对分支事务进行提交或者回滚的操作，但是提交的事务没有写 binlog，存在一定的隐患，可能导致使用 binlog 恢复丢失部分数据。如果存在复制的数据库，则有可能导致主从数据库的数据不一致。\n\n如果分支事务的客户端连接异常中止，那么数据库会自动回滚未完成的分支事务，如果此时分支事务已经执行到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。\n\n如果分支事务在执行到 prepare 状态时，数据库异常，且不能再正常启动，需要使用备份和 binlog 来恢复数据，那么那些在 prepare 状态的分支事务因为并没有记录到 binlog，所以不能通过 binlog 进行恢复，在数据库恢复后，将丢失这部分的数据。\n\n## 总结\nMySQL 的分布式事务还存在比较严重的缺陷，在数据库或者应用异常的情况下，可能会导致分布式事务的不完整。如果应用对于数据的完整性要求不是很高，则可以考虑使用。如果应用对事务的完整性有比较高的要求，则不太推荐使用分布式事务。\n\n> 以上大多摘自《深入浅出MySQL》","source":"_posts/mysql-distributed-transaction.md","raw":"---\ntitle: MySQL 中分布式事务的使用\ndate: 2019-2-12 10:35:26\ncategories: [开发,数据库]\ntags: [MySQL]\n---\n\n## 前言\nMySQL 从 5.0.3 开始支持分布式事务，当前分布式事务只支持 InnoDB 存储引擎。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。\n\n## 分布式事务的原理\n**在 MySQL 中，使用分布式事务的应用程序涉及一个或多个资源管理器和一个事务管理器。**\n\n- 资源管理器（RM）用于提供通向事务资源的途经。**数据库服务器是一种资源管理器。**该管理器必须可以提交或回滚由 RM 管理的事务。例如，多台 MySQL 数据库作为多台资源管理器或者几台 MySQL 服务器和几台 Oracle 服务器作为资源管理器。\n- 事务管理器（TM）用于协调作为一个分布式事务一部分的事务。**TM 与管理每个事务的 RMs 进行通讯。**一个分布式事务中各个单个事务均是分布式事务的“分支事务”。分布式事务和各分支通过一种命名方法进行标识。\n\nMySQL 执行 XA MySQL 时，MySQL 服务器相当于一个用于管理分布式事务中的 XA 事务的资源管理器。与 MySQL 服务器连接的客户端相当于事务管理器。\n\n**要执行一个分布式事务，必须知道这个分布式事务涉及到了哪些资源管理器，并且把每个资源管理器的事务执行到事务可以被提交或回滚时。**根据每个资源管理器报告的有关执行情况的内容，这些分支事务必须作为一个原子性操作全部提交或回滚。要管理一个分布式事务，必须要考虑任何组件或连接网络可能会故障。\n\n用于执行分布式事务的过程使用两阶段提交，发生时间在由分布式事务的各个分支需要进行的行动已经被执行之后。\n\n- 在第一阶段，所有的分支被预备好。即它们被 TM 告知要准备提交。通常，这意味着用于管理分支的每个 RM 会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做。这些结果被用于第二阶段。\n- 在第二阶段，TM 告知 RMs 是否要提交或回滚。如果在预备分支时，所有的分支指示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能提交，则所有分支被告知回滚。\n\n**在有些情况下，一个分布式事务可能会使用一阶段提交。例如，当一个事务管理器发现，一个分布式事务只由一个事务资源组成（即单一分支），则该资源可以被告知同时进行预备和提交。**\n\n## 分布式事务的语法\n分布式事务（XA 事务）的 SQL 语法主要包括：\n\n`XA {START|BEGIN} xid [JOIN|RESUME]`\n\nXA START xid 用于启动一个带给定 xid 值的 XA 事务。每个 XA 事务必须有一个唯一的 xid 值，因此该值当前不能被其他的 XA 事务使用。\n\nxid 是一个 XA 事务标识符，用来唯一标识一个分布式事务。xid 值由客户端提供，或由 MySQL 服务器生成。xid 值包含 1~3 个部分：\n\n`xid: gtrid [, bqual [, formatID ]]`\n\n- gtrid 是一个分布式事务标识符，相同的分布式事务应该使用相同的 gtrid，这样可以明确知道 xa 事务属于哪个分布式事务。\n- bqual 是一个分支限定符，默认值是空串。对于一个分布式事务中的每个分支事务，bqual 值必须是唯一的。\n- formatID 是一个数字，用于标识由 gtrid 和 bqual 值使用的格式，默认值是 1。\n\n下面其他 XA 语法中用到的 xid 值，都必须和 START 操作使用的 xid 值相同，也就是表示对这个启动的 XA 事务进行操作。\n```\nXA END xid [SUSPEND [FOR MIGRATE]]\nXA PREPARE xid\n```\n使事务进入 PREPARE 状态，也就是两阶段提交的第一个提交阶段。\n```\nXA COMMIT xid [ONE PHASE]\nXA ROLLBACK xid\n```\n这两个命令用来提交或者回滚具体的分支事务。也就是两阶段提交的第二个提交阶段，分支事务被实际的提交或者回滚。\n```\nXA RECOVER  返回当前数据库中处于 PREPARE 状态的分支事务的详细信息。\n```\n\n**分布式的关键在于如何确保分布式事务的完整性，以及在某个分支出现问题时的故障解决。**XA 的相关命令就是提供给应用如何在多个独立的数据库之间进行分布式事务的管理，包括启动一个分支事务、使事务进入准备阶段以及事务的实际提交回滚操作等，如下所示的例子演示了一个简单的分布式事务的执行，事务的内容是在 DB1 中插入一条记录，同时在 DB2 中更新一条记录，两个操作作为同一事务提交或者回滚。\n\n**↓↓分布式事务例子↓↓**\n\n|session_1 in DB1|session_2 in DB2|\n|:-:|:-:|\n|在数据库 DB1 中启动一个分布式事务的一个分支事务，xid 的 gtrid 为“test”，bqual 为“db1”：|在数据库 DB2 中启动分布式事务“test”的另外一个分支事务，xid 的 gtrid 为“test”，bqual 为“db2”：|\n|mysql> xa start 'test','db1';|mysql> xa start 'test','db2';|\n|Query OK,0 rows affected(0.00 sec)| Query OK,0 rows affected(0.00 sec)|\n|分支事务 1 在表 actor 中插入一条记录：|分支事务 2 在表 film_actor 中更新了 23 条记录：|\n|mysql> insert into actor (actor_id, first_name, last_name) values (301, 'Simon', 'Tom');|mysql> update film_actor set last_update = now() where actor_id = 178;|\n|Query OK,1 row affected(0.00 sec)|Query OK,23 rows affected(0.04 sec) Rows matched:23 Changed:23 Warnings:0|\n|对分支事务 1 进行第一阶段提交，进入 prepare 状态：|对分支事务 2 进行第一阶段提交，进入 prepare 状态：|\n|mysql> xa end 'test','db1';|mysql> xa end 'test','db2';|\n|Query OK,0 rows affected(0.00 sec)|Query OK,0 rows affected(0.00 sec)|\n|mysql> xa prepare 'test','db1';|mysql> xa prepare 'test','db2';|\n|Query OK,0 rows affected(0.02 sec)|Query OK,0 rows affected(0.02 sec)|\n|||\n|用 xa recover 命令查看当前分支事务状态：|用 xa recover 命令查看当前分支事务状态：|\n|mysql> xa recover \\G|mysql> xa recover \\G|\n|formatID: 1|formatID: 1|\n|gtrid_length: 4|gtrid_length: 4|\n|bqual_length: 3|bqual_length: 3|\n|data: testdb1|data: testdb2|\n|1 row in set(0.00 sec)|1 row in set(0.00 sec)|\n|两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。|两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。|\n|提交分支事务 1：|提交分支事务 2：|\n|mysql> xa commit 'test','db1';|mysql> xa commit 'test','db2';|\n|Query OK,0 rows affected(0.03 sec)|Query OK,0 rows affected(0.03 sec)|\n|两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。|两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。|\n\n## 存在的问题\n虽然 MySQL 支持分布式事务，但是在测试过程中，还是发现存在一些问题。\n\n如果分支事务在达到 prepare 状态时，数据库异常重新启动，服务器重新启动以后，可以继续对分支事务进行提交或者回滚的操作，但是提交的事务没有写 binlog，存在一定的隐患，可能导致使用 binlog 恢复丢失部分数据。如果存在复制的数据库，则有可能导致主从数据库的数据不一致。\n\n如果分支事务的客户端连接异常中止，那么数据库会自动回滚未完成的分支事务，如果此时分支事务已经执行到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。\n\n如果分支事务在执行到 prepare 状态时，数据库异常，且不能再正常启动，需要使用备份和 binlog 来恢复数据，那么那些在 prepare 状态的分支事务因为并没有记录到 binlog，所以不能通过 binlog 进行恢复，在数据库恢复后，将丢失这部分的数据。\n\n## 总结\nMySQL 的分布式事务还存在比较严重的缺陷，在数据库或者应用异常的情况下，可能会导致分布式事务的不完整。如果应用对于数据的完整性要求不是很高，则可以考虑使用。如果应用对事务的完整性有比较高的要求，则不太推荐使用分布式事务。\n\n> 以上大多摘自《深入浅出MySQL》","slug":"mysql-distributed-transaction","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhk007vk9i17l9nf8qx","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>MySQL 从 5.0.3 开始支持分布式事务，当前分布式事务只支持 InnoDB 存储引擎。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>\n<h2 id=\"分布式事务的原理\"><a href=\"#分布式事务的原理\" class=\"headerlink\" title=\"分布式事务的原理\"></a>分布式事务的原理</h2><p><strong>在 MySQL 中，使用分布式事务的应用程序涉及一个或多个资源管理器和一个事务管理器。</strong></p>\n<ul>\n<li>资源管理器（RM）用于提供通向事务资源的途经。<strong>数据库服务器是一种资源管理器。</strong>该管理器必须可以提交或回滚由 RM 管理的事务。例如，多台 MySQL 数据库作为多台资源管理器或者几台 MySQL 服务器和几台 Oracle 服务器作为资源管理器。</li>\n<li>事务管理器（TM）用于协调作为一个分布式事务一部分的事务。<strong>TM 与管理每个事务的 RMs 进行通讯。</strong>一个分布式事务中各个单个事务均是分布式事务的“分支事务”。分布式事务和各分支通过一种命名方法进行标识。</li>\n</ul>\n<p>MySQL 执行 XA MySQL 时，MySQL 服务器相当于一个用于管理分布式事务中的 XA 事务的资源管理器。与 MySQL 服务器连接的客户端相当于事务管理器。</p>\n<p><strong>要执行一个分布式事务，必须知道这个分布式事务涉及到了哪些资源管理器，并且把每个资源管理器的事务执行到事务可以被提交或回滚时。</strong>根据每个资源管理器报告的有关执行情况的内容，这些分支事务必须作为一个原子性操作全部提交或回滚。要管理一个分布式事务，必须要考虑任何组件或连接网络可能会故障。</p>\n<p>用于执行分布式事务的过程使用两阶段提交，发生时间在由分布式事务的各个分支需要进行的行动已经被执行之后。</p>\n<ul>\n<li>在第一阶段，所有的分支被预备好。即它们被 TM 告知要准备提交。通常，这意味着用于管理分支的每个 RM 会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做。这些结果被用于第二阶段。</li>\n<li>在第二阶段，TM 告知 RMs 是否要提交或回滚。如果在预备分支时，所有的分支指示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能提交，则所有分支被告知回滚。</li>\n</ul>\n<p><strong>在有些情况下，一个分布式事务可能会使用一阶段提交。例如，当一个事务管理器发现，一个分布式事务只由一个事务资源组成（即单一分支），则该资源可以被告知同时进行预备和提交。</strong></p>\n<h2 id=\"分布式事务的语法\"><a href=\"#分布式事务的语法\" class=\"headerlink\" title=\"分布式事务的语法\"></a>分布式事务的语法</h2><p>分布式事务（XA 事务）的 SQL 语法主要包括：</p>\n<p><code>XA &#123;START|BEGIN&#125; xid [JOIN|RESUME]</code></p>\n<p>XA START xid 用于启动一个带给定 xid 值的 XA 事务。每个 XA 事务必须有一个唯一的 xid 值，因此该值当前不能被其他的 XA 事务使用。</p>\n<p>xid 是一个 XA 事务标识符，用来唯一标识一个分布式事务。xid 值由客户端提供，或由 MySQL 服务器生成。xid 值包含 1~3 个部分：</p>\n<p><code>xid: gtrid [, bqual [, formatID ]]</code></p>\n<ul>\n<li>gtrid 是一个分布式事务标识符，相同的分布式事务应该使用相同的 gtrid，这样可以明确知道 xa 事务属于哪个分布式事务。</li>\n<li>bqual 是一个分支限定符，默认值是空串。对于一个分布式事务中的每个分支事务，bqual 值必须是唯一的。</li>\n<li>formatID 是一个数字，用于标识由 gtrid 和 bqual 值使用的格式，默认值是 1。</li>\n</ul>\n<p>下面其他 XA 语法中用到的 xid 值，都必须和 START 操作使用的 xid 值相同，也就是表示对这个启动的 XA 事务进行操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XA END xid [SUSPEND [FOR MIGRATE]]</span><br><span class=\"line\">XA PREPARE xid</span><br></pre></td></tr></table></figure>\n<p>使事务进入 PREPARE 状态，也就是两阶段提交的第一个提交阶段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XA COMMIT xid [ONE PHASE]</span><br><span class=\"line\">XA ROLLBACK xid</span><br></pre></td></tr></table></figure>\n<p>这两个命令用来提交或者回滚具体的分支事务。也就是两阶段提交的第二个提交阶段，分支事务被实际的提交或者回滚。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XA RECOVER  返回当前数据库中处于 PREPARE 状态的分支事务的详细信息。</span><br></pre></td></tr></table></figure>\n\n<p><strong>分布式的关键在于如何确保分布式事务的完整性，以及在某个分支出现问题时的故障解决。</strong>XA 的相关命令就是提供给应用如何在多个独立的数据库之间进行分布式事务的管理，包括启动一个分支事务、使事务进入准备阶段以及事务的实际提交回滚操作等，如下所示的例子演示了一个简单的分布式事务的执行，事务的内容是在 DB1 中插入一条记录，同时在 DB2 中更新一条记录，两个操作作为同一事务提交或者回滚。</p>\n<p><strong>↓↓分布式事务例子↓↓</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">session_1 in DB1</th>\n<th align=\"center\">session_2 in DB2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">在数据库 DB1 中启动一个分布式事务的一个分支事务，xid 的 gtrid 为“test”，bqual 为“db1”：</td>\n<td align=\"center\">在数据库 DB2 中启动分布式事务“test”的另外一个分支事务，xid 的 gtrid 为“test”，bqual 为“db2”：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa start ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa start ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">分支事务 1 在表 actor 中插入一条记录：</td>\n<td align=\"center\">分支事务 2 在表 film_actor 中更新了 23 条记录：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; insert into actor (actor_id, first_name, last_name) values (301, ‘Simon’, ‘Tom’);</td>\n<td align=\"center\">mysql&gt; update film_actor set last_update &#x3D; now() where actor_id &#x3D; 178;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,1 row affected(0.00 sec)</td>\n<td align=\"center\">Query OK,23 rows affected(0.04 sec) Rows matched:23 Changed:23 Warnings:0</td>\n</tr>\n<tr>\n<td align=\"center\">对分支事务 1 进行第一阶段提交，进入 prepare 状态：</td>\n<td align=\"center\">对分支事务 2 进行第一阶段提交，进入 prepare 状态：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa end ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa end ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa prepare ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa prepare ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.02 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.02 sec)</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">用 xa recover 命令查看当前分支事务状态：</td>\n<td align=\"center\">用 xa recover 命令查看当前分支事务状态：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa recover \\G</td>\n<td align=\"center\">mysql&gt; xa recover \\G</td>\n</tr>\n<tr>\n<td align=\"center\">formatID: 1</td>\n<td align=\"center\">formatID: 1</td>\n</tr>\n<tr>\n<td align=\"center\">gtrid_length: 4</td>\n<td align=\"center\">gtrid_length: 4</td>\n</tr>\n<tr>\n<td align=\"center\">bqual_length: 3</td>\n<td align=\"center\">bqual_length: 3</td>\n</tr>\n<tr>\n<td align=\"center\">data: testdb1</td>\n<td align=\"center\">data: testdb2</td>\n</tr>\n<tr>\n<td align=\"center\">1 row in set(0.00 sec)</td>\n<td align=\"center\">1 row in set(0.00 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。</td>\n<td align=\"center\">两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。</td>\n</tr>\n<tr>\n<td align=\"center\">提交分支事务 1：</td>\n<td align=\"center\">提交分支事务 2：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa commit ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa commit ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.03 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.03 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。</td>\n<td align=\"center\">两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。</td>\n</tr>\n</tbody></table>\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>虽然 MySQL 支持分布式事务，但是在测试过程中，还是发现存在一些问题。</p>\n<p>如果分支事务在达到 prepare 状态时，数据库异常重新启动，服务器重新启动以后，可以继续对分支事务进行提交或者回滚的操作，但是提交的事务没有写 binlog，存在一定的隐患，可能导致使用 binlog 恢复丢失部分数据。如果存在复制的数据库，则有可能导致主从数据库的数据不一致。</p>\n<p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚未完成的分支事务，如果此时分支事务已经执行到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p>\n<p>如果分支事务在执行到 prepare 状态时，数据库异常，且不能再正常启动，需要使用备份和 binlog 来恢复数据，那么那些在 prepare 状态的分支事务因为并没有记录到 binlog，所以不能通过 binlog 进行恢复，在数据库恢复后，将丢失这部分的数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>MySQL 的分布式事务还存在比较严重的缺陷，在数据库或者应用异常的情况下，可能会导致分布式事务的不完整。如果应用对于数据的完整性要求不是很高，则可以考虑使用。如果应用对事务的完整性有比较高的要求，则不太推荐使用分布式事务。</p>\n<blockquote>\n<p>以上大多摘自《深入浅出MySQL》</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>MySQL 从 5.0.3 开始支持分布式事务，当前分布式事务只支持 InnoDB 存储引擎。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>\n<h2 id=\"分布式事务的原理\"><a href=\"#分布式事务的原理\" class=\"headerlink\" title=\"分布式事务的原理\"></a>分布式事务的原理</h2><p><strong>在 MySQL 中，使用分布式事务的应用程序涉及一个或多个资源管理器和一个事务管理器。</strong></p>\n<ul>\n<li>资源管理器（RM）用于提供通向事务资源的途经。<strong>数据库服务器是一种资源管理器。</strong>该管理器必须可以提交或回滚由 RM 管理的事务。例如，多台 MySQL 数据库作为多台资源管理器或者几台 MySQL 服务器和几台 Oracle 服务器作为资源管理器。</li>\n<li>事务管理器（TM）用于协调作为一个分布式事务一部分的事务。<strong>TM 与管理每个事务的 RMs 进行通讯。</strong>一个分布式事务中各个单个事务均是分布式事务的“分支事务”。分布式事务和各分支通过一种命名方法进行标识。</li>\n</ul>\n<p>MySQL 执行 XA MySQL 时，MySQL 服务器相当于一个用于管理分布式事务中的 XA 事务的资源管理器。与 MySQL 服务器连接的客户端相当于事务管理器。</p>\n<p><strong>要执行一个分布式事务，必须知道这个分布式事务涉及到了哪些资源管理器，并且把每个资源管理器的事务执行到事务可以被提交或回滚时。</strong>根据每个资源管理器报告的有关执行情况的内容，这些分支事务必须作为一个原子性操作全部提交或回滚。要管理一个分布式事务，必须要考虑任何组件或连接网络可能会故障。</p>\n<p>用于执行分布式事务的过程使用两阶段提交，发生时间在由分布式事务的各个分支需要进行的行动已经被执行之后。</p>\n<ul>\n<li>在第一阶段，所有的分支被预备好。即它们被 TM 告知要准备提交。通常，这意味着用于管理分支的每个 RM 会记录对于被稳定保存的分支的行动。分支指示是否它们可以这么做。这些结果被用于第二阶段。</li>\n<li>在第二阶段，TM 告知 RMs 是否要提交或回滚。如果在预备分支时，所有的分支指示它们将能够提交，则所有的分支被告知要提交。如果在预备时，有任何分支指示它将不能提交，则所有分支被告知回滚。</li>\n</ul>\n<p><strong>在有些情况下，一个分布式事务可能会使用一阶段提交。例如，当一个事务管理器发现，一个分布式事务只由一个事务资源组成（即单一分支），则该资源可以被告知同时进行预备和提交。</strong></p>\n<h2 id=\"分布式事务的语法\"><a href=\"#分布式事务的语法\" class=\"headerlink\" title=\"分布式事务的语法\"></a>分布式事务的语法</h2><p>分布式事务（XA 事务）的 SQL 语法主要包括：</p>\n<p><code>XA &#123;START|BEGIN&#125; xid [JOIN|RESUME]</code></p>\n<p>XA START xid 用于启动一个带给定 xid 值的 XA 事务。每个 XA 事务必须有一个唯一的 xid 值，因此该值当前不能被其他的 XA 事务使用。</p>\n<p>xid 是一个 XA 事务标识符，用来唯一标识一个分布式事务。xid 值由客户端提供，或由 MySQL 服务器生成。xid 值包含 1~3 个部分：</p>\n<p><code>xid: gtrid [, bqual [, formatID ]]</code></p>\n<ul>\n<li>gtrid 是一个分布式事务标识符，相同的分布式事务应该使用相同的 gtrid，这样可以明确知道 xa 事务属于哪个分布式事务。</li>\n<li>bqual 是一个分支限定符，默认值是空串。对于一个分布式事务中的每个分支事务，bqual 值必须是唯一的。</li>\n<li>formatID 是一个数字，用于标识由 gtrid 和 bqual 值使用的格式，默认值是 1。</li>\n</ul>\n<p>下面其他 XA 语法中用到的 xid 值，都必须和 START 操作使用的 xid 值相同，也就是表示对这个启动的 XA 事务进行操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XA END xid [SUSPEND [FOR MIGRATE]]</span><br><span class=\"line\">XA PREPARE xid</span><br></pre></td></tr></table></figure>\n<p>使事务进入 PREPARE 状态，也就是两阶段提交的第一个提交阶段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XA COMMIT xid [ONE PHASE]</span><br><span class=\"line\">XA ROLLBACK xid</span><br></pre></td></tr></table></figure>\n<p>这两个命令用来提交或者回滚具体的分支事务。也就是两阶段提交的第二个提交阶段，分支事务被实际的提交或者回滚。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XA RECOVER  返回当前数据库中处于 PREPARE 状态的分支事务的详细信息。</span><br></pre></td></tr></table></figure>\n\n<p><strong>分布式的关键在于如何确保分布式事务的完整性，以及在某个分支出现问题时的故障解决。</strong>XA 的相关命令就是提供给应用如何在多个独立的数据库之间进行分布式事务的管理，包括启动一个分支事务、使事务进入准备阶段以及事务的实际提交回滚操作等，如下所示的例子演示了一个简单的分布式事务的执行，事务的内容是在 DB1 中插入一条记录，同时在 DB2 中更新一条记录，两个操作作为同一事务提交或者回滚。</p>\n<p><strong>↓↓分布式事务例子↓↓</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">session_1 in DB1</th>\n<th align=\"center\">session_2 in DB2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">在数据库 DB1 中启动一个分布式事务的一个分支事务，xid 的 gtrid 为“test”，bqual 为“db1”：</td>\n<td align=\"center\">在数据库 DB2 中启动分布式事务“test”的另外一个分支事务，xid 的 gtrid 为“test”，bqual 为“db2”：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa start ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa start ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">分支事务 1 在表 actor 中插入一条记录：</td>\n<td align=\"center\">分支事务 2 在表 film_actor 中更新了 23 条记录：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; insert into actor (actor_id, first_name, last_name) values (301, ‘Simon’, ‘Tom’);</td>\n<td align=\"center\">mysql&gt; update film_actor set last_update &#x3D; now() where actor_id &#x3D; 178;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,1 row affected(0.00 sec)</td>\n<td align=\"center\">Query OK,23 rows affected(0.04 sec) Rows matched:23 Changed:23 Warnings:0</td>\n</tr>\n<tr>\n<td align=\"center\">对分支事务 1 进行第一阶段提交，进入 prepare 状态：</td>\n<td align=\"center\">对分支事务 2 进行第一阶段提交，进入 prepare 状态：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa end ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa end ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.00 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa prepare ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa prepare ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.02 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.02 sec)</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">用 xa recover 命令查看当前分支事务状态：</td>\n<td align=\"center\">用 xa recover 命令查看当前分支事务状态：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa recover \\G</td>\n<td align=\"center\">mysql&gt; xa recover \\G</td>\n</tr>\n<tr>\n<td align=\"center\">formatID: 1</td>\n<td align=\"center\">formatID: 1</td>\n</tr>\n<tr>\n<td align=\"center\">gtrid_length: 4</td>\n<td align=\"center\">gtrid_length: 4</td>\n</tr>\n<tr>\n<td align=\"center\">bqual_length: 3</td>\n<td align=\"center\">bqual_length: 3</td>\n</tr>\n<tr>\n<td align=\"center\">data: testdb1</td>\n<td align=\"center\">data: testdb2</td>\n</tr>\n<tr>\n<td align=\"center\">1 row in set(0.00 sec)</td>\n<td align=\"center\">1 row in set(0.00 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。</td>\n<td align=\"center\">两个事务都进入准备提交阶段，如果之前遇到任何错误，都应该回滚所有的分支，以确保分布式事务的正确。</td>\n</tr>\n<tr>\n<td align=\"center\">提交分支事务 1：</td>\n<td align=\"center\">提交分支事务 2：</td>\n</tr>\n<tr>\n<td align=\"center\">mysql&gt; xa commit ‘test’,’db1’;</td>\n<td align=\"center\">mysql&gt; xa commit ‘test’,’db2’;</td>\n</tr>\n<tr>\n<td align=\"center\">Query OK,0 rows affected(0.03 sec)</td>\n<td align=\"center\">Query OK,0 rows affected(0.03 sec)</td>\n</tr>\n<tr>\n<td align=\"center\">两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。</td>\n<td align=\"center\">两个事务都到达准备提交阶段后，一旦开始进行提交操作，就需要确保全部的分支都提交成功。</td>\n</tr>\n</tbody></table>\n<h2 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h2><p>虽然 MySQL 支持分布式事务，但是在测试过程中，还是发现存在一些问题。</p>\n<p>如果分支事务在达到 prepare 状态时，数据库异常重新启动，服务器重新启动以后，可以继续对分支事务进行提交或者回滚的操作，但是提交的事务没有写 binlog，存在一定的隐患，可能导致使用 binlog 恢复丢失部分数据。如果存在复制的数据库，则有可能导致主从数据库的数据不一致。</p>\n<p>如果分支事务的客户端连接异常中止，那么数据库会自动回滚未完成的分支事务，如果此时分支事务已经执行到 prepare 状态，那么这个分布式事务的其他分支可能已经成功提交，如果这个分支回滚，可能导致分布式事务的不完整，丢失部分分支事务的内容。</p>\n<p>如果分支事务在执行到 prepare 状态时，数据库异常，且不能再正常启动，需要使用备份和 binlog 来恢复数据，那么那些在 prepare 状态的分支事务因为并没有记录到 binlog，所以不能通过 binlog 进行恢复，在数据库恢复后，将丢失这部分的数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>MySQL 的分布式事务还存在比较严重的缺陷，在数据库或者应用异常的情况下，可能会导致分布式事务的不完整。如果应用对于数据的完整性要求不是很高，则可以考虑使用。如果应用对事务的完整性有比较高的要求，则不太推荐使用分布式事务。</p>\n<blockquote>\n<p>以上大多摘自《深入浅出MySQL》</p>\n</blockquote>\n"},{"title":"MySQL 中 MyISAM 和 InnoDB 存储引擎的区别","date":"2019-02-11T02:20:42.000Z","_content":"\n## 前言\n和大多数数据库不同，MySQL 中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。\n\n## 概述\n插件式存储引擎是 MySQL 数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。**MySQL 默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高应用的效率，提供灵活的存储，用户甚至可以按照自己的需要定制和使用自己的存储引擎，以实现最大程度的可定制性。**\n\nMySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，**其中 InnoDB 和 BDB 提供事务安全表，其它存储引擎都是非事务安全表。**\n\n## 特性\n下面列出几种常见的存储引擎，并对比之间的区别。\n\n|特点|MyISAM|InnoDB|MEMORY|MERGE|NDB|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|存储限制|有|64TB|有|没有|有|\n|事务安全||支持||||\n|锁机制|表锁|行锁|表锁|表锁|行锁|\n|B 树索引|支持|支持|支持|支持|支持|\n|哈希索引|||支持||支持|\n|全文索引|支持|||||\n|集群索引||支持||||\n|数据缓存||支持|支持||支持|\n|索引缓存|支持|支持|支持|支持|支持|\n|数据可压缩|支持|||||\n|空间使用|低|高|N/A|低|低|\n|内存使用|低|高|中等|低|高|\n|批量插入的速度|高|低|高|高|高|\n|支持外键||支持||||\n\n**本文重点介绍最常遇到的两种存储引擎：MyISAM 和 InnoDB。**\n\n## MyISAM\n**MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表。**\n\n每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：\n\n- .frm（存储表定义）\n- .MYD（MYData，存储数据）\n- .MYI（MYIndex，存储索引）\n\n数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。\n\nMyISAM 类型的表可能会损坏，原因可能是多种多样的，损坏后的表可能不能访问，会提示需要修复或者访问后返回错误的结果。**MyISAM 类型的表提供修复的工具，可以用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表。**表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能地确认损坏的原因。\n\nMyISAM 的表又支持 3 种不同的存储格式，分别是：\n\n- 静态（固定长度）表\n- 动态表\n- 压缩表\n\n**其中，静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的`优点是存储非常迅速，容易缓存，出现故障容易恢复`；`缺点是占用的空间通常比动态表多`。静态表的数据在存储的时候会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。**\n\n## InnoDB\n**InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。**\n\n### 自动增长列\nInnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者 0，则实际插入的将是自动增长后的值。\n\n可以通过 `ALTER TABLE *** AUTO_INCREMENT = n` 语句强制设置自动增长列的初始值，默认从 1 开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。\n\n可以使用 `LAST_INSERT_ID()` 查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。\n\n**对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其它列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。**\n\n### 外键约束\nMySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。\n\n在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。其中 RESTRICT 和 NO ACTION 相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。选择后两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失。\n\n**当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。**\n\n### 存储方式\nInnoDB 存储表和索引有以下两种方式。\n\n- 使用共享表空间存储，这种方式创建的表的表结构保存在 .frm 文件中，数据和索引保存在 `innodb_data_home_dir` 和 `innodb_data_file_path` 定义的表空间中，可以是多个文件。\n- 使用多表空间存储，这种方式创建的表的表结构仍然保存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。如果是个分区表，则每个分区对应单独的 .ibd 文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上。\n\n要使用多表空间的存储方式，需要设置参数 `innodb_file_per_table`，并重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间的方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。\n\n\n**多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。**\n\n对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制 .ibd 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的 .ibd 文件和 .frm 文件恢复时是不能被正确识别的，但可以通过以下命令：\n```\nALTER TABLE tbl_name DISCARD TABLESPACE;\nALTER TABLE tbl_name IMPORT TABLESPACE;\n```\n将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来在的数据库中，而不能恢复到其他的数据库中。如果要将单表恢复到目标数据库，则需要通过 `mysqldump` 和 `mysqlimport` 来实现。\n\n**注意：即便在多表空间的存储方式下，共享表空间仍然是必须的，InnoDB 把内部数据词典和工作日志放在这个文件中。**\n\n## 适用环境\n在选择存储引擎时，应根据应用特点选择合适的存储引擎，对于复杂的应用系统可以根据实际情况选择多种存储引擎进行组合。\n\n- MyISAM：默认的 MySQL 插件式存储引擎。如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。\n- InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。\n\n> 本文大多摘自《深入浅出MySQL》。\n","source":"_posts/mysql-engine.md","raw":"---\ntitle: MySQL 中 MyISAM 和 InnoDB 存储引擎的区别\ndate: 2019-2-11 10:20:42\ncategories: [开发,数据库]\ntags: [MySQL]\n---\n\n## 前言\n和大多数数据库不同，MySQL 中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。\n\n## 概述\n插件式存储引擎是 MySQL 数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。**MySQL 默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高应用的效率，提供灵活的存储，用户甚至可以按照自己的需要定制和使用自己的存储引擎，以实现最大程度的可定制性。**\n\nMySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，**其中 InnoDB 和 BDB 提供事务安全表，其它存储引擎都是非事务安全表。**\n\n## 特性\n下面列出几种常见的存储引擎，并对比之间的区别。\n\n|特点|MyISAM|InnoDB|MEMORY|MERGE|NDB|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|存储限制|有|64TB|有|没有|有|\n|事务安全||支持||||\n|锁机制|表锁|行锁|表锁|表锁|行锁|\n|B 树索引|支持|支持|支持|支持|支持|\n|哈希索引|||支持||支持|\n|全文索引|支持|||||\n|集群索引||支持||||\n|数据缓存||支持|支持||支持|\n|索引缓存|支持|支持|支持|支持|支持|\n|数据可压缩|支持|||||\n|空间使用|低|高|N/A|低|低|\n|内存使用|低|高|中等|低|高|\n|批量插入的速度|高|低|高|高|高|\n|支持外键||支持||||\n\n**本文重点介绍最常遇到的两种存储引擎：MyISAM 和 InnoDB。**\n\n## MyISAM\n**MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表。**\n\n每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：\n\n- .frm（存储表定义）\n- .MYD（MYData，存储数据）\n- .MYI（MYIndex，存储索引）\n\n数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。\n\nMyISAM 类型的表可能会损坏，原因可能是多种多样的，损坏后的表可能不能访问，会提示需要修复或者访问后返回错误的结果。**MyISAM 类型的表提供修复的工具，可以用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表。**表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能地确认损坏的原因。\n\nMyISAM 的表又支持 3 种不同的存储格式，分别是：\n\n- 静态（固定长度）表\n- 动态表\n- 压缩表\n\n**其中，静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的`优点是存储非常迅速，容易缓存，出现故障容易恢复`；`缺点是占用的空间通常比动态表多`。静态表的数据在存储的时候会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。**\n\n## InnoDB\n**InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。**\n\n### 自动增长列\nInnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者 0，则实际插入的将是自动增长后的值。\n\n可以通过 `ALTER TABLE *** AUTO_INCREMENT = n` 语句强制设置自动增长列的初始值，默认从 1 开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。\n\n可以使用 `LAST_INSERT_ID()` 查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。\n\n**对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其它列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。**\n\n### 外键约束\nMySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。\n\n在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。其中 RESTRICT 和 NO ACTION 相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。选择后两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失。\n\n**当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。**\n\n### 存储方式\nInnoDB 存储表和索引有以下两种方式。\n\n- 使用共享表空间存储，这种方式创建的表的表结构保存在 .frm 文件中，数据和索引保存在 `innodb_data_home_dir` 和 `innodb_data_file_path` 定义的表空间中，可以是多个文件。\n- 使用多表空间存储，这种方式创建的表的表结构仍然保存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。如果是个分区表，则每个分区对应单独的 .ibd 文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上。\n\n要使用多表空间的存储方式，需要设置参数 `innodb_file_per_table`，并重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间的方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。\n\n\n**多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。**\n\n对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制 .ibd 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的 .ibd 文件和 .frm 文件恢复时是不能被正确识别的，但可以通过以下命令：\n```\nALTER TABLE tbl_name DISCARD TABLESPACE;\nALTER TABLE tbl_name IMPORT TABLESPACE;\n```\n将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来在的数据库中，而不能恢复到其他的数据库中。如果要将单表恢复到目标数据库，则需要通过 `mysqldump` 和 `mysqlimport` 来实现。\n\n**注意：即便在多表空间的存储方式下，共享表空间仍然是必须的，InnoDB 把内部数据词典和工作日志放在这个文件中。**\n\n## 适用环境\n在选择存储引擎时，应根据应用特点选择合适的存储引擎，对于复杂的应用系统可以根据实际情况选择多种存储引擎进行组合。\n\n- MyISAM：默认的 MySQL 插件式存储引擎。如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。\n- InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。\n\n> 本文大多摘自《深入浅出MySQL》。\n","slug":"mysql-engine","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhk007zk9i1fyzwc7z6","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>和大多数数据库不同，MySQL 中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>插件式存储引擎是 MySQL 数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。<strong>MySQL 默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高应用的效率，提供灵活的存储，用户甚至可以按照自己的需要定制和使用自己的存储引擎，以实现最大程度的可定制性。</strong></p>\n<p>MySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，<strong>其中 InnoDB 和 BDB 提供事务安全表，其它存储引擎都是非事务安全表。</strong></p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>下面列出几种常见的存储引擎，并对比之间的区别。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特点</th>\n<th align=\"center\">MyISAM</th>\n<th align=\"center\">InnoDB</th>\n<th align=\"center\">MEMORY</th>\n<th align=\"center\">MERGE</th>\n<th align=\"center\">NDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">存储限制</td>\n<td align=\"center\">有</td>\n<td align=\"center\">64TB</td>\n<td align=\"center\">有</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">有</td>\n</tr>\n<tr>\n<td align=\"center\">事务安全</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">锁机制</td>\n<td align=\"center\">表锁</td>\n<td align=\"center\">行锁</td>\n<td align=\"center\">表锁</td>\n<td align=\"center\">表锁</td>\n<td align=\"center\">行锁</td>\n</tr>\n<tr>\n<td align=\"center\">B 树索引</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">哈希索引</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">全文索引</td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">集群索引</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">数据缓存</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">索引缓存</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">数据可压缩</td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">空间使用</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">N&#x2F;A</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">内存使用</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">批量插入的速度</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">支持外键</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>本文重点介绍最常遇到的两种存储引擎：MyISAM 和 InnoDB。</strong></p>\n<h2 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h2><p><strong>MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表。</strong></p>\n<p>每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：</p>\n<ul>\n<li>.frm（存储表定义）</li>\n<li>.MYD（MYData，存储数据）</li>\n<li>.MYI（MYIndex，存储索引）</li>\n</ul>\n<p>数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。</p>\n<p>MyISAM 类型的表可能会损坏，原因可能是多种多样的，损坏后的表可能不能访问，会提示需要修复或者访问后返回错误的结果。<strong>MyISAM 类型的表提供修复的工具，可以用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表。</strong>表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能地确认损坏的原因。</p>\n<p>MyISAM 的表又支持 3 种不同的存储格式，分别是：</p>\n<ul>\n<li>静态（固定长度）表</li>\n<li>动态表</li>\n<li>压缩表</li>\n</ul>\n<p><strong>其中，静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的<code>优点是存储非常迅速，容易缓存，出现故障容易恢复</code>；<code>缺点是占用的空间通常比动态表多</code>。静态表的数据在存储的时候会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。</strong></p>\n<h2 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h2><p><strong>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</strong></p>\n<h3 id=\"自动增长列\"><a href=\"#自动增长列\" class=\"headerlink\" title=\"自动增长列\"></a>自动增长列</h3><p>InnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者 0，则实际插入的将是自动增长后的值。</p>\n<p>可以通过 <code>ALTER TABLE *** AUTO_INCREMENT = n</code> 语句强制设置自动增长列的初始值，默认从 1 开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。</p>\n<p>可以使用 <code>LAST_INSERT_ID()</code> 查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。</p>\n<p><strong>对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其它列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</strong></p>\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>MySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p>\n<p>在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。其中 RESTRICT 和 NO ACTION 相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。选择后两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失。</p>\n<p><strong>当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。</strong></p>\n<h3 id=\"存储方式\"><a href=\"#存储方式\" class=\"headerlink\" title=\"存储方式\"></a>存储方式</h3><p>InnoDB 存储表和索引有以下两种方式。</p>\n<ul>\n<li>使用共享表空间存储，这种方式创建的表的表结构保存在 .frm 文件中，数据和索引保存在 <code>innodb_data_home_dir</code> 和 <code>innodb_data_file_path</code> 定义的表空间中，可以是多个文件。</li>\n<li>使用多表空间存储，这种方式创建的表的表结构仍然保存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。如果是个分区表，则每个分区对应单独的 .ibd 文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上。</li>\n</ul>\n<p>要使用多表空间的存储方式，需要设置参数 <code>innodb_file_per_table</code>，并重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间的方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。</p>\n<p><strong>多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。</strong></p>\n<p>对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制 .ibd 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的 .ibd 文件和 .frm 文件恢复时是不能被正确识别的，但可以通过以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl_name DISCARD TABLESPACE;</span><br><span class=\"line\">ALTER TABLE tbl_name IMPORT TABLESPACE;</span><br></pre></td></tr></table></figure>\n<p>将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来在的数据库中，而不能恢复到其他的数据库中。如果要将单表恢复到目标数据库，则需要通过 <code>mysqldump</code> 和 <code>mysqlimport</code> 来实现。</p>\n<p><strong>注意：即便在多表空间的存储方式下，共享表空间仍然是必须的，InnoDB 把内部数据词典和工作日志放在这个文件中。</strong></p>\n<h2 id=\"适用环境\"><a href=\"#适用环境\" class=\"headerlink\" title=\"适用环境\"></a>适用环境</h2><p>在选择存储引擎时，应根据应用特点选择合适的存储引擎，对于复杂的应用系统可以根据实际情况选择多种存储引擎进行组合。</p>\n<ul>\n<li>MyISAM：默认的 MySQL 插件式存储引擎。如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。</li>\n<li>InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。</li>\n</ul>\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>和大多数数据库不同，MySQL 中有一个存储引擎的概念，针对不同的存储需求可以选择最优的存储引擎。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>插件式存储引擎是 MySQL 数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。<strong>MySQL 默认支持多种存储引擎，以适用于不同领域的数据库应用需要，用户可以通过选择使用不同的存储引擎提高应用的效率，提供灵活的存储，用户甚至可以按照自己的需要定制和使用自己的存储引擎，以实现最大程度的可定制性。</strong></p>\n<p>MySQL 5.0 支持的存储引擎包括 MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED 等，<strong>其中 InnoDB 和 BDB 提供事务安全表，其它存储引擎都是非事务安全表。</strong></p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><p>下面列出几种常见的存储引擎，并对比之间的区别。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">特点</th>\n<th align=\"center\">MyISAM</th>\n<th align=\"center\">InnoDB</th>\n<th align=\"center\">MEMORY</th>\n<th align=\"center\">MERGE</th>\n<th align=\"center\">NDB</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">存储限制</td>\n<td align=\"center\">有</td>\n<td align=\"center\">64TB</td>\n<td align=\"center\">有</td>\n<td align=\"center\">没有</td>\n<td align=\"center\">有</td>\n</tr>\n<tr>\n<td align=\"center\">事务安全</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">锁机制</td>\n<td align=\"center\">表锁</td>\n<td align=\"center\">行锁</td>\n<td align=\"center\">表锁</td>\n<td align=\"center\">表锁</td>\n<td align=\"center\">行锁</td>\n</tr>\n<tr>\n<td align=\"center\">B 树索引</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">哈希索引</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">全文索引</td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">集群索引</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">数据缓存</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">索引缓存</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n<td align=\"center\">支持</td>\n</tr>\n<tr>\n<td align=\"center\">数据可压缩</td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">空间使用</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">N&#x2F;A</td>\n<td align=\"center\">低</td>\n<td align=\"center\">低</td>\n</tr>\n<tr>\n<td align=\"center\">内存使用</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">中等</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">批量插入的速度</td>\n<td align=\"center\">高</td>\n<td align=\"center\">低</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n<td align=\"center\">高</td>\n</tr>\n<tr>\n<td align=\"center\">支持外键</td>\n<td align=\"center\"></td>\n<td align=\"center\">支持</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p><strong>本文重点介绍最常遇到的两种存储引擎：MyISAM 和 InnoDB。</strong></p>\n<h2 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h2><p><strong>MyISAM 是 MySQL 的默认存储引擎。MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用这个引擎来创建表。</strong></p>\n<p>每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，但扩展名分别是：</p>\n<ul>\n<li>.frm（存储表定义）</li>\n<li>.MYD（MYData，存储数据）</li>\n<li>.MYI（MYIndex，存储索引）</li>\n</ul>\n<p>数据文件和索引文件可以放置在不同的目录，平均分布 IO，获得更快的速度。</p>\n<p>MyISAM 类型的表可能会损坏，原因可能是多种多样的，损坏后的表可能不能访问，会提示需要修复或者访问后返回错误的结果。<strong>MyISAM 类型的表提供修复的工具，可以用 CHECK TABLE 语句来检查 MyISAM 表的健康，并用 REPAIR TABLE 语句修复一个损坏的 MyISAM 表。</strong>表损坏可能导致数据库异常重新启动，需要尽快修复并尽可能地确认损坏的原因。</p>\n<p>MyISAM 的表又支持 3 种不同的存储格式，分别是：</p>\n<ul>\n<li>静态（固定长度）表</li>\n<li>动态表</li>\n<li>压缩表</li>\n</ul>\n<p><strong>其中，静态表是默认的存储格式。静态表中的字段都是非变长字段，这样每个记录都是固定长度的，这种存储方式的<code>优点是存储非常迅速，容易缓存，出现故障容易恢复</code>；<code>缺点是占用的空间通常比动态表多</code>。静态表的数据在存储的时候会按照列的宽度定义补足空格，但是在应用访问的时候并不会得到这些空格，这些空格在返回给应用之前已经去掉。</strong></p>\n<h2 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h2><p><strong>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。</strong></p>\n<h3 id=\"自动增长列\"><a href=\"#自动增长列\" class=\"headerlink\" title=\"自动增长列\"></a>自动增长列</h3><p>InnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者 0，则实际插入的将是自动增长后的值。</p>\n<p>可以通过 <code>ALTER TABLE *** AUTO_INCREMENT = n</code> 语句强制设置自动增长列的初始值，默认从 1 开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。</p>\n<p>可以使用 <code>LAST_INSERT_ID()</code> 查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。</p>\n<p><strong>对于 InnoDB 表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于 MyISAM 表，自动增长列可以是组合索引的其它列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。</strong></p>\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>MySQL 支持外键的存储引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。</p>\n<p>在创建索引的时候，可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。其中 RESTRICT 和 NO ACTION 相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或者删除时，更新或者删除子表对应记录；SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被 SET NULL。选择后两种方式的时候要谨慎，可能会因为错误的操作导致数据的丢失。</p>\n<p><strong>当某个表被其他表创建了外键参照，那么该表的对应索引或者主键禁止被删除。</strong></p>\n<h3 id=\"存储方式\"><a href=\"#存储方式\" class=\"headerlink\" title=\"存储方式\"></a>存储方式</h3><p>InnoDB 存储表和索引有以下两种方式。</p>\n<ul>\n<li>使用共享表空间存储，这种方式创建的表的表结构保存在 .frm 文件中，数据和索引保存在 <code>innodb_data_home_dir</code> 和 <code>innodb_data_file_path</code> 定义的表空间中，可以是多个文件。</li>\n<li>使用多表空间存储，这种方式创建的表的表结构仍然保存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。如果是个分区表，则每个分区对应单独的 .ibd 文件，文件名是“表名+分区名”，可以在创建分区的时候指定每个分区的数据文件的位置，以此来将表的 IO 均匀分布在多个磁盘上。</li>\n</ul>\n<p>要使用多表空间的存储方式，需要设置参数 <code>innodb_file_per_table</code>，并重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间的方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。</p>\n<p><strong>多表空间的数据文件没有大小限制，不需要设置初始大小，也不需要设置文件的最大限制、扩展大小等参数。</strong></p>\n<p>对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制 .ibd 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的 .ibd 文件和 .frm 文件恢复时是不能被正确识别的，但可以通过以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl_name DISCARD TABLESPACE;</span><br><span class=\"line\">ALTER TABLE tbl_name IMPORT TABLESPACE;</span><br></pre></td></tr></table></figure>\n<p>将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来在的数据库中，而不能恢复到其他的数据库中。如果要将单表恢复到目标数据库，则需要通过 <code>mysqldump</code> 和 <code>mysqlimport</code> 来实现。</p>\n<p><strong>注意：即便在多表空间的存储方式下，共享表空间仍然是必须的，InnoDB 把内部数据词典和工作日志放在这个文件中。</strong></p>\n<h2 id=\"适用环境\"><a href=\"#适用环境\" class=\"headerlink\" title=\"适用环境\"></a>适用环境</h2><p>在选择存储引擎时，应根据应用特点选择合适的存储引擎，对于复杂的应用系统可以根据实际情况选择多种存储引擎进行组合。</p>\n<ul>\n<li>MyISAM：默认的 MySQL 插件式存储引擎。如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。</li>\n<li>InnoDB：用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。</li>\n</ul>\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n"},{"title":"MySQL 中的索引问题","date":"2019-02-13T05:29:01.000Z","_content":"\n## 前言\n索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的 SQL 性能问题。接下来将对 MySQL 中的索引的分类、存储、使用方法做详细的介绍。\n\n## 索引的存储分类\n**MyISAM 存储引擎的表的数据和索引是自动分开存储的，各自是独立的一个文件；InnoDB 存储引擎的表的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。**\n\nMySQL 中索引的存储类型目前只有两种（BTREE 和 HASH），具体和表的存储引擎相关：MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引；MEMORY/HEAP 存储引擎可以支持 HASH 和 BTREE 索引。\n\nMySQL 目前不支持函数索引，但是能对列的前面某一部分进索引，例如 name 字段，可以只取 name 的前 4 个字符进行索引，这个特性可以大大缩小索引文件的大小，用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。下面是创建前缀索引的一个例子：\n```\nmysql> create index ind_company2_name on company2(name(4));\nQuery OK,1000 rows affected(0.03 sec)\nRecords: 1000  Duplicates: 0   Warnings: 0\n```\n\n## 索引的使用\n**索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高 SELECT 操作性能的最佳途径。**\n\n**查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。**\n\n### 使用索引\n在 MySQL 中，下列几种情况下有可能使用到索引。\n\n（1）对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用，举例说明如下。\n\n**首先按 company_id，moneys 的顺序创建一个复合索引，具体如下：**\n```\nmysql> create index ind_sales2_companyid_moneys on sales2(company_id, moneys);\nQuery OK,1000 rows affected(0.03 sec)\nRecords: 1000  Duplicates: 0  Warnings: 0\n```\n**然后按 company_id 进行表查询，具体如下：**\n```\nmysql> explain select * from sales2 where company_id = 2006\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ref\n      possible_keys: ind_sales2_companyid_moneys\n                key: ind_sales2_companyid_moneys\n            key_len: 5\n                ref: const\n               rows: 1\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n**可以发现即便 where 条件中不是用的 company_id 与 moneys 的组合条件，索引仍然能用到，这就是索引的前缀特性。但是如果只按 moneys 条件查询表，那么索引就不会被用到**，具体如下：\n```\nmysql> explain select * from sales2 where moneys = 1\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n（2）对于使用 like 的查询，后面如果是常量并且只有 `%` 号不在第一个字符，索引才可能会被使用，来看下面两个执行计划：\n```\nmysql> explain select * from company2 where name like '%3'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n\nmysql> explain select * from company2 where name like '3%'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: range\n      possible_keys: ind_company2_name\n                key: ind_company2_name\n            key_len: 11\n                ref: NULL\n               rows: 103\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可以发现第一个例子没有使用索引，而第二例子就能够使用索引，区别就在于“%”的位置不同，前者把“%”放到第一位就不能用到索引，而后者没有放到第一位就使用了索引。\n\n**另外，如果 like 后面跟的是一个列的名字，那么索引也不会被使用。**\n\n（3）如果对大的文本进行搜索，使用全文索引而不用使用 like '%...%'。\n\n（4）如果列名是索引，使用 column_name is null 将使用索引。如下例中查询 name 为 null 的记录就用到了索引：\n```\nmysql> explain select * from company2 where name is null\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ref\n      possible_keys: ind_company2_name\n                key: ind_company2_name\n            key_len: 11\n                ref: const\n               rows: 1\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n\n### 存在索引但不使用索引\n在下列情况下，虽然存在索引，但是 MySQL 并不会使用相应的索引。\n\n（1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如如果列 key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：\n```\nSELECT * FROM table_name where key_part1 > 1 and key_part1 < 90;\n```\n\n（2）如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列，那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。\n\n（3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到，例如：\n```\nmysql> show index from sales\\G;\n    **************************** 1. row *************************************\n              Table: sales\n         Non_unique: 1\n           Key_name: ind_sales_year\n       Seq_in_index: 1\n        Column_name: year\n          Collation: A\n        Cardinality: NULL\n           Sub_part: NULL\n             Packed: NULL\n               Null:\n         Index_type: BTREE\n            Comment:\n    1 row in set(0.00 sec)\n```\n从上面可以发现只有 year 列上面有索引，来看如下的执行计划：\n```\nmysql> explain select * from sales where year = 2001 or country = 'China'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales\n               type: ALL\n      possible_keys: ind_sales_year\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 12\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可见虽然在 year 这个列上存在索引 `ind_sales_year`，但是这个 SQL 语句并没有用到这个索引，原因就是 or 中有一个条件中的列没有索引。\n\n（4）如果不是索引列的第一部分，如下例子：\n```\nmysql> explain select * from sales2 where moneys = 1\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可见虽然在 money 上面建有复合索引，但是由于 money 不是索引的第一列，那么在查询中这个索引也不会被 MySQL 采用。\n\n（5）如果 like 是以 `%` 开始，例如：\n```\nmysql> explain select * from company2 where name like '%3'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可见虽然在 name 上建有索引，但是由于 where 条件中 like 的值的“%”在第一位了，那么 MySQL 也不会采用这个索引。\n\n（6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为，MySQL 默认把输入的常量值进行转换以后才进行检索。如下面的例子中 company2 表中的 name 字段是字符型的，但是 SQL 语句中的条件值 294 是一个数值型值，因此即便在 name 上有索引，MySQL 也不能正确地用上索引，而是继续进行全表扫描。\n```\nmysql> explain select * from company2 where name = 294\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ALL\n      possible_keys: ind_company2_name\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n\nmysql> explain select * from company2 where name = '294'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ref\n      possible_keys: ind_company2_name\n                key: ind_company2_name\n            key_len: 23\n                ref: const\n               rows: 1\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n从上面的例子中可以看到，第一个 SQL 语句中把一个数值型常量赋值给了一个字符型的列 name，那么虽然在 name 列上有索引，但是也没有用到；而第二个 SQL 语句就可以正确使用索引。\n\n## 查看索引使用情况\n如果索引正在工作，`Handler_read_key` 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。\n\n`Handler_read_rnd_next` 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描，`Handler_read_rnd_next` 的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具体如下：\n```\nmysql> show status like 'Handler_read%';\n+------------------------+----------+\n|  Variable_name         |  Value   |\n+------------------------+----------+\n|  Handler_read_first    |  0       |\n|  Handler_read_key      |  5       |\n|  Handler_read_next     |  0       |\n|  Handler_read_prev     |  0       |\n|  Handler_read_rnd      |  0       |\n|  Handler_read_rnd_next |  2055    |\n+------------------------+----------+\n\n6 rows in set(0.00 sec)\n```\n从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。\n\n> 本文大多摘自《深入浅出MySQL》。","source":"_posts/mysql-index.md","raw":"---\ntitle: MySQL 中的索引问题\ndate: 2019-2-13 13:29:01\ncategories: [开发,数据库]\ntags: [MySQL]\n---\n\n## 前言\n索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的 SQL 性能问题。接下来将对 MySQL 中的索引的分类、存储、使用方法做详细的介绍。\n\n## 索引的存储分类\n**MyISAM 存储引擎的表的数据和索引是自动分开存储的，各自是独立的一个文件；InnoDB 存储引擎的表的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。**\n\nMySQL 中索引的存储类型目前只有两种（BTREE 和 HASH），具体和表的存储引擎相关：MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引；MEMORY/HEAP 存储引擎可以支持 HASH 和 BTREE 索引。\n\nMySQL 目前不支持函数索引，但是能对列的前面某一部分进索引，例如 name 字段，可以只取 name 的前 4 个字符进行索引，这个特性可以大大缩小索引文件的大小，用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。下面是创建前缀索引的一个例子：\n```\nmysql> create index ind_company2_name on company2(name(4));\nQuery OK,1000 rows affected(0.03 sec)\nRecords: 1000  Duplicates: 0   Warnings: 0\n```\n\n## 索引的使用\n**索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高 SELECT 操作性能的最佳途径。**\n\n**查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。**\n\n### 使用索引\n在 MySQL 中，下列几种情况下有可能使用到索引。\n\n（1）对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用，举例说明如下。\n\n**首先按 company_id，moneys 的顺序创建一个复合索引，具体如下：**\n```\nmysql> create index ind_sales2_companyid_moneys on sales2(company_id, moneys);\nQuery OK,1000 rows affected(0.03 sec)\nRecords: 1000  Duplicates: 0  Warnings: 0\n```\n**然后按 company_id 进行表查询，具体如下：**\n```\nmysql> explain select * from sales2 where company_id = 2006\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ref\n      possible_keys: ind_sales2_companyid_moneys\n                key: ind_sales2_companyid_moneys\n            key_len: 5\n                ref: const\n               rows: 1\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n**可以发现即便 where 条件中不是用的 company_id 与 moneys 的组合条件，索引仍然能用到，这就是索引的前缀特性。但是如果只按 moneys 条件查询表，那么索引就不会被用到**，具体如下：\n```\nmysql> explain select * from sales2 where moneys = 1\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n（2）对于使用 like 的查询，后面如果是常量并且只有 `%` 号不在第一个字符，索引才可能会被使用，来看下面两个执行计划：\n```\nmysql> explain select * from company2 where name like '%3'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n\nmysql> explain select * from company2 where name like '3%'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: range\n      possible_keys: ind_company2_name\n                key: ind_company2_name\n            key_len: 11\n                ref: NULL\n               rows: 103\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可以发现第一个例子没有使用索引，而第二例子就能够使用索引，区别就在于“%”的位置不同，前者把“%”放到第一位就不能用到索引，而后者没有放到第一位就使用了索引。\n\n**另外，如果 like 后面跟的是一个列的名字，那么索引也不会被使用。**\n\n（3）如果对大的文本进行搜索，使用全文索引而不用使用 like '%...%'。\n\n（4）如果列名是索引，使用 column_name is null 将使用索引。如下例中查询 name 为 null 的记录就用到了索引：\n```\nmysql> explain select * from company2 where name is null\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ref\n      possible_keys: ind_company2_name\n                key: ind_company2_name\n            key_len: 11\n                ref: const\n               rows: 1\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n\n### 存在索引但不使用索引\n在下列情况下，虽然存在索引，但是 MySQL 并不会使用相应的索引。\n\n（1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如如果列 key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：\n```\nSELECT * FROM table_name where key_part1 > 1 and key_part1 < 90;\n```\n\n（2）如果使用 MEMORY/HEAP 表并且 where 条件中不使用“=”进行索引列，那么不会用到索引。heap 表只有在“=”的条件下才会使用索引。\n\n（3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到，例如：\n```\nmysql> show index from sales\\G;\n    **************************** 1. row *************************************\n              Table: sales\n         Non_unique: 1\n           Key_name: ind_sales_year\n       Seq_in_index: 1\n        Column_name: year\n          Collation: A\n        Cardinality: NULL\n           Sub_part: NULL\n             Packed: NULL\n               Null:\n         Index_type: BTREE\n            Comment:\n    1 row in set(0.00 sec)\n```\n从上面可以发现只有 year 列上面有索引，来看如下的执行计划：\n```\nmysql> explain select * from sales where year = 2001 or country = 'China'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales\n               type: ALL\n      possible_keys: ind_sales_year\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 12\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可见虽然在 year 这个列上存在索引 `ind_sales_year`，但是这个 SQL 语句并没有用到这个索引，原因就是 or 中有一个条件中的列没有索引。\n\n（4）如果不是索引列的第一部分，如下例子：\n```\nmysql> explain select * from sales2 where moneys = 1\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可见虽然在 money 上面建有复合索引，但是由于 money 不是索引的第一列，那么在查询中这个索引也不会被 MySQL 采用。\n\n（5）如果 like 是以 `%` 开始，例如：\n```\nmysql> explain select * from company2 where name like '%3'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n可见虽然在 name 上建有索引，但是由于 where 条件中 like 的值的“%”在第一位了，那么 MySQL 也不会采用这个索引。\n\n（6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为，MySQL 默认把输入的常量值进行转换以后才进行检索。如下面的例子中 company2 表中的 name 字段是字符型的，但是 SQL 语句中的条件值 294 是一个数值型值，因此即便在 name 上有索引，MySQL 也不能正确地用上索引，而是继续进行全表扫描。\n```\nmysql> explain select * from company2 where name = 294\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ALL\n      possible_keys: ind_company2_name\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n\nmysql> explain select * from company2 where name = '294'\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ref\n      possible_keys: ind_company2_name\n                key: ind_company2_name\n            key_len: 23\n                ref: const\n               rows: 1\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n从上面的例子中可以看到，第一个 SQL 语句中把一个数值型常量赋值给了一个字符型的列 name，那么虽然在 name 列上有索引，但是也没有用到；而第二个 SQL 语句就可以正确使用索引。\n\n## 查看索引使用情况\n如果索引正在工作，`Handler_read_key` 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。\n\n`Handler_read_rnd_next` 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描，`Handler_read_rnd_next` 的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具体如下：\n```\nmysql> show status like 'Handler_read%';\n+------------------------+----------+\n|  Variable_name         |  Value   |\n+------------------------+----------+\n|  Handler_read_first    |  0       |\n|  Handler_read_key      |  5       |\n|  Handler_read_next     |  0       |\n|  Handler_read_prev     |  0       |\n|  Handler_read_rnd      |  0       |\n|  Handler_read_rnd_next |  2055    |\n+------------------------+----------+\n\n6 rows in set(0.00 sec)\n```\n从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。\n\n> 本文大多摘自《深入浅出MySQL》。","slug":"mysql-index","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhk0082k9i14ew0epcn","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的 SQL 性能问题。接下来将对 MySQL 中的索引的分类、存储、使用方法做详细的介绍。</p>\n<h2 id=\"索引的存储分类\"><a href=\"#索引的存储分类\" class=\"headerlink\" title=\"索引的存储分类\"></a>索引的存储分类</h2><p><strong>MyISAM 存储引擎的表的数据和索引是自动分开存储的，各自是独立的一个文件；InnoDB 存储引擎的表的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。</strong></p>\n<p>MySQL 中索引的存储类型目前只有两种（BTREE 和 HASH），具体和表的存储引擎相关：MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引；MEMORY&#x2F;HEAP 存储引擎可以支持 HASH 和 BTREE 索引。</p>\n<p>MySQL 目前不支持函数索引，但是能对列的前面某一部分进索引，例如 name 字段，可以只取 name 的前 4 个字符进行索引，这个特性可以大大缩小索引文件的大小，用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。下面是创建前缀索引的一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create index ind_company2_name on company2(name(4));</span><br><span class=\"line\">Query OK,1000 rows affected(0.03 sec)</span><br><span class=\"line\">Records: 1000  Duplicates: 0   Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h2><p><strong>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高 SELECT 操作性能的最佳途径。</strong></p>\n<p><strong>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</strong></p>\n<h3 id=\"使用索引\"><a href=\"#使用索引\" class=\"headerlink\" title=\"使用索引\"></a>使用索引</h3><p>在 MySQL 中，下列几种情况下有可能使用到索引。</p>\n<p>（1）对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用，举例说明如下。</p>\n<p><strong>首先按 company_id，moneys 的顺序创建一个复合索引，具体如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create index ind_sales2_companyid_moneys on sales2(company_id, moneys);</span><br><span class=\"line\">Query OK,1000 rows affected(0.03 sec)</span><br><span class=\"line\">Records: 1000  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n<p><strong>然后按 company_id 进行表查询，具体如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where company_id = 2006\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_sales2_companyid_moneys</span><br><span class=\"line\">                key: ind_sales2_companyid_moneys</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p><strong>可以发现即便 where 条件中不是用的 company_id 与 moneys 的组合条件，索引仍然能用到，这就是索引的前缀特性。但是如果只按 moneys 条件查询表，那么索引就不会被用到</strong>，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where moneys = 1\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>（2）对于使用 like 的查询，后面如果是常量并且只有 <code>%</code> 号不在第一个字符，索引才可能会被使用，来看下面两个执行计划：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name like &#x27;%3&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from company2 where name like &#x27;3%&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: range</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: ind_company2_name</span><br><span class=\"line\">            key_len: 11</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 103</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可以发现第一个例子没有使用索引，而第二例子就能够使用索引，区别就在于“%”的位置不同，前者把“%”放到第一位就不能用到索引，而后者没有放到第一位就使用了索引。</p>\n<p><strong>另外，如果 like 后面跟的是一个列的名字，那么索引也不会被使用。</strong></p>\n<p>（3）如果对大的文本进行搜索，使用全文索引而不用使用 like ‘%…%’。</p>\n<p>（4）如果列名是索引，使用 column_name is null 将使用索引。如下例中查询 name 为 null 的记录就用到了索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name is null\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: ind_company2_name</span><br><span class=\"line\">            key_len: 11</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存在索引但不使用索引\"><a href=\"#存在索引但不使用索引\" class=\"headerlink\" title=\"存在索引但不使用索引\"></a>存在索引但不使用索引</h3><p>在下列情况下，虽然存在索引，但是 MySQL 并不会使用相应的索引。</p>\n<p>（1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如如果列 key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90;</span><br></pre></td></tr></table></figure>\n\n<p>（2）如果使用 MEMORY&#x2F;HEAP 表并且 where 条件中不使用“&#x3D;”进行索引列，那么不会用到索引。heap 表只有在“&#x3D;”的条件下才会使用索引。</p>\n<p>（3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show index from sales\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">              Table: sales</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales_year</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: year</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: NULL</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null:</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从上面可以发现只有 year 列上面有索引，来看如下的执行计划：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales where year = 2001 or country = &#x27;China&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: ind_sales_year</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 12</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可见虽然在 year 这个列上存在索引 <code>ind_sales_year</code>，但是这个 SQL 语句并没有用到这个索引，原因就是 or 中有一个条件中的列没有索引。</p>\n<p>（4）如果不是索引列的第一部分，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where moneys = 1\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可见虽然在 money 上面建有复合索引，但是由于 money 不是索引的第一列，那么在查询中这个索引也不会被 MySQL 采用。</p>\n<p>（5）如果 like 是以 <code>%</code> 开始，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name like &#x27;%3&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可见虽然在 name 上建有索引，但是由于 where 条件中 like 的值的“%”在第一位了，那么 MySQL 也不会采用这个索引。</p>\n<p>（6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为，MySQL 默认把输入的常量值进行转换以后才进行检索。如下面的例子中 company2 表中的 name 字段是字符型的，但是 SQL 语句中的条件值 294 是一个数值型值，因此即便在 name 上有索引，MySQL 也不能正确地用上索引，而是继续进行全表扫描。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name = 294\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from company2 where name = &#x27;294&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: ind_company2_name</span><br><span class=\"line\">            key_len: 23</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中可以看到，第一个 SQL 语句中把一个数值型常量赋值给了一个字符型的列 name，那么虽然在 name 列上有索引，但是也没有用到；而第二个 SQL 语句就可以正确使用索引。</p>\n<h2 id=\"查看索引使用情况\"><a href=\"#查看索引使用情况\" class=\"headerlink\" title=\"查看索引使用情况\"></a>查看索引使用情况</h2><p>如果索引正在工作，<code>Handler_read_key</code> 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p>\n<p><code>Handler_read_rnd_next</code> 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描，<code>Handler_read_rnd_next</code> 的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &#x27;Handler_read%&#x27;;</span><br><span class=\"line\">+------------------------+----------+</span><br><span class=\"line\">|  Variable_name         |  Value   |</span><br><span class=\"line\">+------------------------+----------+</span><br><span class=\"line\">|  Handler_read_first    |  0       |</span><br><span class=\"line\">|  Handler_read_key      |  5       |</span><br><span class=\"line\">|  Handler_read_next     |  0       |</span><br><span class=\"line\">|  Handler_read_prev     |  0       |</span><br><span class=\"line\">|  Handler_read_rnd      |  0       |</span><br><span class=\"line\">|  Handler_read_rnd_next |  2055    |</span><br><span class=\"line\">+------------------------+----------+</span><br><span class=\"line\"></span><br><span class=\"line\">6 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。</p>\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的 SQL 性能问题。接下来将对 MySQL 中的索引的分类、存储、使用方法做详细的介绍。</p>\n<h2 id=\"索引的存储分类\"><a href=\"#索引的存储分类\" class=\"headerlink\" title=\"索引的存储分类\"></a>索引的存储分类</h2><p><strong>MyISAM 存储引擎的表的数据和索引是自动分开存储的，各自是独立的一个文件；InnoDB 存储引擎的表的数据和索引是存储在同一个表空间里面，但可以有多个文件组成。</strong></p>\n<p>MySQL 中索引的存储类型目前只有两种（BTREE 和 HASH），具体和表的存储引擎相关：MyISAM 和 InnoDB 存储引擎都只支持 BTREE 索引；MEMORY&#x2F;HEAP 存储引擎可以支持 HASH 和 BTREE 索引。</p>\n<p>MySQL 目前不支持函数索引，但是能对列的前面某一部分进索引，例如 name 字段，可以只取 name 的前 4 个字符进行索引，这个特性可以大大缩小索引文件的大小，用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。下面是创建前缀索引的一个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create index ind_company2_name on company2(name(4));</span><br><span class=\"line\">Query OK,1000 rows affected(0.03 sec)</span><br><span class=\"line\">Records: 1000  Duplicates: 0   Warnings: 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h2><p><strong>索引用于快速找出在某个列中有一特定值的行。对相关列使用索引是提高 SELECT 操作性能的最佳途径。</strong></p>\n<p><strong>查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。</strong></p>\n<h3 id=\"使用索引\"><a href=\"#使用索引\" class=\"headerlink\" title=\"使用索引\"></a>使用索引</h3><p>在 MySQL 中，下列几种情况下有可能使用到索引。</p>\n<p>（1）对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用，举例说明如下。</p>\n<p><strong>首先按 company_id，moneys 的顺序创建一个复合索引，具体如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create index ind_sales2_companyid_moneys on sales2(company_id, moneys);</span><br><span class=\"line\">Query OK,1000 rows affected(0.03 sec)</span><br><span class=\"line\">Records: 1000  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n<p><strong>然后按 company_id 进行表查询，具体如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where company_id = 2006\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_sales2_companyid_moneys</span><br><span class=\"line\">                key: ind_sales2_companyid_moneys</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p><strong>可以发现即便 where 条件中不是用的 company_id 与 moneys 的组合条件，索引仍然能用到，这就是索引的前缀特性。但是如果只按 moneys 条件查询表，那么索引就不会被用到</strong>，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where moneys = 1\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>（2）对于使用 like 的查询，后面如果是常量并且只有 <code>%</code> 号不在第一个字符，索引才可能会被使用，来看下面两个执行计划：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name like &#x27;%3&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from company2 where name like &#x27;3%&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: range</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: ind_company2_name</span><br><span class=\"line\">            key_len: 11</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 103</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可以发现第一个例子没有使用索引，而第二例子就能够使用索引，区别就在于“%”的位置不同，前者把“%”放到第一位就不能用到索引，而后者没有放到第一位就使用了索引。</p>\n<p><strong>另外，如果 like 后面跟的是一个列的名字，那么索引也不会被使用。</strong></p>\n<p>（3）如果对大的文本进行搜索，使用全文索引而不用使用 like ‘%…%’。</p>\n<p>（4）如果列名是索引，使用 column_name is null 将使用索引。如下例中查询 name 为 null 的记录就用到了索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name is null\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: ind_company2_name</span><br><span class=\"line\">            key_len: 11</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存在索引但不使用索引\"><a href=\"#存在索引但不使用索引\" class=\"headerlink\" title=\"存在索引但不使用索引\"></a>存在索引但不使用索引</h3><p>在下列情况下，虽然存在索引，但是 MySQL 并不会使用相应的索引。</p>\n<p>（1）如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。例如如果列 key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90;</span><br></pre></td></tr></table></figure>\n\n<p>（2）如果使用 MEMORY&#x2F;HEAP 表并且 where 条件中不使用“&#x3D;”进行索引列，那么不会用到索引。heap 表只有在“&#x3D;”的条件下才会使用索引。</p>\n<p>（3）用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show index from sales\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">              Table: sales</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales_year</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: year</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: NULL</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null:</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从上面可以发现只有 year 列上面有索引，来看如下的执行计划：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales where year = 2001 or country = &#x27;China&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: ind_sales_year</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 12</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可见虽然在 year 这个列上存在索引 <code>ind_sales_year</code>，但是这个 SQL 语句并没有用到这个索引，原因就是 or 中有一个条件中的列没有索引。</p>\n<p>（4）如果不是索引列的第一部分，如下例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where moneys = 1\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可见虽然在 money 上面建有复合索引，但是由于 money 不是索引的第一列，那么在查询中这个索引也不会被 MySQL 采用。</p>\n<p>（5）如果 like 是以 <code>%</code> 开始，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name like &#x27;%3&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可见虽然在 name 上建有索引，但是由于 where 条件中 like 的值的“%”在第一位了，那么 MySQL 也不会采用这个索引。</p>\n<p>（6）如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为，MySQL 默认把输入的常量值进行转换以后才进行检索。如下面的例子中 company2 表中的 name 字段是字符型的，但是 SQL 语句中的条件值 294 是一个数值型值，因此即便在 name 上有索引，MySQL 也不能正确地用上索引，而是继续进行全表扫描。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from company2 where name = 294\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select * from company2 where name = &#x27;294&#x27;\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company2_name</span><br><span class=\"line\">                key: ind_company2_name</span><br><span class=\"line\">            key_len: 23</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中可以看到，第一个 SQL 语句中把一个数值型常量赋值给了一个字符型的列 name，那么虽然在 name 列上有索引，但是也没有用到；而第二个 SQL 语句就可以正确使用索引。</p>\n<h2 id=\"查看索引使用情况\"><a href=\"#查看索引使用情况\" class=\"headerlink\" title=\"查看索引使用情况\"></a>查看索引使用情况</h2><p>如果索引正在工作，<code>Handler_read_key</code> 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</p>\n<p><code>Handler_read_rnd_next</code> 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描，<code>Handler_read_rnd_next</code> 的值较高，则通常说明表索引不正确或写入的查询没有利用索引，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &#x27;Handler_read%&#x27;;</span><br><span class=\"line\">+------------------------+----------+</span><br><span class=\"line\">|  Variable_name         |  Value   |</span><br><span class=\"line\">+------------------------+----------+</span><br><span class=\"line\">|  Handler_read_first    |  0       |</span><br><span class=\"line\">|  Handler_read_key      |  5       |</span><br><span class=\"line\">|  Handler_read_next     |  0       |</span><br><span class=\"line\">|  Handler_read_prev     |  0       |</span><br><span class=\"line\">|  Handler_read_rnd      |  0       |</span><br><span class=\"line\">|  Handler_read_rnd_next |  2055    |</span><br><span class=\"line\">+------------------------+----------+</span><br><span class=\"line\"></span><br><span class=\"line\">6 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。</p>\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n"},{"title":"MySQL 中优化 SQL 语句的一般步骤","date":"2019-02-13T02:21:00.000Z","_content":"\n## 前言\n当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。\n\n## show status\n**通过 show status 命令了解各种 SQL 的执行频率。**\n\nMySQL 客户端连接成功后，通过 `show[session|global] status` 命令可以提供服务器状态信息，也可以在操作系统上使用 `mysqladmin extended-status` 命令获得这些消息。`show[session|global] status` 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。**如果不写，默认使用参数是“session”。**\n\n下面的命令显示了当前 session 中所有统计参数的值：\n```\nmysql> show status like 'Com_%';\n+------------------------------+---------+\n|  Variable_name               |  Value  |\n+------------------------------+---------+\n|  Com_admin_commands          |  0      |\n|  Com_alter_db                |  0      |\n|  Com_alter_event             |  0      |\n|  Com_alter_table             |  0      |\n|  Com_analyze                 |  0      |\n|  Com_backup_table            |  0      |\n|  Com_begin                   |  0      |\n|  Com_change_db               |  1      |\n|  Com_change_master           |  0      |\n|  Com_check                   |  0      |\n|  Com_checksum                |  0      |\n|  Com_commit                  |  0      |\n......\n```\nCom_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。\n\n- Com_select：执行 SELECT 操作的次数，一次查询只累加 1。\n- Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。\n- Com_update：执行 UPDATE 操作的次数。\n- Com_delete：执行 DELETE 操作的次数。\n\n上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。\n\n- Innodb_rows_read：执行 SELECT 操作查询返回的行数。\n- Innodb_rows_inserted：执行 INSERT 操作插入的行数。\n- Innodb_rows_updated：执行 UPDATE 操作更新的行数。\n- Innodb_rows_deleted：执行 DELETE 操作删除的行数。\n\n通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。\n\n对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。\n\n此外，以下几个参数便于用户了解数据库的基本情况。\n\n- Connections：试图连接 MySQL 服务器的次数。\n- Uptime：服务器工作时间。\n- Slow_queries：慢查询的次数。\n\n## 定位 SQL 语句\n**可以通过以下两种方式定位执行效率较低的 SQL 语句。**\n\n- 通过慢查询日志定位那些执行效率较低的 SQL 语句，用 `--log-slow-queries[=file_name]` 选项启动时，mysqld 写一个包含所有执行时间超过 `long_query_time` 秒的 SQL 语句的日志文件。\n- 慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 `show processlist` 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。\n\n## EXPLAIN\n**通过 EXPLAIN 分析低效 SQL 的执行计划**\n\n通过以上步骤查询到效率低的 SQL 语句后，可以通过 `EXPLAIN` 或者 `DESC` 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段做求和（sum）操作，相应 SQL 的执行计划如下：\n```\nmysql> explain select sum(moneys) from sales a,company b where a.company_id = b.id and a.year = 2006\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: a\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: b\n               type: ref\n      possible_keys: ind_company_id\n                key: ind_company_id\n            key_len: 5\n                ref: sakila.a.company_id\n               rows: 1\n              Extra: Using where; Using index\n    2 rows in set (0.00 sec)\n```\n每个列的简单解释如下：\n\n- select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等。\n- table：输出结果集的表。\n- type：表示表的连接类型，性能由好到差的连接类型为 system（表中仅有一行，即常量表）、const（单表中最多有一个匹配行，例如 primary key 或者 unique index）、eq_ref（对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index）、ref（与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index，而是使用普通的索引）、ref_or_null（与 ref 类似，区别在于条件中包含对 NULL 的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、range（单表中的范围查询）、index（对于前面的每一行，都通过查询索引来得到数据）、all（对于前面的每一行，都通过全表扫描来得到数据）。\n- possible_keys：表示查询时，可能使用的索引。\n- key：表示实际使用的索引。\n- key_len：索引字段的长度。\n- rows：扫描行的数量。\n- Extra：执行情况的说明和描述。\n\n## 确定问题并采取相应的优化措施\n**经过以上步骤，基本就可以确认问题出现的原因。此时可以根据情况采取相应的措施，进行优化提高执行的效率。**\n\n在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的 year 字段创建索引，具体如下：\n```\nmysql> create index ind_sales2_year on sales2(year);\nQuery OK,1000 rows affected(0.03 sec)\nRecords:1000 Duplicates: 0  Warnings: 0\n```\n创建索引后，再看一下这条语句的执行计划，具体如下：\n```\nmysql> explain select sum(moneys) from sales2 a,company2 b where a.company_id = b.id and a.year = 2006\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: a\n               type: ref\n      possible_keys: ind_sales2_year\n                key: ind_sales2_year\n            key_len: 2\n                ref: const\n               rows: 1\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: b\n               type: ref\n      possible_keys: ind_company_id\n                key: ind_company_id\n            key_len: 5\n                ref: sakila.a.company_id\n               rows: 1\n              Extra: Using where; Using index\n    2 rows in set (0.00 sec)\n```\n可以发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。\n\n> 本文大多摘自《深入浅出MySQL》。","source":"_posts/mysql-sql-optimization.md","raw":"---\ntitle: MySQL 中优化 SQL 语句的一般步骤\ndate: 2019-2-13 10:21:00\ncategories: [开发,数据库]\ntags: [MySQL]\n---\n\n## 前言\n当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。\n\n## show status\n**通过 show status 命令了解各种 SQL 的执行频率。**\n\nMySQL 客户端连接成功后，通过 `show[session|global] status` 命令可以提供服务器状态信息，也可以在操作系统上使用 `mysqladmin extended-status` 命令获得这些消息。`show[session|global] status` 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。**如果不写，默认使用参数是“session”。**\n\n下面的命令显示了当前 session 中所有统计参数的值：\n```\nmysql> show status like 'Com_%';\n+------------------------------+---------+\n|  Variable_name               |  Value  |\n+------------------------------+---------+\n|  Com_admin_commands          |  0      |\n|  Com_alter_db                |  0      |\n|  Com_alter_event             |  0      |\n|  Com_alter_table             |  0      |\n|  Com_analyze                 |  0      |\n|  Com_backup_table            |  0      |\n|  Com_begin                   |  0      |\n|  Com_change_db               |  1      |\n|  Com_change_master           |  0      |\n|  Com_check                   |  0      |\n|  Com_checksum                |  0      |\n|  Com_commit                  |  0      |\n......\n```\nCom_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。\n\n- Com_select：执行 SELECT 操作的次数，一次查询只累加 1。\n- Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。\n- Com_update：执行 UPDATE 操作的次数。\n- Com_delete：执行 DELETE 操作的次数。\n\n上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。\n\n- Innodb_rows_read：执行 SELECT 操作查询返回的行数。\n- Innodb_rows_inserted：执行 INSERT 操作插入的行数。\n- Innodb_rows_updated：执行 UPDATE 操作更新的行数。\n- Innodb_rows_deleted：执行 DELETE 操作删除的行数。\n\n通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。\n\n对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。\n\n此外，以下几个参数便于用户了解数据库的基本情况。\n\n- Connections：试图连接 MySQL 服务器的次数。\n- Uptime：服务器工作时间。\n- Slow_queries：慢查询的次数。\n\n## 定位 SQL 语句\n**可以通过以下两种方式定位执行效率较低的 SQL 语句。**\n\n- 通过慢查询日志定位那些执行效率较低的 SQL 语句，用 `--log-slow-queries[=file_name]` 选项启动时，mysqld 写一个包含所有执行时间超过 `long_query_time` 秒的 SQL 语句的日志文件。\n- 慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 `show processlist` 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。\n\n## EXPLAIN\n**通过 EXPLAIN 分析低效 SQL 的执行计划**\n\n通过以上步骤查询到效率低的 SQL 语句后，可以通过 `EXPLAIN` 或者 `DESC` 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段做求和（sum）操作，相应 SQL 的执行计划如下：\n```\nmysql> explain select sum(moneys) from sales a,company b where a.company_id = b.id and a.year = 2006\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: a\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: b\n               type: ref\n      possible_keys: ind_company_id\n                key: ind_company_id\n            key_len: 5\n                ref: sakila.a.company_id\n               rows: 1\n              Extra: Using where; Using index\n    2 rows in set (0.00 sec)\n```\n每个列的简单解释如下：\n\n- select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等。\n- table：输出结果集的表。\n- type：表示表的连接类型，性能由好到差的连接类型为 system（表中仅有一行，即常量表）、const（单表中最多有一个匹配行，例如 primary key 或者 unique index）、eq_ref（对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index）、ref（与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index，而是使用普通的索引）、ref_or_null（与 ref 类似，区别在于条件中包含对 NULL 的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、range（单表中的范围查询）、index（对于前面的每一行，都通过查询索引来得到数据）、all（对于前面的每一行，都通过全表扫描来得到数据）。\n- possible_keys：表示查询时，可能使用的索引。\n- key：表示实际使用的索引。\n- key_len：索引字段的长度。\n- rows：扫描行的数量。\n- Extra：执行情况的说明和描述。\n\n## 确定问题并采取相应的优化措施\n**经过以上步骤，基本就可以确认问题出现的原因。此时可以根据情况采取相应的措施，进行优化提高执行的效率。**\n\n在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的 year 字段创建索引，具体如下：\n```\nmysql> create index ind_sales2_year on sales2(year);\nQuery OK,1000 rows affected(0.03 sec)\nRecords:1000 Duplicates: 0  Warnings: 0\n```\n创建索引后，再看一下这条语句的执行计划，具体如下：\n```\nmysql> explain select sum(moneys) from sales2 a,company2 b where a.company_id = b.id and a.year = 2006\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: a\n               type: ref\n      possible_keys: ind_sales2_year\n                key: ind_sales2_year\n            key_len: 2\n                ref: const\n               rows: 1\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: b\n               type: ref\n      possible_keys: ind_company_id\n                key: ind_company_id\n            key_len: 5\n                ref: sakila.a.company_id\n               rows: 1\n              Extra: Using where; Using index\n    2 rows in set (0.00 sec)\n```\n可以发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。\n\n> 本文大多摘自《深入浅出MySQL》。","slug":"mysql-sql-optimization","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhl0086k9i1be797xe4","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p>\n<h2 id=\"show-status\"><a href=\"#show-status\" class=\"headerlink\" title=\"show status\"></a>show status</h2><p><strong>通过 show status 命令了解各种 SQL 的执行频率。</strong></p>\n<p>MySQL 客户端连接成功后，通过 <code>show[session|global] status</code> 命令可以提供服务器状态信息，也可以在操作系统上使用 <code>mysqladmin extended-status</code> 命令获得这些消息。<code>show[session|global] status</code> 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。<strong>如果不写，默认使用参数是“session”。</strong></p>\n<p>下面的命令显示了当前 session 中所有统计参数的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &#x27;Com_%&#x27;;</span><br><span class=\"line\">+------------------------------+---------+</span><br><span class=\"line\">|  Variable_name               |  Value  |</span><br><span class=\"line\">+------------------------------+---------+</span><br><span class=\"line\">|  Com_admin_commands          |  0      |</span><br><span class=\"line\">|  Com_alter_db                |  0      |</span><br><span class=\"line\">|  Com_alter_event             |  0      |</span><br><span class=\"line\">|  Com_alter_table             |  0      |</span><br><span class=\"line\">|  Com_analyze                 |  0      |</span><br><span class=\"line\">|  Com_backup_table            |  0      |</span><br><span class=\"line\">|  Com_begin                   |  0      |</span><br><span class=\"line\">|  Com_change_db               |  1      |</span><br><span class=\"line\">|  Com_change_master           |  0      |</span><br><span class=\"line\">|  Com_check                   |  0      |</span><br><span class=\"line\">|  Com_checksum                |  0      |</span><br><span class=\"line\">|  Com_commit                  |  0      |</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p>\n<ul>\n<li>Com_select：执行 SELECT 操作的次数，一次查询只累加 1。</li>\n<li>Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</li>\n<li>Com_update：执行 UPDATE 操作的次数。</li>\n<li>Com_delete：执行 DELETE 操作的次数。</li>\n</ul>\n<p>上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。</p>\n<ul>\n<li>Innodb_rows_read：执行 SELECT 操作查询返回的行数。</li>\n<li>Innodb_rows_inserted：执行 INSERT 操作插入的行数。</li>\n<li>Innodb_rows_updated：执行 UPDATE 操作更新的行数。</li>\n<li>Innodb_rows_deleted：执行 DELETE 操作删除的行数。</li>\n</ul>\n<p>通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。</p>\n<p>对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p>\n<p>此外，以下几个参数便于用户了解数据库的基本情况。</p>\n<ul>\n<li>Connections：试图连接 MySQL 服务器的次数。</li>\n<li>Uptime：服务器工作时间。</li>\n<li>Slow_queries：慢查询的次数。</li>\n</ul>\n<h2 id=\"定位-SQL-语句\"><a href=\"#定位-SQL-语句\" class=\"headerlink\" title=\"定位 SQL 语句\"></a>定位 SQL 语句</h2><p><strong>可以通过以下两种方式定位执行效率较低的 SQL 语句。</strong></p>\n<ul>\n<li>通过慢查询日志定位那些执行效率较低的 SQL 语句，用 <code>--log-slow-queries[=file_name]</code> 选项启动时，mysqld 写一个包含所有执行时间超过 <code>long_query_time</code> 秒的 SQL 语句的日志文件。</li>\n<li>慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 <code>show processlist</code> 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li>\n</ul>\n<h2 id=\"EXPLAIN\"><a href=\"#EXPLAIN\" class=\"headerlink\" title=\"EXPLAIN\"></a>EXPLAIN</h2><p><strong>通过 EXPLAIN 分析低效 SQL 的执行计划</strong></p>\n<p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 <code>EXPLAIN</code> 或者 <code>DESC</code> 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段做求和（sum）操作，相应 SQL 的执行计划如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select sum(moneys) from sales a,company b where a.company_id = b.id and a.year = 2006\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: a</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: b</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company_id</span><br><span class=\"line\">                key: ind_company_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: sakila.a.company_id</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where; Using index</span><br><span class=\"line\">    2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>每个列的简单解释如下：</p>\n<ul>\n<li>select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等。</li>\n<li>table：输出结果集的表。</li>\n<li>type：表示表的连接类型，性能由好到差的连接类型为 system（表中仅有一行，即常量表）、const（单表中最多有一个匹配行，例如 primary key 或者 unique index）、eq_ref（对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index）、ref（与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index，而是使用普通的索引）、ref_or_null（与 ref 类似，区别在于条件中包含对 NULL 的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、range（单表中的范围查询）、index（对于前面的每一行，都通过查询索引来得到数据）、all（对于前面的每一行，都通过全表扫描来得到数据）。</li>\n<li>possible_keys：表示查询时，可能使用的索引。</li>\n<li>key：表示实际使用的索引。</li>\n<li>key_len：索引字段的长度。</li>\n<li>rows：扫描行的数量。</li>\n<li>Extra：执行情况的说明和描述。</li>\n</ul>\n<h2 id=\"确定问题并采取相应的优化措施\"><a href=\"#确定问题并采取相应的优化措施\" class=\"headerlink\" title=\"确定问题并采取相应的优化措施\"></a>确定问题并采取相应的优化措施</h2><p><strong>经过以上步骤，基本就可以确认问题出现的原因。此时可以根据情况采取相应的措施，进行优化提高执行的效率。</strong></p>\n<p>在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的 year 字段创建索引，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create index ind_sales2_year on sales2(year);</span><br><span class=\"line\">Query OK,1000 rows affected(0.03 sec)</span><br><span class=\"line\">Records:1000 Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n<p>创建索引后，再看一下这条语句的执行计划，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select sum(moneys) from sales2 a,company2 b where a.company_id = b.id and a.year = 2006\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: a</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_sales2_year</span><br><span class=\"line\">                key: ind_sales2_year</span><br><span class=\"line\">            key_len: 2</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: b</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company_id</span><br><span class=\"line\">                key: ind_company_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: sakila.a.company_id</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where; Using index</span><br><span class=\"line\">    2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可以发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。</p>\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p>\n<h2 id=\"show-status\"><a href=\"#show-status\" class=\"headerlink\" title=\"show status\"></a>show status</h2><p><strong>通过 show status 命令了解各种 SQL 的执行频率。</strong></p>\n<p>MySQL 客户端连接成功后，通过 <code>show[session|global] status</code> 命令可以提供服务器状态信息，也可以在操作系统上使用 <code>mysqladmin extended-status</code> 命令获得这些消息。<code>show[session|global] status</code> 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。<strong>如果不写，默认使用参数是“session”。</strong></p>\n<p>下面的命令显示了当前 session 中所有统计参数的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &#x27;Com_%&#x27;;</span><br><span class=\"line\">+------------------------------+---------+</span><br><span class=\"line\">|  Variable_name               |  Value  |</span><br><span class=\"line\">+------------------------------+---------+</span><br><span class=\"line\">|  Com_admin_commands          |  0      |</span><br><span class=\"line\">|  Com_alter_db                |  0      |</span><br><span class=\"line\">|  Com_alter_event             |  0      |</span><br><span class=\"line\">|  Com_alter_table             |  0      |</span><br><span class=\"line\">|  Com_analyze                 |  0      |</span><br><span class=\"line\">|  Com_backup_table            |  0      |</span><br><span class=\"line\">|  Com_begin                   |  0      |</span><br><span class=\"line\">|  Com_change_db               |  1      |</span><br><span class=\"line\">|  Com_change_master           |  0      |</span><br><span class=\"line\">|  Com_check                   |  0      |</span><br><span class=\"line\">|  Com_checksum                |  0      |</span><br><span class=\"line\">|  Com_commit                  |  0      |</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p>\n<ul>\n<li>Com_select：执行 SELECT 操作的次数，一次查询只累加 1。</li>\n<li>Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</li>\n<li>Com_update：执行 UPDATE 操作的次数。</li>\n<li>Com_delete：执行 DELETE 操作的次数。</li>\n</ul>\n<p>上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。</p>\n<ul>\n<li>Innodb_rows_read：执行 SELECT 操作查询返回的行数。</li>\n<li>Innodb_rows_inserted：执行 INSERT 操作插入的行数。</li>\n<li>Innodb_rows_updated：执行 UPDATE 操作更新的行数。</li>\n<li>Innodb_rows_deleted：执行 DELETE 操作删除的行数。</li>\n</ul>\n<p>通过以上几个参数，可以很容易地了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的 SQL 大致的执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。</p>\n<p>对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。</p>\n<p>此外，以下几个参数便于用户了解数据库的基本情况。</p>\n<ul>\n<li>Connections：试图连接 MySQL 服务器的次数。</li>\n<li>Uptime：服务器工作时间。</li>\n<li>Slow_queries：慢查询的次数。</li>\n</ul>\n<h2 id=\"定位-SQL-语句\"><a href=\"#定位-SQL-语句\" class=\"headerlink\" title=\"定位 SQL 语句\"></a>定位 SQL 语句</h2><p><strong>可以通过以下两种方式定位执行效率较低的 SQL 语句。</strong></p>\n<ul>\n<li>通过慢查询日志定位那些执行效率较低的 SQL 语句，用 <code>--log-slow-queries[=file_name]</code> 选项启动时，mysqld 写一个包含所有执行时间超过 <code>long_query_time</code> 秒的 SQL 语句的日志文件。</li>\n<li>慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 <code>show processlist</code> 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li>\n</ul>\n<h2 id=\"EXPLAIN\"><a href=\"#EXPLAIN\" class=\"headerlink\" title=\"EXPLAIN\"></a>EXPLAIN</h2><p><strong>通过 EXPLAIN 分析低效 SQL 的执行计划</strong></p>\n<p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 <code>EXPLAIN</code> 或者 <code>DESC</code> 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想计算 2006 年所有公司的销售额，需要关联 sales 表和 company 表，并且对 moneys 字段做求和（sum）操作，相应 SQL 的执行计划如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select sum(moneys) from sales a,company b where a.company_id = b.id and a.year = 2006\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: a</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: b</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company_id</span><br><span class=\"line\">                key: ind_company_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: sakila.a.company_id</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where; Using index</span><br><span class=\"line\">    2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>每个列的简单解释如下：</p>\n<ul>\n<li>select_type：表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等。</li>\n<li>table：输出结果集的表。</li>\n<li>type：表示表的连接类型，性能由好到差的连接类型为 system（表中仅有一行，即常量表）、const（单表中最多有一个匹配行，例如 primary key 或者 unique index）、eq_ref（对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用 primary key 或者 unique index）、ref（与 eq_ref 类似，区别在于不是使用 primary key 或者 unique index，而是使用普通的索引）、ref_or_null（与 ref 类似，区别在于条件中包含对 NULL 的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与 unique_subquery 类似，区别在于 in 的后面是查询非唯一索引字段的子查询）、range（单表中的范围查询）、index（对于前面的每一行，都通过查询索引来得到数据）、all（对于前面的每一行，都通过全表扫描来得到数据）。</li>\n<li>possible_keys：表示查询时，可能使用的索引。</li>\n<li>key：表示实际使用的索引。</li>\n<li>key_len：索引字段的长度。</li>\n<li>rows：扫描行的数量。</li>\n<li>Extra：执行情况的说明和描述。</li>\n</ul>\n<h2 id=\"确定问题并采取相应的优化措施\"><a href=\"#确定问题并采取相应的优化措施\" class=\"headerlink\" title=\"确定问题并采取相应的优化措施\"></a>确定问题并采取相应的优化措施</h2><p><strong>经过以上步骤，基本就可以确认问题出现的原因。此时可以根据情况采取相应的措施，进行优化提高执行的效率。</strong></p>\n<p>在上面的例子中，已经可以确认是对 a 表的全表扫描导致效率的不理想，那么对 a 表的 year 字段创建索引，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create index ind_sales2_year on sales2(year);</span><br><span class=\"line\">Query OK,1000 rows affected(0.03 sec)</span><br><span class=\"line\">Records:1000 Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>\n<p>创建索引后，再看一下这条语句的执行计划，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select sum(moneys) from sales2 a,company2 b where a.company_id = b.id and a.year = 2006\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: a</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_sales2_year</span><br><span class=\"line\">                key: ind_sales2_year</span><br><span class=\"line\">            key_len: 2</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: b</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company_id</span><br><span class=\"line\">                key: ind_company_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: sakila.a.company_id</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where; Using index</span><br><span class=\"line\">    2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可以发现建立索引后对 a 表需要扫描的行数明显减少（从 1000 行减少到 1 行），可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候这种优势更为明显。</p>\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n"},{"title":"MySQL 中常用 SQL 的优化","date":"2019-02-13T07:16:46.000Z","_content":"\n## 前言\n之前介绍了 MySQL 中怎么样通过索引来优化查询。日常开发中，除了使用查询外，我们还会使用一些其他的常用 SQL，比如 INSERT、GROUP BY 等。对于这些 SQL 语句，我们该怎么样进行优化呢？接下来将针对这些 SQL 语句介绍一些优化的方法。\n\n## 大批量插入数据\n当用 load 命令导入数据的时候，适当的设置可以提高导入的速度。\n\n对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。\n```\nALTER TABLE tbl_name DISABLE KEYS;\nloading the data\nALTER TABLE tbl_name ENABLE KEYS;\n```\n`DISABLE KEYS` 和 `ENABLE KEYS` 用来打开或者关闭 MyISAM 表非唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的 MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。\n\n下面例子中，用 LOAD 语句导入数据耗时 115.12 秒：\n```\nmysql> load data infile '/home/mysql/film_test.txt' into table film_test2;\nQuery OK,529056 rows affected(1 min 55.12 sec)\nRecords: 529056  Deleted: 0  Skipped: 0  Warning: 0\n```\n而用 `alter table tbl_name disable keys` 方式总耗时 6.34+12.25 = 18.59 秒，提高了 6 倍多。\n```\nmysql> alter table film_test2 disable keys;\nQuery OK,0 rows affected(0.00 sec)\n\nmysql> load data infile '/home/mysql/film_test.txt' into table film_test2;\nQuery OK,529056 rows affected(6.34 sec)\nRecords: 529056  Deleted: 0  Skipped: 0  Warnings: 0\n\nmysql> alter table film_test2 enable keys;\nQuery OK,0 rows affected(12.25 sec)\n```\n上面是对 MyISAM 表进行数据导入时的优化措施，对于 InnoDB 类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高 InnoDB 表的导入效率。\n\n（1）因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效地提高导入数据的效率。\n\n例如，下面文本 film_test3.txt 是按表 film_tst4 的主键存储的，那么导入的时候共耗时 27.92 秒。\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(22.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n而下面的 film_test4.txt 是没有任何顺序的文本，那么导入的时候共耗时 31.16 秒。\n```\nmysql> load data infile '/home/mysql/film_test4.txt' into table film_test4;\nQuery OK,1587168 rows affected(31.16 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n从上面的例子可以看出当被导入的文件按表主键顺序存储的时候比不按主键顺序存储的时候快 1.12 倍。\n\n（2）在导入数据前执行 `SET UNIQUE_CHECKS=0`，关闭唯一性校验，在导入结束后执行 `SET UNIQUE_CHECK=1`，恢复唯一性校验，可以提高导入的效率。\n\n例如，当 UNIQUE_CHECKS=1 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(22.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n当 SET UNIQUE_CHECKS=0 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(19.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n可见比 UNIQUE_CHECKS=0 的时候比 SET UNIQUE_CHECKS=1 的时候要快一些。\n\n（3）如果应用使用自动提交的方式，建议在导入前执行 `SET AUTOCOMMIT=0`，关闭自动提交，导入结束后再执行 `SET AUTOCOMMIT=1`，打开自动提交，也可以提高导入的效率。\n\n例如，当 AUTOCOMMIT=1 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(22.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n当 AUTOCOMMIT=0 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(20.87 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n对比一下可以知道，当 AUTOCOMMIT=0 时比 AUTOCOMMIT=1 时导入数据要快一些。\n\n## 优化 INSERT 语句\n当进行数据 INSERT 的时候，可以考虑采用以下几种优化方式。\n\n- 如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语句快（在一些情况中几倍）。下面是一次插入多值的一个例子：\n```\ninsert into test values(1,2),(1,3),(1,4)...\n```\n- 如果从不同客户插入很多行，能通过使用 `INSERT DELAYED` 语句得到更高的速度。DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘，这比每条语句分别插入要快得多；`LOW_PRIORITY` 刚好相反，在所有其他用户对表的读写完后才进行插入；\n- 将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；\n- 如果进行批量插入，可以增加 `bulk_insert_buffer_size` 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用；\n- 当从一个文本文件装载一个表时，使用 `LOAD DATA INFILE`。这通常比使用很多 INSERT 语句快 20 倍。\n\n## 优化 GROUP BY 语句\n默认情况下，MySQL 对所有 GROUP BY col1，col2...的字段进行排序。这与在查询中指定 ORDER BY col1，col2...类似。因此，如果显式包括一个包含相同的列的 ORDER BY 子句，则对 MySQL 的实际执行性能没有什么影响。\n\n如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL 禁止排序，如下面的例子：\n```\nmysql> explain select id, sum(moneys) from sales2 group by id\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using temporary; Using filesort\n    1 row in set(0.00 sec)\n\nmysql> explain select id, sum(moneys) from sales2 group by id order by null\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using temporary\n```\n从上面的例子可以看出第一个 SQL 语句需要进行“filesort”，而第二个 SQL 由于 ORDER BY NULL 不需要进行“filesort”，而 filesort 往往非常耗费时间。\n\n## 优化 ORDER BY 语句\n在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。WHERE 条件和 ORDER BY 使用相同的索引，并且 ORDER BY 的顺序和索引顺序相同，并且 ORDER BY 的字段都是升序或者都是降序。\n\n例如，下列 SQL 可以使用索引：\n```\nSELECT * FROM t1 ORDER BY key_part1,key_part2,...;\nSELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;\nSELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;\n```\n但是在以下几种情况下则不使用索引：\n```\nSELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;  --order by 的字段混合 ASC 和 DESC\nSELECT * FROM t1 WHERE key2=constant ORDER BY key1;  --用于查询行的关键字与 ORDER BY 中所使用的不相同\nSELECT * FROM t1 ORDER BY key1, key2;  --对不同的关键字使用 ORDER BY\n```\n\n## 优化嵌套查询\nMySQL 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性地完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。\n\n在下面的例子中，要从 sales2 表中找到那些在 company2 表中不存在的所有公司的信息：\n```\nmysql> explain select * from sales2 where company_id not in (select id from company2)\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: PRIMARY\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 2\n        select_type: DEPENDENT SUBQUERY\n              table: company2\n               type: index_subquery\n      possible_keys: ind_company2_id\n                key: ind_company2_id\n            key_len: 5\n                ref: func\n               rows: 2\n              Extra: Using index\n\n   2 rows in set(0.00 sec)\n```\n如果使用连接（JOIN）来完成这个查询工作，速度将会快很多。尤其是当 company2 表中对 id 建有索引的话，性能将会更好，具体查询如下：\n```\nmysql> explain select * from sales2 left join company2 on sales2.company_id = company2.id where sales2.company_id is null\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ref\n      possible_keys: ind_sales2_companyid_moneys\n                key: ind_sales2_companyid_moneys\n            key_len: 5\n                ref: const\n               rows: 1\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ref\n      possible_keys: ind_company2_id\n                key: ind_company2_id\n            key_len: 5\n                ref: sakila.sales2.company_id\n               rows: 1\n              Extra: \n   2 rows in set(0.00 sec)\n```\n从执行计划中可以明显看出查询扫描的记录范围和使用索引的情况都有了很大的改善。\n\n**连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。**\n\n## 优化 OR 条件\n**对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。**\n\n例如，首先使用 `show index` 命令查看表 sales2 的索引，可知它有 3 个索引，在 id、year 两个字段上分别有 1 个独立的索引，在 company_id 和 year 字段上有 1 个复合索引。\n```\nmysql> show index from sales2\\G;\n    **************************** 1. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_id\n       Seq_in_index: 1\n        Column_name: id\n          Collation: A\n        Cardinality: 1000\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    **************************** 2. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_year\n       Seq_in_index: 1\n        Column_name: year\n          Collation: A\n        Cardinality: 250\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    **************************** 3. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_companyid_moneys\n       Seq_in_index: 1\n        Column_name: company_id\n          Collation: A\n        Cardinality: 1000\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    **************************** 4. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_companyid_moneys\n       Seq_in_index: 2\n        Column_name: year\n          Collation: A\n        Cardinality: 1000\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    4 rows in set(0.00 sec)\n```\n然后在两个独立索引上面做 OR 操作，具体如下：\n```\nmysql> explain select * from sales2 where id = 2 or year = 1998\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: index_merge\n      possible_keys: ind_sales2_id,ind_sales2_year\n                key: ind_sales2_id,ind_sales2_year\n            key_len: 5,2\n                ref: NULL\n               rows: 2\n              Extra: Using union(ind_sales2_id,ind_sales2_year); Using where\n    1 row in set(0.00 sec)\n```\n可以发现查询正确的用到了索引，并且从执行计划的描述中，**发现 MySQL 在处理含有 OR 子句的查询时，实际是对 OR 的各个字段分别查询后的结果进行了 UNION。**\n\n但是当在建有复合索引的列 company_id 和 moneys 上面做 OR 操作的时候，却不能用到索引，具体结果如下：\n```\nmysql> explain select * from sales2 where company_id = 3 or moneys = 100\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: ind_sales2_companyid_moneys\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n\n> 本文大多摘自《深入浅出MySQL》。","source":"_posts/mysql-sql.md","raw":"---\ntitle: MySQL 中常用 SQL 的优化\ndate: 2019-2-13 15:16:46\ncategories: [开发,数据库]\ntags: [MySQL]\n---\n\n## 前言\n之前介绍了 MySQL 中怎么样通过索引来优化查询。日常开发中，除了使用查询外，我们还会使用一些其他的常用 SQL，比如 INSERT、GROUP BY 等。对于这些 SQL 语句，我们该怎么样进行优化呢？接下来将针对这些 SQL 语句介绍一些优化的方法。\n\n## 大批量插入数据\n当用 load 命令导入数据的时候，适当的设置可以提高导入的速度。\n\n对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。\n```\nALTER TABLE tbl_name DISABLE KEYS;\nloading the data\nALTER TABLE tbl_name ENABLE KEYS;\n```\n`DISABLE KEYS` 和 `ENABLE KEYS` 用来打开或者关闭 MyISAM 表非唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的 MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。\n\n下面例子中，用 LOAD 语句导入数据耗时 115.12 秒：\n```\nmysql> load data infile '/home/mysql/film_test.txt' into table film_test2;\nQuery OK,529056 rows affected(1 min 55.12 sec)\nRecords: 529056  Deleted: 0  Skipped: 0  Warning: 0\n```\n而用 `alter table tbl_name disable keys` 方式总耗时 6.34+12.25 = 18.59 秒，提高了 6 倍多。\n```\nmysql> alter table film_test2 disable keys;\nQuery OK,0 rows affected(0.00 sec)\n\nmysql> load data infile '/home/mysql/film_test.txt' into table film_test2;\nQuery OK,529056 rows affected(6.34 sec)\nRecords: 529056  Deleted: 0  Skipped: 0  Warnings: 0\n\nmysql> alter table film_test2 enable keys;\nQuery OK,0 rows affected(12.25 sec)\n```\n上面是对 MyISAM 表进行数据导入时的优化措施，对于 InnoDB 类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高 InnoDB 表的导入效率。\n\n（1）因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效地提高导入数据的效率。\n\n例如，下面文本 film_test3.txt 是按表 film_tst4 的主键存储的，那么导入的时候共耗时 27.92 秒。\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(22.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n而下面的 film_test4.txt 是没有任何顺序的文本，那么导入的时候共耗时 31.16 秒。\n```\nmysql> load data infile '/home/mysql/film_test4.txt' into table film_test4;\nQuery OK,1587168 rows affected(31.16 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n从上面的例子可以看出当被导入的文件按表主键顺序存储的时候比不按主键顺序存储的时候快 1.12 倍。\n\n（2）在导入数据前执行 `SET UNIQUE_CHECKS=0`，关闭唯一性校验，在导入结束后执行 `SET UNIQUE_CHECK=1`，恢复唯一性校验，可以提高导入的效率。\n\n例如，当 UNIQUE_CHECKS=1 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(22.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n当 SET UNIQUE_CHECKS=0 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(19.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n可见比 UNIQUE_CHECKS=0 的时候比 SET UNIQUE_CHECKS=1 的时候要快一些。\n\n（3）如果应用使用自动提交的方式，建议在导入前执行 `SET AUTOCOMMIT=0`，关闭自动提交，导入结束后再执行 `SET AUTOCOMMIT=1`，打开自动提交，也可以提高导入的效率。\n\n例如，当 AUTOCOMMIT=1 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(22.92 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n当 AUTOCOMMIT=0 时：\n```\nmysql> load data infile '/home/mysql/film_test3.txt' into table film_test4;\nQuery OK,1587168 rows affected(20.87 sec)\nRecords: 1587168  Deleted: 0  Skipped: 0  Warning: 0\n```\n对比一下可以知道，当 AUTOCOMMIT=0 时比 AUTOCOMMIT=1 时导入数据要快一些。\n\n## 优化 INSERT 语句\n当进行数据 INSERT 的时候，可以考虑采用以下几种优化方式。\n\n- 如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语句快（在一些情况中几倍）。下面是一次插入多值的一个例子：\n```\ninsert into test values(1,2),(1,3),(1,4)...\n```\n- 如果从不同客户插入很多行，能通过使用 `INSERT DELAYED` 语句得到更高的速度。DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘，这比每条语句分别插入要快得多；`LOW_PRIORITY` 刚好相反，在所有其他用户对表的读写完后才进行插入；\n- 将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；\n- 如果进行批量插入，可以增加 `bulk_insert_buffer_size` 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用；\n- 当从一个文本文件装载一个表时，使用 `LOAD DATA INFILE`。这通常比使用很多 INSERT 语句快 20 倍。\n\n## 优化 GROUP BY 语句\n默认情况下，MySQL 对所有 GROUP BY col1，col2...的字段进行排序。这与在查询中指定 ORDER BY col1，col2...类似。因此，如果显式包括一个包含相同的列的 ORDER BY 子句，则对 MySQL 的实际执行性能没有什么影响。\n\n如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL 禁止排序，如下面的例子：\n```\nmysql> explain select id, sum(moneys) from sales2 group by id\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using temporary; Using filesort\n    1 row in set(0.00 sec)\n\nmysql> explain select id, sum(moneys) from sales2 group by id order by null\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using temporary\n```\n从上面的例子可以看出第一个 SQL 语句需要进行“filesort”，而第二个 SQL 由于 ORDER BY NULL 不需要进行“filesort”，而 filesort 往往非常耗费时间。\n\n## 优化 ORDER BY 语句\n在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。WHERE 条件和 ORDER BY 使用相同的索引，并且 ORDER BY 的顺序和索引顺序相同，并且 ORDER BY 的字段都是升序或者都是降序。\n\n例如，下列 SQL 可以使用索引：\n```\nSELECT * FROM t1 ORDER BY key_part1,key_part2,...;\nSELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;\nSELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;\n```\n但是在以下几种情况下则不使用索引：\n```\nSELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;  --order by 的字段混合 ASC 和 DESC\nSELECT * FROM t1 WHERE key2=constant ORDER BY key1;  --用于查询行的关键字与 ORDER BY 中所使用的不相同\nSELECT * FROM t1 ORDER BY key1, key2;  --对不同的关键字使用 ORDER BY\n```\n\n## 优化嵌套查询\nMySQL 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性地完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。\n\n在下面的例子中，要从 sales2 表中找到那些在 company2 表中不存在的所有公司的信息：\n```\nmysql> explain select * from sales2 where company_id not in (select id from company2)\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: PRIMARY\n              table: sales2\n               type: ALL\n      possible_keys: NULL\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 2\n        select_type: DEPENDENT SUBQUERY\n              table: company2\n               type: index_subquery\n      possible_keys: ind_company2_id\n                key: ind_company2_id\n            key_len: 5\n                ref: func\n               rows: 2\n              Extra: Using index\n\n   2 rows in set(0.00 sec)\n```\n如果使用连接（JOIN）来完成这个查询工作，速度将会快很多。尤其是当 company2 表中对 id 建有索引的话，性能将会更好，具体查询如下：\n```\nmysql> explain select * from sales2 left join company2 on sales2.company_id = company2.id where sales2.company_id is null\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ref\n      possible_keys: ind_sales2_companyid_moneys\n                key: ind_sales2_companyid_moneys\n            key_len: 5\n                ref: const\n               rows: 1\n              Extra: Using where\n    **************************** 2. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: company2\n               type: ref\n      possible_keys: ind_company2_id\n                key: ind_company2_id\n            key_len: 5\n                ref: sakila.sales2.company_id\n               rows: 1\n              Extra: \n   2 rows in set(0.00 sec)\n```\n从执行计划中可以明显看出查询扫描的记录范围和使用索引的情况都有了很大的改善。\n\n**连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。**\n\n## 优化 OR 条件\n**对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。**\n\n例如，首先使用 `show index` 命令查看表 sales2 的索引，可知它有 3 个索引，在 id、year 两个字段上分别有 1 个独立的索引，在 company_id 和 year 字段上有 1 个复合索引。\n```\nmysql> show index from sales2\\G;\n    **************************** 1. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_id\n       Seq_in_index: 1\n        Column_name: id\n          Collation: A\n        Cardinality: 1000\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    **************************** 2. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_year\n       Seq_in_index: 1\n        Column_name: year\n          Collation: A\n        Cardinality: 250\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    **************************** 3. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_companyid_moneys\n       Seq_in_index: 1\n        Column_name: company_id\n          Collation: A\n        Cardinality: 1000\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    **************************** 4. row *************************************\n              Table: sales2\n         Non_unique: 1\n           Key_name: ind_sales2_companyid_moneys\n       Seq_in_index: 2\n        Column_name: year\n          Collation: A\n        Cardinality: 1000\n           Sub_part: NULL\n             Packed: NULL\n               Null: YES\n         Index_type: BTREE\n            Comment:\n    4 rows in set(0.00 sec)\n```\n然后在两个独立索引上面做 OR 操作，具体如下：\n```\nmysql> explain select * from sales2 where id = 2 or year = 1998\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: index_merge\n      possible_keys: ind_sales2_id,ind_sales2_year\n                key: ind_sales2_id,ind_sales2_year\n            key_len: 5,2\n                ref: NULL\n               rows: 2\n              Extra: Using union(ind_sales2_id,ind_sales2_year); Using where\n    1 row in set(0.00 sec)\n```\n可以发现查询正确的用到了索引，并且从执行计划的描述中，**发现 MySQL 在处理含有 OR 子句的查询时，实际是对 OR 的各个字段分别查询后的结果进行了 UNION。**\n\n但是当在建有复合索引的列 company_id 和 moneys 上面做 OR 操作的时候，却不能用到索引，具体结果如下：\n```\nmysql> explain select * from sales2 where company_id = 3 or moneys = 100\\G;\n    **************************** 1. row *************************************\n                 id: 1\n        select_type: SIMPLE\n              table: sales2\n               type: ALL\n      possible_keys: ind_sales2_companyid_moneys\n                key: NULL\n            key_len: NULL\n                ref: NULL\n               rows: 1000\n              Extra: Using where\n    1 row in set(0.00 sec)\n```\n\n> 本文大多摘自《深入浅出MySQL》。","slug":"mysql-sql","published":1,"updated":"2023-12-23T15:35:23.828Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhl0089k9i1abom2a4j","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前介绍了 MySQL 中怎么样通过索引来优化查询。日常开发中，除了使用查询外，我们还会使用一些其他的常用 SQL，比如 INSERT、GROUP BY 等。对于这些 SQL 语句，我们该怎么样进行优化呢？接下来将针对这些 SQL 语句介绍一些优化的方法。</p>\n<h2 id=\"大批量插入数据\"><a href=\"#大批量插入数据\" class=\"headerlink\" title=\"大批量插入数据\"></a>大批量插入数据</h2><p>当用 load 命令导入数据的时候，适当的设置可以提高导入的速度。</p>\n<p>对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl_name DISABLE KEYS;</span><br><span class=\"line\">loading the data</span><br><span class=\"line\">ALTER TABLE tbl_name ENABLE KEYS;</span><br></pre></td></tr></table></figure>\n<p><code>DISABLE KEYS</code> 和 <code>ENABLE KEYS</code> 用来打开或者关闭 MyISAM 表非唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的 MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p>\n<p>下面例子中，用 LOAD 语句导入数据耗时 115.12 秒：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test.txt&#x27; into table film_test2;</span><br><span class=\"line\">Query OK,529056 rows affected(1 min 55.12 sec)</span><br><span class=\"line\">Records: 529056  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>而用 <code>alter table tbl_name disable keys</code> 方式总耗时 6.34+12.25 &#x3D; 18.59 秒，提高了 6 倍多。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; alter table film_test2 disable keys;</span><br><span class=\"line\">Query OK,0 rows affected(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test.txt&#x27; into table film_test2;</span><br><span class=\"line\">Query OK,529056 rows affected(6.34 sec)</span><br><span class=\"line\">Records: 529056  Deleted: 0  Skipped: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; alter table film_test2 enable keys;</span><br><span class=\"line\">Query OK,0 rows affected(12.25 sec)</span><br></pre></td></tr></table></figure>\n<p>上面是对 MyISAM 表进行数据导入时的优化措施，对于 InnoDB 类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高 InnoDB 表的导入效率。</p>\n<p>（1）因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效地提高导入数据的效率。</p>\n<p>例如，下面文本 film_test3.txt 是按表 film_tst4 的主键存储的，那么导入的时候共耗时 27.92 秒。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(22.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>而下面的 film_test4.txt 是没有任何顺序的文本，那么导入的时候共耗时 31.16 秒。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test4.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(31.16 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看出当被导入的文件按表主键顺序存储的时候比不按主键顺序存储的时候快 1.12 倍。</p>\n<p>（2）在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行 <code>SET UNIQUE_CHECK=1</code>，恢复唯一性校验，可以提高导入的效率。</p>\n<p>例如，当 UNIQUE_CHECKS&#x3D;1 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(22.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>当 SET UNIQUE_CHECKS&#x3D;0 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(19.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>可见比 UNIQUE_CHECKS&#x3D;0 的时候比 SET UNIQUE_CHECKS&#x3D;1 的时候要快一些。</p>\n<p>（3）如果应用使用自动提交的方式，建议在导入前执行 <code>SET AUTOCOMMIT=0</code>，关闭自动提交，导入结束后再执行 <code>SET AUTOCOMMIT=1</code>，打开自动提交，也可以提高导入的效率。</p>\n<p>例如，当 AUTOCOMMIT&#x3D;1 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(22.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>当 AUTOCOMMIT&#x3D;0 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(20.87 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>对比一下可以知道，当 AUTOCOMMIT&#x3D;0 时比 AUTOCOMMIT&#x3D;1 时导入数据要快一些。</p>\n<h2 id=\"优化-INSERT-语句\"><a href=\"#优化-INSERT-语句\" class=\"headerlink\" title=\"优化 INSERT 语句\"></a>优化 INSERT 语句</h2><p>当进行数据 INSERT 的时候，可以考虑采用以下几种优化方式。</p>\n<ul>\n<li>如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语句快（在一些情况中几倍）。下面是一次插入多值的一个例子：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into test values(1,2),(1,3),(1,4)...</span><br></pre></td></tr></table></figure></li>\n<li>如果从不同客户插入很多行，能通过使用 <code>INSERT DELAYED</code> 语句得到更高的速度。DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘，这比每条语句分别插入要快得多；<code>LOW_PRIORITY</code> 刚好相反，在所有其他用户对表的读写完后才进行插入；</li>\n<li>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；</li>\n<li>如果进行批量插入，可以增加 <code>bulk_insert_buffer_size</code> 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用；</li>\n<li>当从一个文本文件装载一个表时，使用 <code>LOAD DATA INFILE</code>。这通常比使用很多 INSERT 语句快 20 倍。</li>\n</ul>\n<h2 id=\"优化-GROUP-BY-语句\"><a href=\"#优化-GROUP-BY-语句\" class=\"headerlink\" title=\"优化 GROUP BY 语句\"></a>优化 GROUP BY 语句</h2><p>默认情况下，MySQL 对所有 GROUP BY col1，col2…的字段进行排序。这与在查询中指定 ORDER BY col1，col2…类似。因此，如果显式包括一个包含相同的列的 ORDER BY 子句，则对 MySQL 的实际执行性能没有什么影响。</p>\n<p>如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL 禁止排序，如下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select id, sum(moneys) from sales2 group by id\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using temporary; Using filesort</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select id, sum(moneys) from sales2 group by id order by null\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using temporary</span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看出第一个 SQL 语句需要进行“filesort”，而第二个 SQL 由于 ORDER BY NULL 不需要进行“filesort”，而 filesort 往往非常耗费时间。</p>\n<h2 id=\"优化-ORDER-BY-语句\"><a href=\"#优化-ORDER-BY-语句\" class=\"headerlink\" title=\"优化 ORDER BY 语句\"></a>优化 ORDER BY 语句</h2><p>在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。WHERE 条件和 ORDER BY 使用相同的索引，并且 ORDER BY 的顺序和索引顺序相同，并且 ORDER BY 的字段都是升序或者都是降序。</p>\n<p>例如，下列 SQL 可以使用索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM t1 ORDER BY key_part1,key_part2,...;</span><br><span class=\"line\">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class=\"line\">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br></pre></td></tr></table></figure>\n<p>但是在以下几种情况下则不使用索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;  --order by 的字段混合 ASC 和 DESC</span><br><span class=\"line\">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;  --用于查询行的关键字与 ORDER BY 中所使用的不相同</span><br><span class=\"line\">SELECT * FROM t1 ORDER BY key1, key2;  --对不同的关键字使用 ORDER BY</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优化嵌套查询\"><a href=\"#优化嵌套查询\" class=\"headerlink\" title=\"优化嵌套查询\"></a>优化嵌套查询</h2><p>MySQL 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性地完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。</p>\n<p>在下面的例子中，要从 sales2 表中找到那些在 company2 表中不存在的所有公司的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where company_id not in (select id from company2)\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: PRIMARY</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 2</span><br><span class=\"line\">        select_type: DEPENDENT SUBQUERY</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: index_subquery</span><br><span class=\"line\">      possible_keys: ind_company2_id</span><br><span class=\"line\">                key: ind_company2_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: func</span><br><span class=\"line\">               rows: 2</span><br><span class=\"line\">              Extra: Using index</span><br><span class=\"line\"></span><br><span class=\"line\">   2 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>如果使用连接（JOIN）来完成这个查询工作，速度将会快很多。尤其是当 company2 表中对 id 建有索引的话，性能将会更好，具体查询如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 left join company2 on sales2.company_id = company2.id where sales2.company_id is null\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_sales2_companyid_moneys</span><br><span class=\"line\">                key: ind_sales2_companyid_moneys</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company2_id</span><br><span class=\"line\">                key: ind_company2_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: sakila.sales2.company_id</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: </span><br><span class=\"line\">   2 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从执行计划中可以明显看出查询扫描的记录范围和使用索引的情况都有了很大的改善。</p>\n<p><strong>连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</strong></p>\n<h2 id=\"优化-OR-条件\"><a href=\"#优化-OR-条件\" class=\"headerlink\" title=\"优化 OR 条件\"></a>优化 OR 条件</h2><p><strong>对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</strong></p>\n<p>例如，首先使用 <code>show index</code> 命令查看表 sales2 的索引，可知它有 3 个索引，在 id、year 两个字段上分别有 1 个独立的索引，在 company_id 和 year 字段上有 1 个复合索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show index from sales2\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_id</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: id</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 1000</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_year</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: year</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 250</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    **************************** 3. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_companyid_moneys</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: company_id</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 1000</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    **************************** 4. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_companyid_moneys</span><br><span class=\"line\">       Seq_in_index: 2</span><br><span class=\"line\">        Column_name: year</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 1000</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    4 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>然后在两个独立索引上面做 OR 操作，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where id = 2 or year = 1998\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: index_merge</span><br><span class=\"line\">      possible_keys: ind_sales2_id,ind_sales2_year</span><br><span class=\"line\">                key: ind_sales2_id,ind_sales2_year</span><br><span class=\"line\">            key_len: 5,2</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 2</span><br><span class=\"line\">              Extra: Using union(ind_sales2_id,ind_sales2_year); Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可以发现查询正确的用到了索引，并且从执行计划的描述中，<strong>发现 MySQL 在处理含有 OR 子句的查询时，实际是对 OR 的各个字段分别查询后的结果进行了 UNION。</strong></p>\n<p>但是当在建有复合索引的列 company_id 和 moneys 上面做 OR 操作的时候，却不能用到索引，具体结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where company_id = 3 or moneys = 100\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: ind_sales2_companyid_moneys</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前介绍了 MySQL 中怎么样通过索引来优化查询。日常开发中，除了使用查询外，我们还会使用一些其他的常用 SQL，比如 INSERT、GROUP BY 等。对于这些 SQL 语句，我们该怎么样进行优化呢？接下来将针对这些 SQL 语句介绍一些优化的方法。</p>\n<h2 id=\"大批量插入数据\"><a href=\"#大批量插入数据\" class=\"headerlink\" title=\"大批量插入数据\"></a>大批量插入数据</h2><p>当用 load 命令导入数据的时候，适当的设置可以提高导入的速度。</p>\n<p>对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALTER TABLE tbl_name DISABLE KEYS;</span><br><span class=\"line\">loading the data</span><br><span class=\"line\">ALTER TABLE tbl_name ENABLE KEYS;</span><br></pre></td></tr></table></figure>\n<p><code>DISABLE KEYS</code> 和 <code>ENABLE KEYS</code> 用来打开或者关闭 MyISAM 表非唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的 MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。</p>\n<p>下面例子中，用 LOAD 语句导入数据耗时 115.12 秒：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test.txt&#x27; into table film_test2;</span><br><span class=\"line\">Query OK,529056 rows affected(1 min 55.12 sec)</span><br><span class=\"line\">Records: 529056  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>而用 <code>alter table tbl_name disable keys</code> 方式总耗时 6.34+12.25 &#x3D; 18.59 秒，提高了 6 倍多。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; alter table film_test2 disable keys;</span><br><span class=\"line\">Query OK,0 rows affected(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test.txt&#x27; into table film_test2;</span><br><span class=\"line\">Query OK,529056 rows affected(6.34 sec)</span><br><span class=\"line\">Records: 529056  Deleted: 0  Skipped: 0  Warnings: 0</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; alter table film_test2 enable keys;</span><br><span class=\"line\">Query OK,0 rows affected(12.25 sec)</span><br></pre></td></tr></table></figure>\n<p>上面是对 MyISAM 表进行数据导入时的优化措施，对于 InnoDB 类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高 InnoDB 表的导入效率。</p>\n<p>（1）因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效地提高导入数据的效率。</p>\n<p>例如，下面文本 film_test3.txt 是按表 film_tst4 的主键存储的，那么导入的时候共耗时 27.92 秒。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(22.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>而下面的 film_test4.txt 是没有任何顺序的文本，那么导入的时候共耗时 31.16 秒。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test4.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(31.16 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看出当被导入的文件按表主键顺序存储的时候比不按主键顺序存储的时候快 1.12 倍。</p>\n<p>（2）在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行 <code>SET UNIQUE_CHECK=1</code>，恢复唯一性校验，可以提高导入的效率。</p>\n<p>例如，当 UNIQUE_CHECKS&#x3D;1 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(22.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>当 SET UNIQUE_CHECKS&#x3D;0 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(19.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>可见比 UNIQUE_CHECKS&#x3D;0 的时候比 SET UNIQUE_CHECKS&#x3D;1 的时候要快一些。</p>\n<p>（3）如果应用使用自动提交的方式，建议在导入前执行 <code>SET AUTOCOMMIT=0</code>，关闭自动提交，导入结束后再执行 <code>SET AUTOCOMMIT=1</code>，打开自动提交，也可以提高导入的效率。</p>\n<p>例如，当 AUTOCOMMIT&#x3D;1 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(22.92 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>当 AUTOCOMMIT&#x3D;0 时：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; load data infile &#x27;/home/mysql/film_test3.txt&#x27; into table film_test4;</span><br><span class=\"line\">Query OK,1587168 rows affected(20.87 sec)</span><br><span class=\"line\">Records: 1587168  Deleted: 0  Skipped: 0  Warning: 0</span><br></pre></td></tr></table></figure>\n<p>对比一下可以知道，当 AUTOCOMMIT&#x3D;0 时比 AUTOCOMMIT&#x3D;1 时导入数据要快一些。</p>\n<h2 id=\"优化-INSERT-语句\"><a href=\"#优化-INSERT-语句\" class=\"headerlink\" title=\"优化 INSERT 语句\"></a>优化 INSERT 语句</h2><p>当进行数据 INSERT 的时候，可以考虑采用以下几种优化方式。</p>\n<ul>\n<li>如果同时从同一客户插入很多行，尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗，使得效率比分开执行的单个 INSERT 语句快（在一些情况中几倍）。下面是一次插入多值的一个例子：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into test values(1,2),(1,3),(1,4)...</span><br></pre></td></tr></table></figure></li>\n<li>如果从不同客户插入很多行，能通过使用 <code>INSERT DELAYED</code> 语句得到更高的速度。DELAYED 的含义是让 INSERT 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘，这比每条语句分别插入要快得多；<code>LOW_PRIORITY</code> 刚好相反，在所有其他用户对表的读写完后才进行插入；</li>\n<li>将索引文件和数据文件分在不同的磁盘上存放（利用建表中的选项）；</li>\n<li>如果进行批量插入，可以增加 <code>bulk_insert_buffer_size</code> 变量值的方法来提高速度，但是，这只能对 MyISAM 表使用；</li>\n<li>当从一个文本文件装载一个表时，使用 <code>LOAD DATA INFILE</code>。这通常比使用很多 INSERT 语句快 20 倍。</li>\n</ul>\n<h2 id=\"优化-GROUP-BY-语句\"><a href=\"#优化-GROUP-BY-语句\" class=\"headerlink\" title=\"优化 GROUP BY 语句\"></a>优化 GROUP BY 语句</h2><p>默认情况下，MySQL 对所有 GROUP BY col1，col2…的字段进行排序。这与在查询中指定 ORDER BY col1，col2…类似。因此，如果显式包括一个包含相同的列的 ORDER BY 子句，则对 MySQL 的实际执行性能没有什么影响。</p>\n<p>如果查询包括 GROUP BY 但用户想要避免排序结果的消耗，则可以指定 ORDER BY NULL 禁止排序，如下面的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select id, sum(moneys) from sales2 group by id\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using temporary; Using filesort</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; explain select id, sum(moneys) from sales2 group by id order by null\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using temporary</span><br></pre></td></tr></table></figure>\n<p>从上面的例子可以看出第一个 SQL 语句需要进行“filesort”，而第二个 SQL 由于 ORDER BY NULL 不需要进行“filesort”，而 filesort 往往非常耗费时间。</p>\n<h2 id=\"优化-ORDER-BY-语句\"><a href=\"#优化-ORDER-BY-语句\" class=\"headerlink\" title=\"优化 ORDER BY 语句\"></a>优化 ORDER BY 语句</h2><p>在某些情况中，MySQL 可以使用一个索引来满足 ORDER BY 子句，而不需要额外的排序。WHERE 条件和 ORDER BY 使用相同的索引，并且 ORDER BY 的顺序和索引顺序相同，并且 ORDER BY 的字段都是升序或者都是降序。</p>\n<p>例如，下列 SQL 可以使用索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM t1 ORDER BY key_part1,key_part2,...;</span><br><span class=\"line\">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br><span class=\"line\">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</span><br></pre></td></tr></table></figure>\n<p>但是在以下几种情况下则不使用索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC;  --order by 的字段混合 ASC 和 DESC</span><br><span class=\"line\">SELECT * FROM t1 WHERE key2=constant ORDER BY key1;  --用于查询行的关键字与 ORDER BY 中所使用的不相同</span><br><span class=\"line\">SELECT * FROM t1 ORDER BY key1, key2;  --对不同的关键字使用 ORDER BY</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优化嵌套查询\"><a href=\"#优化嵌套查询\" class=\"headerlink\" title=\"优化嵌套查询\"></a>优化嵌套查询</h2><p>MySQL 4.1 开始支持 SQL 的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性地完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。</p>\n<p>在下面的例子中，要从 sales2 表中找到那些在 company2 表中不存在的所有公司的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where company_id not in (select id from company2)\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: PRIMARY</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: NULL</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 2</span><br><span class=\"line\">        select_type: DEPENDENT SUBQUERY</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: index_subquery</span><br><span class=\"line\">      possible_keys: ind_company2_id</span><br><span class=\"line\">                key: ind_company2_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: func</span><br><span class=\"line\">               rows: 2</span><br><span class=\"line\">              Extra: Using index</span><br><span class=\"line\"></span><br><span class=\"line\">   2 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>如果使用连接（JOIN）来完成这个查询工作，速度将会快很多。尤其是当 company2 表中对 id 建有索引的话，性能将会更好，具体查询如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 left join company2 on sales2.company_id = company2.id where sales2.company_id is null\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_sales2_companyid_moneys</span><br><span class=\"line\">                key: ind_sales2_companyid_moneys</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: const</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: company2</span><br><span class=\"line\">               type: ref</span><br><span class=\"line\">      possible_keys: ind_company2_id</span><br><span class=\"line\">                key: ind_company2_id</span><br><span class=\"line\">            key_len: 5</span><br><span class=\"line\">                ref: sakila.sales2.company_id</span><br><span class=\"line\">               rows: 1</span><br><span class=\"line\">              Extra: </span><br><span class=\"line\">   2 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>从执行计划中可以明显看出查询扫描的记录范围和使用索引的情况都有了很大的改善。</p>\n<p><strong>连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</strong></p>\n<h2 id=\"优化-OR-条件\"><a href=\"#优化-OR-条件\" class=\"headerlink\" title=\"优化 OR 条件\"></a>优化 OR 条件</h2><p><strong>对于含有 OR 的查询子句，如果要利用索引，则 OR 之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。</strong></p>\n<p>例如，首先使用 <code>show index</code> 命令查看表 sales2 的索引，可知它有 3 个索引，在 id、year 两个字段上分别有 1 个独立的索引，在 company_id 和 year 字段上有 1 个复合索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show index from sales2\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_id</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: id</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 1000</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    **************************** 2. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_year</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: year</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 250</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    **************************** 3. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_companyid_moneys</span><br><span class=\"line\">       Seq_in_index: 1</span><br><span class=\"line\">        Column_name: company_id</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 1000</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    **************************** 4. row *************************************</span><br><span class=\"line\">              Table: sales2</span><br><span class=\"line\">         Non_unique: 1</span><br><span class=\"line\">           Key_name: ind_sales2_companyid_moneys</span><br><span class=\"line\">       Seq_in_index: 2</span><br><span class=\"line\">        Column_name: year</span><br><span class=\"line\">          Collation: A</span><br><span class=\"line\">        Cardinality: 1000</span><br><span class=\"line\">           Sub_part: NULL</span><br><span class=\"line\">             Packed: NULL</span><br><span class=\"line\">               Null: YES</span><br><span class=\"line\">         Index_type: BTREE</span><br><span class=\"line\">            Comment:</span><br><span class=\"line\">    4 rows in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>然后在两个独立索引上面做 OR 操作，具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where id = 2 or year = 1998\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: index_merge</span><br><span class=\"line\">      possible_keys: ind_sales2_id,ind_sales2_year</span><br><span class=\"line\">                key: ind_sales2_id,ind_sales2_year</span><br><span class=\"line\">            key_len: 5,2</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 2</span><br><span class=\"line\">              Extra: Using union(ind_sales2_id,ind_sales2_year); Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>可以发现查询正确的用到了索引，并且从执行计划的描述中，<strong>发现 MySQL 在处理含有 OR 子句的查询时，实际是对 OR 的各个字段分别查询后的结果进行了 UNION。</strong></p>\n<p>但是当在建有复合索引的列 company_id 和 moneys 上面做 OR 操作的时候，却不能用到索引，具体结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from sales2 where company_id = 3 or moneys = 100\\G;</span><br><span class=\"line\">    **************************** 1. row *************************************</span><br><span class=\"line\">                 id: 1</span><br><span class=\"line\">        select_type: SIMPLE</span><br><span class=\"line\">              table: sales2</span><br><span class=\"line\">               type: ALL</span><br><span class=\"line\">      possible_keys: ind_sales2_companyid_moneys</span><br><span class=\"line\">                key: NULL</span><br><span class=\"line\">            key_len: NULL</span><br><span class=\"line\">                ref: NULL</span><br><span class=\"line\">               rows: 1000</span><br><span class=\"line\">              Extra: Using where</span><br><span class=\"line\">    1 row in set(0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本文大多摘自《深入浅出MySQL》。</p>\n</blockquote>\n"},{"title":"Netty4 实现数据传输中间层处理","date":"2019-10-11T02:59:49.000Z","_content":"\n> Netty4 实现数据报文的接收/拆包/重组/转发<br><br>\n> 完整代码：[netty4-datatrans](https://github.com/Folgerjun/netty4-datatrans)\n\n---\n\n## 前言\n由于项目中有对建筑的 GPS 定位模块，而 GPS 仪器作为客户端连接，传输的是标准的 GPGGA 语句，也就是多个客户端对一个服务端发送数据，节约端口资源故配置的是同一个端口，此时服务端接收到的 GPGGA 数据却并不能分辨出到底是哪一个客户端发送的，由此决定写一个数据中间层处理，给报文重组根据规则加上唯一标识符。\n\n## 正题\n根据实际需求我这写了服务端和客户端，即该脚本部署的机器同时作为 server 和 client。\n\n可以进行对接收数据的拆包/逻辑重组/添加数据标识符等等 DIY 操作，再进行定向转发。\n\n### 客户端处理\n\n- 添加了 Listener 启动时可监听判断 client 是否正常启动，即对应 server 端口是否启用监听\n    +   若通道连通，正常连接进行数据传输\n    +   若通道未连通，则调用 schedule 进行定时重连操作\n\n**GPSTransClientConnectionListener.java**\n```\nif (!future.isSuccess()) {\n    final EventLoop loop = future.channel().eventLoop();\n    loop.schedule(new Runnable() {\n        @Override\n        public void run() {\n            System.err.println(\"client reconnecting ...\");\n            try {\n                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));\n            } catch (NumberFormatException | InterruptedException e) {\n                System.out.println(\"restart err...\");\n                e.printStackTrace();\n            }\n        }\n    }, 5L, TimeUnit.SECONDS);\n} else {\n    System.out.println(\"client connected ...\");\n}\n```\n\n- 同时若是启动成功但是运行一段时间后 server 端口关闭监听了，那也要进行重连处理，可以根据实际需求更改\n\n**GPSTransClientHandler.java**\n```\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n    System.err.println(\"server disconnect ...\");\n    success = false;\n    // 使用过程中断线重连\n    final EventLoop eventLoop = ctx.channel().eventLoop();\n    eventLoop.schedule(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));\n            } catch (Exception e) {\n                System.out.println(\"restart err...\");\n                e.printStackTrace();\n            }\n        }\n    }, 5L, TimeUnit.SECONDS);\n    super.channelInactive(ctx);\n}\n```\n\n由于是不停的进行转发操作，所以需要循环处理。\n\n定义了 `private static volatile boolean success;` 作为数据发送线程的循环标志符。\n\n当连接成功时，success 置为 true，当连接断开时，success 置为 false。\n\n`volatile` 修饰故保证了其可见性。\n\n```\n@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n    System.out.println(\"channelActive ...\");\n    success = true;\n    System.out.println(\"send data to server ...\");\n    // 必须另开线程处理，否则会在这个方法中出不去\n    new Thread() {\n        @Override\n        public void run() {\n            while (success) {\n                if (!GPSTransConsts.NAME_MESS.isEmpty()) {\n                    StringBuilder sb = new StringBuilder();\n                    GPSTransConsts.NAME_MESS.values().forEach(value -> {\n                        sb.append(value);\n                    });\n                    ByteBuf resp = Unpooled.copiedBuffer(sb.toString(), CharsetUtil.UTF_8);\n                    ctx.writeAndFlush(resp);\n                    try {\n                        Thread.sleep(1000L);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            System.out.println(\"client thread exit ...\");\n        };\n    }.start();\n    super.channelActive(ctx);\n}\n```\n\n### 服务端处理\n\n接收多个客户端数据，根据其 IP 来定位设备，再进行报文拆包重组 DIY，存储到内存中便于 client 模块进行转发。\n\n**GPSTransServerHandler.java**\n```\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n  \n    InetSocketAddress ipsocket = (InetSocketAddress) ctx.channel().remoteAddress();\n    // 获取客户端 IP\n    String clientIP = ipsocket.getAddress().getHostAddress();\n    int index = clientIP.lastIndexOf(\".\");\n    String ipNum = clientIP.substring(index + 1);\n    ByteBuf in = (ByteBuf) msg;\n    String message = in.toString(CharsetUtil.UTF_8);\n    if (message.startsWith(\"$\")) {\n        message = message.replace(\"$\", \"#\");\n        if (!GPSTransConsts.IP_NAME.containsKey(ipNum)) {\n            System.err.println(ipNum + \"未配置!\");\n            return;\n        }\n        String name = GPSTransConsts.IP_NAME.get(ipNum);\n        message = \"#\" + GPSTransConsts.IP_NAME.get(ipNum) + message + \"\\r\";\n        GPSTransConsts.NAME_MESS.put(name, message);\n    }\n    // 释放\n    super.channelRead(ctx, msg);\n}\n```\n因为我们没有进行 write 和 flush 操作，所以需要进行释放。\n\n### 配置文件\n\n为了方便配置的修改，可以把项目打成 jar 包，然后在同目录下新建一个 config 文件夹，把 gps.properties 丢进去，完事。","source":"_posts/netty4-datatrans.md","raw":"---\ntitle: Netty4 实现数据传输中间层处理\ndate: 2019-10-11 10:59:49\ncategories: [开发,总结]\ntags: [Java,Netty4]\n---\n\n> Netty4 实现数据报文的接收/拆包/重组/转发<br><br>\n> 完整代码：[netty4-datatrans](https://github.com/Folgerjun/netty4-datatrans)\n\n---\n\n## 前言\n由于项目中有对建筑的 GPS 定位模块，而 GPS 仪器作为客户端连接，传输的是标准的 GPGGA 语句，也就是多个客户端对一个服务端发送数据，节约端口资源故配置的是同一个端口，此时服务端接收到的 GPGGA 数据却并不能分辨出到底是哪一个客户端发送的，由此决定写一个数据中间层处理，给报文重组根据规则加上唯一标识符。\n\n## 正题\n根据实际需求我这写了服务端和客户端，即该脚本部署的机器同时作为 server 和 client。\n\n可以进行对接收数据的拆包/逻辑重组/添加数据标识符等等 DIY 操作，再进行定向转发。\n\n### 客户端处理\n\n- 添加了 Listener 启动时可监听判断 client 是否正常启动，即对应 server 端口是否启用监听\n    +   若通道连通，正常连接进行数据传输\n    +   若通道未连通，则调用 schedule 进行定时重连操作\n\n**GPSTransClientConnectionListener.java**\n```\nif (!future.isSuccess()) {\n    final EventLoop loop = future.channel().eventLoop();\n    loop.schedule(new Runnable() {\n        @Override\n        public void run() {\n            System.err.println(\"client reconnecting ...\");\n            try {\n                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));\n            } catch (NumberFormatException | InterruptedException e) {\n                System.out.println(\"restart err...\");\n                e.printStackTrace();\n            }\n        }\n    }, 5L, TimeUnit.SECONDS);\n} else {\n    System.out.println(\"client connected ...\");\n}\n```\n\n- 同时若是启动成功但是运行一段时间后 server 端口关闭监听了，那也要进行重连处理，可以根据实际需求更改\n\n**GPSTransClientHandler.java**\n```\n@Override\npublic void channelInactive(ChannelHandlerContext ctx) throws Exception {\n    System.err.println(\"server disconnect ...\");\n    success = false;\n    // 使用过程中断线重连\n    final EventLoop eventLoop = ctx.channel().eventLoop();\n    eventLoop.schedule(new Runnable() {\n        @Override\n        public void run() {\n            try {\n                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));\n            } catch (Exception e) {\n                System.out.println(\"restart err...\");\n                e.printStackTrace();\n            }\n        }\n    }, 5L, TimeUnit.SECONDS);\n    super.channelInactive(ctx);\n}\n```\n\n由于是不停的进行转发操作，所以需要循环处理。\n\n定义了 `private static volatile boolean success;` 作为数据发送线程的循环标志符。\n\n当连接成功时，success 置为 true，当连接断开时，success 置为 false。\n\n`volatile` 修饰故保证了其可见性。\n\n```\n@Override\npublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n    System.out.println(\"channelActive ...\");\n    success = true;\n    System.out.println(\"send data to server ...\");\n    // 必须另开线程处理，否则会在这个方法中出不去\n    new Thread() {\n        @Override\n        public void run() {\n            while (success) {\n                if (!GPSTransConsts.NAME_MESS.isEmpty()) {\n                    StringBuilder sb = new StringBuilder();\n                    GPSTransConsts.NAME_MESS.values().forEach(value -> {\n                        sb.append(value);\n                    });\n                    ByteBuf resp = Unpooled.copiedBuffer(sb.toString(), CharsetUtil.UTF_8);\n                    ctx.writeAndFlush(resp);\n                    try {\n                        Thread.sleep(1000L);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            System.out.println(\"client thread exit ...\");\n        };\n    }.start();\n    super.channelActive(ctx);\n}\n```\n\n### 服务端处理\n\n接收多个客户端数据，根据其 IP 来定位设备，再进行报文拆包重组 DIY，存储到内存中便于 client 模块进行转发。\n\n**GPSTransServerHandler.java**\n```\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n  \n    InetSocketAddress ipsocket = (InetSocketAddress) ctx.channel().remoteAddress();\n    // 获取客户端 IP\n    String clientIP = ipsocket.getAddress().getHostAddress();\n    int index = clientIP.lastIndexOf(\".\");\n    String ipNum = clientIP.substring(index + 1);\n    ByteBuf in = (ByteBuf) msg;\n    String message = in.toString(CharsetUtil.UTF_8);\n    if (message.startsWith(\"$\")) {\n        message = message.replace(\"$\", \"#\");\n        if (!GPSTransConsts.IP_NAME.containsKey(ipNum)) {\n            System.err.println(ipNum + \"未配置!\");\n            return;\n        }\n        String name = GPSTransConsts.IP_NAME.get(ipNum);\n        message = \"#\" + GPSTransConsts.IP_NAME.get(ipNum) + message + \"\\r\";\n        GPSTransConsts.NAME_MESS.put(name, message);\n    }\n    // 释放\n    super.channelRead(ctx, msg);\n}\n```\n因为我们没有进行 write 和 flush 操作，所以需要进行释放。\n\n### 配置文件\n\n为了方便配置的修改，可以把项目打成 jar 包，然后在同目录下新建一个 config 文件夹，把 gps.properties 丢进去，完事。","slug":"netty4-datatrans","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhl008ck9i134yv2ghs","content":"<blockquote>\n<p>Netty4 实现数据报文的接收&#x2F;拆包&#x2F;重组&#x2F;转发<br><br><br>完整代码：<a href=\"https://github.com/Folgerjun/netty4-datatrans\">netty4-datatrans</a></p>\n</blockquote>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于项目中有对建筑的 GPS 定位模块，而 GPS 仪器作为客户端连接，传输的是标准的 GPGGA 语句，也就是多个客户端对一个服务端发送数据，节约端口资源故配置的是同一个端口，此时服务端接收到的 GPGGA 数据却并不能分辨出到底是哪一个客户端发送的，由此决定写一个数据中间层处理，给报文重组根据规则加上唯一标识符。</p>\n<h2 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h2><p>根据实际需求我这写了服务端和客户端，即该脚本部署的机器同时作为 server 和 client。</p>\n<p>可以进行对接收数据的拆包&#x2F;逻辑重组&#x2F;添加数据标识符等等 DIY 操作，再进行定向转发。</p>\n<h3 id=\"客户端处理\"><a href=\"#客户端处理\" class=\"headerlink\" title=\"客户端处理\"></a>客户端处理</h3><ul>\n<li>添加了 Listener 启动时可监听判断 client 是否正常启动，即对应 server 端口是否启用监听<ul>\n<li>若通道连通，正常连接进行数据传输</li>\n<li>若通道未连通，则调用 schedule 进行定时重连操作</li>\n</ul>\n</li>\n</ul>\n<p><strong>GPSTransClientConnectionListener.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!future.isSuccess()) &#123;</span><br><span class=\"line\">    final EventLoop loop = future.channel().eventLoop();</span><br><span class=\"line\">    loop.schedule(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.err.println(&quot;client reconnecting ...&quot;);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));</span><br><span class=\"line\">            &#125; catch (NumberFormatException | InterruptedException e) &#123;</span><br><span class=\"line\">                System.out.println(&quot;restart err...&quot;);</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, 5L, TimeUnit.SECONDS);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    System.out.println(&quot;client connected ...&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>同时若是启动成功但是运行一段时间后 server 端口关闭监听了，那也要进行重连处理，可以根据实际需求更改</li>\n</ul>\n<p><strong>GPSTransClientHandler.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">    System.err.println(&quot;server disconnect ...&quot;);</span><br><span class=\"line\">    success = false;</span><br><span class=\"line\">    // 使用过程中断线重连</span><br><span class=\"line\">    final EventLoop eventLoop = ctx.channel().eventLoop();</span><br><span class=\"line\">    eventLoop.schedule(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                System.out.println(&quot;restart err...&quot;);</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, 5L, TimeUnit.SECONDS);</span><br><span class=\"line\">    super.channelInactive(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于是不停的进行转发操作，所以需要循环处理。</p>\n<p>定义了 <code>private static volatile boolean success;</code> 作为数据发送线程的循环标志符。</p>\n<p>当连接成功时，success 置为 true，当连接断开时，success 置为 false。</p>\n<p><code>volatile</code> 修饰故保证了其可见性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">    System.out.println(&quot;channelActive ...&quot;);</span><br><span class=\"line\">    success = true;</span><br><span class=\"line\">    System.out.println(&quot;send data to server ...&quot;);</span><br><span class=\"line\">    // 必须另开线程处理，否则会在这个方法中出不去</span><br><span class=\"line\">    new Thread() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (success) &#123;</span><br><span class=\"line\">                if (!GPSTransConsts.NAME_MESS.isEmpty()) &#123;</span><br><span class=\"line\">                    StringBuilder sb = new StringBuilder();</span><br><span class=\"line\">                    GPSTransConsts.NAME_MESS.values().forEach(value -&gt; &#123;</span><br><span class=\"line\">                        sb.append(value);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    ByteBuf resp = Unpooled.copiedBuffer(sb.toString(), CharsetUtil.UTF_8);</span><br><span class=\"line\">                    ctx.writeAndFlush(resp);</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(1000L);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;client thread exit ...&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">    super.channelActive(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端处理\"><a href=\"#服务端处理\" class=\"headerlink\" title=\"服务端处理\"></a>服务端处理</h3><p>接收多个客户端数据，根据其 IP 来定位设备，再进行报文拆包重组 DIY，存储到内存中便于 client 模块进行转发。</p>\n<p><strong>GPSTransServerHandler.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    InetSocketAddress ipsocket = (InetSocketAddress) ctx.channel().remoteAddress();</span><br><span class=\"line\">    // 获取客户端 IP</span><br><span class=\"line\">    String clientIP = ipsocket.getAddress().getHostAddress();</span><br><span class=\"line\">    int index = clientIP.lastIndexOf(&quot;.&quot;);</span><br><span class=\"line\">    String ipNum = clientIP.substring(index + 1);</span><br><span class=\"line\">    ByteBuf in = (ByteBuf) msg;</span><br><span class=\"line\">    String message = in.toString(CharsetUtil.UTF_8);</span><br><span class=\"line\">    if (message.startsWith(&quot;$&quot;)) &#123;</span><br><span class=\"line\">        message = message.replace(&quot;$&quot;, &quot;#&quot;);</span><br><span class=\"line\">        if (!GPSTransConsts.IP_NAME.containsKey(ipNum)) &#123;</span><br><span class=\"line\">            System.err.println(ipNum + &quot;未配置!&quot;);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String name = GPSTransConsts.IP_NAME.get(ipNum);</span><br><span class=\"line\">        message = &quot;#&quot; + GPSTransConsts.IP_NAME.get(ipNum) + message + &quot;\\r&quot;;</span><br><span class=\"line\">        GPSTransConsts.NAME_MESS.put(name, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 释放</span><br><span class=\"line\">    super.channelRead(ctx, msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我们没有进行 write 和 flush 操作，所以需要进行释放。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>为了方便配置的修改，可以把项目打成 jar 包，然后在同目录下新建一个 config 文件夹，把 gps.properties 丢进去，完事。</p>\n","excerpt":"","more":"<blockquote>\n<p>Netty4 实现数据报文的接收&#x2F;拆包&#x2F;重组&#x2F;转发<br><br><br>完整代码：<a href=\"https://github.com/Folgerjun/netty4-datatrans\">netty4-datatrans</a></p>\n</blockquote>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于项目中有对建筑的 GPS 定位模块，而 GPS 仪器作为客户端连接，传输的是标准的 GPGGA 语句，也就是多个客户端对一个服务端发送数据，节约端口资源故配置的是同一个端口，此时服务端接收到的 GPGGA 数据却并不能分辨出到底是哪一个客户端发送的，由此决定写一个数据中间层处理，给报文重组根据规则加上唯一标识符。</p>\n<h2 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h2><p>根据实际需求我这写了服务端和客户端，即该脚本部署的机器同时作为 server 和 client。</p>\n<p>可以进行对接收数据的拆包&#x2F;逻辑重组&#x2F;添加数据标识符等等 DIY 操作，再进行定向转发。</p>\n<h3 id=\"客户端处理\"><a href=\"#客户端处理\" class=\"headerlink\" title=\"客户端处理\"></a>客户端处理</h3><ul>\n<li>添加了 Listener 启动时可监听判断 client 是否正常启动，即对应 server 端口是否启用监听<ul>\n<li>若通道连通，正常连接进行数据传输</li>\n<li>若通道未连通，则调用 schedule 进行定时重连操作</li>\n</ul>\n</li>\n</ul>\n<p><strong>GPSTransClientConnectionListener.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!future.isSuccess()) &#123;</span><br><span class=\"line\">    final EventLoop loop = future.channel().eventLoop();</span><br><span class=\"line\">    loop.schedule(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.err.println(&quot;client reconnecting ...&quot;);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));</span><br><span class=\"line\">            &#125; catch (NumberFormatException | InterruptedException e) &#123;</span><br><span class=\"line\">                System.out.println(&quot;restart err...&quot;);</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, 5L, TimeUnit.SECONDS);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    System.out.println(&quot;client connected ...&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>同时若是启动成功但是运行一段时间后 server 端口关闭监听了，那也要进行重连处理，可以根据实际需求更改</li>\n</ul>\n<p><strong>GPSTransClientHandler.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">    System.err.println(&quot;server disconnect ...&quot;);</span><br><span class=\"line\">    success = false;</span><br><span class=\"line\">    // 使用过程中断线重连</span><br><span class=\"line\">    final EventLoop eventLoop = ctx.channel().eventLoop();</span><br><span class=\"line\">    eventLoop.schedule(new Runnable() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                client.connect(GPSTransConsts.REMOTE_IP, Integer.parseInt(GPSTransConsts.REMOTE_PORT));</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">                System.out.println(&quot;restart err...&quot;);</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, 5L, TimeUnit.SECONDS);</span><br><span class=\"line\">    super.channelInactive(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于是不停的进行转发操作，所以需要循环处理。</p>\n<p>定义了 <code>private static volatile boolean success;</code> 作为数据发送线程的循环标志符。</p>\n<p>当连接成功时，success 置为 true，当连接断开时，success 置为 false。</p>\n<p><code>volatile</code> 修饰故保证了其可见性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">    System.out.println(&quot;channelActive ...&quot;);</span><br><span class=\"line\">    success = true;</span><br><span class=\"line\">    System.out.println(&quot;send data to server ...&quot;);</span><br><span class=\"line\">    // 必须另开线程处理，否则会在这个方法中出不去</span><br><span class=\"line\">    new Thread() &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            while (success) &#123;</span><br><span class=\"line\">                if (!GPSTransConsts.NAME_MESS.isEmpty()) &#123;</span><br><span class=\"line\">                    StringBuilder sb = new StringBuilder();</span><br><span class=\"line\">                    GPSTransConsts.NAME_MESS.values().forEach(value -&gt; &#123;</span><br><span class=\"line\">                        sb.append(value);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    ByteBuf resp = Unpooled.copiedBuffer(sb.toString(), CharsetUtil.UTF_8);</span><br><span class=\"line\">                    ctx.writeAndFlush(resp);</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(1000L);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;client thread exit ...&quot;);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;.start();</span><br><span class=\"line\">    super.channelActive(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端处理\"><a href=\"#服务端处理\" class=\"headerlink\" title=\"服务端处理\"></a>服务端处理</h3><p>接收多个客户端数据，根据其 IP 来定位设备，再进行报文拆包重组 DIY，存储到内存中便于 client 模块进行转发。</p>\n<p><strong>GPSTransServerHandler.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    InetSocketAddress ipsocket = (InetSocketAddress) ctx.channel().remoteAddress();</span><br><span class=\"line\">    // 获取客户端 IP</span><br><span class=\"line\">    String clientIP = ipsocket.getAddress().getHostAddress();</span><br><span class=\"line\">    int index = clientIP.lastIndexOf(&quot;.&quot;);</span><br><span class=\"line\">    String ipNum = clientIP.substring(index + 1);</span><br><span class=\"line\">    ByteBuf in = (ByteBuf) msg;</span><br><span class=\"line\">    String message = in.toString(CharsetUtil.UTF_8);</span><br><span class=\"line\">    if (message.startsWith(&quot;$&quot;)) &#123;</span><br><span class=\"line\">        message = message.replace(&quot;$&quot;, &quot;#&quot;);</span><br><span class=\"line\">        if (!GPSTransConsts.IP_NAME.containsKey(ipNum)) &#123;</span><br><span class=\"line\">            System.err.println(ipNum + &quot;未配置!&quot;);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String name = GPSTransConsts.IP_NAME.get(ipNum);</span><br><span class=\"line\">        message = &quot;#&quot; + GPSTransConsts.IP_NAME.get(ipNum) + message + &quot;\\r&quot;;</span><br><span class=\"line\">        GPSTransConsts.NAME_MESS.put(name, message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 释放</span><br><span class=\"line\">    super.channelRead(ctx, msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我们没有进行 write 和 flush 操作，所以需要进行释放。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>为了方便配置的修改，可以把项目打成 jar 包，然后在同目录下新建一个 config 文件夹，把 gps.properties 丢进去，完事。</p>\n"},{"title":"又是一月（2021）","date":"2021-01-29T12:10:55.000Z","_content":"\n> 时光追不上白马……\n\n时隔一年，疫情还是没有得到完全控制，去年年前湖北严重，今年河北好像稍微严重一些，难不成今年是要在外头过年了吗？元旦回去倒还是较为顺利，并没有什么额外繁琐的步骤也没有强制要求核酸检测，不知年前会怎样。\n\n今天刚公司年会回来，相较之前参加的公司年会来说规模是更大一些的。不过这又有何用，阳光照样照我脸上……年会占用了周末时间，宾馆住了一晚，说实在的，除了抽奖那会会比较激动，其余也就那样了，在奉贤那边，周边也没有什么好的娱乐地方，也就只能打打牌了。\n\n哪知道形势变得这么快，上海前几天出了几例，黄浦区变成了中风险地区，公司进出都得戴口罩验体验看健康码。上头文件下来进出沪都得做核酸检测还得隔离，这不明摆着过年回不去了嘛，真的得在外头过年了？从小到大记忆中还没有自己一个人在外头过过年，一想到这强烈的孤独感就涌上来。事态都不知道会往哪个方向发展，任何微小的事物都有改变世界的能力。在很多情况下，现状逆着常态走，一个一个意外外力无情助推。“无知”是福，悟懂这个可不容易啊。\n\n差不离了，留沪过年。还好有个会做饭的室友也留沪，不然我得泡面面包吃到吐。本来长大后就觉得过年也就那样没啥劲了，这下倒好，真就成了一个长周末了，一点点年味儿都没得咯。现在想想自己还要在外面漂多久，这个过年就只有老爸老妈两人，为人子却不能陪伴其右，是一种不孝吧。\n\n大家都在改变，社会在改变，国家也在改变。很多方式从未尝试我们也在积极适应。前十年二十年是科技互联网改变生活，现在今后怕很长一段时间就是环境改变生活。这么说确实有一点可怕，就好像是因果，前者发展破坏后者，后者又开始影响生活。\n\n刚跟父母说了过年不回家的事，老妈就说要不要给我寄点吃的，真的很感动。再听她说今年就只有她跟爸两人过除夕了，又很难受。自知事以后还真是没有在外头过过除夕，感触。\n\n时间真的，快得很。","source":"_posts/new-january.md","raw":"---\ntitle: 又是一月（2021）\ndate: 2021-01-29 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 时光追不上白马……\n\n时隔一年，疫情还是没有得到完全控制，去年年前湖北严重，今年河北好像稍微严重一些，难不成今年是要在外头过年了吗？元旦回去倒还是较为顺利，并没有什么额外繁琐的步骤也没有强制要求核酸检测，不知年前会怎样。\n\n今天刚公司年会回来，相较之前参加的公司年会来说规模是更大一些的。不过这又有何用，阳光照样照我脸上……年会占用了周末时间，宾馆住了一晚，说实在的，除了抽奖那会会比较激动，其余也就那样了，在奉贤那边，周边也没有什么好的娱乐地方，也就只能打打牌了。\n\n哪知道形势变得这么快，上海前几天出了几例，黄浦区变成了中风险地区，公司进出都得戴口罩验体验看健康码。上头文件下来进出沪都得做核酸检测还得隔离，这不明摆着过年回不去了嘛，真的得在外头过年了？从小到大记忆中还没有自己一个人在外头过过年，一想到这强烈的孤独感就涌上来。事态都不知道会往哪个方向发展，任何微小的事物都有改变世界的能力。在很多情况下，现状逆着常态走，一个一个意外外力无情助推。“无知”是福，悟懂这个可不容易啊。\n\n差不离了，留沪过年。还好有个会做饭的室友也留沪，不然我得泡面面包吃到吐。本来长大后就觉得过年也就那样没啥劲了，这下倒好，真就成了一个长周末了，一点点年味儿都没得咯。现在想想自己还要在外面漂多久，这个过年就只有老爸老妈两人，为人子却不能陪伴其右，是一种不孝吧。\n\n大家都在改变，社会在改变，国家也在改变。很多方式从未尝试我们也在积极适应。前十年二十年是科技互联网改变生活，现在今后怕很长一段时间就是环境改变生活。这么说确实有一点可怕，就好像是因果，前者发展破坏后者，后者又开始影响生活。\n\n刚跟父母说了过年不回家的事，老妈就说要不要给我寄点吃的，真的很感动。再听她说今年就只有她跟爸两人过除夕了，又很难受。自知事以后还真是没有在外头过过除夕，感触。\n\n时间真的，快得很。","slug":"new-january","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhl008ek9i1f6vu93xy","content":"<blockquote>\n<p>时光追不上白马……</p>\n</blockquote>\n<p>时隔一年，疫情还是没有得到完全控制，去年年前湖北严重，今年河北好像稍微严重一些，难不成今年是要在外头过年了吗？元旦回去倒还是较为顺利，并没有什么额外繁琐的步骤也没有强制要求核酸检测，不知年前会怎样。</p>\n<p>今天刚公司年会回来，相较之前参加的公司年会来说规模是更大一些的。不过这又有何用，阳光照样照我脸上……年会占用了周末时间，宾馆住了一晚，说实在的，除了抽奖那会会比较激动，其余也就那样了，在奉贤那边，周边也没有什么好的娱乐地方，也就只能打打牌了。</p>\n<p>哪知道形势变得这么快，上海前几天出了几例，黄浦区变成了中风险地区，公司进出都得戴口罩验体验看健康码。上头文件下来进出沪都得做核酸检测还得隔离，这不明摆着过年回不去了嘛，真的得在外头过年了？从小到大记忆中还没有自己一个人在外头过过年，一想到这强烈的孤独感就涌上来。事态都不知道会往哪个方向发展，任何微小的事物都有改变世界的能力。在很多情况下，现状逆着常态走，一个一个意外外力无情助推。“无知”是福，悟懂这个可不容易啊。</p>\n<p>差不离了，留沪过年。还好有个会做饭的室友也留沪，不然我得泡面面包吃到吐。本来长大后就觉得过年也就那样没啥劲了，这下倒好，真就成了一个长周末了，一点点年味儿都没得咯。现在想想自己还要在外面漂多久，这个过年就只有老爸老妈两人，为人子却不能陪伴其右，是一种不孝吧。</p>\n<p>大家都在改变，社会在改变，国家也在改变。很多方式从未尝试我们也在积极适应。前十年二十年是科技互联网改变生活，现在今后怕很长一段时间就是环境改变生活。这么说确实有一点可怕，就好像是因果，前者发展破坏后者，后者又开始影响生活。</p>\n<p>刚跟父母说了过年不回家的事，老妈就说要不要给我寄点吃的，真的很感动。再听她说今年就只有她跟爸两人过除夕了，又很难受。自知事以后还真是没有在外头过过除夕，感触。</p>\n<p>时间真的，快得很。</p>\n","excerpt":"","more":"<blockquote>\n<p>时光追不上白马……</p>\n</blockquote>\n<p>时隔一年，疫情还是没有得到完全控制，去年年前湖北严重，今年河北好像稍微严重一些，难不成今年是要在外头过年了吗？元旦回去倒还是较为顺利，并没有什么额外繁琐的步骤也没有强制要求核酸检测，不知年前会怎样。</p>\n<p>今天刚公司年会回来，相较之前参加的公司年会来说规模是更大一些的。不过这又有何用，阳光照样照我脸上……年会占用了周末时间，宾馆住了一晚，说实在的，除了抽奖那会会比较激动，其余也就那样了，在奉贤那边，周边也没有什么好的娱乐地方，也就只能打打牌了。</p>\n<p>哪知道形势变得这么快，上海前几天出了几例，黄浦区变成了中风险地区，公司进出都得戴口罩验体验看健康码。上头文件下来进出沪都得做核酸检测还得隔离，这不明摆着过年回不去了嘛，真的得在外头过年了？从小到大记忆中还没有自己一个人在外头过过年，一想到这强烈的孤独感就涌上来。事态都不知道会往哪个方向发展，任何微小的事物都有改变世界的能力。在很多情况下，现状逆着常态走，一个一个意外外力无情助推。“无知”是福，悟懂这个可不容易啊。</p>\n<p>差不离了，留沪过年。还好有个会做饭的室友也留沪，不然我得泡面面包吃到吐。本来长大后就觉得过年也就那样没啥劲了，这下倒好，真就成了一个长周末了，一点点年味儿都没得咯。现在想想自己还要在外面漂多久，这个过年就只有老爸老妈两人，为人子却不能陪伴其右，是一种不孝吧。</p>\n<p>大家都在改变，社会在改变，国家也在改变。很多方式从未尝试我们也在积极适应。前十年二十年是科技互联网改变生活，现在今后怕很长一段时间就是环境改变生活。这么说确实有一点可怕，就好像是因果，前者发展破坏后者，后者又开始影响生活。</p>\n<p>刚跟父母说了过年不回家的事，老妈就说要不要给我寄点吃的，真的很感动。再听她说今年就只有她跟爸两人过除夕了，又很难受。自知事以后还真是没有在外头过过除夕，感触。</p>\n<p>时间真的，快得很。</p>\n"},{"title":"全新五月（2020）","date":"2020-05-31T12:10:55.000Z","_content":"\n> 多事之 May\n\n破镜重圆，碎片拼接裂痕依旧存在；利刃抽去，伤口愈合伤痕依旧存在。随着时间和人物修复，在很好的情况下痕迹会越来越淡。可能到年老色衰之时，脑中容量不足便会抛弃此事，也或许这将伴随一生，直至死去。\n\n日子一天天过去，气温逐渐回升趋于稳定，生活却是依然飘荡不安。往后之事不堪臆想，黑云密布压得胸口时常透不过气来。但我又是温情之人，想到未来家庭、妻儿，心中便会涌起热流无比温暖畅快。\n\n舍即是得。\n\n---\n\n今年这个五月注定是个特殊的月份，往后回首，可能又会是个人生的重要分岔口，之后的几十年与之联系紧密。\n\n在我有印象的过去时光中，让我难忘的重要时刻有那么几个：\n\n- 小学升初中\n\n若是那时候没有考县城里的学校，若是父母没有帮我买进县城里的学校（成绩出来差三分），我就应该在镇子上上初中，然后不出意外的成了人们口中的“小混混”……当然之后也许又是另一番道路，不尽然都是不好的一面。\n\n- 初中升高中\n\n那时候中考提前批考试，本来我的名次可以保上县城重点中学，后来却被告知统计错误（之后越想越不对，或许有猫腻……）。然后那段时间低落过，不过最终中考成绩还是挺理想的，高出了县城重点中学录取分数二十多分。不过最终由于其他原因，老妈把我送去了金华市区上学，虽然是二中，但是那时候市区的学校也肯定比县城的师资力量要好。不过由于离家远，没人管教约束，我的成绩便不再像以前一样突出（当时数理化还是可以的），甚至产生了自我否定的感觉。以前觉得我就随便学学就能进班里前三，上了高中后便再也没有这种愚蠢的想法了。也是因此，我的世界观开始慢慢建立起来，学习了很多以前小地方不曾有的东西，见识了很多新鲜前沿的玩意儿，开始向往城市里的生活。也是因此，我快速长大变得成熟，有了超出同龄人的想法与担当。也是在高中时期，收获了我的第一份爱情。\n\n- 大学填志愿\n\n由于高中的不努力以及自我放纵，不出意外的高考没有个好成绩。当时根本不知道自己想要读什么专业，也没有人指点我，只记得那时候金融与土木是超级火的两个专业，不过我却选择了计算机。我没什么想法，只是觉得我选了计算机这个专业那就可以正大光明的买笔记本了，可以想玩游戏就玩游戏了！也是这个想法，拯救了大学毕业的我，好歹也是个“高薪”职业，不至于毕业出来了没得饭吃。\n\n- 毕业找工作\n\n大学的快乐时光总是觉得那么短暂，不决定考研的我们也要早早为自己毕业后的去向做打算。当时我在合肥找了一圈，发现不是变相培训就是基本给不了钱，也没有找到一个正儿八经的。后来是我当时的大学寝室长在上海，我便说那我去找你顺便找找看。就是这顺便找找看，我便在上海留到了现在。\n\n……\n\n人生就是这么一环套着一环套着一环……\n\n---\n\n今年是我毕业的第三个年头了，我想给自己重新定一个起点，再看后一个三年。共勉。","source":"_posts/new-may.md","raw":"---\ntitle: 全新五月（2020）\ndate: 2020-05-31 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 多事之 May\n\n破镜重圆，碎片拼接裂痕依旧存在；利刃抽去，伤口愈合伤痕依旧存在。随着时间和人物修复，在很好的情况下痕迹会越来越淡。可能到年老色衰之时，脑中容量不足便会抛弃此事，也或许这将伴随一生，直至死去。\n\n日子一天天过去，气温逐渐回升趋于稳定，生活却是依然飘荡不安。往后之事不堪臆想，黑云密布压得胸口时常透不过气来。但我又是温情之人，想到未来家庭、妻儿，心中便会涌起热流无比温暖畅快。\n\n舍即是得。\n\n---\n\n今年这个五月注定是个特殊的月份，往后回首，可能又会是个人生的重要分岔口，之后的几十年与之联系紧密。\n\n在我有印象的过去时光中，让我难忘的重要时刻有那么几个：\n\n- 小学升初中\n\n若是那时候没有考县城里的学校，若是父母没有帮我买进县城里的学校（成绩出来差三分），我就应该在镇子上上初中，然后不出意外的成了人们口中的“小混混”……当然之后也许又是另一番道路，不尽然都是不好的一面。\n\n- 初中升高中\n\n那时候中考提前批考试，本来我的名次可以保上县城重点中学，后来却被告知统计错误（之后越想越不对，或许有猫腻……）。然后那段时间低落过，不过最终中考成绩还是挺理想的，高出了县城重点中学录取分数二十多分。不过最终由于其他原因，老妈把我送去了金华市区上学，虽然是二中，但是那时候市区的学校也肯定比县城的师资力量要好。不过由于离家远，没人管教约束，我的成绩便不再像以前一样突出（当时数理化还是可以的），甚至产生了自我否定的感觉。以前觉得我就随便学学就能进班里前三，上了高中后便再也没有这种愚蠢的想法了。也是因此，我的世界观开始慢慢建立起来，学习了很多以前小地方不曾有的东西，见识了很多新鲜前沿的玩意儿，开始向往城市里的生活。也是因此，我快速长大变得成熟，有了超出同龄人的想法与担当。也是在高中时期，收获了我的第一份爱情。\n\n- 大学填志愿\n\n由于高中的不努力以及自我放纵，不出意外的高考没有个好成绩。当时根本不知道自己想要读什么专业，也没有人指点我，只记得那时候金融与土木是超级火的两个专业，不过我却选择了计算机。我没什么想法，只是觉得我选了计算机这个专业那就可以正大光明的买笔记本了，可以想玩游戏就玩游戏了！也是这个想法，拯救了大学毕业的我，好歹也是个“高薪”职业，不至于毕业出来了没得饭吃。\n\n- 毕业找工作\n\n大学的快乐时光总是觉得那么短暂，不决定考研的我们也要早早为自己毕业后的去向做打算。当时我在合肥找了一圈，发现不是变相培训就是基本给不了钱，也没有找到一个正儿八经的。后来是我当时的大学寝室长在上海，我便说那我去找你顺便找找看。就是这顺便找找看，我便在上海留到了现在。\n\n……\n\n人生就是这么一环套着一环套着一环……\n\n---\n\n今年是我毕业的第三个年头了，我想给自己重新定一个起点，再看后一个三年。共勉。","slug":"new-may","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhl008jk9i1angu6gma","content":"<blockquote>\n<p>多事之 May</p>\n</blockquote>\n<p>破镜重圆，碎片拼接裂痕依旧存在；利刃抽去，伤口愈合伤痕依旧存在。随着时间和人物修复，在很好的情况下痕迹会越来越淡。可能到年老色衰之时，脑中容量不足便会抛弃此事，也或许这将伴随一生，直至死去。</p>\n<p>日子一天天过去，气温逐渐回升趋于稳定，生活却是依然飘荡不安。往后之事不堪臆想，黑云密布压得胸口时常透不过气来。但我又是温情之人，想到未来家庭、妻儿，心中便会涌起热流无比温暖畅快。</p>\n<p>舍即是得。</p>\n<hr>\n<p>今年这个五月注定是个特殊的月份，往后回首，可能又会是个人生的重要分岔口，之后的几十年与之联系紧密。</p>\n<p>在我有印象的过去时光中，让我难忘的重要时刻有那么几个：</p>\n<ul>\n<li>小学升初中</li>\n</ul>\n<p>若是那时候没有考县城里的学校，若是父母没有帮我买进县城里的学校（成绩出来差三分），我就应该在镇子上上初中，然后不出意外的成了人们口中的“小混混”……当然之后也许又是另一番道路，不尽然都是不好的一面。</p>\n<ul>\n<li>初中升高中</li>\n</ul>\n<p>那时候中考提前批考试，本来我的名次可以保上县城重点中学，后来却被告知统计错误（之后越想越不对，或许有猫腻……）。然后那段时间低落过，不过最终中考成绩还是挺理想的，高出了县城重点中学录取分数二十多分。不过最终由于其他原因，老妈把我送去了金华市区上学，虽然是二中，但是那时候市区的学校也肯定比县城的师资力量要好。不过由于离家远，没人管教约束，我的成绩便不再像以前一样突出（当时数理化还是可以的），甚至产生了自我否定的感觉。以前觉得我就随便学学就能进班里前三，上了高中后便再也没有这种愚蠢的想法了。也是因此，我的世界观开始慢慢建立起来，学习了很多以前小地方不曾有的东西，见识了很多新鲜前沿的玩意儿，开始向往城市里的生活。也是因此，我快速长大变得成熟，有了超出同龄人的想法与担当。也是在高中时期，收获了我的第一份爱情。</p>\n<ul>\n<li>大学填志愿</li>\n</ul>\n<p>由于高中的不努力以及自我放纵，不出意外的高考没有个好成绩。当时根本不知道自己想要读什么专业，也没有人指点我，只记得那时候金融与土木是超级火的两个专业，不过我却选择了计算机。我没什么想法，只是觉得我选了计算机这个专业那就可以正大光明的买笔记本了，可以想玩游戏就玩游戏了！也是这个想法，拯救了大学毕业的我，好歹也是个“高薪”职业，不至于毕业出来了没得饭吃。</p>\n<ul>\n<li>毕业找工作</li>\n</ul>\n<p>大学的快乐时光总是觉得那么短暂，不决定考研的我们也要早早为自己毕业后的去向做打算。当时我在合肥找了一圈，发现不是变相培训就是基本给不了钱，也没有找到一个正儿八经的。后来是我当时的大学寝室长在上海，我便说那我去找你顺便找找看。就是这顺便找找看，我便在上海留到了现在。</p>\n<p>……</p>\n<p>人生就是这么一环套着一环套着一环……</p>\n<hr>\n<p>今年是我毕业的第三个年头了，我想给自己重新定一个起点，再看后一个三年。共勉。</p>\n","excerpt":"","more":"<blockquote>\n<p>多事之 May</p>\n</blockquote>\n<p>破镜重圆，碎片拼接裂痕依旧存在；利刃抽去，伤口愈合伤痕依旧存在。随着时间和人物修复，在很好的情况下痕迹会越来越淡。可能到年老色衰之时，脑中容量不足便会抛弃此事，也或许这将伴随一生，直至死去。</p>\n<p>日子一天天过去，气温逐渐回升趋于稳定，生活却是依然飘荡不安。往后之事不堪臆想，黑云密布压得胸口时常透不过气来。但我又是温情之人，想到未来家庭、妻儿，心中便会涌起热流无比温暖畅快。</p>\n<p>舍即是得。</p>\n<hr>\n<p>今年这个五月注定是个特殊的月份，往后回首，可能又会是个人生的重要分岔口，之后的几十年与之联系紧密。</p>\n<p>在我有印象的过去时光中，让我难忘的重要时刻有那么几个：</p>\n<ul>\n<li>小学升初中</li>\n</ul>\n<p>若是那时候没有考县城里的学校，若是父母没有帮我买进县城里的学校（成绩出来差三分），我就应该在镇子上上初中，然后不出意外的成了人们口中的“小混混”……当然之后也许又是另一番道路，不尽然都是不好的一面。</p>\n<ul>\n<li>初中升高中</li>\n</ul>\n<p>那时候中考提前批考试，本来我的名次可以保上县城重点中学，后来却被告知统计错误（之后越想越不对，或许有猫腻……）。然后那段时间低落过，不过最终中考成绩还是挺理想的，高出了县城重点中学录取分数二十多分。不过最终由于其他原因，老妈把我送去了金华市区上学，虽然是二中，但是那时候市区的学校也肯定比县城的师资力量要好。不过由于离家远，没人管教约束，我的成绩便不再像以前一样突出（当时数理化还是可以的），甚至产生了自我否定的感觉。以前觉得我就随便学学就能进班里前三，上了高中后便再也没有这种愚蠢的想法了。也是因此，我的世界观开始慢慢建立起来，学习了很多以前小地方不曾有的东西，见识了很多新鲜前沿的玩意儿，开始向往城市里的生活。也是因此，我快速长大变得成熟，有了超出同龄人的想法与担当。也是在高中时期，收获了我的第一份爱情。</p>\n<ul>\n<li>大学填志愿</li>\n</ul>\n<p>由于高中的不努力以及自我放纵，不出意外的高考没有个好成绩。当时根本不知道自己想要读什么专业，也没有人指点我，只记得那时候金融与土木是超级火的两个专业，不过我却选择了计算机。我没什么想法，只是觉得我选了计算机这个专业那就可以正大光明的买笔记本了，可以想玩游戏就玩游戏了！也是这个想法，拯救了大学毕业的我，好歹也是个“高薪”职业，不至于毕业出来了没得饭吃。</p>\n<ul>\n<li>毕业找工作</li>\n</ul>\n<p>大学的快乐时光总是觉得那么短暂，不决定考研的我们也要早早为自己毕业后的去向做打算。当时我在合肥找了一圈，发现不是变相培训就是基本给不了钱，也没有找到一个正儿八经的。后来是我当时的大学寝室长在上海，我便说那我去找你顺便找找看。就是这顺便找找看，我便在上海留到了现在。</p>\n<p>……</p>\n<p>人生就是这么一环套着一环套着一环……</p>\n<hr>\n<p>今年是我毕业的第三个年头了，我想给自己重新定一个起点，再看后一个三年。共勉。</p>\n"},{"title":"链表找环方法证明（拒绝误人子弟）","date":"2018-10-23T01:30:44.000Z","_content":"\n## 前言\n今天又想起来了这个问题，之前最开始是在其他论坛中看到有人说起了这个面试题。\n\n当时只是翻了下，大致了解了如何判断链表中是否有闭环，用两个快慢指针解决，但是没有了解如何去找到闭环开始的节点。\n\n刚上网搜了下，一群垃圾博主乱七八糟胡说八道，就知道从其他地方复制粘贴，都不过脑子的。谁说较快指针一定就是第二次在环上移动就能遇到较慢指针的，我这么个渣渣都能一眼看出来毛病一群人还复制粘贴都说 2，你们还真是 2！\n\n## 问题描述\n**一条链表如何判断是否有环？若是有环那怎么找到链表环的入口？**\n\n## 解决思路\n\n- 先判断是否有环\n\n**思路：**用快慢两个指针分别从链表头开始，慢指针 -> next，快指针 -> next -> next，这样如果有环那快指针务必会跑到慢指针后面，随即两者之间的距离一次会缩小一步，最终相遇。若是未相遇且快指针的 next 为 null，则说明链表无环。\n\n- 若是有环怎么找到环入口\n\n链表中有闭环即快慢两指针相遇了，见下方的手工图：\n\n![链表闭环](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/node-list-close-loop.png)\n\n一切清晰明了。让我们再来捋一捋。\n\n当两指针在 P 点相遇，我们可列出如下等式：\n```\n2(L+x) = L+x+n*H        (n >= 1) // n 为快指针在闭环上的圈数\n=> 2L+2x = L+x+n*H      (n >= 1)\n=> L = n*H-x            (n >= 1)\n=> L = n*(H-x)+(n-1)x   (n >= 1)\n```\n到这里，是不是有种扒光了的快感，哈哈。\n**网上许多博客就是把 n 默认当成了 1，实则不然。**\n\n**思路：**故我们可以这样做，当 l1 与 l2 相遇时，再来一个 l3 指针从链表头开始，而 l1 继续走，l2 就可以终结其使命没必要继续走了。此时 l1 和 l3 指针都是指向其 next。当 l3 指针到达环入口时，l1 也必然到达了环入口，即 l1 和 l3 指针会在环入口相遇，从而可求得入口位置。\n\n\n## 参考博客\n- [《编程之美》3.6判断链表是否相交之扩展：链表找环方法证明](https://www.cnblogs.com/wuyuegb2312/p/3183214.html)\n- [程序员编程艺术：第九章、闲话链表追赶问题](https://blog.csdn.net/v_july_v/article/details/6447013)","source":"_posts/node-list-close-loop.md","raw":"---\ntitle: 链表找环方法证明（拒绝误人子弟）\ndate: 2018-10-23 09:30:44\ncategories: [开发,算法]\ntags: [算法,链表]\n---\n\n## 前言\n今天又想起来了这个问题，之前最开始是在其他论坛中看到有人说起了这个面试题。\n\n当时只是翻了下，大致了解了如何判断链表中是否有闭环，用两个快慢指针解决，但是没有了解如何去找到闭环开始的节点。\n\n刚上网搜了下，一群垃圾博主乱七八糟胡说八道，就知道从其他地方复制粘贴，都不过脑子的。谁说较快指针一定就是第二次在环上移动就能遇到较慢指针的，我这么个渣渣都能一眼看出来毛病一群人还复制粘贴都说 2，你们还真是 2！\n\n## 问题描述\n**一条链表如何判断是否有环？若是有环那怎么找到链表环的入口？**\n\n## 解决思路\n\n- 先判断是否有环\n\n**思路：**用快慢两个指针分别从链表头开始，慢指针 -> next，快指针 -> next -> next，这样如果有环那快指针务必会跑到慢指针后面，随即两者之间的距离一次会缩小一步，最终相遇。若是未相遇且快指针的 next 为 null，则说明链表无环。\n\n- 若是有环怎么找到环入口\n\n链表中有闭环即快慢两指针相遇了，见下方的手工图：\n\n![链表闭环](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/node-list-close-loop.png)\n\n一切清晰明了。让我们再来捋一捋。\n\n当两指针在 P 点相遇，我们可列出如下等式：\n```\n2(L+x) = L+x+n*H        (n >= 1) // n 为快指针在闭环上的圈数\n=> 2L+2x = L+x+n*H      (n >= 1)\n=> L = n*H-x            (n >= 1)\n=> L = n*(H-x)+(n-1)x   (n >= 1)\n```\n到这里，是不是有种扒光了的快感，哈哈。\n**网上许多博客就是把 n 默认当成了 1，实则不然。**\n\n**思路：**故我们可以这样做，当 l1 与 l2 相遇时，再来一个 l3 指针从链表头开始，而 l1 继续走，l2 就可以终结其使命没必要继续走了。此时 l1 和 l3 指针都是指向其 next。当 l3 指针到达环入口时，l1 也必然到达了环入口，即 l1 和 l3 指针会在环入口相遇，从而可求得入口位置。\n\n\n## 参考博客\n- [《编程之美》3.6判断链表是否相交之扩展：链表找环方法证明](https://www.cnblogs.com/wuyuegb2312/p/3183214.html)\n- [程序员编程艺术：第九章、闲话链表追赶问题](https://blog.csdn.net/v_july_v/article/details/6447013)","slug":"node-list-close-loop","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhl008mk9i15mgf7f26","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天又想起来了这个问题，之前最开始是在其他论坛中看到有人说起了这个面试题。</p>\n<p>当时只是翻了下，大致了解了如何判断链表中是否有闭环，用两个快慢指针解决，但是没有了解如何去找到闭环开始的节点。</p>\n<p>刚上网搜了下，一群垃圾博主乱七八糟胡说八道，就知道从其他地方复制粘贴，都不过脑子的。谁说较快指针一定就是第二次在环上移动就能遇到较慢指针的，我这么个渣渣都能一眼看出来毛病一群人还复制粘贴都说 2，你们还真是 2！</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>一条链表如何判断是否有环？若是有环那怎么找到链表环的入口？</strong></p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><ul>\n<li>先判断是否有环</li>\n</ul>\n<p><strong>思路：</strong>用快慢两个指针分别从链表头开始，慢指针 -&gt; next，快指针 -&gt; next -&gt; next，这样如果有环那快指针务必会跑到慢指针后面，随即两者之间的距离一次会缩小一步，最终相遇。若是未相遇且快指针的 next 为 null，则说明链表无环。</p>\n<ul>\n<li>若是有环怎么找到环入口</li>\n</ul>\n<p>链表中有闭环即快慢两指针相遇了，见下方的手工图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/node-list-close-loop.png\" alt=\"链表闭环\"></p>\n<p>一切清晰明了。让我们再来捋一捋。</p>\n<p>当两指针在 P 点相遇，我们可列出如下等式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2(L+x) = L+x+n*H        (n &gt;= 1) // n 为快指针在闭环上的圈数</span><br><span class=\"line\">=&gt; 2L+2x = L+x+n*H      (n &gt;= 1)</span><br><span class=\"line\">=&gt; L = n*H-x            (n &gt;= 1)</span><br><span class=\"line\">=&gt; L = n*(H-x)+(n-1)x   (n &gt;= 1)</span><br></pre></td></tr></table></figure>\n<p>到这里，是不是有种扒光了的快感，哈哈。<br><strong>网上许多博客就是把 n 默认当成了 1，实则不然。</strong></p>\n<p><strong>思路：</strong>故我们可以这样做，当 l1 与 l2 相遇时，再来一个 l3 指针从链表头开始，而 l1 继续走，l2 就可以终结其使命没必要继续走了。此时 l1 和 l3 指针都是指向其 next。当 l3 指针到达环入口时，l1 也必然到达了环入口，即 l1 和 l3 指针会在环入口相遇，从而可求得入口位置。</p>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wuyuegb2312/p/3183214.html\">《编程之美》3.6判断链表是否相交之扩展：链表找环方法证明</a></li>\n<li><a href=\"https://blog.csdn.net/v_july_v/article/details/6447013\">程序员编程艺术：第九章、闲话链表追赶问题</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天又想起来了这个问题，之前最开始是在其他论坛中看到有人说起了这个面试题。</p>\n<p>当时只是翻了下，大致了解了如何判断链表中是否有闭环，用两个快慢指针解决，但是没有了解如何去找到闭环开始的节点。</p>\n<p>刚上网搜了下，一群垃圾博主乱七八糟胡说八道，就知道从其他地方复制粘贴，都不过脑子的。谁说较快指针一定就是第二次在环上移动就能遇到较慢指针的，我这么个渣渣都能一眼看出来毛病一群人还复制粘贴都说 2，你们还真是 2！</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><strong>一条链表如何判断是否有环？若是有环那怎么找到链表环的入口？</strong></p>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><ul>\n<li>先判断是否有环</li>\n</ul>\n<p><strong>思路：</strong>用快慢两个指针分别从链表头开始，慢指针 -&gt; next，快指针 -&gt; next -&gt; next，这样如果有环那快指针务必会跑到慢指针后面，随即两者之间的距离一次会缩小一步，最终相遇。若是未相遇且快指针的 next 为 null，则说明链表无环。</p>\n<ul>\n<li>若是有环怎么找到环入口</li>\n</ul>\n<p>链表中有闭环即快慢两指针相遇了，见下方的手工图：</p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/node-list-close-loop.png\" alt=\"链表闭环\"></p>\n<p>一切清晰明了。让我们再来捋一捋。</p>\n<p>当两指针在 P 点相遇，我们可列出如下等式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2(L+x) = L+x+n*H        (n &gt;= 1) // n 为快指针在闭环上的圈数</span><br><span class=\"line\">=&gt; 2L+2x = L+x+n*H      (n &gt;= 1)</span><br><span class=\"line\">=&gt; L = n*H-x            (n &gt;= 1)</span><br><span class=\"line\">=&gt; L = n*(H-x)+(n-1)x   (n &gt;= 1)</span><br></pre></td></tr></table></figure>\n<p>到这里，是不是有种扒光了的快感，哈哈。<br><strong>网上许多博客就是把 n 默认当成了 1，实则不然。</strong></p>\n<p><strong>思路：</strong>故我们可以这样做，当 l1 与 l2 相遇时，再来一个 l3 指针从链表头开始，而 l1 继续走，l2 就可以终结其使命没必要继续走了。此时 l1 和 l3 指针都是指向其 next。当 l3 指针到达环入口时，l1 也必然到达了环入口，即 l1 和 l3 指针会在环入口相遇，从而可求得入口位置。</p>\n<h2 id=\"参考博客\"><a href=\"#参考博客\" class=\"headerlink\" title=\"参考博客\"></a>参考博客</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wuyuegb2312/p/3183214.html\">《编程之美》3.6判断链表是否相交之扩展：链表找环方法证明</a></li>\n<li><a href=\"https://blog.csdn.net/v_july_v/article/details/6447013\">程序员编程艺术：第九章、闲话链表追赶问题</a></li>\n</ul>\n"},{"title":"无奇十一月（2021）","date":"2021-11-27T12:10:55.000Z","_content":"\n> 今年这个双十一剁得好像还可以\n\n### 龟\n\n去年九月在八戒家买的两只麝香苗前几天出掉了，算下来血亏。我可爱的小麝香啊。\n\n现在只剩下那只北美鳄了，算下来也有四年多了，今年个头倒是长得好像不多，可能跟我有一顿没一顿喂食有关吧。现在龟不在了，龟粮还刚买来没开封，现在又得要降价出掉了，心痛。\n\n\n\n### 冷\n\n又是一天降温十度以上，一天入冬。天冷就应该多吃吃火锅，小邱双十一买的火锅真是太棒了，在家吃火锅也比外头划算得多，吃到瘫在地上。现在电瓶车早上晚上骑的时候呼呼的，不戴手套的话手真的没知觉，还好配备了手套和耳罩，公司离得也近，还是比较方便的。听说今年的冬天要巨冷，现在还没到冷的时候哩！\n\n\n\n### 吃\n\n最近连着吃了两天的寿喜自助，吃完真的连看到肉头都晕。最近一段时间不怎么想吃肉了，还是想吃点蔬菜。现在蔬菜比肉还贵着哩！吃得杂，肚子也胀气，运动也少了，体重就上去了。\n\n\n\n### 地震\n\n之前从来没有亲身经历过这种这么明显震感的地震，这次在办公室都感觉到了大楼的震动和晃动。吓得我们赶紧下楼，直到确定安全了为止，震感很明显。\n\n\n\n### 玩偶\n\n迪士尼的圣诞款官方已经出来了，这次采用的预约购买策略，预约到的名额还要去现场排队购买。这一波不知道二级市场要炒到什么价位。到时候我也试试手气。又爆发疫情了，活动也延期了。\n\n---\n\n\n\n好久没回家了，刚稳定了点，上海网传又出现确诊的了，唉。\n\n","source":"_posts/normal-november.md","raw":"---\ntitle: 无奇十一月（2021）\ndate: 2021-11-27 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 今年这个双十一剁得好像还可以\n\n### 龟\n\n去年九月在八戒家买的两只麝香苗前几天出掉了，算下来血亏。我可爱的小麝香啊。\n\n现在只剩下那只北美鳄了，算下来也有四年多了，今年个头倒是长得好像不多，可能跟我有一顿没一顿喂食有关吧。现在龟不在了，龟粮还刚买来没开封，现在又得要降价出掉了，心痛。\n\n\n\n### 冷\n\n又是一天降温十度以上，一天入冬。天冷就应该多吃吃火锅，小邱双十一买的火锅真是太棒了，在家吃火锅也比外头划算得多，吃到瘫在地上。现在电瓶车早上晚上骑的时候呼呼的，不戴手套的话手真的没知觉，还好配备了手套和耳罩，公司离得也近，还是比较方便的。听说今年的冬天要巨冷，现在还没到冷的时候哩！\n\n\n\n### 吃\n\n最近连着吃了两天的寿喜自助，吃完真的连看到肉头都晕。最近一段时间不怎么想吃肉了，还是想吃点蔬菜。现在蔬菜比肉还贵着哩！吃得杂，肚子也胀气，运动也少了，体重就上去了。\n\n\n\n### 地震\n\n之前从来没有亲身经历过这种这么明显震感的地震，这次在办公室都感觉到了大楼的震动和晃动。吓得我们赶紧下楼，直到确定安全了为止，震感很明显。\n\n\n\n### 玩偶\n\n迪士尼的圣诞款官方已经出来了，这次采用的预约购买策略，预约到的名额还要去现场排队购买。这一波不知道二级市场要炒到什么价位。到时候我也试试手气。又爆发疫情了，活动也延期了。\n\n---\n\n\n\n好久没回家了，刚稳定了点，上海网传又出现确诊的了，唉。\n\n","slug":"normal-november","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhm008qk9i15d9m0fvx","content":"<blockquote>\n<p>今年这个双十一剁得好像还可以</p>\n</blockquote>\n<h3 id=\"龟\"><a href=\"#龟\" class=\"headerlink\" title=\"龟\"></a>龟</h3><p>去年九月在八戒家买的两只麝香苗前几天出掉了，算下来血亏。我可爱的小麝香啊。</p>\n<p>现在只剩下那只北美鳄了，算下来也有四年多了，今年个头倒是长得好像不多，可能跟我有一顿没一顿喂食有关吧。现在龟不在了，龟粮还刚买来没开封，现在又得要降价出掉了，心痛。</p>\n<h3 id=\"冷\"><a href=\"#冷\" class=\"headerlink\" title=\"冷\"></a>冷</h3><p>又是一天降温十度以上，一天入冬。天冷就应该多吃吃火锅，小邱双十一买的火锅真是太棒了，在家吃火锅也比外头划算得多，吃到瘫在地上。现在电瓶车早上晚上骑的时候呼呼的，不戴手套的话手真的没知觉，还好配备了手套和耳罩，公司离得也近，还是比较方便的。听说今年的冬天要巨冷，现在还没到冷的时候哩！</p>\n<h3 id=\"吃\"><a href=\"#吃\" class=\"headerlink\" title=\"吃\"></a>吃</h3><p>最近连着吃了两天的寿喜自助，吃完真的连看到肉头都晕。最近一段时间不怎么想吃肉了，还是想吃点蔬菜。现在蔬菜比肉还贵着哩！吃得杂，肚子也胀气，运动也少了，体重就上去了。</p>\n<h3 id=\"地震\"><a href=\"#地震\" class=\"headerlink\" title=\"地震\"></a>地震</h3><p>之前从来没有亲身经历过这种这么明显震感的地震，这次在办公室都感觉到了大楼的震动和晃动。吓得我们赶紧下楼，直到确定安全了为止，震感很明显。</p>\n<h3 id=\"玩偶\"><a href=\"#玩偶\" class=\"headerlink\" title=\"玩偶\"></a>玩偶</h3><p>迪士尼的圣诞款官方已经出来了，这次采用的预约购买策略，预约到的名额还要去现场排队购买。这一波不知道二级市场要炒到什么价位。到时候我也试试手气。又爆发疫情了，活动也延期了。</p>\n<hr>\n<p>好久没回家了，刚稳定了点，上海网传又出现确诊的了，唉。</p>\n","excerpt":"","more":"<blockquote>\n<p>今年这个双十一剁得好像还可以</p>\n</blockquote>\n<h3 id=\"龟\"><a href=\"#龟\" class=\"headerlink\" title=\"龟\"></a>龟</h3><p>去年九月在八戒家买的两只麝香苗前几天出掉了，算下来血亏。我可爱的小麝香啊。</p>\n<p>现在只剩下那只北美鳄了，算下来也有四年多了，今年个头倒是长得好像不多，可能跟我有一顿没一顿喂食有关吧。现在龟不在了，龟粮还刚买来没开封，现在又得要降价出掉了，心痛。</p>\n<h3 id=\"冷\"><a href=\"#冷\" class=\"headerlink\" title=\"冷\"></a>冷</h3><p>又是一天降温十度以上，一天入冬。天冷就应该多吃吃火锅，小邱双十一买的火锅真是太棒了，在家吃火锅也比外头划算得多，吃到瘫在地上。现在电瓶车早上晚上骑的时候呼呼的，不戴手套的话手真的没知觉，还好配备了手套和耳罩，公司离得也近，还是比较方便的。听说今年的冬天要巨冷，现在还没到冷的时候哩！</p>\n<h3 id=\"吃\"><a href=\"#吃\" class=\"headerlink\" title=\"吃\"></a>吃</h3><p>最近连着吃了两天的寿喜自助，吃完真的连看到肉头都晕。最近一段时间不怎么想吃肉了，还是想吃点蔬菜。现在蔬菜比肉还贵着哩！吃得杂，肚子也胀气，运动也少了，体重就上去了。</p>\n<h3 id=\"地震\"><a href=\"#地震\" class=\"headerlink\" title=\"地震\"></a>地震</h3><p>之前从来没有亲身经历过这种这么明显震感的地震，这次在办公室都感觉到了大楼的震动和晃动。吓得我们赶紧下楼，直到确定安全了为止，震感很明显。</p>\n<h3 id=\"玩偶\"><a href=\"#玩偶\" class=\"headerlink\" title=\"玩偶\"></a>玩偶</h3><p>迪士尼的圣诞款官方已经出来了，这次采用的预约购买策略，预约到的名额还要去现场排队购买。这一波不知道二级市场要炒到什么价位。到时候我也试试手气。又爆发疫情了，活动也延期了。</p>\n<hr>\n<p>好久没回家了，刚稳定了点，上海网传又出现确诊的了，唉。</p>\n"},{"title":"不足七月（2020）","date":"2020-07-30T13:10:55.000Z","_content":"\n> 美景七月，美色七月，不止七月。\n\n水滴滴入湖中引起一丝涟漪 随后恢复平静如镜\n\n只有水中的鱼儿目视了整个过程 可惜也改变不了七秒钟的记忆\n\n---\n\n近日气候忽冷忽热，晚上睡觉清早起床总是鼻涕不止，好像鼻炎又有些加重了。戴着口罩地铁出勤，闷得喘不过气却又不得不带，口罩上的毛絮还跟鼻子打闹，一玩就又容易出水，废纸得很。\n\n上次在租房小区附近意外寻得一个体育场，每日上午十点之前篮球场不收费。趁着周末这档子空期就去耍了会，小学时期的村头“篮球霸王”自从大学还零零散散玩过两下这一晃都三四年没打篮球了，霸王早已不复存在。由于工作原因，也不再像之前一样晚上能有充足的时间来跑跑步，老是疲惫的状态也不适合长跑。这下只能指望着周末的时间来补一补锻炼时长了，白天篮球晚上羽毛球，还不到年纪不能成了个油腻小伙。\n\n生日将至，距离三十周岁只有 5 年的时间了，有时候身处在大城市总是不知不觉会被城市的快节奏给带起来。本来是多么美好的年纪啊，如今却是安排成了这么一个不上不下无比尴尬的处境，值与不值。\n\n---\n\n看了下天气预报，终于有点出梅的兆头了，阴雨过去热浪来袭，喜与不喜都是这么一回事。\n\n窗外的雄蝉奋力发出声音来展现自己的强大魅力，吸引雌蝉来跟他交配。\n\n*蝉的幼虫通常会在土中待上几年甚至十几年，如 3 年、5 年，还会有 17 年，这些数有一个共同点，都是质数。这是因为质数的因数很少，在钻出泥土时可以防止和别的蝉类一起钻出，争夺领土、食物。将要羽化时，于黄昏及夜间钻出土表，爬到树上，然后抓紧树皮，蜕皮羽化。当蝉蛹的背上出现一条黑色的裂缝时，蜕皮的过程就开始了，头先出来，紧接着露出绿色的身体和褶皱的翅膀，停留片刻，使翅膀变硬，颜色变深，便开始起飞。整个过程需要一个小时左右。        ———— 百度百科*\n\n《第八日的蝉》\n\n我没看过这本书，先看看内容简介吧：\n\n★大陆首次出版日本第132届直木奖得主作品\n\n★村上春树的同门师妹，渡边淳一、黑木瞳最为欣赏的日本女作家\n\n★有‘幸’活到第八日的蝉，是悲？是喜？如果我努力的活着，上帝应该不会嫌弃我吧？\n\n蝉在土中七年，破土而出后却只能活七天\n\n但若有一只蝉跟伙伴不一样，独活了下来\n\n那么她感到的是孤独和悲哀，还是看到崭新风景的喜悦呢？\n\n\n我决定先看看其同名电影，豆瓣评分也很不错。\n\n---\n\n去年上海的 ChinaJoy 那几天被派到昆明出差去了，所以也没去成，这次早早就买好了票。\n\n天气也很给力，三十五度。疫情影响，口罩免不了全程佩戴，排着长长的队伍绕弯弯。其中好几个展馆里展位都没有摆满，游戏也大多是手游的宣传，综合看下来还是那些大厂的展台有格调，下了功夫。\n\n拍了几张 show girl 的照片，看那些个都是拿着专业设备的冲在前我这拿着三年前买的手机的手不自主地打抖来着。还是欣赏欣赏就好了。也不容易，穿着十厘米高跟一站就是几个小时，还有那些穿着玩偶套服的还好室内空调比较足。\n\n没什么收获，说实话今年一般般，我就买了个布罗利的手办，也没挑出其他更感兴趣的了。\n\n宅男娱乐，明年还去。","source":"_posts/not-enough-july.md","raw":"---\ntitle: 不足七月（2020）\ndate: 2020-07-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 美景七月，美色七月，不止七月。\n\n水滴滴入湖中引起一丝涟漪 随后恢复平静如镜\n\n只有水中的鱼儿目视了整个过程 可惜也改变不了七秒钟的记忆\n\n---\n\n近日气候忽冷忽热，晚上睡觉清早起床总是鼻涕不止，好像鼻炎又有些加重了。戴着口罩地铁出勤，闷得喘不过气却又不得不带，口罩上的毛絮还跟鼻子打闹，一玩就又容易出水，废纸得很。\n\n上次在租房小区附近意外寻得一个体育场，每日上午十点之前篮球场不收费。趁着周末这档子空期就去耍了会，小学时期的村头“篮球霸王”自从大学还零零散散玩过两下这一晃都三四年没打篮球了，霸王早已不复存在。由于工作原因，也不再像之前一样晚上能有充足的时间来跑跑步，老是疲惫的状态也不适合长跑。这下只能指望着周末的时间来补一补锻炼时长了，白天篮球晚上羽毛球，还不到年纪不能成了个油腻小伙。\n\n生日将至，距离三十周岁只有 5 年的时间了，有时候身处在大城市总是不知不觉会被城市的快节奏给带起来。本来是多么美好的年纪啊，如今却是安排成了这么一个不上不下无比尴尬的处境，值与不值。\n\n---\n\n看了下天气预报，终于有点出梅的兆头了，阴雨过去热浪来袭，喜与不喜都是这么一回事。\n\n窗外的雄蝉奋力发出声音来展现自己的强大魅力，吸引雌蝉来跟他交配。\n\n*蝉的幼虫通常会在土中待上几年甚至十几年，如 3 年、5 年，还会有 17 年，这些数有一个共同点，都是质数。这是因为质数的因数很少，在钻出泥土时可以防止和别的蝉类一起钻出，争夺领土、食物。将要羽化时，于黄昏及夜间钻出土表，爬到树上，然后抓紧树皮，蜕皮羽化。当蝉蛹的背上出现一条黑色的裂缝时，蜕皮的过程就开始了，头先出来，紧接着露出绿色的身体和褶皱的翅膀，停留片刻，使翅膀变硬，颜色变深，便开始起飞。整个过程需要一个小时左右。        ———— 百度百科*\n\n《第八日的蝉》\n\n我没看过这本书，先看看内容简介吧：\n\n★大陆首次出版日本第132届直木奖得主作品\n\n★村上春树的同门师妹，渡边淳一、黑木瞳最为欣赏的日本女作家\n\n★有‘幸’活到第八日的蝉，是悲？是喜？如果我努力的活着，上帝应该不会嫌弃我吧？\n\n蝉在土中七年，破土而出后却只能活七天\n\n但若有一只蝉跟伙伴不一样，独活了下来\n\n那么她感到的是孤独和悲哀，还是看到崭新风景的喜悦呢？\n\n\n我决定先看看其同名电影，豆瓣评分也很不错。\n\n---\n\n去年上海的 ChinaJoy 那几天被派到昆明出差去了，所以也没去成，这次早早就买好了票。\n\n天气也很给力，三十五度。疫情影响，口罩免不了全程佩戴，排着长长的队伍绕弯弯。其中好几个展馆里展位都没有摆满，游戏也大多是手游的宣传，综合看下来还是那些大厂的展台有格调，下了功夫。\n\n拍了几张 show girl 的照片，看那些个都是拿着专业设备的冲在前我这拿着三年前买的手机的手不自主地打抖来着。还是欣赏欣赏就好了。也不容易，穿着十厘米高跟一站就是几个小时，还有那些穿着玩偶套服的还好室内空调比较足。\n\n没什么收获，说实话今年一般般，我就买了个布罗利的手办，也没挑出其他更感兴趣的了。\n\n宅男娱乐，明年还去。","slug":"not-enough-july","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhm008tk9i1fyt62qk6","content":"<blockquote>\n<p>美景七月，美色七月，不止七月。</p>\n</blockquote>\n<p>水滴滴入湖中引起一丝涟漪 随后恢复平静如镜</p>\n<p>只有水中的鱼儿目视了整个过程 可惜也改变不了七秒钟的记忆</p>\n<hr>\n<p>近日气候忽冷忽热，晚上睡觉清早起床总是鼻涕不止，好像鼻炎又有些加重了。戴着口罩地铁出勤，闷得喘不过气却又不得不带，口罩上的毛絮还跟鼻子打闹，一玩就又容易出水，废纸得很。</p>\n<p>上次在租房小区附近意外寻得一个体育场，每日上午十点之前篮球场不收费。趁着周末这档子空期就去耍了会，小学时期的村头“篮球霸王”自从大学还零零散散玩过两下这一晃都三四年没打篮球了，霸王早已不复存在。由于工作原因，也不再像之前一样晚上能有充足的时间来跑跑步，老是疲惫的状态也不适合长跑。这下只能指望着周末的时间来补一补锻炼时长了，白天篮球晚上羽毛球，还不到年纪不能成了个油腻小伙。</p>\n<p>生日将至，距离三十周岁只有 5 年的时间了，有时候身处在大城市总是不知不觉会被城市的快节奏给带起来。本来是多么美好的年纪啊，如今却是安排成了这么一个不上不下无比尴尬的处境，值与不值。</p>\n<hr>\n<p>看了下天气预报，终于有点出梅的兆头了，阴雨过去热浪来袭，喜与不喜都是这么一回事。</p>\n<p>窗外的雄蝉奋力发出声音来展现自己的强大魅力，吸引雌蝉来跟他交配。</p>\n<p><em>蝉的幼虫通常会在土中待上几年甚至十几年，如 3 年、5 年，还会有 17 年，这些数有一个共同点，都是质数。这是因为质数的因数很少，在钻出泥土时可以防止和别的蝉类一起钻出，争夺领土、食物。将要羽化时，于黄昏及夜间钻出土表，爬到树上，然后抓紧树皮，蜕皮羽化。当蝉蛹的背上出现一条黑色的裂缝时，蜕皮的过程就开始了，头先出来，紧接着露出绿色的身体和褶皱的翅膀，停留片刻，使翅膀变硬，颜色变深，便开始起飞。整个过程需要一个小时左右。        ———— 百度百科</em></p>\n<p>《第八日的蝉》</p>\n<p>我没看过这本书，先看看内容简介吧：</p>\n<p>★大陆首次出版日本第132届直木奖得主作品</p>\n<p>★村上春树的同门师妹，渡边淳一、黑木瞳最为欣赏的日本女作家</p>\n<p>★有‘幸’活到第八日的蝉，是悲？是喜？如果我努力的活着，上帝应该不会嫌弃我吧？</p>\n<p>蝉在土中七年，破土而出后却只能活七天</p>\n<p>但若有一只蝉跟伙伴不一样，独活了下来</p>\n<p>那么她感到的是孤独和悲哀，还是看到崭新风景的喜悦呢？</p>\n<p>我决定先看看其同名电影，豆瓣评分也很不错。</p>\n<hr>\n<p>去年上海的 ChinaJoy 那几天被派到昆明出差去了，所以也没去成，这次早早就买好了票。</p>\n<p>天气也很给力，三十五度。疫情影响，口罩免不了全程佩戴，排着长长的队伍绕弯弯。其中好几个展馆里展位都没有摆满，游戏也大多是手游的宣传，综合看下来还是那些大厂的展台有格调，下了功夫。</p>\n<p>拍了几张 show girl 的照片，看那些个都是拿着专业设备的冲在前我这拿着三年前买的手机的手不自主地打抖来着。还是欣赏欣赏就好了。也不容易，穿着十厘米高跟一站就是几个小时，还有那些穿着玩偶套服的还好室内空调比较足。</p>\n<p>没什么收获，说实话今年一般般，我就买了个布罗利的手办，也没挑出其他更感兴趣的了。</p>\n<p>宅男娱乐，明年还去。</p>\n","excerpt":"","more":"<blockquote>\n<p>美景七月，美色七月，不止七月。</p>\n</blockquote>\n<p>水滴滴入湖中引起一丝涟漪 随后恢复平静如镜</p>\n<p>只有水中的鱼儿目视了整个过程 可惜也改变不了七秒钟的记忆</p>\n<hr>\n<p>近日气候忽冷忽热，晚上睡觉清早起床总是鼻涕不止，好像鼻炎又有些加重了。戴着口罩地铁出勤，闷得喘不过气却又不得不带，口罩上的毛絮还跟鼻子打闹，一玩就又容易出水，废纸得很。</p>\n<p>上次在租房小区附近意外寻得一个体育场，每日上午十点之前篮球场不收费。趁着周末这档子空期就去耍了会，小学时期的村头“篮球霸王”自从大学还零零散散玩过两下这一晃都三四年没打篮球了，霸王早已不复存在。由于工作原因，也不再像之前一样晚上能有充足的时间来跑跑步，老是疲惫的状态也不适合长跑。这下只能指望着周末的时间来补一补锻炼时长了，白天篮球晚上羽毛球，还不到年纪不能成了个油腻小伙。</p>\n<p>生日将至，距离三十周岁只有 5 年的时间了，有时候身处在大城市总是不知不觉会被城市的快节奏给带起来。本来是多么美好的年纪啊，如今却是安排成了这么一个不上不下无比尴尬的处境，值与不值。</p>\n<hr>\n<p>看了下天气预报，终于有点出梅的兆头了，阴雨过去热浪来袭，喜与不喜都是这么一回事。</p>\n<p>窗外的雄蝉奋力发出声音来展现自己的强大魅力，吸引雌蝉来跟他交配。</p>\n<p><em>蝉的幼虫通常会在土中待上几年甚至十几年，如 3 年、5 年，还会有 17 年，这些数有一个共同点，都是质数。这是因为质数的因数很少，在钻出泥土时可以防止和别的蝉类一起钻出，争夺领土、食物。将要羽化时，于黄昏及夜间钻出土表，爬到树上，然后抓紧树皮，蜕皮羽化。当蝉蛹的背上出现一条黑色的裂缝时，蜕皮的过程就开始了，头先出来，紧接着露出绿色的身体和褶皱的翅膀，停留片刻，使翅膀变硬，颜色变深，便开始起飞。整个过程需要一个小时左右。        ———— 百度百科</em></p>\n<p>《第八日的蝉》</p>\n<p>我没看过这本书，先看看内容简介吧：</p>\n<p>★大陆首次出版日本第132届直木奖得主作品</p>\n<p>★村上春树的同门师妹，渡边淳一、黑木瞳最为欣赏的日本女作家</p>\n<p>★有‘幸’活到第八日的蝉，是悲？是喜？如果我努力的活着，上帝应该不会嫌弃我吧？</p>\n<p>蝉在土中七年，破土而出后却只能活七天</p>\n<p>但若有一只蝉跟伙伴不一样，独活了下来</p>\n<p>那么她感到的是孤独和悲哀，还是看到崭新风景的喜悦呢？</p>\n<p>我决定先看看其同名电影，豆瓣评分也很不错。</p>\n<hr>\n<p>去年上海的 ChinaJoy 那几天被派到昆明出差去了，所以也没去成，这次早早就买好了票。</p>\n<p>天气也很给力，三十五度。疫情影响，口罩免不了全程佩戴，排着长长的队伍绕弯弯。其中好几个展馆里展位都没有摆满，游戏也大多是手游的宣传，综合看下来还是那些大厂的展台有格调，下了功夫。</p>\n<p>拍了几张 show girl 的照片，看那些个都是拿着专业设备的冲在前我这拿着三年前买的手机的手不自主地打抖来着。还是欣赏欣赏就好了。也不容易，穿着十厘米高跟一站就是几个小时，还有那些穿着玩偶套服的还好室内空调比较足。</p>\n<p>没什么收获，说实话今年一般般，我就买了个布罗利的手办，也没挑出其他更感兴趣的了。</p>\n<p>宅男娱乐，明年还去。</p>\n"},{"title":"事务嵌套使用注意点","date":"2021-03-06T12:10:55.000Z","_content":"\n最近在项目中需要用到事务嵌套使用，即方法 A 中调用方法 B，A 和 B 都有事务控制，且方法 B 的事务独立于 A，为一个独立新事务。\n\n刚开始用默认的事务类型 `PROPAGATION_REQUIRED`，结果当然是失败了。后来查找了事务的类型以及事务传播机制，简单列一下如下：\n\n\n- `PROPAGATION_REQUIRED`\t表示如果当前事务存在，则支持当前事务。否则，会启动一个新的事务。默认的事务类型。\n- `PROPAGATION_SUPPORTS`\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，就以非事务方式执行。\n- `PROPAGATION_MANDATORY`\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，则返回事务嵌套错误。\n- `PROPAGATION_REQUIRES_NEW`\t表示新建一个全新 Session 开启一个全新事务，如果当前存在事务，则把当前事务挂起。\n- `PROPAGATION_NOT_SUPPORTED`\t表示以非事务方式执行操作，如果当前存在事务，则新建一个Session以非事务方式执行操作，把当前事务挂起。\n- `PROPAGATION_NEVER`\t表示以非事务方式执行操作，如果当前存在事务，则返回事务嵌套错误。\n- `PROPAGATION_NESTED`\t表示如果当前事务存在，则在嵌套事务内执行，如嵌套事务回滚，则只会在嵌套事务内回滚，不会影响当前事务。如果当前没有事务，则进行与 PROPAGATION_REQUIRED 类似的操作。\n- `PROPAGATION_NOT_REQUIRED`\t表示如果当前没有事务，就新建一个事务，否则返回错误。\n\n\n了解了事务类型以及其传播机制之后，结合业务我当然选择了 `PROPAGATION_REQUIRES_NEW`。\n\n当我以为一切就将迎刃而解之时，debug...，what！！为什么没有生效！！\n\n然后我又在知识海洋中继续搜寻蛛丝马迹，渴求那些曾与我一同有此境遇的可怜人的良方。\n\n最终在几年前的帖子中终于找到了我想要的解决方案：\n\n**方法 B 需要写在另一个类中，不能跟方法 A 写在一个类里面，不然就不会生效！**\n\n详情可看该文章：[spring事务@Transactional在同一个类中的方法调用不生效](https://blog.csdn.net/qq_30336433/article/details/83338835)\n\n简单来说就是： **Spring 采用动态代理(AOP)实现对 bean 的管理和切片，它为我们的每个 class 生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。而触发切面逻辑才会进入事务拦截器从而加入到事务管理器中让事务生效！**\n\n记录一下。","source":"_posts/note-transactions.md","raw":"---\ntitle: 事务嵌套使用注意点\ndate: 2021-03-06 20:10:55\ncategories: [开发,总结]\ntags: [事务]\n---\n\n最近在项目中需要用到事务嵌套使用，即方法 A 中调用方法 B，A 和 B 都有事务控制，且方法 B 的事务独立于 A，为一个独立新事务。\n\n刚开始用默认的事务类型 `PROPAGATION_REQUIRED`，结果当然是失败了。后来查找了事务的类型以及事务传播机制，简单列一下如下：\n\n\n- `PROPAGATION_REQUIRED`\t表示如果当前事务存在，则支持当前事务。否则，会启动一个新的事务。默认的事务类型。\n- `PROPAGATION_SUPPORTS`\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，就以非事务方式执行。\n- `PROPAGATION_MANDATORY`\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，则返回事务嵌套错误。\n- `PROPAGATION_REQUIRES_NEW`\t表示新建一个全新 Session 开启一个全新事务，如果当前存在事务，则把当前事务挂起。\n- `PROPAGATION_NOT_SUPPORTED`\t表示以非事务方式执行操作，如果当前存在事务，则新建一个Session以非事务方式执行操作，把当前事务挂起。\n- `PROPAGATION_NEVER`\t表示以非事务方式执行操作，如果当前存在事务，则返回事务嵌套错误。\n- `PROPAGATION_NESTED`\t表示如果当前事务存在，则在嵌套事务内执行，如嵌套事务回滚，则只会在嵌套事务内回滚，不会影响当前事务。如果当前没有事务，则进行与 PROPAGATION_REQUIRED 类似的操作。\n- `PROPAGATION_NOT_REQUIRED`\t表示如果当前没有事务，就新建一个事务，否则返回错误。\n\n\n了解了事务类型以及其传播机制之后，结合业务我当然选择了 `PROPAGATION_REQUIRES_NEW`。\n\n当我以为一切就将迎刃而解之时，debug...，what！！为什么没有生效！！\n\n然后我又在知识海洋中继续搜寻蛛丝马迹，渴求那些曾与我一同有此境遇的可怜人的良方。\n\n最终在几年前的帖子中终于找到了我想要的解决方案：\n\n**方法 B 需要写在另一个类中，不能跟方法 A 写在一个类里面，不然就不会生效！**\n\n详情可看该文章：[spring事务@Transactional在同一个类中的方法调用不生效](https://blog.csdn.net/qq_30336433/article/details/83338835)\n\n简单来说就是： **Spring 采用动态代理(AOP)实现对 bean 的管理和切片，它为我们的每个 class 生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。而触发切面逻辑才会进入事务拦截器从而加入到事务管理器中让事务生效！**\n\n记录一下。","slug":"note-transactions","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhm008yk9i13q5l3tzf","content":"<p>最近在项目中需要用到事务嵌套使用，即方法 A 中调用方法 B，A 和 B 都有事务控制，且方法 B 的事务独立于 A，为一个独立新事务。</p>\n<p>刚开始用默认的事务类型 <code>PROPAGATION_REQUIRED</code>，结果当然是失败了。后来查找了事务的类型以及事务传播机制，简单列一下如下：</p>\n<ul>\n<li><code>PROPAGATION_REQUIRED</code>\t表示如果当前事务存在，则支持当前事务。否则，会启动一个新的事务。默认的事务类型。</li>\n<li><code>PROPAGATION_SUPPORTS</code>\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，就以非事务方式执行。</li>\n<li><code>PROPAGATION_MANDATORY</code>\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，则返回事务嵌套错误。</li>\n<li><code>PROPAGATION_REQUIRES_NEW</code>\t表示新建一个全新 Session 开启一个全新事务，如果当前存在事务，则把当前事务挂起。</li>\n<li><code>PROPAGATION_NOT_SUPPORTED</code>\t表示以非事务方式执行操作，如果当前存在事务，则新建一个Session以非事务方式执行操作，把当前事务挂起。</li>\n<li><code>PROPAGATION_NEVER</code>\t表示以非事务方式执行操作，如果当前存在事务，则返回事务嵌套错误。</li>\n<li><code>PROPAGATION_NESTED</code>\t表示如果当前事务存在，则在嵌套事务内执行，如嵌套事务回滚，则只会在嵌套事务内回滚，不会影响当前事务。如果当前没有事务，则进行与 PROPAGATION_REQUIRED 类似的操作。</li>\n<li><code>PROPAGATION_NOT_REQUIRED</code>\t表示如果当前没有事务，就新建一个事务，否则返回错误。</li>\n</ul>\n<p>了解了事务类型以及其传播机制之后，结合业务我当然选择了 <code>PROPAGATION_REQUIRES_NEW</code>。</p>\n<p>当我以为一切就将迎刃而解之时，debug…，what！！为什么没有生效！！</p>\n<p>然后我又在知识海洋中继续搜寻蛛丝马迹，渴求那些曾与我一同有此境遇的可怜人的良方。</p>\n<p>最终在几年前的帖子中终于找到了我想要的解决方案：</p>\n<p><strong>方法 B 需要写在另一个类中，不能跟方法 A 写在一个类里面，不然就不会生效！</strong></p>\n<p>详情可看该文章：<a href=\"https://blog.csdn.net/qq_30336433/article/details/83338835\">spring事务@Transactional在同一个类中的方法调用不生效</a></p>\n<p>简单来说就是： <strong>Spring 采用动态代理(AOP)实现对 bean 的管理和切片，它为我们的每个 class 生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。而触发切面逻辑才会进入事务拦截器从而加入到事务管理器中让事务生效！</strong></p>\n<p>记录一下。</p>\n","excerpt":"","more":"<p>最近在项目中需要用到事务嵌套使用，即方法 A 中调用方法 B，A 和 B 都有事务控制，且方法 B 的事务独立于 A，为一个独立新事务。</p>\n<p>刚开始用默认的事务类型 <code>PROPAGATION_REQUIRED</code>，结果当然是失败了。后来查找了事务的类型以及事务传播机制，简单列一下如下：</p>\n<ul>\n<li><code>PROPAGATION_REQUIRED</code>\t表示如果当前事务存在，则支持当前事务。否则，会启动一个新的事务。默认的事务类型。</li>\n<li><code>PROPAGATION_SUPPORTS</code>\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，就以非事务方式执行。</li>\n<li><code>PROPAGATION_MANDATORY</code>\t表示如果当前事务存在，则支持当前事务，如果当前没有事务，则返回事务嵌套错误。</li>\n<li><code>PROPAGATION_REQUIRES_NEW</code>\t表示新建一个全新 Session 开启一个全新事务，如果当前存在事务，则把当前事务挂起。</li>\n<li><code>PROPAGATION_NOT_SUPPORTED</code>\t表示以非事务方式执行操作，如果当前存在事务，则新建一个Session以非事务方式执行操作，把当前事务挂起。</li>\n<li><code>PROPAGATION_NEVER</code>\t表示以非事务方式执行操作，如果当前存在事务，则返回事务嵌套错误。</li>\n<li><code>PROPAGATION_NESTED</code>\t表示如果当前事务存在，则在嵌套事务内执行，如嵌套事务回滚，则只会在嵌套事务内回滚，不会影响当前事务。如果当前没有事务，则进行与 PROPAGATION_REQUIRED 类似的操作。</li>\n<li><code>PROPAGATION_NOT_REQUIRED</code>\t表示如果当前没有事务，就新建一个事务，否则返回错误。</li>\n</ul>\n<p>了解了事务类型以及其传播机制之后，结合业务我当然选择了 <code>PROPAGATION_REQUIRES_NEW</code>。</p>\n<p>当我以为一切就将迎刃而解之时，debug…，what！！为什么没有生效！！</p>\n<p>然后我又在知识海洋中继续搜寻蛛丝马迹，渴求那些曾与我一同有此境遇的可怜人的良方。</p>\n<p>最终在几年前的帖子中终于找到了我想要的解决方案：</p>\n<p><strong>方法 B 需要写在另一个类中，不能跟方法 A 写在一个类里面，不然就不会生效！</strong></p>\n<p>详情可看该文章：<a href=\"https://blog.csdn.net/qq_30336433/article/details/83338835\">spring事务@Transactional在同一个类中的方法调用不生效</a></p>\n<p>简单来说就是： <strong>Spring 采用动态代理(AOP)实现对 bean 的管理和切片，它为我们的每个 class 生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。而触发切面逻辑才会进入事务拦截器从而加入到事务管理器中让事务生效！</strong></p>\n<p>记录一下。</p>\n"},{"title":"住在对面的居民","date":"2018-12-13T03:01:50.000Z","_content":"\n住在对面的居民，我想与我这边环境也相似，只是人口数量略有差异。\n\n有段时间，每晚下班我进房间打开房灯，第一件事就是站在窗外静静的看着对面的居民们。因为是老式小区，楼层不高，每栋之间的间隔也不大，看不清对面的模样但至少看得清对面的举动。\n\n住在对面的居民，每户人家做的事皆不相同，作息时间皆不相同，窗外布置也是皆不相同。有时我就呆呆的站在那看，不知为什么，我就是能呆呆的站在那看。\n\n住在对面的居民，能看见内部情况的户数不多，却给我有种人生百态的感觉。我想这也是吸引我的原因，是我在此执笔想要记录的原因吧。\n\n住在对面楼斜上角的住户，是一家三口。看不清他们具体模样，只是知道小孩还小，还不会走路。往往见到他们都是在轮流抱着孩子，哄着睡觉，经常就是一哄一两个小时。当小孩入睡后，夫妻俩才开始走到厨房，不知是洗吃完饭后的碗筷还是才开始动手做饭。\n\n住在夫妻俩下两层的是一位好学之人，对其的了解甚少，因为当我驻窗前“偷窥”时，他八成是坐在桌前，也只有桌前那扇窗没拉窗帘。由于晚上视线昏暗加之一定的观察距离，我只知他是位男性，大多独自一人坐在桌前，看书或是写字，我便看不大清了。纵上观之，好学之人，那是定错不了的了。\n\n住在正对面楼偏上一点的是一个大家庭，观察至今我看到出现过一个老头、一个老太、还有较之年轻的一男一女。因为楼层的原因，我只能看到其窗外晾晒的衣物，无法窥视到内部的情形。只是有时能看到一男的或是女的走过来拉上窗户，拉上窗帘，像似要与外界隔绝，美美地做个美美的梦。有个周末，我坐在床上看着投影中的电影，眼睛往窗外一瞥，霎时汗毛直立。待我定睛瞧时，原来是这户窗外挂了个人形玩偶在那晾晒，好不瘆人。\n\n住在对面稍偏右下的一个小房间里住着一个人，应该是男性。经常看他坐在电脑桌前，毛玻璃的蒙眬使我看不清他在键盘上的手速，但我想，那定是青轴。偶尔起身，那便应该是尿意来袭或是口干舌燥了吧。\n\n再往右数米处有间房间最近一直在粉刷装修，往往十一二点还能见到粉刷匠在吊灯下的身影。背后有个美满的家庭，再多的重担肩上扛着，脸上还是挂着幸福的笑容。\n\n再往上一点有个房间好像是个女性独处，有次晚上偶尔看到其窗帘未拉上，她正趴在床上玩手机，还是毛玻璃蒙眬，也许是男性也说不准。后来我每每往那边瞧时，皆是漆黑一片。恐是精神作祟？好不瘆人。\n\n前些日子降了几场大雪，我去杭州出差那几日正是雪下得最大的时候。出门时撑的是黑伞，没过几分钟便已是白伞了。一夜过后，清晨出门，看着路边单车坐垫上足足有五六公分积雪，已是多少年没下过如此大雪了。犹记得儿时，记忆中的过年都是在厚厚的白雪上渡过。那时我们喜欢玩鞭炮，点火花棒在空中使劲了甩，不像如今，我们老家已经禁炮许多年了。都说现在过年越来越没有年味儿了，不是年味儿它消失了，是我们不知觉中已然长大。\n\n忙碌，如今整日忙碌，却有时又不知到底在忙碌些什么。我们不妨自己找个时间，静静呆会，可以看看月亮看看星星，看看过往的路人，也可以跟我一样看看住在对面的居民。\n\n**Life is like a box of chocolate,you never know what you are going to get.**\n\n共勉。","source":"_posts/opposite-build.md","raw":"---\ntitle: 住在对面的居民\ndate: 2018-12-13 11:01:50\ncategories: [生活,杂侃]\ntags: []\n---\n\n住在对面的居民，我想与我这边环境也相似，只是人口数量略有差异。\n\n有段时间，每晚下班我进房间打开房灯，第一件事就是站在窗外静静的看着对面的居民们。因为是老式小区，楼层不高，每栋之间的间隔也不大，看不清对面的模样但至少看得清对面的举动。\n\n住在对面的居民，每户人家做的事皆不相同，作息时间皆不相同，窗外布置也是皆不相同。有时我就呆呆的站在那看，不知为什么，我就是能呆呆的站在那看。\n\n住在对面的居民，能看见内部情况的户数不多，却给我有种人生百态的感觉。我想这也是吸引我的原因，是我在此执笔想要记录的原因吧。\n\n住在对面楼斜上角的住户，是一家三口。看不清他们具体模样，只是知道小孩还小，还不会走路。往往见到他们都是在轮流抱着孩子，哄着睡觉，经常就是一哄一两个小时。当小孩入睡后，夫妻俩才开始走到厨房，不知是洗吃完饭后的碗筷还是才开始动手做饭。\n\n住在夫妻俩下两层的是一位好学之人，对其的了解甚少，因为当我驻窗前“偷窥”时，他八成是坐在桌前，也只有桌前那扇窗没拉窗帘。由于晚上视线昏暗加之一定的观察距离，我只知他是位男性，大多独自一人坐在桌前，看书或是写字，我便看不大清了。纵上观之，好学之人，那是定错不了的了。\n\n住在正对面楼偏上一点的是一个大家庭，观察至今我看到出现过一个老头、一个老太、还有较之年轻的一男一女。因为楼层的原因，我只能看到其窗外晾晒的衣物，无法窥视到内部的情形。只是有时能看到一男的或是女的走过来拉上窗户，拉上窗帘，像似要与外界隔绝，美美地做个美美的梦。有个周末，我坐在床上看着投影中的电影，眼睛往窗外一瞥，霎时汗毛直立。待我定睛瞧时，原来是这户窗外挂了个人形玩偶在那晾晒，好不瘆人。\n\n住在对面稍偏右下的一个小房间里住着一个人，应该是男性。经常看他坐在电脑桌前，毛玻璃的蒙眬使我看不清他在键盘上的手速，但我想，那定是青轴。偶尔起身，那便应该是尿意来袭或是口干舌燥了吧。\n\n再往右数米处有间房间最近一直在粉刷装修，往往十一二点还能见到粉刷匠在吊灯下的身影。背后有个美满的家庭，再多的重担肩上扛着，脸上还是挂着幸福的笑容。\n\n再往上一点有个房间好像是个女性独处，有次晚上偶尔看到其窗帘未拉上，她正趴在床上玩手机，还是毛玻璃蒙眬，也许是男性也说不准。后来我每每往那边瞧时，皆是漆黑一片。恐是精神作祟？好不瘆人。\n\n前些日子降了几场大雪，我去杭州出差那几日正是雪下得最大的时候。出门时撑的是黑伞，没过几分钟便已是白伞了。一夜过后，清晨出门，看着路边单车坐垫上足足有五六公分积雪，已是多少年没下过如此大雪了。犹记得儿时，记忆中的过年都是在厚厚的白雪上渡过。那时我们喜欢玩鞭炮，点火花棒在空中使劲了甩，不像如今，我们老家已经禁炮许多年了。都说现在过年越来越没有年味儿了，不是年味儿它消失了，是我们不知觉中已然长大。\n\n忙碌，如今整日忙碌，却有时又不知到底在忙碌些什么。我们不妨自己找个时间，静静呆会，可以看看月亮看看星星，看看过往的路人，也可以跟我一样看看住在对面的居民。\n\n**Life is like a box of chocolate,you never know what you are going to get.**\n\n共勉。","slug":"opposite-build","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhm0091k9i1dh3kc5lm","content":"<p>住在对面的居民，我想与我这边环境也相似，只是人口数量略有差异。</p>\n<p>有段时间，每晚下班我进房间打开房灯，第一件事就是站在窗外静静的看着对面的居民们。因为是老式小区，楼层不高，每栋之间的间隔也不大，看不清对面的模样但至少看得清对面的举动。</p>\n<p>住在对面的居民，每户人家做的事皆不相同，作息时间皆不相同，窗外布置也是皆不相同。有时我就呆呆的站在那看，不知为什么，我就是能呆呆的站在那看。</p>\n<p>住在对面的居民，能看见内部情况的户数不多，却给我有种人生百态的感觉。我想这也是吸引我的原因，是我在此执笔想要记录的原因吧。</p>\n<p>住在对面楼斜上角的住户，是一家三口。看不清他们具体模样，只是知道小孩还小，还不会走路。往往见到他们都是在轮流抱着孩子，哄着睡觉，经常就是一哄一两个小时。当小孩入睡后，夫妻俩才开始走到厨房，不知是洗吃完饭后的碗筷还是才开始动手做饭。</p>\n<p>住在夫妻俩下两层的是一位好学之人，对其的了解甚少，因为当我驻窗前“偷窥”时，他八成是坐在桌前，也只有桌前那扇窗没拉窗帘。由于晚上视线昏暗加之一定的观察距离，我只知他是位男性，大多独自一人坐在桌前，看书或是写字，我便看不大清了。纵上观之，好学之人，那是定错不了的了。</p>\n<p>住在正对面楼偏上一点的是一个大家庭，观察至今我看到出现过一个老头、一个老太、还有较之年轻的一男一女。因为楼层的原因，我只能看到其窗外晾晒的衣物，无法窥视到内部的情形。只是有时能看到一男的或是女的走过来拉上窗户，拉上窗帘，像似要与外界隔绝，美美地做个美美的梦。有个周末，我坐在床上看着投影中的电影，眼睛往窗外一瞥，霎时汗毛直立。待我定睛瞧时，原来是这户窗外挂了个人形玩偶在那晾晒，好不瘆人。</p>\n<p>住在对面稍偏右下的一个小房间里住着一个人，应该是男性。经常看他坐在电脑桌前，毛玻璃的蒙眬使我看不清他在键盘上的手速，但我想，那定是青轴。偶尔起身，那便应该是尿意来袭或是口干舌燥了吧。</p>\n<p>再往右数米处有间房间最近一直在粉刷装修，往往十一二点还能见到粉刷匠在吊灯下的身影。背后有个美满的家庭，再多的重担肩上扛着，脸上还是挂着幸福的笑容。</p>\n<p>再往上一点有个房间好像是个女性独处，有次晚上偶尔看到其窗帘未拉上，她正趴在床上玩手机，还是毛玻璃蒙眬，也许是男性也说不准。后来我每每往那边瞧时，皆是漆黑一片。恐是精神作祟？好不瘆人。</p>\n<p>前些日子降了几场大雪，我去杭州出差那几日正是雪下得最大的时候。出门时撑的是黑伞，没过几分钟便已是白伞了。一夜过后，清晨出门，看着路边单车坐垫上足足有五六公分积雪，已是多少年没下过如此大雪了。犹记得儿时，记忆中的过年都是在厚厚的白雪上渡过。那时我们喜欢玩鞭炮，点火花棒在空中使劲了甩，不像如今，我们老家已经禁炮许多年了。都说现在过年越来越没有年味儿了，不是年味儿它消失了，是我们不知觉中已然长大。</p>\n<p>忙碌，如今整日忙碌，却有时又不知到底在忙碌些什么。我们不妨自己找个时间，静静呆会，可以看看月亮看看星星，看看过往的路人，也可以跟我一样看看住在对面的居民。</p>\n<p><strong>Life is like a box of chocolate,you never know what you are going to get.</strong></p>\n<p>共勉。</p>\n","excerpt":"","more":"<p>住在对面的居民，我想与我这边环境也相似，只是人口数量略有差异。</p>\n<p>有段时间，每晚下班我进房间打开房灯，第一件事就是站在窗外静静的看着对面的居民们。因为是老式小区，楼层不高，每栋之间的间隔也不大，看不清对面的模样但至少看得清对面的举动。</p>\n<p>住在对面的居民，每户人家做的事皆不相同，作息时间皆不相同，窗外布置也是皆不相同。有时我就呆呆的站在那看，不知为什么，我就是能呆呆的站在那看。</p>\n<p>住在对面的居民，能看见内部情况的户数不多，却给我有种人生百态的感觉。我想这也是吸引我的原因，是我在此执笔想要记录的原因吧。</p>\n<p>住在对面楼斜上角的住户，是一家三口。看不清他们具体模样，只是知道小孩还小，还不会走路。往往见到他们都是在轮流抱着孩子，哄着睡觉，经常就是一哄一两个小时。当小孩入睡后，夫妻俩才开始走到厨房，不知是洗吃完饭后的碗筷还是才开始动手做饭。</p>\n<p>住在夫妻俩下两层的是一位好学之人，对其的了解甚少，因为当我驻窗前“偷窥”时，他八成是坐在桌前，也只有桌前那扇窗没拉窗帘。由于晚上视线昏暗加之一定的观察距离，我只知他是位男性，大多独自一人坐在桌前，看书或是写字，我便看不大清了。纵上观之，好学之人，那是定错不了的了。</p>\n<p>住在正对面楼偏上一点的是一个大家庭，观察至今我看到出现过一个老头、一个老太、还有较之年轻的一男一女。因为楼层的原因，我只能看到其窗外晾晒的衣物，无法窥视到内部的情形。只是有时能看到一男的或是女的走过来拉上窗户，拉上窗帘，像似要与外界隔绝，美美地做个美美的梦。有个周末，我坐在床上看着投影中的电影，眼睛往窗外一瞥，霎时汗毛直立。待我定睛瞧时，原来是这户窗外挂了个人形玩偶在那晾晒，好不瘆人。</p>\n<p>住在对面稍偏右下的一个小房间里住着一个人，应该是男性。经常看他坐在电脑桌前，毛玻璃的蒙眬使我看不清他在键盘上的手速，但我想，那定是青轴。偶尔起身，那便应该是尿意来袭或是口干舌燥了吧。</p>\n<p>再往右数米处有间房间最近一直在粉刷装修，往往十一二点还能见到粉刷匠在吊灯下的身影。背后有个美满的家庭，再多的重担肩上扛着，脸上还是挂着幸福的笑容。</p>\n<p>再往上一点有个房间好像是个女性独处，有次晚上偶尔看到其窗帘未拉上，她正趴在床上玩手机，还是毛玻璃蒙眬，也许是男性也说不准。后来我每每往那边瞧时，皆是漆黑一片。恐是精神作祟？好不瘆人。</p>\n<p>前些日子降了几场大雪，我去杭州出差那几日正是雪下得最大的时候。出门时撑的是黑伞，没过几分钟便已是白伞了。一夜过后，清晨出门，看着路边单车坐垫上足足有五六公分积雪，已是多少年没下过如此大雪了。犹记得儿时，记忆中的过年都是在厚厚的白雪上渡过。那时我们喜欢玩鞭炮，点火花棒在空中使劲了甩，不像如今，我们老家已经禁炮许多年了。都说现在过年越来越没有年味儿了，不是年味儿它消失了，是我们不知觉中已然长大。</p>\n<p>忙碌，如今整日忙碌，却有时又不知到底在忙碌些什么。我们不妨自己找个时间，静静呆会，可以看看月亮看看星星，看看过往的路人，也可以跟我一样看看住在对面的居民。</p>\n<p><strong>Life is like a box of chocolate,you never know what you are going to get.</strong></p>\n<p>共勉。</p>\n"},{"title":"秋游十月（2023）","date":"2023-11-08T13:10:55.000Z","_content":"\n>  十月过得好快，可能是假期占了四分之一的缘故吧。\n\n\n## 南京周末游\n\n我们找了一个周末去南京秋了个游，由于时间紧凑没去很多景点，但我觉得周末已然足够，逛得再久只会更加疲惫。\n\n我们第一站是**红山森林动物园**，我们到的时候已经是周六中午了，于是在园外找了一家鸭血粉丝店，意外的是价格还可以，味道也还真不错呢！我们是从北门进的，没有使用园内自费的小车（也没看到）纯靠双腿闲逛，逛了三四个小时才给逛完了。虽然没有之前我们去过的上海野生动物园那么大（主要还有野兽区），动物种类数量那么多，但逛个一下午也是没有问题的。天气也正好没那么热，很适合出门溜达，时常亲近大自然，也让自己心情舒缓，放慢一些脚步。\n\n\n晚上去了**新街口**那边觅食，走走逛逛了一大片，路边吃了点小吃，后来在网上找了一家本地菜馆，令我惊讶的是，价格还挺划算量还真的多啊！就看到路边的「茶颜悦色」总是排着个大长队，营销果然可以，转头去了「马伍旺」。商场路边人真的好多啊，而且还都是年轻人，不知道刚好那周南京有音乐节的缘故还是本就如此，真是大街上全是年轻人，密密麻麻，而且路边全是吃的店，各色各样，看来南京的消费水平也是相当可以的。而且发现南京打车也不贵，可能是我去的地方都在那一块吧。\n\n周日我们去了**侵华日军南京大屠杀遇难同胞纪念馆**，几年前我来的时候还不需要预约，现在如果不提前预约的话是不让你进的。馆内种种资料，历史涌现眼前，中国人民永远忘不了那段可怕的历史，愿再无战争，世界和平！\n\n我们没去夫子庙、海底世界这些景点，第一是时间确实有点紧，第二是人也确实有点逛累了，南京，下次再去！\n\n\n## 公司动荡\n\n说是公司动荡，其实也是因为整个大环境的动荡。这几年大家有个共识：互联网已经开始走下坡了。\n\n所在公司最近整了一系列骚操作，变动薪资结构、让改签合同、不签走人直接辞退书不给赔偿……操作真是骚啊！已经有同事申请仲裁，没想到很快就受理了（可能是人多受理快），赔偿 2n 是没跑了。大环境不好，公司经营情况不好大家也都理解，大家有缘共事一场，既然这样为何不能“和平分手”呢，非得整这些，唉。\n\n看这情况，我也离这不远了，想着做个啥副业的也没什么好点子，进一个好公司难，遇到个好领导更难哦。现在距离过年还有三个月，在这时候失业的话还真不太好找工作，可能就真得休息个几个月，年后再寻新岗位了。\n\n---\n\n大家共勉！","source":"_posts/play-october.md","raw":"---\ntitle: 秋游十月（2023）\ndate: 2023-11-08 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n>  十月过得好快，可能是假期占了四分之一的缘故吧。\n\n\n## 南京周末游\n\n我们找了一个周末去南京秋了个游，由于时间紧凑没去很多景点，但我觉得周末已然足够，逛得再久只会更加疲惫。\n\n我们第一站是**红山森林动物园**，我们到的时候已经是周六中午了，于是在园外找了一家鸭血粉丝店，意外的是价格还可以，味道也还真不错呢！我们是从北门进的，没有使用园内自费的小车（也没看到）纯靠双腿闲逛，逛了三四个小时才给逛完了。虽然没有之前我们去过的上海野生动物园那么大（主要还有野兽区），动物种类数量那么多，但逛个一下午也是没有问题的。天气也正好没那么热，很适合出门溜达，时常亲近大自然，也让自己心情舒缓，放慢一些脚步。\n\n\n晚上去了**新街口**那边觅食，走走逛逛了一大片，路边吃了点小吃，后来在网上找了一家本地菜馆，令我惊讶的是，价格还挺划算量还真的多啊！就看到路边的「茶颜悦色」总是排着个大长队，营销果然可以，转头去了「马伍旺」。商场路边人真的好多啊，而且还都是年轻人，不知道刚好那周南京有音乐节的缘故还是本就如此，真是大街上全是年轻人，密密麻麻，而且路边全是吃的店，各色各样，看来南京的消费水平也是相当可以的。而且发现南京打车也不贵，可能是我去的地方都在那一块吧。\n\n周日我们去了**侵华日军南京大屠杀遇难同胞纪念馆**，几年前我来的时候还不需要预约，现在如果不提前预约的话是不让你进的。馆内种种资料，历史涌现眼前，中国人民永远忘不了那段可怕的历史，愿再无战争，世界和平！\n\n我们没去夫子庙、海底世界这些景点，第一是时间确实有点紧，第二是人也确实有点逛累了，南京，下次再去！\n\n\n## 公司动荡\n\n说是公司动荡，其实也是因为整个大环境的动荡。这几年大家有个共识：互联网已经开始走下坡了。\n\n所在公司最近整了一系列骚操作，变动薪资结构、让改签合同、不签走人直接辞退书不给赔偿……操作真是骚啊！已经有同事申请仲裁，没想到很快就受理了（可能是人多受理快），赔偿 2n 是没跑了。大环境不好，公司经营情况不好大家也都理解，大家有缘共事一场，既然这样为何不能“和平分手”呢，非得整这些，唉。\n\n看这情况，我也离这不远了，想着做个啥副业的也没什么好点子，进一个好公司难，遇到个好领导更难哦。现在距离过年还有三个月，在这时候失业的话还真不太好找工作，可能就真得休息个几个月，年后再寻新岗位了。\n\n---\n\n大家共勉！","slug":"play-october","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhm0096k9i1fq718h9r","content":"<blockquote>\n<p> 十月过得好快，可能是假期占了四分之一的缘故吧。</p>\n</blockquote>\n<h2 id=\"南京周末游\"><a href=\"#南京周末游\" class=\"headerlink\" title=\"南京周末游\"></a>南京周末游</h2><p>我们找了一个周末去南京秋了个游，由于时间紧凑没去很多景点，但我觉得周末已然足够，逛得再久只会更加疲惫。</p>\n<p>我们第一站是<strong>红山森林动物园</strong>，我们到的时候已经是周六中午了，于是在园外找了一家鸭血粉丝店，意外的是价格还可以，味道也还真不错呢！我们是从北门进的，没有使用园内自费的小车（也没看到）纯靠双腿闲逛，逛了三四个小时才给逛完了。虽然没有之前我们去过的上海野生动物园那么大（主要还有野兽区），动物种类数量那么多，但逛个一下午也是没有问题的。天气也正好没那么热，很适合出门溜达，时常亲近大自然，也让自己心情舒缓，放慢一些脚步。</p>\n<p>晚上去了<strong>新街口</strong>那边觅食，走走逛逛了一大片，路边吃了点小吃，后来在网上找了一家本地菜馆，令我惊讶的是，价格还挺划算量还真的多啊！就看到路边的「茶颜悦色」总是排着个大长队，营销果然可以，转头去了「马伍旺」。商场路边人真的好多啊，而且还都是年轻人，不知道刚好那周南京有音乐节的缘故还是本就如此，真是大街上全是年轻人，密密麻麻，而且路边全是吃的店，各色各样，看来南京的消费水平也是相当可以的。而且发现南京打车也不贵，可能是我去的地方都在那一块吧。</p>\n<p>周日我们去了<strong>侵华日军南京大屠杀遇难同胞纪念馆</strong>，几年前我来的时候还不需要预约，现在如果不提前预约的话是不让你进的。馆内种种资料，历史涌现眼前，中国人民永远忘不了那段可怕的历史，愿再无战争，世界和平！</p>\n<p>我们没去夫子庙、海底世界这些景点，第一是时间确实有点紧，第二是人也确实有点逛累了，南京，下次再去！</p>\n<h2 id=\"公司动荡\"><a href=\"#公司动荡\" class=\"headerlink\" title=\"公司动荡\"></a>公司动荡</h2><p>说是公司动荡，其实也是因为整个大环境的动荡。这几年大家有个共识：互联网已经开始走下坡了。</p>\n<p>所在公司最近整了一系列骚操作，变动薪资结构、让改签合同、不签走人直接辞退书不给赔偿……操作真是骚啊！已经有同事申请仲裁，没想到很快就受理了（可能是人多受理快），赔偿 2n 是没跑了。大环境不好，公司经营情况不好大家也都理解，大家有缘共事一场，既然这样为何不能“和平分手”呢，非得整这些，唉。</p>\n<p>看这情况，我也离这不远了，想着做个啥副业的也没什么好点子，进一个好公司难，遇到个好领导更难哦。现在距离过年还有三个月，在这时候失业的话还真不太好找工作，可能就真得休息个几个月，年后再寻新岗位了。</p>\n<hr>\n<p>大家共勉！</p>\n","excerpt":"","more":"<blockquote>\n<p> 十月过得好快，可能是假期占了四分之一的缘故吧。</p>\n</blockquote>\n<h2 id=\"南京周末游\"><a href=\"#南京周末游\" class=\"headerlink\" title=\"南京周末游\"></a>南京周末游</h2><p>我们找了一个周末去南京秋了个游，由于时间紧凑没去很多景点，但我觉得周末已然足够，逛得再久只会更加疲惫。</p>\n<p>我们第一站是<strong>红山森林动物园</strong>，我们到的时候已经是周六中午了，于是在园外找了一家鸭血粉丝店，意外的是价格还可以，味道也还真不错呢！我们是从北门进的，没有使用园内自费的小车（也没看到）纯靠双腿闲逛，逛了三四个小时才给逛完了。虽然没有之前我们去过的上海野生动物园那么大（主要还有野兽区），动物种类数量那么多，但逛个一下午也是没有问题的。天气也正好没那么热，很适合出门溜达，时常亲近大自然，也让自己心情舒缓，放慢一些脚步。</p>\n<p>晚上去了<strong>新街口</strong>那边觅食，走走逛逛了一大片，路边吃了点小吃，后来在网上找了一家本地菜馆，令我惊讶的是，价格还挺划算量还真的多啊！就看到路边的「茶颜悦色」总是排着个大长队，营销果然可以，转头去了「马伍旺」。商场路边人真的好多啊，而且还都是年轻人，不知道刚好那周南京有音乐节的缘故还是本就如此，真是大街上全是年轻人，密密麻麻，而且路边全是吃的店，各色各样，看来南京的消费水平也是相当可以的。而且发现南京打车也不贵，可能是我去的地方都在那一块吧。</p>\n<p>周日我们去了<strong>侵华日军南京大屠杀遇难同胞纪念馆</strong>，几年前我来的时候还不需要预约，现在如果不提前预约的话是不让你进的。馆内种种资料，历史涌现眼前，中国人民永远忘不了那段可怕的历史，愿再无战争，世界和平！</p>\n<p>我们没去夫子庙、海底世界这些景点，第一是时间确实有点紧，第二是人也确实有点逛累了，南京，下次再去！</p>\n<h2 id=\"公司动荡\"><a href=\"#公司动荡\" class=\"headerlink\" title=\"公司动荡\"></a>公司动荡</h2><p>说是公司动荡，其实也是因为整个大环境的动荡。这几年大家有个共识：互联网已经开始走下坡了。</p>\n<p>所在公司最近整了一系列骚操作，变动薪资结构、让改签合同、不签走人直接辞退书不给赔偿……操作真是骚啊！已经有同事申请仲裁，没想到很快就受理了（可能是人多受理快），赔偿 2n 是没跑了。大环境不好，公司经营情况不好大家也都理解，大家有缘共事一场，既然这样为何不能“和平分手”呢，非得整这些，唉。</p>\n<p>看这情况，我也离这不远了，想着做个啥副业的也没什么好点子，进一个好公司难，遇到个好领导更难哦。现在距离过年还有三个月，在这时候失业的话还真不太好找工作，可能就真得休息个几个月，年后再寻新岗位了。</p>\n<hr>\n<p>大家共勉！</p>\n"},{"title":"备婚九月（2023）","date":"2023-10-09T13:10:55.000Z","_content":"\n日子一天天流逝，终于即将迎来这个重大的时刻。\n\n意味着身份的叠加，责任的变化，人生步入下一个阶段。\n\n---\n\n今年的车票是真难买啊，尤其是节假日，真的，以前买票从没感觉这么难买。刚我边上的同事说连景区国庆的票都买不到了，疫情三年，大家人心思玩吗？\n\n由于买不到回去的票，再加上本来这次带回去的东西就多，还是把丈母娘的车开来了，上周南通到上海开了二个多小时，没走苏通走的崇启，路上的车还好不多，希望明天去浙江的路上也不要堵车！\n\n回去的事情还多着呢，屋子还没有装扮，酒店也要弄，衣服得去拿，日子快要到了，还是有点兴奋的！\n\n---\n\n> 由于一直在忙着备婚，现在已经是国庆回来了，我来一起记录下这期间的事吧。\n\n我们早上七点左右从上海出发，下午一点多才到家，开了有六个多小时……主要是高速上一出车祸，路就变得非常堵，我们还是中途下的高速走的一段国道。而且浙江那边本来就山多，很多隧道从山穿过，很多二车道的高速路，所以车一多也自然就慢了。不过还好一路安全，目睹了前车的前车追尾，五车连撞，后备箱盖子直接弹开，还好速度开得慢。\n\n---\n\n买了好多装饰的东西，结果一大部分都没弄上，要么感觉太复杂没时间弄，要么就不知道弄哪。虽然这样，结婚前一天我也是弄到了凌晨二点……光光粘那几个气球就得花了有个把小时，然后楼梯的装饰，着实是费精力。好在一切都顺利，完美ending！在这里感谢爸妈的无私辛苦付出，有时候我着急脾气会不太好，感谢你们的包容！\n\n---\n\n之后去南通的回门宴上也全场没冷，不枉我们准备了那么多礼物，有玩偶，有啪啪圈，有盲盒礼盒，有零食大礼包，还有数十个小红包。也感谢岳父岳母的包容和付出，一直在忙活这忙活那，那几天都没怎么好好睡觉。准备了这么久，终于完美结束，接下来就是要准备好好生活了，选择一个城市定居，开启下一段人生。","source":"_posts/prepare-marry-september.md","raw":"---\ntitle: 备婚九月（2023）\ndate: 2023-10-09 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n日子一天天流逝，终于即将迎来这个重大的时刻。\n\n意味着身份的叠加，责任的变化，人生步入下一个阶段。\n\n---\n\n今年的车票是真难买啊，尤其是节假日，真的，以前买票从没感觉这么难买。刚我边上的同事说连景区国庆的票都买不到了，疫情三年，大家人心思玩吗？\n\n由于买不到回去的票，再加上本来这次带回去的东西就多，还是把丈母娘的车开来了，上周南通到上海开了二个多小时，没走苏通走的崇启，路上的车还好不多，希望明天去浙江的路上也不要堵车！\n\n回去的事情还多着呢，屋子还没有装扮，酒店也要弄，衣服得去拿，日子快要到了，还是有点兴奋的！\n\n---\n\n> 由于一直在忙着备婚，现在已经是国庆回来了，我来一起记录下这期间的事吧。\n\n我们早上七点左右从上海出发，下午一点多才到家，开了有六个多小时……主要是高速上一出车祸，路就变得非常堵，我们还是中途下的高速走的一段国道。而且浙江那边本来就山多，很多隧道从山穿过，很多二车道的高速路，所以车一多也自然就慢了。不过还好一路安全，目睹了前车的前车追尾，五车连撞，后备箱盖子直接弹开，还好速度开得慢。\n\n---\n\n买了好多装饰的东西，结果一大部分都没弄上，要么感觉太复杂没时间弄，要么就不知道弄哪。虽然这样，结婚前一天我也是弄到了凌晨二点……光光粘那几个气球就得花了有个把小时，然后楼梯的装饰，着实是费精力。好在一切都顺利，完美ending！在这里感谢爸妈的无私辛苦付出，有时候我着急脾气会不太好，感谢你们的包容！\n\n---\n\n之后去南通的回门宴上也全场没冷，不枉我们准备了那么多礼物，有玩偶，有啪啪圈，有盲盒礼盒，有零食大礼包，还有数十个小红包。也感谢岳父岳母的包容和付出，一直在忙活这忙活那，那几天都没怎么好好睡觉。准备了这么久，终于完美结束，接下来就是要准备好好生活了，选择一个城市定居，开启下一段人生。","slug":"prepare-marry-september","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhm0099k9i1he090q6s","content":"<p>日子一天天流逝，终于即将迎来这个重大的时刻。</p>\n<p>意味着身份的叠加，责任的变化，人生步入下一个阶段。</p>\n<hr>\n<p>今年的车票是真难买啊，尤其是节假日，真的，以前买票从没感觉这么难买。刚我边上的同事说连景区国庆的票都买不到了，疫情三年，大家人心思玩吗？</p>\n<p>由于买不到回去的票，再加上本来这次带回去的东西就多，还是把丈母娘的车开来了，上周南通到上海开了二个多小时，没走苏通走的崇启，路上的车还好不多，希望明天去浙江的路上也不要堵车！</p>\n<p>回去的事情还多着呢，屋子还没有装扮，酒店也要弄，衣服得去拿，日子快要到了，还是有点兴奋的！</p>\n<hr>\n<blockquote>\n<p>由于一直在忙着备婚，现在已经是国庆回来了，我来一起记录下这期间的事吧。</p>\n</blockquote>\n<p>我们早上七点左右从上海出发，下午一点多才到家，开了有六个多小时……主要是高速上一出车祸，路就变得非常堵，我们还是中途下的高速走的一段国道。而且浙江那边本来就山多，很多隧道从山穿过，很多二车道的高速路，所以车一多也自然就慢了。不过还好一路安全，目睹了前车的前车追尾，五车连撞，后备箱盖子直接弹开，还好速度开得慢。</p>\n<hr>\n<p>买了好多装饰的东西，结果一大部分都没弄上，要么感觉太复杂没时间弄，要么就不知道弄哪。虽然这样，结婚前一天我也是弄到了凌晨二点……光光粘那几个气球就得花了有个把小时，然后楼梯的装饰，着实是费精力。好在一切都顺利，完美ending！在这里感谢爸妈的无私辛苦付出，有时候我着急脾气会不太好，感谢你们的包容！</p>\n<hr>\n<p>之后去南通的回门宴上也全场没冷，不枉我们准备了那么多礼物，有玩偶，有啪啪圈，有盲盒礼盒，有零食大礼包，还有数十个小红包。也感谢岳父岳母的包容和付出，一直在忙活这忙活那，那几天都没怎么好好睡觉。准备了这么久，终于完美结束，接下来就是要准备好好生活了，选择一个城市定居，开启下一段人生。</p>\n","excerpt":"","more":"<p>日子一天天流逝，终于即将迎来这个重大的时刻。</p>\n<p>意味着身份的叠加，责任的变化，人生步入下一个阶段。</p>\n<hr>\n<p>今年的车票是真难买啊，尤其是节假日，真的，以前买票从没感觉这么难买。刚我边上的同事说连景区国庆的票都买不到了，疫情三年，大家人心思玩吗？</p>\n<p>由于买不到回去的票，再加上本来这次带回去的东西就多，还是把丈母娘的车开来了，上周南通到上海开了二个多小时，没走苏通走的崇启，路上的车还好不多，希望明天去浙江的路上也不要堵车！</p>\n<p>回去的事情还多着呢，屋子还没有装扮，酒店也要弄，衣服得去拿，日子快要到了，还是有点兴奋的！</p>\n<hr>\n<blockquote>\n<p>由于一直在忙着备婚，现在已经是国庆回来了，我来一起记录下这期间的事吧。</p>\n</blockquote>\n<p>我们早上七点左右从上海出发，下午一点多才到家，开了有六个多小时……主要是高速上一出车祸，路就变得非常堵，我们还是中途下的高速走的一段国道。而且浙江那边本来就山多，很多隧道从山穿过，很多二车道的高速路，所以车一多也自然就慢了。不过还好一路安全，目睹了前车的前车追尾，五车连撞，后备箱盖子直接弹开，还好速度开得慢。</p>\n<hr>\n<p>买了好多装饰的东西，结果一大部分都没弄上，要么感觉太复杂没时间弄，要么就不知道弄哪。虽然这样，结婚前一天我也是弄到了凌晨二点……光光粘那几个气球就得花了有个把小时，然后楼梯的装饰，着实是费精力。好在一切都顺利，完美ending！在这里感谢爸妈的无私辛苦付出，有时候我着急脾气会不太好，感谢你们的包容！</p>\n<hr>\n<p>之后去南通的回门宴上也全场没冷，不枉我们准备了那么多礼物，有玩偶，有啪啪圈，有盲盒礼盒，有零食大礼包，还有数十个小红包。也感谢岳父岳母的包容和付出，一直在忙活这忙活那，那几天都没怎么好好睡觉。准备了这么久，终于完美结束，接下来就是要准备好好生活了，选择一个城市定居，开启下一段人生。</p>\n"},{"title":"梅雨六月（2020）","date":"2020-06-30T12:10:55.000Z","_content":"\n> 上月末提了离职 本想着给自己一段过渡时间休息休息 没承想给无缝衔接了\n> \n> 有时我比较佛系 那就这么着了吧 随缘\n\n月中入职了新公司，现在还在尽快熟悉业务，由于跟现在住的地方有一段距离，上班通勤时间便由原先的二十分钟成了如今的四个二十分钟……还好早上是九点半上班，不过以后加班估计会是常态了……公司处于快速发展中，大家都很有激情，团队也很年轻化，整体氛围还是很不错的，希望能与公司共同进步，见证成功。\n\n今年确实也比较特殊，许许多多的行业大大受到疫情的影响，同时也给今年的就业市场带来了很大的压力。危机也总是伴随着机遇，也正是许多企业借着危机来迅速成长，最终成为了各自领域中的巨头。大家心里都应该有一把秤，当这把秤失衡了偏移了一端无法调整时，你就得到另一头去给它拨正。坚守是好品质，但是一味坚守一方不见得是最佳的方式。当方向错误的时候，这条路再怎么走，它也是条错路，无论未来是否会见到光亮。疫情一来，许多企业收到冲击，有的迅速找到方向切换方式，有的毅然“断臂生存”，也有的苦苦支撑等待黎明。经此一疫，倒下的企业数不胜数，在这高压社会下，活下去成为了 2020 年大家心中排名第一的愿望。是啊，别说什么永垂不朽举世无双，在流感面前我们都是这么的无助弱小。我们一生都与细菌病毒相伴，是不是可以认为是它们一直在支配着我们？而我们自认为可以支配控制它们？依稀记得《天才在左疯子在右》中有一篇就是讲述一位整日都在洗手的人，认为就是细菌在支配着我们，细思极恐，深想之后浑身打颤……\n\n这月还有件大事，哈哈，我成舅舅了！老姐顺利产下大胖外甥女，家中新增一大成员，着实欢喜！以后也是当舅舅的人了，做事得更加稳重些了。给外甥女买了生肖足金，希望健康快乐成长哟，舅舅会见证你的成长。\n\n---\n\n近些时日，阴雨连绵，梅雨季节，室内潮闷难忍。趁着周末去拔了个罐，去去体内湿气。由于房间朝北，四季无光照，又是到了这种季节，挂着两个除湿袋没过几天就积了不少水。晚上睡觉也确实不太舒服，只能开着风扇让空气流动起来缓解缓解，以后还是得要找个朝南的房间，对自己好点，本来身体就湿气重，偏寒。\n\n新公司位置距此也较远，过一段时间等稳定吧，且看。搬来搬去真的比较麻烦，我是不太愿意老是挪窝的，好不容易布置的差不多了顺了就又得换个新住地，不是滋味儿啊，唉。\n\n---\n\n开始慢慢适应新环境，与组内新同事也渐渐相熟，熟悉业务的同时修改“前辈们”遗留下来的历史问题。每天更是两点一线来回，往日里夜间还能抽空锻炼看书，近些时日多是回家已疲惫困乏。早早晚晚看地铁间人们来来往往，匆匆碌碌。魔都职业气息较为浓厚，大家多是职场打拼者，年龄三十上下的最多，有的已婚可能定居更多的则是为了各自心中追寻的美好而努力。\n\n充实而美好，那就是最好的生活了。\n\n---\n\n今年已过半，上半年因疫情影响好像没做什么事就过去了。回回头自己也已毕业三年，时年二十六了。有时候或许对自己要求过高，太看得起自己了，终究也只是个普通小伙子。有时候也会想着给自己找找台阶，生活嘛，及时行乐。但自己心里终是清楚的，不是一个能过安逸日子的人，让我闲下来久了也会烦躁。也会幻想自己终于等到运气爆棚的那天，自己成功的那天，但是那天到底是哪天，会不会来，不知道。自己唯一能清楚知道的确定无误的那就是踏踏实实成长，每一天都有进步，稳稳当当走路，让自己有能拥有那一天来临的资格，否则要是眼看着却无法拥有，那该会是最痛恨自己的时候吧。\n\n人的一生能改变命运，跨越阶级的机会就那么几次，一定要好好把握住！\n\n---\n\n**毕竟西湖六月中，风光不与四时同。**\n\n**接天莲叶无穷碧，映日荷花别样红。**\n\n本应该去西湖逛逛的，连着下雨快个把月了。","source":"_posts/rain-june-2020.md","raw":"---\ntitle: 梅雨六月（2020）\ndate: 2020-06-30 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 上月末提了离职 本想着给自己一段过渡时间休息休息 没承想给无缝衔接了\n> \n> 有时我比较佛系 那就这么着了吧 随缘\n\n月中入职了新公司，现在还在尽快熟悉业务，由于跟现在住的地方有一段距离，上班通勤时间便由原先的二十分钟成了如今的四个二十分钟……还好早上是九点半上班，不过以后加班估计会是常态了……公司处于快速发展中，大家都很有激情，团队也很年轻化，整体氛围还是很不错的，希望能与公司共同进步，见证成功。\n\n今年确实也比较特殊，许许多多的行业大大受到疫情的影响，同时也给今年的就业市场带来了很大的压力。危机也总是伴随着机遇，也正是许多企业借着危机来迅速成长，最终成为了各自领域中的巨头。大家心里都应该有一把秤，当这把秤失衡了偏移了一端无法调整时，你就得到另一头去给它拨正。坚守是好品质，但是一味坚守一方不见得是最佳的方式。当方向错误的时候，这条路再怎么走，它也是条错路，无论未来是否会见到光亮。疫情一来，许多企业收到冲击，有的迅速找到方向切换方式，有的毅然“断臂生存”，也有的苦苦支撑等待黎明。经此一疫，倒下的企业数不胜数，在这高压社会下，活下去成为了 2020 年大家心中排名第一的愿望。是啊，别说什么永垂不朽举世无双，在流感面前我们都是这么的无助弱小。我们一生都与细菌病毒相伴，是不是可以认为是它们一直在支配着我们？而我们自认为可以支配控制它们？依稀记得《天才在左疯子在右》中有一篇就是讲述一位整日都在洗手的人，认为就是细菌在支配着我们，细思极恐，深想之后浑身打颤……\n\n这月还有件大事，哈哈，我成舅舅了！老姐顺利产下大胖外甥女，家中新增一大成员，着实欢喜！以后也是当舅舅的人了，做事得更加稳重些了。给外甥女买了生肖足金，希望健康快乐成长哟，舅舅会见证你的成长。\n\n---\n\n近些时日，阴雨连绵，梅雨季节，室内潮闷难忍。趁着周末去拔了个罐，去去体内湿气。由于房间朝北，四季无光照，又是到了这种季节，挂着两个除湿袋没过几天就积了不少水。晚上睡觉也确实不太舒服，只能开着风扇让空气流动起来缓解缓解，以后还是得要找个朝南的房间，对自己好点，本来身体就湿气重，偏寒。\n\n新公司位置距此也较远，过一段时间等稳定吧，且看。搬来搬去真的比较麻烦，我是不太愿意老是挪窝的，好不容易布置的差不多了顺了就又得换个新住地，不是滋味儿啊，唉。\n\n---\n\n开始慢慢适应新环境，与组内新同事也渐渐相熟，熟悉业务的同时修改“前辈们”遗留下来的历史问题。每天更是两点一线来回，往日里夜间还能抽空锻炼看书，近些时日多是回家已疲惫困乏。早早晚晚看地铁间人们来来往往，匆匆碌碌。魔都职业气息较为浓厚，大家多是职场打拼者，年龄三十上下的最多，有的已婚可能定居更多的则是为了各自心中追寻的美好而努力。\n\n充实而美好，那就是最好的生活了。\n\n---\n\n今年已过半，上半年因疫情影响好像没做什么事就过去了。回回头自己也已毕业三年，时年二十六了。有时候或许对自己要求过高，太看得起自己了，终究也只是个普通小伙子。有时候也会想着给自己找找台阶，生活嘛，及时行乐。但自己心里终是清楚的，不是一个能过安逸日子的人，让我闲下来久了也会烦躁。也会幻想自己终于等到运气爆棚的那天，自己成功的那天，但是那天到底是哪天，会不会来，不知道。自己唯一能清楚知道的确定无误的那就是踏踏实实成长，每一天都有进步，稳稳当当走路，让自己有能拥有那一天来临的资格，否则要是眼看着却无法拥有，那该会是最痛恨自己的时候吧。\n\n人的一生能改变命运，跨越阶级的机会就那么几次，一定要好好把握住！\n\n---\n\n**毕竟西湖六月中，风光不与四时同。**\n\n**接天莲叶无穷碧，映日荷花别样红。**\n\n本应该去西湖逛逛的，连着下雨快个把月了。","slug":"rain-june-2020","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn009ek9i1e91oezq0","content":"<blockquote>\n<p>上月末提了离职 本想着给自己一段过渡时间休息休息 没承想给无缝衔接了</p>\n<p>有时我比较佛系 那就这么着了吧 随缘</p>\n</blockquote>\n<p>月中入职了新公司，现在还在尽快熟悉业务，由于跟现在住的地方有一段距离，上班通勤时间便由原先的二十分钟成了如今的四个二十分钟……还好早上是九点半上班，不过以后加班估计会是常态了……公司处于快速发展中，大家都很有激情，团队也很年轻化，整体氛围还是很不错的，希望能与公司共同进步，见证成功。</p>\n<p>今年确实也比较特殊，许许多多的行业大大受到疫情的影响，同时也给今年的就业市场带来了很大的压力。危机也总是伴随着机遇，也正是许多企业借着危机来迅速成长，最终成为了各自领域中的巨头。大家心里都应该有一把秤，当这把秤失衡了偏移了一端无法调整时，你就得到另一头去给它拨正。坚守是好品质，但是一味坚守一方不见得是最佳的方式。当方向错误的时候，这条路再怎么走，它也是条错路，无论未来是否会见到光亮。疫情一来，许多企业收到冲击，有的迅速找到方向切换方式，有的毅然“断臂生存”，也有的苦苦支撑等待黎明。经此一疫，倒下的企业数不胜数，在这高压社会下，活下去成为了 2020 年大家心中排名第一的愿望。是啊，别说什么永垂不朽举世无双，在流感面前我们都是这么的无助弱小。我们一生都与细菌病毒相伴，是不是可以认为是它们一直在支配着我们？而我们自认为可以支配控制它们？依稀记得《天才在左疯子在右》中有一篇就是讲述一位整日都在洗手的人，认为就是细菌在支配着我们，细思极恐，深想之后浑身打颤……</p>\n<p>这月还有件大事，哈哈，我成舅舅了！老姐顺利产下大胖外甥女，家中新增一大成员，着实欢喜！以后也是当舅舅的人了，做事得更加稳重些了。给外甥女买了生肖足金，希望健康快乐成长哟，舅舅会见证你的成长。</p>\n<hr>\n<p>近些时日，阴雨连绵，梅雨季节，室内潮闷难忍。趁着周末去拔了个罐，去去体内湿气。由于房间朝北，四季无光照，又是到了这种季节，挂着两个除湿袋没过几天就积了不少水。晚上睡觉也确实不太舒服，只能开着风扇让空气流动起来缓解缓解，以后还是得要找个朝南的房间，对自己好点，本来身体就湿气重，偏寒。</p>\n<p>新公司位置距此也较远，过一段时间等稳定吧，且看。搬来搬去真的比较麻烦，我是不太愿意老是挪窝的，好不容易布置的差不多了顺了就又得换个新住地，不是滋味儿啊，唉。</p>\n<hr>\n<p>开始慢慢适应新环境，与组内新同事也渐渐相熟，熟悉业务的同时修改“前辈们”遗留下来的历史问题。每天更是两点一线来回，往日里夜间还能抽空锻炼看书，近些时日多是回家已疲惫困乏。早早晚晚看地铁间人们来来往往，匆匆碌碌。魔都职业气息较为浓厚，大家多是职场打拼者，年龄三十上下的最多，有的已婚可能定居更多的则是为了各自心中追寻的美好而努力。</p>\n<p>充实而美好，那就是最好的生活了。</p>\n<hr>\n<p>今年已过半，上半年因疫情影响好像没做什么事就过去了。回回头自己也已毕业三年，时年二十六了。有时候或许对自己要求过高，太看得起自己了，终究也只是个普通小伙子。有时候也会想着给自己找找台阶，生活嘛，及时行乐。但自己心里终是清楚的，不是一个能过安逸日子的人，让我闲下来久了也会烦躁。也会幻想自己终于等到运气爆棚的那天，自己成功的那天，但是那天到底是哪天，会不会来，不知道。自己唯一能清楚知道的确定无误的那就是踏踏实实成长，每一天都有进步，稳稳当当走路，让自己有能拥有那一天来临的资格，否则要是眼看着却无法拥有，那该会是最痛恨自己的时候吧。</p>\n<p>人的一生能改变命运，跨越阶级的机会就那么几次，一定要好好把握住！</p>\n<hr>\n<p><strong>毕竟西湖六月中，风光不与四时同。</strong></p>\n<p><strong>接天莲叶无穷碧，映日荷花别样红。</strong></p>\n<p>本应该去西湖逛逛的，连着下雨快个把月了。</p>\n","excerpt":"","more":"<blockquote>\n<p>上月末提了离职 本想着给自己一段过渡时间休息休息 没承想给无缝衔接了</p>\n<p>有时我比较佛系 那就这么着了吧 随缘</p>\n</blockquote>\n<p>月中入职了新公司，现在还在尽快熟悉业务，由于跟现在住的地方有一段距离，上班通勤时间便由原先的二十分钟成了如今的四个二十分钟……还好早上是九点半上班，不过以后加班估计会是常态了……公司处于快速发展中，大家都很有激情，团队也很年轻化，整体氛围还是很不错的，希望能与公司共同进步，见证成功。</p>\n<p>今年确实也比较特殊，许许多多的行业大大受到疫情的影响，同时也给今年的就业市场带来了很大的压力。危机也总是伴随着机遇，也正是许多企业借着危机来迅速成长，最终成为了各自领域中的巨头。大家心里都应该有一把秤，当这把秤失衡了偏移了一端无法调整时，你就得到另一头去给它拨正。坚守是好品质，但是一味坚守一方不见得是最佳的方式。当方向错误的时候，这条路再怎么走，它也是条错路，无论未来是否会见到光亮。疫情一来，许多企业收到冲击，有的迅速找到方向切换方式，有的毅然“断臂生存”，也有的苦苦支撑等待黎明。经此一疫，倒下的企业数不胜数，在这高压社会下，活下去成为了 2020 年大家心中排名第一的愿望。是啊，别说什么永垂不朽举世无双，在流感面前我们都是这么的无助弱小。我们一生都与细菌病毒相伴，是不是可以认为是它们一直在支配着我们？而我们自认为可以支配控制它们？依稀记得《天才在左疯子在右》中有一篇就是讲述一位整日都在洗手的人，认为就是细菌在支配着我们，细思极恐，深想之后浑身打颤……</p>\n<p>这月还有件大事，哈哈，我成舅舅了！老姐顺利产下大胖外甥女，家中新增一大成员，着实欢喜！以后也是当舅舅的人了，做事得更加稳重些了。给外甥女买了生肖足金，希望健康快乐成长哟，舅舅会见证你的成长。</p>\n<hr>\n<p>近些时日，阴雨连绵，梅雨季节，室内潮闷难忍。趁着周末去拔了个罐，去去体内湿气。由于房间朝北，四季无光照，又是到了这种季节，挂着两个除湿袋没过几天就积了不少水。晚上睡觉也确实不太舒服，只能开着风扇让空气流动起来缓解缓解，以后还是得要找个朝南的房间，对自己好点，本来身体就湿气重，偏寒。</p>\n<p>新公司位置距此也较远，过一段时间等稳定吧，且看。搬来搬去真的比较麻烦，我是不太愿意老是挪窝的，好不容易布置的差不多了顺了就又得换个新住地，不是滋味儿啊，唉。</p>\n<hr>\n<p>开始慢慢适应新环境，与组内新同事也渐渐相熟，熟悉业务的同时修改“前辈们”遗留下来的历史问题。每天更是两点一线来回，往日里夜间还能抽空锻炼看书，近些时日多是回家已疲惫困乏。早早晚晚看地铁间人们来来往往，匆匆碌碌。魔都职业气息较为浓厚，大家多是职场打拼者，年龄三十上下的最多，有的已婚可能定居更多的则是为了各自心中追寻的美好而努力。</p>\n<p>充实而美好，那就是最好的生活了。</p>\n<hr>\n<p>今年已过半，上半年因疫情影响好像没做什么事就过去了。回回头自己也已毕业三年，时年二十六了。有时候或许对自己要求过高，太看得起自己了，终究也只是个普通小伙子。有时候也会想着给自己找找台阶，生活嘛，及时行乐。但自己心里终是清楚的，不是一个能过安逸日子的人，让我闲下来久了也会烦躁。也会幻想自己终于等到运气爆棚的那天，自己成功的那天，但是那天到底是哪天，会不会来，不知道。自己唯一能清楚知道的确定无误的那就是踏踏实实成长，每一天都有进步，稳稳当当走路，让自己有能拥有那一天来临的资格，否则要是眼看着却无法拥有，那该会是最痛恨自己的时候吧。</p>\n<p>人的一生能改变命运，跨越阶级的机会就那么几次，一定要好好把握住！</p>\n<hr>\n<p><strong>毕竟西湖六月中，风光不与四时同。</strong></p>\n<p><strong>接天莲叶无穷碧，映日荷花别样红。</strong></p>\n<p>本应该去西湖逛逛的，连着下雨快个把月了。</p>\n"},{"title":"梅雨六月（2023）","date":"2023-06-28T13:10:55.000Z","_content":"\n> 六月的雨\n\n六月梅雨季，天又闷又热，下了几场大雨后最近又是高温闷热天。\n\n今年是老妈六十生日，本来准备是给买条大金链子的，可是看着这个金价实在是下不了手，黄金是一年比一年贵啊，涨幅还不小。然后就换成了手机，刚好现在的手机也用了三四年了。这几年眼看着父母白发越来越多，背也越来越驼，感叹时间过得太快，真希望岁月能够放缓脚步，驻足停留，多欣赏沿途风景。\n\n---\n\n已过年半，但似乎并没有多大变化。如今大环境也不好，公司内部也不像之前那般激情，更是为之后的职业道路新增了些许担忧。\n\n---\n\n五穷六绝七翻身。","source":"_posts/rain-june.md","raw":"---\ntitle: 梅雨六月（2023）\ndate: 2023-06-28 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 六月的雨\n\n六月梅雨季，天又闷又热，下了几场大雨后最近又是高温闷热天。\n\n今年是老妈六十生日，本来准备是给买条大金链子的，可是看着这个金价实在是下不了手，黄金是一年比一年贵啊，涨幅还不小。然后就换成了手机，刚好现在的手机也用了三四年了。这几年眼看着父母白发越来越多，背也越来越驼，感叹时间过得太快，真希望岁月能够放缓脚步，驻足停留，多欣赏沿途风景。\n\n---\n\n已过年半，但似乎并没有多大变化。如今大环境也不好，公司内部也不像之前那般激情，更是为之后的职业道路新增了些许担忧。\n\n---\n\n五穷六绝七翻身。","slug":"rain-june","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn009hk9i11lvjd423","content":"<blockquote>\n<p>六月的雨</p>\n</blockquote>\n<p>六月梅雨季，天又闷又热，下了几场大雨后最近又是高温闷热天。</p>\n<p>今年是老妈六十生日，本来准备是给买条大金链子的，可是看着这个金价实在是下不了手，黄金是一年比一年贵啊，涨幅还不小。然后就换成了手机，刚好现在的手机也用了三四年了。这几年眼看着父母白发越来越多，背也越来越驼，感叹时间过得太快，真希望岁月能够放缓脚步，驻足停留，多欣赏沿途风景。</p>\n<hr>\n<p>已过年半，但似乎并没有多大变化。如今大环境也不好，公司内部也不像之前那般激情，更是为之后的职业道路新增了些许担忧。</p>\n<hr>\n<p>五穷六绝七翻身。</p>\n","excerpt":"","more":"<blockquote>\n<p>六月的雨</p>\n</blockquote>\n<p>六月梅雨季，天又闷又热，下了几场大雨后最近又是高温闷热天。</p>\n<p>今年是老妈六十生日，本来准备是给买条大金链子的，可是看着这个金价实在是下不了手，黄金是一年比一年贵啊，涨幅还不小。然后就换成了手机，刚好现在的手机也用了三四年了。这几年眼看着父母白发越来越多，背也越来越驼，感叹时间过得太快，真希望岁月能够放缓脚步，驻足停留，多欣赏沿途风景。</p>\n<hr>\n<p>已过年半，但似乎并没有多大变化。如今大环境也不好，公司内部也不像之前那般激情，更是为之后的职业道路新增了些许担忧。</p>\n<hr>\n<p>五穷六绝七翻身。</p>\n"},{"title":"红色十一月（2022）","date":"2022-11-30T13:10:55.000Z","_content":"\n> 要说上个月是绿油油，那这月可算是否极泰来了！\n\n月首日就拉了一个大阳，中概也还是慢慢好转的迹象，真是回了一口血啊。\n\n世界杯开始了，本身对足球也不甚了解，不过这种国际火热赛事，咱有空也得瞧瞧，尽管还是没有国家队的影子……\n\n接二连三的爆冷门，这不仅股市不理想，那些个DU球的今年也是不好过啊，戴维斯双击。\n\n日本韩国的比赛我差不多都看了，确实是厉害，个个都有冲的狠劲，厉害厉害。足球还是蛮好看的，尽管不是很懂，但也不影响看球啊。\n\n真快，这个双十一没有买什么东西，就买了一些个生活必需品，什么纸巾啊洗衣液的，拼多多的财报数据越来越好看了，真的是消费降级了吗？我最近也用拼多多比较多，东西确实有些蛮便宜也不错的。\n\n最近降温许多，前些日子还是有个十来度的，这一下子就给干到了不到五度，羽绒服已经穿上，室内还是感觉有点冷的，空调也不给力。\n\n寒冬已到，各自取暖。","source":"_posts/red-november.md","raw":"---\ntitle: 红色十一月（2022）\ndate: 2022-11-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 要说上个月是绿油油，那这月可算是否极泰来了！\n\n月首日就拉了一个大阳，中概也还是慢慢好转的迹象，真是回了一口血啊。\n\n世界杯开始了，本身对足球也不甚了解，不过这种国际火热赛事，咱有空也得瞧瞧，尽管还是没有国家队的影子……\n\n接二连三的爆冷门，这不仅股市不理想，那些个DU球的今年也是不好过啊，戴维斯双击。\n\n日本韩国的比赛我差不多都看了，确实是厉害，个个都有冲的狠劲，厉害厉害。足球还是蛮好看的，尽管不是很懂，但也不影响看球啊。\n\n真快，这个双十一没有买什么东西，就买了一些个生活必需品，什么纸巾啊洗衣液的，拼多多的财报数据越来越好看了，真的是消费降级了吗？我最近也用拼多多比较多，东西确实有些蛮便宜也不错的。\n\n最近降温许多，前些日子还是有个十来度的，这一下子就给干到了不到五度，羽绒服已经穿上，室内还是感觉有点冷的，空调也不给力。\n\n寒冬已到，各自取暖。","slug":"red-november","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn009mk9i17xdtatlv","content":"<blockquote>\n<p>要说上个月是绿油油，那这月可算是否极泰来了！</p>\n</blockquote>\n<p>月首日就拉了一个大阳，中概也还是慢慢好转的迹象，真是回了一口血啊。</p>\n<p>世界杯开始了，本身对足球也不甚了解，不过这种国际火热赛事，咱有空也得瞧瞧，尽管还是没有国家队的影子……</p>\n<p>接二连三的爆冷门，这不仅股市不理想，那些个DU球的今年也是不好过啊，戴维斯双击。</p>\n<p>日本韩国的比赛我差不多都看了，确实是厉害，个个都有冲的狠劲，厉害厉害。足球还是蛮好看的，尽管不是很懂，但也不影响看球啊。</p>\n<p>真快，这个双十一没有买什么东西，就买了一些个生活必需品，什么纸巾啊洗衣液的，拼多多的财报数据越来越好看了，真的是消费降级了吗？我最近也用拼多多比较多，东西确实有些蛮便宜也不错的。</p>\n<p>最近降温许多，前些日子还是有个十来度的，这一下子就给干到了不到五度，羽绒服已经穿上，室内还是感觉有点冷的，空调也不给力。</p>\n<p>寒冬已到，各自取暖。</p>\n","excerpt":"","more":"<blockquote>\n<p>要说上个月是绿油油，那这月可算是否极泰来了！</p>\n</blockquote>\n<p>月首日就拉了一个大阳，中概也还是慢慢好转的迹象，真是回了一口血啊。</p>\n<p>世界杯开始了，本身对足球也不甚了解，不过这种国际火热赛事，咱有空也得瞧瞧，尽管还是没有国家队的影子……</p>\n<p>接二连三的爆冷门，这不仅股市不理想，那些个DU球的今年也是不好过啊，戴维斯双击。</p>\n<p>日本韩国的比赛我差不多都看了，确实是厉害，个个都有冲的狠劲，厉害厉害。足球还是蛮好看的，尽管不是很懂，但也不影响看球啊。</p>\n<p>真快，这个双十一没有买什么东西，就买了一些个生活必需品，什么纸巾啊洗衣液的，拼多多的财报数据越来越好看了，真的是消费降级了吗？我最近也用拼多多比较多，东西确实有些蛮便宜也不错的。</p>\n<p>最近降温许多，前些日子还是有个十来度的，这一下子就给干到了不到五度，羽绒服已经穿上，室内还是感觉有点冷的，空调也不给力。</p>\n<p>寒冬已到，各自取暖。</p>\n"},{"title":"放松二月（2021）","date":"2021-02-28T12:10:55.000Z","_content":"\n> 讲真，不上班自由的时间是真的放松！\n\n自打记事以来，今年是在外头过得第一个年。年夜饭就跟平时一个样，哦不对，那还是有点不一样，来上海自做还没有一次性上桌过这么些个菜，丰盛是挺丰盛的。\n\n老妈果然给我寄了好些个年货，我最爱的山核桃还有开心果，感谢老妈！\n\n大过年的在外头也没什么事做，天天凌晨才睡觉，然后睡到中午，起来随便一顿吃又开始坐在电脑前捣鼓。出去看了几场电影，感觉今年留沪的人应该不少，影院人还是挺多的。这几天刷了一遍《灌篮高手》动漫，经典永不超越，一群平凡人为着梦想努力拼搏，太热血了。看完特地又买了个篮球，不免想起了自己小学放学后的篮球时光。已经记不得是我哪一年的生日，那天放学后回家看到桌上有一个崭新的篮球，是爸妈给我的生日礼物。从那天开始，我只要有空就会去附近的篮球场，当时个子小又没什么力气，大多时间都是乱抛乱甩自娱自乐，到后来开始自己拍球抛球。有一说一，当时同龄人中我的个子也不算矮，球技也不错，年少无知一统球场！不过后来上初中后开始就不怎么接触篮球了，所以导致现在虽然能打打球但水平也就那样了……\n\n有梦想谁都了不起！\n\n这几天看完了村上春树的《挪威的森林》，看完很有感触，有时候觉得自己跟渡边是多么得相似。村上这部小说写得很直白露骨，看完可能会有些许的压抑也可能会让你瞬间成长一些。就引用译序中我认为非常能概括此书的一段话吧：**其间无数读者来信朝我这个译者手里飞来，每三封就有两封谈《挪威的森林》，或为故事的情节所吸引，或为主人公的个性所打动，或为韵味的别具一格所感染，或为语言的洗炼优美所陶醉。有人说像小河虾纤细的触角刺破自己的泪腺，有人说像静夜如水的月光抚慰自己孤独的心灵，有人说引领自己走出四顾茫然的青春沼泽，有人说让人刻骨铭心地懂得了什么叫成长……**\n\n又把《SHOE DOG 鞋狗》看完了，耐克创始人菲尔·奈特亲笔自传，看完后我算是对耐克的历史有了更深刻的了解。整本书看的过程中不像一般的自传吹嘘种种，更像是一本小说，按照时间线将故事娓娓道来，讲述了成功路上的坎坷。总之看的很过瘾，一部体育巨头的成长史。\n\n一眨眼这个年也就这样过去了，又要重复打工人的生活了。","source":"_posts/relax-february.md","raw":"---\ntitle: 放松二月（2021）\ndate: 2021-02-28 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 讲真，不上班自由的时间是真的放松！\n\n自打记事以来，今年是在外头过得第一个年。年夜饭就跟平时一个样，哦不对，那还是有点不一样，来上海自做还没有一次性上桌过这么些个菜，丰盛是挺丰盛的。\n\n老妈果然给我寄了好些个年货，我最爱的山核桃还有开心果，感谢老妈！\n\n大过年的在外头也没什么事做，天天凌晨才睡觉，然后睡到中午，起来随便一顿吃又开始坐在电脑前捣鼓。出去看了几场电影，感觉今年留沪的人应该不少，影院人还是挺多的。这几天刷了一遍《灌篮高手》动漫，经典永不超越，一群平凡人为着梦想努力拼搏，太热血了。看完特地又买了个篮球，不免想起了自己小学放学后的篮球时光。已经记不得是我哪一年的生日，那天放学后回家看到桌上有一个崭新的篮球，是爸妈给我的生日礼物。从那天开始，我只要有空就会去附近的篮球场，当时个子小又没什么力气，大多时间都是乱抛乱甩自娱自乐，到后来开始自己拍球抛球。有一说一，当时同龄人中我的个子也不算矮，球技也不错，年少无知一统球场！不过后来上初中后开始就不怎么接触篮球了，所以导致现在虽然能打打球但水平也就那样了……\n\n有梦想谁都了不起！\n\n这几天看完了村上春树的《挪威的森林》，看完很有感触，有时候觉得自己跟渡边是多么得相似。村上这部小说写得很直白露骨，看完可能会有些许的压抑也可能会让你瞬间成长一些。就引用译序中我认为非常能概括此书的一段话吧：**其间无数读者来信朝我这个译者手里飞来，每三封就有两封谈《挪威的森林》，或为故事的情节所吸引，或为主人公的个性所打动，或为韵味的别具一格所感染，或为语言的洗炼优美所陶醉。有人说像小河虾纤细的触角刺破自己的泪腺，有人说像静夜如水的月光抚慰自己孤独的心灵，有人说引领自己走出四顾茫然的青春沼泽，有人说让人刻骨铭心地懂得了什么叫成长……**\n\n又把《SHOE DOG 鞋狗》看完了，耐克创始人菲尔·奈特亲笔自传，看完后我算是对耐克的历史有了更深刻的了解。整本书看的过程中不像一般的自传吹嘘种种，更像是一本小说，按照时间线将故事娓娓道来，讲述了成功路上的坎坷。总之看的很过瘾，一部体育巨头的成长史。\n\n一眨眼这个年也就这样过去了，又要重复打工人的生活了。","slug":"relax-february","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn009pk9i15bhm0mpl","content":"<blockquote>\n<p>讲真，不上班自由的时间是真的放松！</p>\n</blockquote>\n<p>自打记事以来，今年是在外头过得第一个年。年夜饭就跟平时一个样，哦不对，那还是有点不一样，来上海自做还没有一次性上桌过这么些个菜，丰盛是挺丰盛的。</p>\n<p>老妈果然给我寄了好些个年货，我最爱的山核桃还有开心果，感谢老妈！</p>\n<p>大过年的在外头也没什么事做，天天凌晨才睡觉，然后睡到中午，起来随便一顿吃又开始坐在电脑前捣鼓。出去看了几场电影，感觉今年留沪的人应该不少，影院人还是挺多的。这几天刷了一遍《灌篮高手》动漫，经典永不超越，一群平凡人为着梦想努力拼搏，太热血了。看完特地又买了个篮球，不免想起了自己小学放学后的篮球时光。已经记不得是我哪一年的生日，那天放学后回家看到桌上有一个崭新的篮球，是爸妈给我的生日礼物。从那天开始，我只要有空就会去附近的篮球场，当时个子小又没什么力气，大多时间都是乱抛乱甩自娱自乐，到后来开始自己拍球抛球。有一说一，当时同龄人中我的个子也不算矮，球技也不错，年少无知一统球场！不过后来上初中后开始就不怎么接触篮球了，所以导致现在虽然能打打球但水平也就那样了……</p>\n<p>有梦想谁都了不起！</p>\n<p>这几天看完了村上春树的《挪威的森林》，看完很有感触，有时候觉得自己跟渡边是多么得相似。村上这部小说写得很直白露骨，看完可能会有些许的压抑也可能会让你瞬间成长一些。就引用译序中我认为非常能概括此书的一段话吧：<strong>其间无数读者来信朝我这个译者手里飞来，每三封就有两封谈《挪威的森林》，或为故事的情节所吸引，或为主人公的个性所打动，或为韵味的别具一格所感染，或为语言的洗炼优美所陶醉。有人说像小河虾纤细的触角刺破自己的泪腺，有人说像静夜如水的月光抚慰自己孤独的心灵，有人说引领自己走出四顾茫然的青春沼泽，有人说让人刻骨铭心地懂得了什么叫成长……</strong></p>\n<p>又把《SHOE DOG 鞋狗》看完了，耐克创始人菲尔·奈特亲笔自传，看完后我算是对耐克的历史有了更深刻的了解。整本书看的过程中不像一般的自传吹嘘种种，更像是一本小说，按照时间线将故事娓娓道来，讲述了成功路上的坎坷。总之看的很过瘾，一部体育巨头的成长史。</p>\n<p>一眨眼这个年也就这样过去了，又要重复打工人的生活了。</p>\n","excerpt":"","more":"<blockquote>\n<p>讲真，不上班自由的时间是真的放松！</p>\n</blockquote>\n<p>自打记事以来，今年是在外头过得第一个年。年夜饭就跟平时一个样，哦不对，那还是有点不一样，来上海自做还没有一次性上桌过这么些个菜，丰盛是挺丰盛的。</p>\n<p>老妈果然给我寄了好些个年货，我最爱的山核桃还有开心果，感谢老妈！</p>\n<p>大过年的在外头也没什么事做，天天凌晨才睡觉，然后睡到中午，起来随便一顿吃又开始坐在电脑前捣鼓。出去看了几场电影，感觉今年留沪的人应该不少，影院人还是挺多的。这几天刷了一遍《灌篮高手》动漫，经典永不超越，一群平凡人为着梦想努力拼搏，太热血了。看完特地又买了个篮球，不免想起了自己小学放学后的篮球时光。已经记不得是我哪一年的生日，那天放学后回家看到桌上有一个崭新的篮球，是爸妈给我的生日礼物。从那天开始，我只要有空就会去附近的篮球场，当时个子小又没什么力气，大多时间都是乱抛乱甩自娱自乐，到后来开始自己拍球抛球。有一说一，当时同龄人中我的个子也不算矮，球技也不错，年少无知一统球场！不过后来上初中后开始就不怎么接触篮球了，所以导致现在虽然能打打球但水平也就那样了……</p>\n<p>有梦想谁都了不起！</p>\n<p>这几天看完了村上春树的《挪威的森林》，看完很有感触，有时候觉得自己跟渡边是多么得相似。村上这部小说写得很直白露骨，看完可能会有些许的压抑也可能会让你瞬间成长一些。就引用译序中我认为非常能概括此书的一段话吧：<strong>其间无数读者来信朝我这个译者手里飞来，每三封就有两封谈《挪威的森林》，或为故事的情节所吸引，或为主人公的个性所打动，或为韵味的别具一格所感染，或为语言的洗炼优美所陶醉。有人说像小河虾纤细的触角刺破自己的泪腺，有人说像静夜如水的月光抚慰自己孤独的心灵，有人说引领自己走出四顾茫然的青春沼泽，有人说让人刻骨铭心地懂得了什么叫成长……</strong></p>\n<p>又把《SHOE DOG 鞋狗》看完了，耐克创始人菲尔·奈特亲笔自传，看完后我算是对耐克的历史有了更深刻的了解。整本书看的过程中不像一般的自传吹嘘种种，更像是一本小说，按照时间线将故事娓娓道来，讲述了成功路上的坎坷。总之看的很过瘾，一部体育巨头的成长史。</p>\n<p>一眨眼这个年也就这样过去了，又要重复打工人的生活了。</p>\n"},{"title":"RESTful URL 命名规则","date":"2020-08-04T13:10:55.000Z","_content":"\nURL 命名规则：\n\n- 驼峰命名法(serverAddress)\n- 蛇形命名法(server_address)\n- 脊柱命名法(server-address)\n\n驼峰命名法和蛇形命名法都会涉及到输入法的切换，在实际情况中确实会增加操作的复杂性。\n\n相比之下，脊柱命名法确实是较为合适的，我看 GitHub 网站也是用的脊柱命名法。\n\n---\n\n公司随着规模不断的扩大，功能越加越多，补丁越打越多，紧接着接口也越来越多越来越杂。再加上开发人员各自都有一套独特的风格，组内开发人数越多也就越难控制风格，最近感觉越来越强烈了。一开始我还是习惯用驼峰命名法，命名也很不规范，动词一大堆，慢慢得，自己看着也越来越难受，就网上找大家比较公认的规范了。\n\n## 驼峰命名法\n骆驼式命名法（Camel-Case）又称驼峰式命名法，是电脑程式编写时的一套命名规则（惯例）。正如它的名称 CamelCase 所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。程序员们为了自己的代码能更容易的在同行之间交流，所以多采取统一的可读性比较好的命名方式。\n\n## 蛇形命名法\n蛇形命名法（snake_case），变量名由多个部分组成，每个部分之间使用下划线 `_` 进行连接，所以也称之为**下划线命名法**。\n\n## 脊柱命名法\n脊柱命名法（spinal-case），跟蛇形命名法类似，不过连接符为连接符 `-`。也称之为 `kebab-case`、`train-case`。在 URL 命名，HTML 属性、CSS 属性、Lisp 语言比较常见，所以也称之为 `lisp-case`。\n\n### 相关文章\n\n- [RESTful API 设计指南-阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)\n- [RESTful 风格的接口命名规范](https://www.cnblogs.com/MTRD/p/12153561.html)","source":"_posts/restful-url-api.md","raw":"---\ntitle: RESTful URL 命名规则\ndate: 2020-08-04 21:10:55\ncategories: [开发,总结]\ntags: [RESTful]\n---\n\nURL 命名规则：\n\n- 驼峰命名法(serverAddress)\n- 蛇形命名法(server_address)\n- 脊柱命名法(server-address)\n\n驼峰命名法和蛇形命名法都会涉及到输入法的切换，在实际情况中确实会增加操作的复杂性。\n\n相比之下，脊柱命名法确实是较为合适的，我看 GitHub 网站也是用的脊柱命名法。\n\n---\n\n公司随着规模不断的扩大，功能越加越多，补丁越打越多，紧接着接口也越来越多越来越杂。再加上开发人员各自都有一套独特的风格，组内开发人数越多也就越难控制风格，最近感觉越来越强烈了。一开始我还是习惯用驼峰命名法，命名也很不规范，动词一大堆，慢慢得，自己看着也越来越难受，就网上找大家比较公认的规范了。\n\n## 驼峰命名法\n骆驼式命名法（Camel-Case）又称驼峰式命名法，是电脑程式编写时的一套命名规则（惯例）。正如它的名称 CamelCase 所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。程序员们为了自己的代码能更容易的在同行之间交流，所以多采取统一的可读性比较好的命名方式。\n\n## 蛇形命名法\n蛇形命名法（snake_case），变量名由多个部分组成，每个部分之间使用下划线 `_` 进行连接，所以也称之为**下划线命名法**。\n\n## 脊柱命名法\n脊柱命名法（spinal-case），跟蛇形命名法类似，不过连接符为连接符 `-`。也称之为 `kebab-case`、`train-case`。在 URL 命名，HTML 属性、CSS 属性、Lisp 语言比较常见，所以也称之为 `lisp-case`。\n\n### 相关文章\n\n- [RESTful API 设计指南-阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)\n- [RESTful 风格的接口命名规范](https://www.cnblogs.com/MTRD/p/12153561.html)","slug":"restful-url-api","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn009uk9i11xuq166m","content":"<p>URL 命名规则：</p>\n<ul>\n<li>驼峰命名法(serverAddress)</li>\n<li>蛇形命名法(server_address)</li>\n<li>脊柱命名法(server-address)</li>\n</ul>\n<p>驼峰命名法和蛇形命名法都会涉及到输入法的切换，在实际情况中确实会增加操作的复杂性。</p>\n<p>相比之下，脊柱命名法确实是较为合适的，我看 GitHub 网站也是用的脊柱命名法。</p>\n<hr>\n<p>公司随着规模不断的扩大，功能越加越多，补丁越打越多，紧接着接口也越来越多越来越杂。再加上开发人员各自都有一套独特的风格，组内开发人数越多也就越难控制风格，最近感觉越来越强烈了。一开始我还是习惯用驼峰命名法，命名也很不规范，动词一大堆，慢慢得，自己看着也越来越难受，就网上找大家比较公认的规范了。</p>\n<h2 id=\"驼峰命名法\"><a href=\"#驼峰命名法\" class=\"headerlink\" title=\"驼峰命名法\"></a>驼峰命名法</h2><p>骆驼式命名法（Camel-Case）又称驼峰式命名法，是电脑程式编写时的一套命名规则（惯例）。正如它的名称 CamelCase 所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。程序员们为了自己的代码能更容易的在同行之间交流，所以多采取统一的可读性比较好的命名方式。</p>\n<h2 id=\"蛇形命名法\"><a href=\"#蛇形命名法\" class=\"headerlink\" title=\"蛇形命名法\"></a>蛇形命名法</h2><p>蛇形命名法（snake_case），变量名由多个部分组成，每个部分之间使用下划线 <code>_</code> 进行连接，所以也称之为<strong>下划线命名法</strong>。</p>\n<h2 id=\"脊柱命名法\"><a href=\"#脊柱命名法\" class=\"headerlink\" title=\"脊柱命名法\"></a>脊柱命名法</h2><p>脊柱命名法（spinal-case），跟蛇形命名法类似，不过连接符为连接符 <code>-</code>。也称之为 <code>kebab-case</code>、<code>train-case</code>。在 URL 命名，HTML 属性、CSS 属性、Lisp 语言比较常见，所以也称之为 <code>lisp-case</code>。</p>\n<h3 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南-阮一峰的网络日志</a></li>\n<li><a href=\"https://www.cnblogs.com/MTRD/p/12153561.html\">RESTful 风格的接口命名规范</a></li>\n</ul>\n","excerpt":"","more":"<p>URL 命名规则：</p>\n<ul>\n<li>驼峰命名法(serverAddress)</li>\n<li>蛇形命名法(server_address)</li>\n<li>脊柱命名法(server-address)</li>\n</ul>\n<p>驼峰命名法和蛇形命名法都会涉及到输入法的切换，在实际情况中确实会增加操作的复杂性。</p>\n<p>相比之下，脊柱命名法确实是较为合适的，我看 GitHub 网站也是用的脊柱命名法。</p>\n<hr>\n<p>公司随着规模不断的扩大，功能越加越多，补丁越打越多，紧接着接口也越来越多越来越杂。再加上开发人员各自都有一套独特的风格，组内开发人数越多也就越难控制风格，最近感觉越来越强烈了。一开始我还是习惯用驼峰命名法，命名也很不规范，动词一大堆，慢慢得，自己看着也越来越难受，就网上找大家比较公认的规范了。</p>\n<h2 id=\"驼峰命名法\"><a href=\"#驼峰命名法\" class=\"headerlink\" title=\"驼峰命名法\"></a>驼峰命名法</h2><p>骆驼式命名法（Camel-Case）又称驼峰式命名法，是电脑程式编写时的一套命名规则（惯例）。正如它的名称 CamelCase 所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。程序员们为了自己的代码能更容易的在同行之间交流，所以多采取统一的可读性比较好的命名方式。</p>\n<h2 id=\"蛇形命名法\"><a href=\"#蛇形命名法\" class=\"headerlink\" title=\"蛇形命名法\"></a>蛇形命名法</h2><p>蛇形命名法（snake_case），变量名由多个部分组成，每个部分之间使用下划线 <code>_</code> 进行连接，所以也称之为<strong>下划线命名法</strong>。</p>\n<h2 id=\"脊柱命名法\"><a href=\"#脊柱命名法\" class=\"headerlink\" title=\"脊柱命名法\"></a>脊柱命名法</h2><p>脊柱命名法（spinal-case），跟蛇形命名法类似，不过连接符为连接符 <code>-</code>。也称之为 <code>kebab-case</code>、<code>train-case</code>。在 URL 命名，HTML 属性、CSS 属性、Lisp 语言比较常见，所以也称之为 <code>lisp-case</code>。</p>\n<h3 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南-阮一峰的网络日志</a></li>\n<li><a href=\"https://www.cnblogs.com/MTRD/p/12153561.html\">RESTful 风格的接口命名规范</a></li>\n</ul>\n"},{"title":"焦躁三月（2022）","date":"2022-03-31T14:10:55.000Z","_content":"\n> 这个三月有点焦躁，不光是气温回升换季的焦躁还是那些个想要救国纷纷下海的人的焦躁，包括有我……\n\n本来想着年初已经跌到位了，再缓缓就取出来买金器各种开销，没成想，一切只是开始，短短十几天已经是到了地板摩擦了。黄金还给涨了不少，郁闷……\n\n没办法，愿赌服输，这几年的利润算是全回吐出去了。好好被市场先生教育了一番。\n\n今天是 2022-03-15，可以看看中概股都变成啥样了，以后看到可以上网回顾回顾。\n\n再给市场一星期，实在不行那我也没撤，钱也是到了必取的时候了，这一波投资有点失败。\n\n这一波波的要是能撑下来，今后的收获绝对满意。可惜啊，要用钱了，真是要用闲钱投资。\n\n---\n\n昨天还在感慨，今天市场就来个大反转。\n\n> 3月16日，国务院金融稳定发展委员会召开专题会议。受此消息影响，A股港股全线反攻。\n>\n> 截至收盘，沪指涨3.48%，深成指涨4.02%，创业板指涨5.20%，两市超4300只个股上涨，成交额近1.2万亿，北向资金净卖出0.82亿元。\n>\n> 午后金融股异动拉升，券商板块大幅冲高。中银证券、华鑫股份、国盛金控、广发证券涨停，中金公司、天风证券、东方财富等涨超7%。\n>\n> 港股方面，在昨夜中概股企稳止跌之后，今日恒生科技指数绝地反击，涨超20%，单日涨幅创最高纪录，盘中涨幅一度扩至22%；恒生指数涨近8%。\n>\n> 恒生科技指数成份股中，哔哩哔哩涨近40%，美团、京东一度涨超30%，腾讯控股最高涨幅24%。\n\n这种直下直上的感觉真是有点刺激，安全带不系紧一点恐怕一下子就甩没影了。\n\n有人欢喜有人忧。\n\n---\n\n这个月下半月都是居家办公，就快要解封的时候楼下又出了一个阳的，这下又得 14 天，估计再这样弄下去得到劳动节了。上海这波是真的没控制住，影响太大了，经济靠什么来增长呢。\n\n之前屯的菜已经快消耗完了，最近早上都在抢菜，是真难抢，实在没撤还好有许多面饼，还有一袋米。整天头发打缕，赤脚走动，时间久了确实是希望能正常出入上班，但实话说居家办公舒服确实是舒服。\n\n---\n\n第一个季度过去了，希望下个季度能都有所好转。","source":"_posts/restless-march.md","raw":"---\ntitle: 焦躁三月（2022）\ndate: 2022-03-31 22:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个三月有点焦躁，不光是气温回升换季的焦躁还是那些个想要救国纷纷下海的人的焦躁，包括有我……\n\n本来想着年初已经跌到位了，再缓缓就取出来买金器各种开销，没成想，一切只是开始，短短十几天已经是到了地板摩擦了。黄金还给涨了不少，郁闷……\n\n没办法，愿赌服输，这几年的利润算是全回吐出去了。好好被市场先生教育了一番。\n\n今天是 2022-03-15，可以看看中概股都变成啥样了，以后看到可以上网回顾回顾。\n\n再给市场一星期，实在不行那我也没撤，钱也是到了必取的时候了，这一波投资有点失败。\n\n这一波波的要是能撑下来，今后的收获绝对满意。可惜啊，要用钱了，真是要用闲钱投资。\n\n---\n\n昨天还在感慨，今天市场就来个大反转。\n\n> 3月16日，国务院金融稳定发展委员会召开专题会议。受此消息影响，A股港股全线反攻。\n>\n> 截至收盘，沪指涨3.48%，深成指涨4.02%，创业板指涨5.20%，两市超4300只个股上涨，成交额近1.2万亿，北向资金净卖出0.82亿元。\n>\n> 午后金融股异动拉升，券商板块大幅冲高。中银证券、华鑫股份、国盛金控、广发证券涨停，中金公司、天风证券、东方财富等涨超7%。\n>\n> 港股方面，在昨夜中概股企稳止跌之后，今日恒生科技指数绝地反击，涨超20%，单日涨幅创最高纪录，盘中涨幅一度扩至22%；恒生指数涨近8%。\n>\n> 恒生科技指数成份股中，哔哩哔哩涨近40%，美团、京东一度涨超30%，腾讯控股最高涨幅24%。\n\n这种直下直上的感觉真是有点刺激，安全带不系紧一点恐怕一下子就甩没影了。\n\n有人欢喜有人忧。\n\n---\n\n这个月下半月都是居家办公，就快要解封的时候楼下又出了一个阳的，这下又得 14 天，估计再这样弄下去得到劳动节了。上海这波是真的没控制住，影响太大了，经济靠什么来增长呢。\n\n之前屯的菜已经快消耗完了，最近早上都在抢菜，是真难抢，实在没撤还好有许多面饼，还有一袋米。整天头发打缕，赤脚走动，时间久了确实是希望能正常出入上班，但实话说居家办公舒服确实是舒服。\n\n---\n\n第一个季度过去了，希望下个季度能都有所好转。","slug":"restless-march","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn009xk9i10axxcf9w","content":"<blockquote>\n<p>这个三月有点焦躁，不光是气温回升换季的焦躁还是那些个想要救国纷纷下海的人的焦躁，包括有我……</p>\n</blockquote>\n<p>本来想着年初已经跌到位了，再缓缓就取出来买金器各种开销，没成想，一切只是开始，短短十几天已经是到了地板摩擦了。黄金还给涨了不少，郁闷……</p>\n<p>没办法，愿赌服输，这几年的利润算是全回吐出去了。好好被市场先生教育了一番。</p>\n<p>今天是 2022-03-15，可以看看中概股都变成啥样了，以后看到可以上网回顾回顾。</p>\n<p>再给市场一星期，实在不行那我也没撤，钱也是到了必取的时候了，这一波投资有点失败。</p>\n<p>这一波波的要是能撑下来，今后的收获绝对满意。可惜啊，要用钱了，真是要用闲钱投资。</p>\n<hr>\n<p>昨天还在感慨，今天市场就来个大反转。</p>\n<blockquote>\n<p>3月16日，国务院金融稳定发展委员会召开专题会议。受此消息影响，A股港股全线反攻。</p>\n<p>截至收盘，沪指涨3.48%，深成指涨4.02%，创业板指涨5.20%，两市超4300只个股上涨，成交额近1.2万亿，北向资金净卖出0.82亿元。</p>\n<p>午后金融股异动拉升，券商板块大幅冲高。中银证券、华鑫股份、国盛金控、广发证券涨停，中金公司、天风证券、东方财富等涨超7%。</p>\n<p>港股方面，在昨夜中概股企稳止跌之后，今日恒生科技指数绝地反击，涨超20%，单日涨幅创最高纪录，盘中涨幅一度扩至22%；恒生指数涨近8%。</p>\n<p>恒生科技指数成份股中，哔哩哔哩涨近40%，美团、京东一度涨超30%，腾讯控股最高涨幅24%。</p>\n</blockquote>\n<p>这种直下直上的感觉真是有点刺激，安全带不系紧一点恐怕一下子就甩没影了。</p>\n<p>有人欢喜有人忧。</p>\n<hr>\n<p>这个月下半月都是居家办公，就快要解封的时候楼下又出了一个阳的，这下又得 14 天，估计再这样弄下去得到劳动节了。上海这波是真的没控制住，影响太大了，经济靠什么来增长呢。</p>\n<p>之前屯的菜已经快消耗完了，最近早上都在抢菜，是真难抢，实在没撤还好有许多面饼，还有一袋米。整天头发打缕，赤脚走动，时间久了确实是希望能正常出入上班，但实话说居家办公舒服确实是舒服。</p>\n<hr>\n<p>第一个季度过去了，希望下个季度能都有所好转。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个三月有点焦躁，不光是气温回升换季的焦躁还是那些个想要救国纷纷下海的人的焦躁，包括有我……</p>\n</blockquote>\n<p>本来想着年初已经跌到位了，再缓缓就取出来买金器各种开销，没成想，一切只是开始，短短十几天已经是到了地板摩擦了。黄金还给涨了不少，郁闷……</p>\n<p>没办法，愿赌服输，这几年的利润算是全回吐出去了。好好被市场先生教育了一番。</p>\n<p>今天是 2022-03-15，可以看看中概股都变成啥样了，以后看到可以上网回顾回顾。</p>\n<p>再给市场一星期，实在不行那我也没撤，钱也是到了必取的时候了，这一波投资有点失败。</p>\n<p>这一波波的要是能撑下来，今后的收获绝对满意。可惜啊，要用钱了，真是要用闲钱投资。</p>\n<hr>\n<p>昨天还在感慨，今天市场就来个大反转。</p>\n<blockquote>\n<p>3月16日，国务院金融稳定发展委员会召开专题会议。受此消息影响，A股港股全线反攻。</p>\n<p>截至收盘，沪指涨3.48%，深成指涨4.02%，创业板指涨5.20%，两市超4300只个股上涨，成交额近1.2万亿，北向资金净卖出0.82亿元。</p>\n<p>午后金融股异动拉升，券商板块大幅冲高。中银证券、华鑫股份、国盛金控、广发证券涨停，中金公司、天风证券、东方财富等涨超7%。</p>\n<p>港股方面，在昨夜中概股企稳止跌之后，今日恒生科技指数绝地反击，涨超20%，单日涨幅创最高纪录，盘中涨幅一度扩至22%；恒生指数涨近8%。</p>\n<p>恒生科技指数成份股中，哔哩哔哩涨近40%，美团、京东一度涨超30%，腾讯控股最高涨幅24%。</p>\n</blockquote>\n<p>这种直下直上的感觉真是有点刺激，安全带不系紧一点恐怕一下子就甩没影了。</p>\n<p>有人欢喜有人忧。</p>\n<hr>\n<p>这个月下半月都是居家办公，就快要解封的时候楼下又出了一个阳的，这下又得 14 天，估计再这样弄下去得到劳动节了。上海这波是真的没控制住，影响太大了，经济靠什么来增长呢。</p>\n<p>之前屯的菜已经快消耗完了，最近早上都在抢菜，是真难抢，实在没撤还好有许多面饼，还有一袋米。整天头发打缕，赤脚走动，时间久了确实是希望能正常出入上班，但实话说居家办公舒服确实是舒服。</p>\n<hr>\n<p>第一个季度过去了，希望下个季度能都有所好转。</p>\n"},{"title":"团圆二月（2022）","date":"2022-03-03T13:10:55.000Z","_content":"\n> 其实年味没那么浓了，不过一家人在一起就很满足\n\n\n\n去年没有能回家，今年可算是回去了。回去的前一天在曙光医院做了核酸，排了一个多小时吧，然后到了之后在镇上又做了几次核酸，免费的。\n\n老爸之前看猪肉那么贵，去年养了几头猪，可想而知，贵了一段时间后价格就下来了，到后来就没赚到几个钱，人还弄得辛苦。年前也是杀猪的时候，现在不像以前了，现在先用电给猪电一下，再动手。喊声凄惨凄惨的。弱肉强食，生物链。年前忙活了两天，几头猪到了年三十还没弄都卖掉，还留下来差不多一扇。没办法，只能自己塞到冰箱了，塞不下就用盐腌起来，反正也是要吃肉的嘛。这么一整，老爸说不愿意养猪了，寻思去养牛……\n\n今年也是没有走亲戚，省事却是省事了。过年期间也是天天呆在家，吃吃喝喝躺躺看看电视，十分惬意。\n\n在家呆上个一星期，又要背上行囊沪飘了，这么算来，到今年就在上海呆了五年了，好快啊。时间都耗在了大上海，钱也没赚几个，最近这个大 A 也疲软不堪，不成气候啊。\n\n这个月大事必要数俄乌大战了，这一战波及全国，重金属也随之狂飙，本来是准备最近就要买金器的。上次一犹豫没有买，现在都已经每克又涨了几十了，头皮发麻。再看看吧，再过个几天 A 还是这样疲软也没办法，该取出来的还是要取出来，用钱之时。\n\n国内的和平是其他国家所渴望的，生活在如今这个和平的国度是我们大家的幸福。\n\n及时行乐，命最重要。","source":"_posts/reunion-february.md","raw":"---\ntitle: 团圆二月（2022）\ndate: 2022-03-03 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 其实年味没那么浓了，不过一家人在一起就很满足\n\n\n\n去年没有能回家，今年可算是回去了。回去的前一天在曙光医院做了核酸，排了一个多小时吧，然后到了之后在镇上又做了几次核酸，免费的。\n\n老爸之前看猪肉那么贵，去年养了几头猪，可想而知，贵了一段时间后价格就下来了，到后来就没赚到几个钱，人还弄得辛苦。年前也是杀猪的时候，现在不像以前了，现在先用电给猪电一下，再动手。喊声凄惨凄惨的。弱肉强食，生物链。年前忙活了两天，几头猪到了年三十还没弄都卖掉，还留下来差不多一扇。没办法，只能自己塞到冰箱了，塞不下就用盐腌起来，反正也是要吃肉的嘛。这么一整，老爸说不愿意养猪了，寻思去养牛……\n\n今年也是没有走亲戚，省事却是省事了。过年期间也是天天呆在家，吃吃喝喝躺躺看看电视，十分惬意。\n\n在家呆上个一星期，又要背上行囊沪飘了，这么算来，到今年就在上海呆了五年了，好快啊。时间都耗在了大上海，钱也没赚几个，最近这个大 A 也疲软不堪，不成气候啊。\n\n这个月大事必要数俄乌大战了，这一战波及全国，重金属也随之狂飙，本来是准备最近就要买金器的。上次一犹豫没有买，现在都已经每克又涨了几十了，头皮发麻。再看看吧，再过个几天 A 还是这样疲软也没办法，该取出来的还是要取出来，用钱之时。\n\n国内的和平是其他国家所渴望的，生活在如今这个和平的国度是我们大家的幸福。\n\n及时行乐，命最重要。","slug":"reunion-february","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhn00a1k9i1f541f97o","content":"<blockquote>\n<p>其实年味没那么浓了，不过一家人在一起就很满足</p>\n</blockquote>\n<p>去年没有能回家，今年可算是回去了。回去的前一天在曙光医院做了核酸，排了一个多小时吧，然后到了之后在镇上又做了几次核酸，免费的。</p>\n<p>老爸之前看猪肉那么贵，去年养了几头猪，可想而知，贵了一段时间后价格就下来了，到后来就没赚到几个钱，人还弄得辛苦。年前也是杀猪的时候，现在不像以前了，现在先用电给猪电一下，再动手。喊声凄惨凄惨的。弱肉强食，生物链。年前忙活了两天，几头猪到了年三十还没弄都卖掉，还留下来差不多一扇。没办法，只能自己塞到冰箱了，塞不下就用盐腌起来，反正也是要吃肉的嘛。这么一整，老爸说不愿意养猪了，寻思去养牛……</p>\n<p>今年也是没有走亲戚，省事却是省事了。过年期间也是天天呆在家，吃吃喝喝躺躺看看电视，十分惬意。</p>\n<p>在家呆上个一星期，又要背上行囊沪飘了，这么算来，到今年就在上海呆了五年了，好快啊。时间都耗在了大上海，钱也没赚几个，最近这个大 A 也疲软不堪，不成气候啊。</p>\n<p>这个月大事必要数俄乌大战了，这一战波及全国，重金属也随之狂飙，本来是准备最近就要买金器的。上次一犹豫没有买，现在都已经每克又涨了几十了，头皮发麻。再看看吧，再过个几天 A 还是这样疲软也没办法，该取出来的还是要取出来，用钱之时。</p>\n<p>国内的和平是其他国家所渴望的，生活在如今这个和平的国度是我们大家的幸福。</p>\n<p>及时行乐，命最重要。</p>\n","excerpt":"","more":"<blockquote>\n<p>其实年味没那么浓了，不过一家人在一起就很满足</p>\n</blockquote>\n<p>去年没有能回家，今年可算是回去了。回去的前一天在曙光医院做了核酸，排了一个多小时吧，然后到了之后在镇上又做了几次核酸，免费的。</p>\n<p>老爸之前看猪肉那么贵，去年养了几头猪，可想而知，贵了一段时间后价格就下来了，到后来就没赚到几个钱，人还弄得辛苦。年前也是杀猪的时候，现在不像以前了，现在先用电给猪电一下，再动手。喊声凄惨凄惨的。弱肉强食，生物链。年前忙活了两天，几头猪到了年三十还没弄都卖掉，还留下来差不多一扇。没办法，只能自己塞到冰箱了，塞不下就用盐腌起来，反正也是要吃肉的嘛。这么一整，老爸说不愿意养猪了，寻思去养牛……</p>\n<p>今年也是没有走亲戚，省事却是省事了。过年期间也是天天呆在家，吃吃喝喝躺躺看看电视，十分惬意。</p>\n<p>在家呆上个一星期，又要背上行囊沪飘了，这么算来，到今年就在上海呆了五年了，好快啊。时间都耗在了大上海，钱也没赚几个，最近这个大 A 也疲软不堪，不成气候啊。</p>\n<p>这个月大事必要数俄乌大战了，这一战波及全国，重金属也随之狂飙，本来是准备最近就要买金器的。上次一犹豫没有买，现在都已经每克又涨了几十了，头皮发麻。再看看吧，再过个几天 A 还是这样疲软也没办法，该取出来的还是要取出来，用钱之时。</p>\n<p>国内的和平是其他国家所渴望的，生活在如今这个和平的国度是我们大家的幸福。</p>\n<p>及时行乐，命最重要。</p>\n"},{"title":"书香八月（2018）","date":"2018-09-03T01:21:59.000Z","_content":"\n<center>\n又是一月悄悄溜走，蓦然回首，措不及防，顿有种惊魂失措之意\n\n昨日刚看了些沈复写的《浮生六记》——浮生若梦，为欢几何\n\n多么美好令人羡艳的爱情，平淡如水，举案齐眉，彼此心心想通\n\n可以想象沈复当年回忆并写下这些往事时是种什么样的心情\n\n俱往矣。\n</center>\n\n---\n\n- 如今游戏已没有当年学生时代那么为之疯狂，想想当时一时兴起就会叫上几个同学坐上人力车或是残疾三轮摩托（我们老家称之田鸡蹦），照着熟之不能再熟的小路在那黑网吧相聚。为什么我说是黑网吧，自然是因为那时我们都还未成年，只需报个身份证即可入座。这一坐往往就是个通宵。\n\n- 最近趁着开学季，有些APP上图书优惠幅度较大，便又是忍不住入手了几本，其中自然有专业书籍也有些闲暇时候用于静心的读物。\n\n- 可能是我太害怕孤独故连我早已习惯了孤独，都不知。犹记早在小学两三年级我便时常晚上一人在家睡觉，但我已不记得那时我的心中所想，只记得往往是被子过头，闷闷入睡。儿时的睡眠质量倒不像如今，睡得早也睡得着，早上自己也能早起，偶尔自做一碗红烧牛肉面用于饱腹，或是去街上花个一元买个大饼。\n\n- 依稀还是能记得儿时的事情，不过实在太久远的我便一脸茫然。就如家人常常饭桌上提起的那件“大事”：那时我们一家还在义乌，爸妈还在那做生意，我可能三岁，或是更小吧。有一日我和我姐（亲姐大我四岁）去摊位上，不知怎的当我姐回头看我时，我已不在她视线中。听闻全家跑遍了整个商场寻我，最终还是我姐在商场顶楼寻到了我，我那时白白胖胖一双小短腿，殊不知怎的能一步一步迈着上了四楼，真可谓神乎其技啊。还有一事便是我在托儿所抄起凳子准备与老师干架。由于父母忙于生意，无再有精力将我带在身边，而我那时也已三岁，到了该读书学习的年纪了。于是就将我安排进了托儿所与我姐一个学校，只不过我是小班，她在大班。每每到了午饭时间我便要拿着我的家伙跑到姐姐的班级去要我姐喂我吃（听着傲娇也是从小就开始的啊），姐姐无奈也只得喂我。然老师不从，要将我“赶回”自己所在班级，我那时也是有脾气（果真性子在小时候就已经定型了啊）顺手就抄起身下的小板凳准备扔向该老师，做好了大干一场的风范。次次谈论此，我以手掩面，不语不语。\n\n---\n\n- 08年大雪，雪灾。十年后的18年，也是多灾多难。\n\n- 如今的网络舆论力量不容小觑，听闻国家也是准备出政策实名发表舆论，不知会如何。\n\n- 以前人们没有手机没有网络，两耳不闻窗外事，生活无忧，也无需顾此失彼，做一件事便能专心做到极致。网络的力量使人们不知名有了一种使命感、一种自我重要感，便会觉得我不能缺，缺我不可。想太多，心累，吃好睡好，长生不老。\n\n- 前几日猛然想起之前听闻爷爷的死因是前列腺癌，而前列腺癌遗传的概率极高，不知我会不会中招，忐忑不安忐忑不安啊。人生不尽人意之事多矣。\n\n- 魔都寸土寸金，在小房间里无地安置写字桌，便买了个小桌放置床头用于平日里书写干活。人生不会一直如此，美妙人生须有美丽心人。\n\n---\n\n- 恍然又快一年，去年元旦同大学室友游逛了美丽苏州，除了遍地黄牛与无良卖家，一切还是如此美好。尤是夜晚的街道显得古韵十足。\n\n- 前几日我们便定了中秋相聚游玩之地，本是准备花个大价钱去重庆探一探辣妹底子，可还是奈不住干瘪的钱袋子，于是便定了去杭州。计划是先去杭州再去横店玩耍，若时间有余，还可去我家静坐一番，亲自入园采摘葡萄也是极好（浙江浦江巨峰葡萄远近闻名，我家尚有几亩，养老足矣）。\n\n---\n\n平日主还是务实基础，提升自我价值。\n\n以上便是八月之总结。写于 戊戌年 狗年 庚申月 戊戌日。抗战胜利日。","source":"_posts/scholarly-august-2018.md","raw":"---\ntitle: 书香八月（2018）\ndate: 2018-9-3 09:21:59\ncategories: [生活,杂侃]\ntags: []\n---\n\n<center>\n又是一月悄悄溜走，蓦然回首，措不及防，顿有种惊魂失措之意\n\n昨日刚看了些沈复写的《浮生六记》——浮生若梦，为欢几何\n\n多么美好令人羡艳的爱情，平淡如水，举案齐眉，彼此心心想通\n\n可以想象沈复当年回忆并写下这些往事时是种什么样的心情\n\n俱往矣。\n</center>\n\n---\n\n- 如今游戏已没有当年学生时代那么为之疯狂，想想当时一时兴起就会叫上几个同学坐上人力车或是残疾三轮摩托（我们老家称之田鸡蹦），照着熟之不能再熟的小路在那黑网吧相聚。为什么我说是黑网吧，自然是因为那时我们都还未成年，只需报个身份证即可入座。这一坐往往就是个通宵。\n\n- 最近趁着开学季，有些APP上图书优惠幅度较大，便又是忍不住入手了几本，其中自然有专业书籍也有些闲暇时候用于静心的读物。\n\n- 可能是我太害怕孤独故连我早已习惯了孤独，都不知。犹记早在小学两三年级我便时常晚上一人在家睡觉，但我已不记得那时我的心中所想，只记得往往是被子过头，闷闷入睡。儿时的睡眠质量倒不像如今，睡得早也睡得着，早上自己也能早起，偶尔自做一碗红烧牛肉面用于饱腹，或是去街上花个一元买个大饼。\n\n- 依稀还是能记得儿时的事情，不过实在太久远的我便一脸茫然。就如家人常常饭桌上提起的那件“大事”：那时我们一家还在义乌，爸妈还在那做生意，我可能三岁，或是更小吧。有一日我和我姐（亲姐大我四岁）去摊位上，不知怎的当我姐回头看我时，我已不在她视线中。听闻全家跑遍了整个商场寻我，最终还是我姐在商场顶楼寻到了我，我那时白白胖胖一双小短腿，殊不知怎的能一步一步迈着上了四楼，真可谓神乎其技啊。还有一事便是我在托儿所抄起凳子准备与老师干架。由于父母忙于生意，无再有精力将我带在身边，而我那时也已三岁，到了该读书学习的年纪了。于是就将我安排进了托儿所与我姐一个学校，只不过我是小班，她在大班。每每到了午饭时间我便要拿着我的家伙跑到姐姐的班级去要我姐喂我吃（听着傲娇也是从小就开始的啊），姐姐无奈也只得喂我。然老师不从，要将我“赶回”自己所在班级，我那时也是有脾气（果真性子在小时候就已经定型了啊）顺手就抄起身下的小板凳准备扔向该老师，做好了大干一场的风范。次次谈论此，我以手掩面，不语不语。\n\n---\n\n- 08年大雪，雪灾。十年后的18年，也是多灾多难。\n\n- 如今的网络舆论力量不容小觑，听闻国家也是准备出政策实名发表舆论，不知会如何。\n\n- 以前人们没有手机没有网络，两耳不闻窗外事，生活无忧，也无需顾此失彼，做一件事便能专心做到极致。网络的力量使人们不知名有了一种使命感、一种自我重要感，便会觉得我不能缺，缺我不可。想太多，心累，吃好睡好，长生不老。\n\n- 前几日猛然想起之前听闻爷爷的死因是前列腺癌，而前列腺癌遗传的概率极高，不知我会不会中招，忐忑不安忐忑不安啊。人生不尽人意之事多矣。\n\n- 魔都寸土寸金，在小房间里无地安置写字桌，便买了个小桌放置床头用于平日里书写干活。人生不会一直如此，美妙人生须有美丽心人。\n\n---\n\n- 恍然又快一年，去年元旦同大学室友游逛了美丽苏州，除了遍地黄牛与无良卖家，一切还是如此美好。尤是夜晚的街道显得古韵十足。\n\n- 前几日我们便定了中秋相聚游玩之地，本是准备花个大价钱去重庆探一探辣妹底子，可还是奈不住干瘪的钱袋子，于是便定了去杭州。计划是先去杭州再去横店玩耍，若时间有余，还可去我家静坐一番，亲自入园采摘葡萄也是极好（浙江浦江巨峰葡萄远近闻名，我家尚有几亩，养老足矣）。\n\n---\n\n平日主还是务实基础，提升自我价值。\n\n以上便是八月之总结。写于 戊戌年 狗年 庚申月 戊戌日。抗战胜利日。","slug":"scholarly-august-2018","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjho00a5k9i1fkf3e8wu","content":"<center>\n又是一月悄悄溜走，蓦然回首，措不及防，顿有种惊魂失措之意\n\n<p>昨日刚看了些沈复写的《浮生六记》——浮生若梦，为欢几何</p>\n<p>多么美好令人羡艳的爱情，平淡如水，举案齐眉，彼此心心想通</p>\n<p>可以想象沈复当年回忆并写下这些往事时是种什么样的心情</p>\n<p>俱往矣。</p>\n</center>\n\n<hr>\n<ul>\n<li><p>如今游戏已没有当年学生时代那么为之疯狂，想想当时一时兴起就会叫上几个同学坐上人力车或是残疾三轮摩托（我们老家称之田鸡蹦），照着熟之不能再熟的小路在那黑网吧相聚。为什么我说是黑网吧，自然是因为那时我们都还未成年，只需报个身份证即可入座。这一坐往往就是个通宵。</p>\n</li>\n<li><p>最近趁着开学季，有些APP上图书优惠幅度较大，便又是忍不住入手了几本，其中自然有专业书籍也有些闲暇时候用于静心的读物。</p>\n</li>\n<li><p>可能是我太害怕孤独故连我早已习惯了孤独，都不知。犹记早在小学两三年级我便时常晚上一人在家睡觉，但我已不记得那时我的心中所想，只记得往往是被子过头，闷闷入睡。儿时的睡眠质量倒不像如今，睡得早也睡得着，早上自己也能早起，偶尔自做一碗红烧牛肉面用于饱腹，或是去街上花个一元买个大饼。</p>\n</li>\n<li><p>依稀还是能记得儿时的事情，不过实在太久远的我便一脸茫然。就如家人常常饭桌上提起的那件“大事”：那时我们一家还在义乌，爸妈还在那做生意，我可能三岁，或是更小吧。有一日我和我姐（亲姐大我四岁）去摊位上，不知怎的当我姐回头看我时，我已不在她视线中。听闻全家跑遍了整个商场寻我，最终还是我姐在商场顶楼寻到了我，我那时白白胖胖一双小短腿，殊不知怎的能一步一步迈着上了四楼，真可谓神乎其技啊。还有一事便是我在托儿所抄起凳子准备与老师干架。由于父母忙于生意，无再有精力将我带在身边，而我那时也已三岁，到了该读书学习的年纪了。于是就将我安排进了托儿所与我姐一个学校，只不过我是小班，她在大班。每每到了午饭时间我便要拿着我的家伙跑到姐姐的班级去要我姐喂我吃（听着傲娇也是从小就开始的啊），姐姐无奈也只得喂我。然老师不从，要将我“赶回”自己所在班级，我那时也是有脾气（果真性子在小时候就已经定型了啊）顺手就抄起身下的小板凳准备扔向该老师，做好了大干一场的风范。次次谈论此，我以手掩面，不语不语。</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>08年大雪，雪灾。十年后的18年，也是多灾多难。</p>\n</li>\n<li><p>如今的网络舆论力量不容小觑，听闻国家也是准备出政策实名发表舆论，不知会如何。</p>\n</li>\n<li><p>以前人们没有手机没有网络，两耳不闻窗外事，生活无忧，也无需顾此失彼，做一件事便能专心做到极致。网络的力量使人们不知名有了一种使命感、一种自我重要感，便会觉得我不能缺，缺我不可。想太多，心累，吃好睡好，长生不老。</p>\n</li>\n<li><p>前几日猛然想起之前听闻爷爷的死因是前列腺癌，而前列腺癌遗传的概率极高，不知我会不会中招，忐忑不安忐忑不安啊。人生不尽人意之事多矣。</p>\n</li>\n<li><p>魔都寸土寸金，在小房间里无地安置写字桌，便买了个小桌放置床头用于平日里书写干活。人生不会一直如此，美妙人生须有美丽心人。</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>恍然又快一年，去年元旦同大学室友游逛了美丽苏州，除了遍地黄牛与无良卖家，一切还是如此美好。尤是夜晚的街道显得古韵十足。</p>\n</li>\n<li><p>前几日我们便定了中秋相聚游玩之地，本是准备花个大价钱去重庆探一探辣妹底子，可还是奈不住干瘪的钱袋子，于是便定了去杭州。计划是先去杭州再去横店玩耍，若时间有余，还可去我家静坐一番，亲自入园采摘葡萄也是极好（浙江浦江巨峰葡萄远近闻名，我家尚有几亩，养老足矣）。</p>\n</li>\n</ul>\n<hr>\n<p>平日主还是务实基础，提升自我价值。</p>\n<p>以上便是八月之总结。写于 戊戌年 狗年 庚申月 戊戌日。抗战胜利日。</p>\n","excerpt":"","more":"<center>\n又是一月悄悄溜走，蓦然回首，措不及防，顿有种惊魂失措之意\n\n<p>昨日刚看了些沈复写的《浮生六记》——浮生若梦，为欢几何</p>\n<p>多么美好令人羡艳的爱情，平淡如水，举案齐眉，彼此心心想通</p>\n<p>可以想象沈复当年回忆并写下这些往事时是种什么样的心情</p>\n<p>俱往矣。</p>\n</center>\n\n<hr>\n<ul>\n<li><p>如今游戏已没有当年学生时代那么为之疯狂，想想当时一时兴起就会叫上几个同学坐上人力车或是残疾三轮摩托（我们老家称之田鸡蹦），照着熟之不能再熟的小路在那黑网吧相聚。为什么我说是黑网吧，自然是因为那时我们都还未成年，只需报个身份证即可入座。这一坐往往就是个通宵。</p>\n</li>\n<li><p>最近趁着开学季，有些APP上图书优惠幅度较大，便又是忍不住入手了几本，其中自然有专业书籍也有些闲暇时候用于静心的读物。</p>\n</li>\n<li><p>可能是我太害怕孤独故连我早已习惯了孤独，都不知。犹记早在小学两三年级我便时常晚上一人在家睡觉，但我已不记得那时我的心中所想，只记得往往是被子过头，闷闷入睡。儿时的睡眠质量倒不像如今，睡得早也睡得着，早上自己也能早起，偶尔自做一碗红烧牛肉面用于饱腹，或是去街上花个一元买个大饼。</p>\n</li>\n<li><p>依稀还是能记得儿时的事情，不过实在太久远的我便一脸茫然。就如家人常常饭桌上提起的那件“大事”：那时我们一家还在义乌，爸妈还在那做生意，我可能三岁，或是更小吧。有一日我和我姐（亲姐大我四岁）去摊位上，不知怎的当我姐回头看我时，我已不在她视线中。听闻全家跑遍了整个商场寻我，最终还是我姐在商场顶楼寻到了我，我那时白白胖胖一双小短腿，殊不知怎的能一步一步迈着上了四楼，真可谓神乎其技啊。还有一事便是我在托儿所抄起凳子准备与老师干架。由于父母忙于生意，无再有精力将我带在身边，而我那时也已三岁，到了该读书学习的年纪了。于是就将我安排进了托儿所与我姐一个学校，只不过我是小班，她在大班。每每到了午饭时间我便要拿着我的家伙跑到姐姐的班级去要我姐喂我吃（听着傲娇也是从小就开始的啊），姐姐无奈也只得喂我。然老师不从，要将我“赶回”自己所在班级，我那时也是有脾气（果真性子在小时候就已经定型了啊）顺手就抄起身下的小板凳准备扔向该老师，做好了大干一场的风范。次次谈论此，我以手掩面，不语不语。</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>08年大雪，雪灾。十年后的18年，也是多灾多难。</p>\n</li>\n<li><p>如今的网络舆论力量不容小觑，听闻国家也是准备出政策实名发表舆论，不知会如何。</p>\n</li>\n<li><p>以前人们没有手机没有网络，两耳不闻窗外事，生活无忧，也无需顾此失彼，做一件事便能专心做到极致。网络的力量使人们不知名有了一种使命感、一种自我重要感，便会觉得我不能缺，缺我不可。想太多，心累，吃好睡好，长生不老。</p>\n</li>\n<li><p>前几日猛然想起之前听闻爷爷的死因是前列腺癌，而前列腺癌遗传的概率极高，不知我会不会中招，忐忑不安忐忑不安啊。人生不尽人意之事多矣。</p>\n</li>\n<li><p>魔都寸土寸金，在小房间里无地安置写字桌，便买了个小桌放置床头用于平日里书写干活。人生不会一直如此，美妙人生须有美丽心人。</p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p>恍然又快一年，去年元旦同大学室友游逛了美丽苏州，除了遍地黄牛与无良卖家，一切还是如此美好。尤是夜晚的街道显得古韵十足。</p>\n</li>\n<li><p>前几日我们便定了中秋相聚游玩之地，本是准备花个大价钱去重庆探一探辣妹底子，可还是奈不住干瘪的钱袋子，于是便定了去杭州。计划是先去杭州再去横店玩耍，若时间有余，还可去我家静坐一番，亲自入园采摘葡萄也是极好（浙江浦江巨峰葡萄远近闻名，我家尚有几亩，养老足矣）。</p>\n</li>\n</ul>\n<hr>\n<p>平日主还是务实基础，提升自我价值。</p>\n<p>以上便是八月之总结。写于 戊戌年 狗年 庚申月 戊戌日。抗战胜利日。</p>\n"},{"title":"科幻十月（2018）","date":"2018-10-29T07:46:12.000Z","_content":"\n> 近些日子里差不多都在看《三体》，专业书籍都抛到脑后了，甚是着迷。\n\n《三体》中每本序言都说了“基石”二字。刘慈欣先生真是可谓中国科幻届领军人物！其脑洞之大，学术之广，思维之严谨。书中大量出现了数学、物理等知识，众多专业术语，还将中外古今大多名人汇聚一起，展开“搏斗”，来回穿梭于时光长廊。\n\n这几周每每到了周末，我便早上泡了杯麦片弄了点简易早餐（就是搞了个手抓饼），吃完躺床上稍稍休整便开始动手收拾《三体》世界，奔向不远的城建职业学院中去。到了那差不多十一点半，便顺道去了其食堂解决了中午伙食，这学校看上去有点年代的样子，环境倒是还不错就是人不多。吃完我就去图书馆里找了个位置开始翻起来。\n\n当我一开始看的时候我就想起来了前几年看过的那本《天才在左，疯子在右》。其中有个微观故事我印象十分深刻，大致讲的是有个人不停洗澡洗手，洗到脱皮还是要洗，他说要把身上的细菌洗掉，细菌占领了我们，我们的世界其实是在它们的控制之下。是啊，生活中到处都是它们，我们处处被监视，自以为是的我们又怎么会知道它们到底是个什么样的存在。\n\n`自以为历尽沧桑，其实刚蹒跚学步，自以为掌握了竞争的秘密，其实远没有竞争的资格。`\n\n\n- 射手假说：有一名神枪手，在一个靶子上，每隔10cm打出一个洞。设想这个靶子上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：每隔 10cm 单位，必然会有一个洞。 它们把这个神枪手一时兴起的随意行为，看成自己宇宙中的铁律。 \n\n- 农场主假说：一个农场里有一群火鸡，农场主每天上午11点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有出现例外，于是它也发现了自己宇宙中的伟大定律：每天早上 11 点，就有食物降临。 它在感恩节早晨向大家宣布了这个定律，但这天早上 11 点食物没有降临，农场主进来把他们都捉去杀了。\n\n\n`给时光以生命，给岁月以文明。`\n\n...\n\n将人类这种生物剖析得连骨头渣子都不剩，大量反映了人性的情节。我试想，倘若真有朝一日三体人入侵地球，地球上会不会出现**极权只需五秒钟**的情况。不敢想，真的可怕，越想越可怕。我们都是虫子，不敢仰望星空。\n\n看完《三体》后整个人精神状况都不好了，本来就是有点悲观主义思维，现在却像打上了思想烙印，觉得这世界随时都会爆炸。。\n\n---\n\n不过常看看这类书籍对我们还是很有好处的。码农，不就需要思维发散，眼界开阔，炸开世界视角。这能使我们想的更多，头脑更加灵活，逻辑能力自然也就上去了，看得还是很爽的。何况，刘慈欣先生怎么说也算是同行啊，要向先生看齐！\n\n成功者有个特点，他们都具有前沿的思维，能够灵敏地感知未来的变化并能很快去拥抱现实。刘老在 06 年便能在脑中浮现如此气势磅礴的场景，读完作品我真是深深被其折服了。以后的日子里还需要再锻炼触觉，开阔视野，发散思维，并在实际生活中能应用自如，走向成功之路！\n\n**期待三体电影~**\n\n---\n\n今早著名主持人李咏抗癌去世的消息出现在了大众面前，曾经站在台上“我是李咏，我们下期再见！”的声音虽然已经很久没有听到，但也算是从小看着他的节目长大。现在我们长大了，他却不见了。生命真的很脆弱，不由得又想起了《三体》中多次爆发的伤亡场景。\n\n听我姑父说我爷爷是前列腺癌去世的。这种癌症遗传率很高，不知道我会不会中招，惨兮兮。冬眠技术啥时候能普及啊，我要冬眠，我要去未来看看人还是不是人。\n","source":"_posts/science-fiction-october-2018.md","raw":"---\ntitle: 科幻十月（2018）\ndate: 2018-10-29 15:46:12\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 近些日子里差不多都在看《三体》，专业书籍都抛到脑后了，甚是着迷。\n\n《三体》中每本序言都说了“基石”二字。刘慈欣先生真是可谓中国科幻届领军人物！其脑洞之大，学术之广，思维之严谨。书中大量出现了数学、物理等知识，众多专业术语，还将中外古今大多名人汇聚一起，展开“搏斗”，来回穿梭于时光长廊。\n\n这几周每每到了周末，我便早上泡了杯麦片弄了点简易早餐（就是搞了个手抓饼），吃完躺床上稍稍休整便开始动手收拾《三体》世界，奔向不远的城建职业学院中去。到了那差不多十一点半，便顺道去了其食堂解决了中午伙食，这学校看上去有点年代的样子，环境倒是还不错就是人不多。吃完我就去图书馆里找了个位置开始翻起来。\n\n当我一开始看的时候我就想起来了前几年看过的那本《天才在左，疯子在右》。其中有个微观故事我印象十分深刻，大致讲的是有个人不停洗澡洗手，洗到脱皮还是要洗，他说要把身上的细菌洗掉，细菌占领了我们，我们的世界其实是在它们的控制之下。是啊，生活中到处都是它们，我们处处被监视，自以为是的我们又怎么会知道它们到底是个什么样的存在。\n\n`自以为历尽沧桑，其实刚蹒跚学步，自以为掌握了竞争的秘密，其实远没有竞争的资格。`\n\n\n- 射手假说：有一名神枪手，在一个靶子上，每隔10cm打出一个洞。设想这个靶子上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：每隔 10cm 单位，必然会有一个洞。 它们把这个神枪手一时兴起的随意行为，看成自己宇宙中的铁律。 \n\n- 农场主假说：一个农场里有一群火鸡，农场主每天上午11点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有出现例外，于是它也发现了自己宇宙中的伟大定律：每天早上 11 点，就有食物降临。 它在感恩节早晨向大家宣布了这个定律，但这天早上 11 点食物没有降临，农场主进来把他们都捉去杀了。\n\n\n`给时光以生命，给岁月以文明。`\n\n...\n\n将人类这种生物剖析得连骨头渣子都不剩，大量反映了人性的情节。我试想，倘若真有朝一日三体人入侵地球，地球上会不会出现**极权只需五秒钟**的情况。不敢想，真的可怕，越想越可怕。我们都是虫子，不敢仰望星空。\n\n看完《三体》后整个人精神状况都不好了，本来就是有点悲观主义思维，现在却像打上了思想烙印，觉得这世界随时都会爆炸。。\n\n---\n\n不过常看看这类书籍对我们还是很有好处的。码农，不就需要思维发散，眼界开阔，炸开世界视角。这能使我们想的更多，头脑更加灵活，逻辑能力自然也就上去了，看得还是很爽的。何况，刘慈欣先生怎么说也算是同行啊，要向先生看齐！\n\n成功者有个特点，他们都具有前沿的思维，能够灵敏地感知未来的变化并能很快去拥抱现实。刘老在 06 年便能在脑中浮现如此气势磅礴的场景，读完作品我真是深深被其折服了。以后的日子里还需要再锻炼触觉，开阔视野，发散思维，并在实际生活中能应用自如，走向成功之路！\n\n**期待三体电影~**\n\n---\n\n今早著名主持人李咏抗癌去世的消息出现在了大众面前，曾经站在台上“我是李咏，我们下期再见！”的声音虽然已经很久没有听到，但也算是从小看着他的节目长大。现在我们长大了，他却不见了。生命真的很脆弱，不由得又想起了《三体》中多次爆发的伤亡场景。\n\n听我姑父说我爷爷是前列腺癌去世的。这种癌症遗传率很高，不知道我会不会中招，惨兮兮。冬眠技术啥时候能普及啊，我要冬眠，我要去未来看看人还是不是人。\n","slug":"science-fiction-october-2018","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjho00a9k9i1a822gowl","content":"<blockquote>\n<p>近些日子里差不多都在看《三体》，专业书籍都抛到脑后了，甚是着迷。</p>\n</blockquote>\n<p>《三体》中每本序言都说了“基石”二字。刘慈欣先生真是可谓中国科幻届领军人物！其脑洞之大，学术之广，思维之严谨。书中大量出现了数学、物理等知识，众多专业术语，还将中外古今大多名人汇聚一起，展开“搏斗”，来回穿梭于时光长廊。</p>\n<p>这几周每每到了周末，我便早上泡了杯麦片弄了点简易早餐（就是搞了个手抓饼），吃完躺床上稍稍休整便开始动手收拾《三体》世界，奔向不远的城建职业学院中去。到了那差不多十一点半，便顺道去了其食堂解决了中午伙食，这学校看上去有点年代的样子，环境倒是还不错就是人不多。吃完我就去图书馆里找了个位置开始翻起来。</p>\n<p>当我一开始看的时候我就想起来了前几年看过的那本《天才在左，疯子在右》。其中有个微观故事我印象十分深刻，大致讲的是有个人不停洗澡洗手，洗到脱皮还是要洗，他说要把身上的细菌洗掉，细菌占领了我们，我们的世界其实是在它们的控制之下。是啊，生活中到处都是它们，我们处处被监视，自以为是的我们又怎么会知道它们到底是个什么样的存在。</p>\n<p><code>自以为历尽沧桑，其实刚蹒跚学步，自以为掌握了竞争的秘密，其实远没有竞争的资格。</code></p>\n<ul>\n<li><p>射手假说：有一名神枪手，在一个靶子上，每隔10cm打出一个洞。设想这个靶子上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：每隔 10cm 单位，必然会有一个洞。 它们把这个神枪手一时兴起的随意行为，看成自己宇宙中的铁律。 </p>\n</li>\n<li><p>农场主假说：一个农场里有一群火鸡，农场主每天上午11点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有出现例外，于是它也发现了自己宇宙中的伟大定律：每天早上 11 点，就有食物降临。 它在感恩节早晨向大家宣布了这个定律，但这天早上 11 点食物没有降临，农场主进来把他们都捉去杀了。</p>\n</li>\n</ul>\n<p><code>给时光以生命，给岁月以文明。</code></p>\n<p>…</p>\n<p>将人类这种生物剖析得连骨头渣子都不剩，大量反映了人性的情节。我试想，倘若真有朝一日三体人入侵地球，地球上会不会出现<strong>极权只需五秒钟</strong>的情况。不敢想，真的可怕，越想越可怕。我们都是虫子，不敢仰望星空。</p>\n<p>看完《三体》后整个人精神状况都不好了，本来就是有点悲观主义思维，现在却像打上了思想烙印，觉得这世界随时都会爆炸。。</p>\n<hr>\n<p>不过常看看这类书籍对我们还是很有好处的。码农，不就需要思维发散，眼界开阔，炸开世界视角。这能使我们想的更多，头脑更加灵活，逻辑能力自然也就上去了，看得还是很爽的。何况，刘慈欣先生怎么说也算是同行啊，要向先生看齐！</p>\n<p>成功者有个特点，他们都具有前沿的思维，能够灵敏地感知未来的变化并能很快去拥抱现实。刘老在 06 年便能在脑中浮现如此气势磅礴的场景，读完作品我真是深深被其折服了。以后的日子里还需要再锻炼触觉，开阔视野，发散思维，并在实际生活中能应用自如，走向成功之路！</p>\n<p><strong>期待三体电影~</strong></p>\n<hr>\n<p>今早著名主持人李咏抗癌去世的消息出现在了大众面前，曾经站在台上“我是李咏，我们下期再见！”的声音虽然已经很久没有听到，但也算是从小看着他的节目长大。现在我们长大了，他却不见了。生命真的很脆弱，不由得又想起了《三体》中多次爆发的伤亡场景。</p>\n<p>听我姑父说我爷爷是前列腺癌去世的。这种癌症遗传率很高，不知道我会不会中招，惨兮兮。冬眠技术啥时候能普及啊，我要冬眠，我要去未来看看人还是不是人。</p>\n","excerpt":"","more":"<blockquote>\n<p>近些日子里差不多都在看《三体》，专业书籍都抛到脑后了，甚是着迷。</p>\n</blockquote>\n<p>《三体》中每本序言都说了“基石”二字。刘慈欣先生真是可谓中国科幻届领军人物！其脑洞之大，学术之广，思维之严谨。书中大量出现了数学、物理等知识，众多专业术语，还将中外古今大多名人汇聚一起，展开“搏斗”，来回穿梭于时光长廊。</p>\n<p>这几周每每到了周末，我便早上泡了杯麦片弄了点简易早餐（就是搞了个手抓饼），吃完躺床上稍稍休整便开始动手收拾《三体》世界，奔向不远的城建职业学院中去。到了那差不多十一点半，便顺道去了其食堂解决了中午伙食，这学校看上去有点年代的样子，环境倒是还不错就是人不多。吃完我就去图书馆里找了个位置开始翻起来。</p>\n<p>当我一开始看的时候我就想起来了前几年看过的那本《天才在左，疯子在右》。其中有个微观故事我印象十分深刻，大致讲的是有个人不停洗澡洗手，洗到脱皮还是要洗，他说要把身上的细菌洗掉，细菌占领了我们，我们的世界其实是在它们的控制之下。是啊，生活中到处都是它们，我们处处被监视，自以为是的我们又怎么会知道它们到底是个什么样的存在。</p>\n<p><code>自以为历尽沧桑，其实刚蹒跚学步，自以为掌握了竞争的秘密，其实远没有竞争的资格。</code></p>\n<ul>\n<li><p>射手假说：有一名神枪手，在一个靶子上，每隔10cm打出一个洞。设想这个靶子上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律：每隔 10cm 单位，必然会有一个洞。 它们把这个神枪手一时兴起的随意行为，看成自己宇宙中的铁律。 </p>\n</li>\n<li><p>农场主假说：一个农场里有一群火鸡，农场主每天上午11点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有出现例外，于是它也发现了自己宇宙中的伟大定律：每天早上 11 点，就有食物降临。 它在感恩节早晨向大家宣布了这个定律，但这天早上 11 点食物没有降临，农场主进来把他们都捉去杀了。</p>\n</li>\n</ul>\n<p><code>给时光以生命，给岁月以文明。</code></p>\n<p>…</p>\n<p>将人类这种生物剖析得连骨头渣子都不剩，大量反映了人性的情节。我试想，倘若真有朝一日三体人入侵地球，地球上会不会出现<strong>极权只需五秒钟</strong>的情况。不敢想，真的可怕，越想越可怕。我们都是虫子，不敢仰望星空。</p>\n<p>看完《三体》后整个人精神状况都不好了，本来就是有点悲观主义思维，现在却像打上了思想烙印，觉得这世界随时都会爆炸。。</p>\n<hr>\n<p>不过常看看这类书籍对我们还是很有好处的。码农，不就需要思维发散，眼界开阔，炸开世界视角。这能使我们想的更多，头脑更加灵活，逻辑能力自然也就上去了，看得还是很爽的。何况，刘慈欣先生怎么说也算是同行啊，要向先生看齐！</p>\n<p>成功者有个特点，他们都具有前沿的思维，能够灵敏地感知未来的变化并能很快去拥抱现实。刘老在 06 年便能在脑中浮现如此气势磅礴的场景，读完作品我真是深深被其折服了。以后的日子里还需要再锻炼触觉，开阔视野，发散思维，并在实际生活中能应用自如，走向成功之路！</p>\n<p><strong>期待三体电影~</strong></p>\n<hr>\n<p>今早著名主持人李咏抗癌去世的消息出现在了大众面前，曾经站在台上“我是李咏，我们下期再见！”的声音虽然已经很久没有听到，但也算是从小看着他的节目长大。现在我们长大了，他却不见了。生命真的很脆弱，不由得又想起了《三体》中多次爆发的伤亡场景。</p>\n<p>听我姑父说我爷爷是前列腺癌去世的。这种癌症遗传率很高，不知道我会不会中招，惨兮兮。冬眠技术啥时候能普及啊，我要冬眠，我要去未来看看人还是不是人。</p>\n"},{"title":"再怎么样也不能废了自己","date":"2018-07-11T02:21:01.000Z","_content":"## 拥有一个自律的生活\n身边有太多的人都因为身体健康而发愁。等到病魔来找你，那就真的晚了，什么都抵不过健康二字。\n\n**把自己的身体精神养好，也是对自己的一种负责，更是对父母的负责。**\n\n这里我就记录一下最近自己的生活状态，再怎么样也不能废了自己。\n\n---\n\n- 早上\n    + 七点一个闹钟，往往过个十分钟才动身起床，也就是七点十分左右（工作日）\n    + 起床烧一壶开水，泡一杯燕麦，拉几个拉力绳\n    + 上厕所，洗脸，刷牙\n    + 偶尔做个手抓饼（自己网上买的食材）\n    + 打开电脑，编辑一篇情爱的诗词丢上公众号（自娱自乐）\n    + 给龟崽子喂点吃的（鱼干、虾干、面包虫...）\n    + 自己吃个面包，喝了那杯燕麦，再拉几个拉力绳，准备出门上班\n    + 周末的话早上可能起得迟一点，起床后就打开电脑看看电影玩玩游戏\n\n- 上班\n    + 上班找小黄车，距离上班地点6公里左右，骑车半小时\n    + 由于地铁站距离比较远，加上最近需要减脂就还是骑车最舒服了（常年坐工位体脂率高）\n    + 中午公司包餐，伙食一般般，吃的也不多，所以有时候需要下午自己补给一下\n    + 朝九晚六，基本上七点能回家，当然也是骑车回去\n\n- 晚上\n    + 下班骑车回去，基本上两三天要去菜市场补点货\n    + 鸡胸肉、黄瓜、胡萝卜、西红柿、生菜...\n    + 周二、四、六晚上我会选择去跑步，一般都是环形，一起算上5公里吧也不多\n    + 不跑步的时候会躺床上先看个电影，练练口琴或者练练pop\n    + 运动回去缓一缓，拉几个拉力绳，准备动手自己做鸡胸晚餐了\n    + 基本上全部弄完要将近九点了，再休息休息洗个澡\n    + 最近晚上有球赛的话我会用投影看球赛，没有的话就趴在床上自己看看书，犯困就睡觉\n    + 睡眠质量不太好，所以基本睡觉都比较晚，我知道这对身体很不利，最近也在慢慢改\n\n- 周末\n    + 周末的话稍微就自由放松一点，平时没睡够的觉可以补一补\n    + 上周发现附近有个学校，去那边操场跑了跑\n    + 准备周末带着书去那边的图书馆泡着，晚上还可以顺带跑跑步\n\n---\n\n总是在你回头的时候才会感慨时间流逝得快。\n\n有一句话我一直忘不了：\n**学习和健身是两种最便宜而有效的改变人的方式**。\n\n**再怎么样，我们也不能废了自己。保持自律。**\n\n","source":"_posts/self-regulation.md","raw":"---\ntitle: 再怎么样也不能废了自己\ndate: 2018-7-11 10:21:01\ncategories: [生活,杂侃]\ntags: [自律]\n---\n## 拥有一个自律的生活\n身边有太多的人都因为身体健康而发愁。等到病魔来找你，那就真的晚了，什么都抵不过健康二字。\n\n**把自己的身体精神养好，也是对自己的一种负责，更是对父母的负责。**\n\n这里我就记录一下最近自己的生活状态，再怎么样也不能废了自己。\n\n---\n\n- 早上\n    + 七点一个闹钟，往往过个十分钟才动身起床，也就是七点十分左右（工作日）\n    + 起床烧一壶开水，泡一杯燕麦，拉几个拉力绳\n    + 上厕所，洗脸，刷牙\n    + 偶尔做个手抓饼（自己网上买的食材）\n    + 打开电脑，编辑一篇情爱的诗词丢上公众号（自娱自乐）\n    + 给龟崽子喂点吃的（鱼干、虾干、面包虫...）\n    + 自己吃个面包，喝了那杯燕麦，再拉几个拉力绳，准备出门上班\n    + 周末的话早上可能起得迟一点，起床后就打开电脑看看电影玩玩游戏\n\n- 上班\n    + 上班找小黄车，距离上班地点6公里左右，骑车半小时\n    + 由于地铁站距离比较远，加上最近需要减脂就还是骑车最舒服了（常年坐工位体脂率高）\n    + 中午公司包餐，伙食一般般，吃的也不多，所以有时候需要下午自己补给一下\n    + 朝九晚六，基本上七点能回家，当然也是骑车回去\n\n- 晚上\n    + 下班骑车回去，基本上两三天要去菜市场补点货\n    + 鸡胸肉、黄瓜、胡萝卜、西红柿、生菜...\n    + 周二、四、六晚上我会选择去跑步，一般都是环形，一起算上5公里吧也不多\n    + 不跑步的时候会躺床上先看个电影，练练口琴或者练练pop\n    + 运动回去缓一缓，拉几个拉力绳，准备动手自己做鸡胸晚餐了\n    + 基本上全部弄完要将近九点了，再休息休息洗个澡\n    + 最近晚上有球赛的话我会用投影看球赛，没有的话就趴在床上自己看看书，犯困就睡觉\n    + 睡眠质量不太好，所以基本睡觉都比较晚，我知道这对身体很不利，最近也在慢慢改\n\n- 周末\n    + 周末的话稍微就自由放松一点，平时没睡够的觉可以补一补\n    + 上周发现附近有个学校，去那边操场跑了跑\n    + 准备周末带着书去那边的图书馆泡着，晚上还可以顺带跑跑步\n\n---\n\n总是在你回头的时候才会感慨时间流逝得快。\n\n有一句话我一直忘不了：\n**学习和健身是两种最便宜而有效的改变人的方式**。\n\n**再怎么样，我们也不能废了自己。保持自律。**\n\n","slug":"self-regulation","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjho00adk9i17kwrh0ch","content":"<h2 id=\"拥有一个自律的生活\"><a href=\"#拥有一个自律的生活\" class=\"headerlink\" title=\"拥有一个自律的生活\"></a>拥有一个自律的生活</h2><p>身边有太多的人都因为身体健康而发愁。等到病魔来找你，那就真的晚了，什么都抵不过健康二字。</p>\n<p><strong>把自己的身体精神养好，也是对自己的一种负责，更是对父母的负责。</strong></p>\n<p>这里我就记录一下最近自己的生活状态，再怎么样也不能废了自己。</p>\n<hr>\n<ul>\n<li><p>早上</p>\n<ul>\n<li>七点一个闹钟，往往过个十分钟才动身起床，也就是七点十分左右（工作日）</li>\n<li>起床烧一壶开水，泡一杯燕麦，拉几个拉力绳</li>\n<li>上厕所，洗脸，刷牙</li>\n<li>偶尔做个手抓饼（自己网上买的食材）</li>\n<li>打开电脑，编辑一篇情爱的诗词丢上公众号（自娱自乐）</li>\n<li>给龟崽子喂点吃的（鱼干、虾干、面包虫…）</li>\n<li>自己吃个面包，喝了那杯燕麦，再拉几个拉力绳，准备出门上班</li>\n<li>周末的话早上可能起得迟一点，起床后就打开电脑看看电影玩玩游戏</li>\n</ul>\n</li>\n<li><p>上班</p>\n<ul>\n<li>上班找小黄车，距离上班地点6公里左右，骑车半小时</li>\n<li>由于地铁站距离比较远，加上最近需要减脂就还是骑车最舒服了（常年坐工位体脂率高）</li>\n<li>中午公司包餐，伙食一般般，吃的也不多，所以有时候需要下午自己补给一下</li>\n<li>朝九晚六，基本上七点能回家，当然也是骑车回去</li>\n</ul>\n</li>\n<li><p>晚上</p>\n<ul>\n<li>下班骑车回去，基本上两三天要去菜市场补点货</li>\n<li>鸡胸肉、黄瓜、胡萝卜、西红柿、生菜…</li>\n<li>周二、四、六晚上我会选择去跑步，一般都是环形，一起算上5公里吧也不多</li>\n<li>不跑步的时候会躺床上先看个电影，练练口琴或者练练pop</li>\n<li>运动回去缓一缓，拉几个拉力绳，准备动手自己做鸡胸晚餐了</li>\n<li>基本上全部弄完要将近九点了，再休息休息洗个澡</li>\n<li>最近晚上有球赛的话我会用投影看球赛，没有的话就趴在床上自己看看书，犯困就睡觉</li>\n<li>睡眠质量不太好，所以基本睡觉都比较晚，我知道这对身体很不利，最近也在慢慢改</li>\n</ul>\n</li>\n<li><p>周末</p>\n<ul>\n<li>周末的话稍微就自由放松一点，平时没睡够的觉可以补一补</li>\n<li>上周发现附近有个学校，去那边操场跑了跑</li>\n<li>准备周末带着书去那边的图书馆泡着，晚上还可以顺带跑跑步</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>总是在你回头的时候才会感慨时间流逝得快。</p>\n<p>有一句话我一直忘不了：<br><strong>学习和健身是两种最便宜而有效的改变人的方式</strong>。</p>\n<p><strong>再怎么样，我们也不能废了自己。保持自律。</strong></p>\n","excerpt":"","more":"<h2 id=\"拥有一个自律的生活\"><a href=\"#拥有一个自律的生活\" class=\"headerlink\" title=\"拥有一个自律的生活\"></a>拥有一个自律的生活</h2><p>身边有太多的人都因为身体健康而发愁。等到病魔来找你，那就真的晚了，什么都抵不过健康二字。</p>\n<p><strong>把自己的身体精神养好，也是对自己的一种负责，更是对父母的负责。</strong></p>\n<p>这里我就记录一下最近自己的生活状态，再怎么样也不能废了自己。</p>\n<hr>\n<ul>\n<li><p>早上</p>\n<ul>\n<li>七点一个闹钟，往往过个十分钟才动身起床，也就是七点十分左右（工作日）</li>\n<li>起床烧一壶开水，泡一杯燕麦，拉几个拉力绳</li>\n<li>上厕所，洗脸，刷牙</li>\n<li>偶尔做个手抓饼（自己网上买的食材）</li>\n<li>打开电脑，编辑一篇情爱的诗词丢上公众号（自娱自乐）</li>\n<li>给龟崽子喂点吃的（鱼干、虾干、面包虫…）</li>\n<li>自己吃个面包，喝了那杯燕麦，再拉几个拉力绳，准备出门上班</li>\n<li>周末的话早上可能起得迟一点，起床后就打开电脑看看电影玩玩游戏</li>\n</ul>\n</li>\n<li><p>上班</p>\n<ul>\n<li>上班找小黄车，距离上班地点6公里左右，骑车半小时</li>\n<li>由于地铁站距离比较远，加上最近需要减脂就还是骑车最舒服了（常年坐工位体脂率高）</li>\n<li>中午公司包餐，伙食一般般，吃的也不多，所以有时候需要下午自己补给一下</li>\n<li>朝九晚六，基本上七点能回家，当然也是骑车回去</li>\n</ul>\n</li>\n<li><p>晚上</p>\n<ul>\n<li>下班骑车回去，基本上两三天要去菜市场补点货</li>\n<li>鸡胸肉、黄瓜、胡萝卜、西红柿、生菜…</li>\n<li>周二、四、六晚上我会选择去跑步，一般都是环形，一起算上5公里吧也不多</li>\n<li>不跑步的时候会躺床上先看个电影，练练口琴或者练练pop</li>\n<li>运动回去缓一缓，拉几个拉力绳，准备动手自己做鸡胸晚餐了</li>\n<li>基本上全部弄完要将近九点了，再休息休息洗个澡</li>\n<li>最近晚上有球赛的话我会用投影看球赛，没有的话就趴在床上自己看看书，犯困就睡觉</li>\n<li>睡眠质量不太好，所以基本睡觉都比较晚，我知道这对身体很不利，最近也在慢慢改</li>\n</ul>\n</li>\n<li><p>周末</p>\n<ul>\n<li>周末的话稍微就自由放松一点，平时没睡够的觉可以补一补</li>\n<li>上周发现附近有个学校，去那边操场跑了跑</li>\n<li>准备周末带着书去那边的图书馆泡着，晚上还可以顺带跑跑步</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>总是在你回头的时候才会感慨时间流逝得快。</p>\n<p>有一句话我一直忘不了：<br><strong>学习和健身是两种最便宜而有效的改变人的方式</strong>。</p>\n<p><strong>再怎么样，我们也不能废了自己。保持自律。</strong></p>\n"},{"title":"Shell 脚本定时重启项目","date":"2020-11-29T09:10:55.000Z","_content":"\n> 是时候解放双手了。\n\n## 前言\n自己很早之前就买了一台阿里云服务器，当时新用户买的时候很便宜后来每年续费简直贵得离谱。要不是我已经装了很多东西，还有我的懒（换服务器还需要重新配置和备案）。当然这跟我下面要说的关系不是很大。\n\n我一直以来用这服务器只是为了挂自己的博客和几个很早之前练手的小项目，结果发现这破服务器总是会把我的项目进程给干掉，等我偶尔访问的时候发现早已经打不开小网站了，相当郁闷。\n\n终于，今天我实在是忍不了了。\n\n## 解决方案\n想了想，最简单的解决方案就是我写个定时脚本去定时重启项目。这下我管你正不正常，直接给你重启了。通过网上资料的搜集和我自己的测试，不一会就搞定了，问题不大（以前也就懒，早应该弄了）。\n\n实现脚本具体如下：\n\n```\n#!/bin/bash\n\necho \"===start===\"\ntt=$(date \"+%Y-%m-%d %H:%M:%S\")\necho $tt\n\n# kill\nfaceshow_pid=$(ps -ef | grep 'faceshow.jar' | grep -v grep |  awk '{print $2}')\nif [ -z $faceshow_pid ] ;then\n    echo \"faceshow not exist\"\nelse\n    echo \"faceshow_pid: $faceshow_pid\"\n    kill -9 ${faceshow_pid}\n    echo \"faceshow killed\"\nfi\nmishow_pid=$(ps -ef | grep 'mishow.jar' | grep -v grep | awk '{print $2}')\nif [ -z $mishow_pid ] ;then\n    echo \"mishow not exist\"\nelse\n    echo \"mishow_pid: $mishow_pid\"\n    kill -9 ${mishow_pid}\n    echo \"mishow killed\"\nfi\n\n# start\nnohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/faceshow.jar >/usr/local/jar/log/faceshow.log 2>&1 &\necho \"faceshow restarted\"\n\nnohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/mishow.jar >/usr/local/jar/log/mishow.log 2>&1 &\necho \"mishow restarted\"\n\necho \"===end===\"\n\n```\n\n当然还有很多可以简洁的地方，可以慢慢搞。\n\n**说明点：**\n\n-  `$(date \"+%Y-%m-%d %H:%M:%S\")` 格式化当前时间 如：2020-11-29 16:45:01\n- `grep -v grep` 过滤 `grep` 自身进程\n- 空格该有的有，不该有的不要有\n- 执行脚本内指定需要写全路径，不然可能会报错找不到某某指令\n\n> 脚本写好后 用 [crontab ](https://www.runoob.com/linux/linux-comm-crontab.html) 定时执行就可以了。\n\n## 最后\n脚本还是很重要的，平时绝大多数事情脚本都可以帮我们实现，科技不就是脚本实现化吗。","source":"_posts/shell-restart.md","raw":"---\ntitle: Shell 脚本定时重启项目\ndate: 2020-11-29 17:10:55\ncategories: [开发,运维]\ntags: [Shell]\n---\n\n> 是时候解放双手了。\n\n## 前言\n自己很早之前就买了一台阿里云服务器，当时新用户买的时候很便宜后来每年续费简直贵得离谱。要不是我已经装了很多东西，还有我的懒（换服务器还需要重新配置和备案）。当然这跟我下面要说的关系不是很大。\n\n我一直以来用这服务器只是为了挂自己的博客和几个很早之前练手的小项目，结果发现这破服务器总是会把我的项目进程给干掉，等我偶尔访问的时候发现早已经打不开小网站了，相当郁闷。\n\n终于，今天我实在是忍不了了。\n\n## 解决方案\n想了想，最简单的解决方案就是我写个定时脚本去定时重启项目。这下我管你正不正常，直接给你重启了。通过网上资料的搜集和我自己的测试，不一会就搞定了，问题不大（以前也就懒，早应该弄了）。\n\n实现脚本具体如下：\n\n```\n#!/bin/bash\n\necho \"===start===\"\ntt=$(date \"+%Y-%m-%d %H:%M:%S\")\necho $tt\n\n# kill\nfaceshow_pid=$(ps -ef | grep 'faceshow.jar' | grep -v grep |  awk '{print $2}')\nif [ -z $faceshow_pid ] ;then\n    echo \"faceshow not exist\"\nelse\n    echo \"faceshow_pid: $faceshow_pid\"\n    kill -9 ${faceshow_pid}\n    echo \"faceshow killed\"\nfi\nmishow_pid=$(ps -ef | grep 'mishow.jar' | grep -v grep | awk '{print $2}')\nif [ -z $mishow_pid ] ;then\n    echo \"mishow not exist\"\nelse\n    echo \"mishow_pid: $mishow_pid\"\n    kill -9 ${mishow_pid}\n    echo \"mishow killed\"\nfi\n\n# start\nnohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/faceshow.jar >/usr/local/jar/log/faceshow.log 2>&1 &\necho \"faceshow restarted\"\n\nnohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/mishow.jar >/usr/local/jar/log/mishow.log 2>&1 &\necho \"mishow restarted\"\n\necho \"===end===\"\n\n```\n\n当然还有很多可以简洁的地方，可以慢慢搞。\n\n**说明点：**\n\n-  `$(date \"+%Y-%m-%d %H:%M:%S\")` 格式化当前时间 如：2020-11-29 16:45:01\n- `grep -v grep` 过滤 `grep` 自身进程\n- 空格该有的有，不该有的不要有\n- 执行脚本内指定需要写全路径，不然可能会报错找不到某某指令\n\n> 脚本写好后 用 [crontab ](https://www.runoob.com/linux/linux-comm-crontab.html) 定时执行就可以了。\n\n## 最后\n脚本还是很重要的，平时绝大多数事情脚本都可以帮我们实现，科技不就是脚本实现化吗。","slug":"shell-restart","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjho00ahk9i17uymezbk","content":"<blockquote>\n<p>是时候解放双手了。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>自己很早之前就买了一台阿里云服务器，当时新用户买的时候很便宜后来每年续费简直贵得离谱。要不是我已经装了很多东西，还有我的懒（换服务器还需要重新配置和备案）。当然这跟我下面要说的关系不是很大。</p>\n<p>我一直以来用这服务器只是为了挂自己的博客和几个很早之前练手的小项目，结果发现这破服务器总是会把我的项目进程给干掉，等我偶尔访问的时候发现早已经打不开小网站了，相当郁闷。</p>\n<p>终于，今天我实在是忍不了了。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>想了想，最简单的解决方案就是我写个定时脚本去定时重启项目。这下我管你正不正常，直接给你重启了。通过网上资料的搜集和我自己的测试，不一会就搞定了，问题不大（以前也就懒，早应该弄了）。</p>\n<p>实现脚本具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;===start===&quot;</span><br><span class=\"line\">tt=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class=\"line\">echo $tt</span><br><span class=\"line\"></span><br><span class=\"line\"># kill</span><br><span class=\"line\">faceshow_pid=$(ps -ef | grep &#x27;faceshow.jar&#x27; | grep -v grep |  awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\">if [ -z $faceshow_pid ] ;then</span><br><span class=\"line\">    echo &quot;faceshow not exist&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;faceshow_pid: $faceshow_pid&quot;</span><br><span class=\"line\">    kill -9 $&#123;faceshow_pid&#125;</span><br><span class=\"line\">    echo &quot;faceshow killed&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">mishow_pid=$(ps -ef | grep &#x27;mishow.jar&#x27; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\">if [ -z $mishow_pid ] ;then</span><br><span class=\"line\">    echo &quot;mishow not exist&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;mishow_pid: $mishow_pid&quot;</span><br><span class=\"line\">    kill -9 $&#123;mishow_pid&#125;</span><br><span class=\"line\">    echo &quot;mishow killed&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\"># start</span><br><span class=\"line\">nohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/faceshow.jar &gt;/usr/local/jar/log/faceshow.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo &quot;faceshow restarted&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">nohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/mishow.jar &gt;/usr/local/jar/log/mishow.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo &quot;mishow restarted&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;===end===&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当然还有很多可以简洁的地方，可以慢慢搞。</p>\n<p><strong>说明点：</strong></p>\n<ul>\n<li><code>$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</code> 格式化当前时间 如：2020-11-29 16:45:01</li>\n<li><code>grep -v grep</code> 过滤 <code>grep</code> 自身进程</li>\n<li>空格该有的有，不该有的不要有</li>\n<li>执行脚本内指定需要写全路径，不然可能会报错找不到某某指令</li>\n</ul>\n<blockquote>\n<p>脚本写好后 用 <a href=\"https://www.runoob.com/linux/linux-comm-crontab.html\">crontab </a> 定时执行就可以了。</p>\n</blockquote>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>脚本还是很重要的，平时绝大多数事情脚本都可以帮我们实现，科技不就是脚本实现化吗。</p>\n","excerpt":"","more":"<blockquote>\n<p>是时候解放双手了。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>自己很早之前就买了一台阿里云服务器，当时新用户买的时候很便宜后来每年续费简直贵得离谱。要不是我已经装了很多东西，还有我的懒（换服务器还需要重新配置和备案）。当然这跟我下面要说的关系不是很大。</p>\n<p>我一直以来用这服务器只是为了挂自己的博客和几个很早之前练手的小项目，结果发现这破服务器总是会把我的项目进程给干掉，等我偶尔访问的时候发现早已经打不开小网站了，相当郁闷。</p>\n<p>终于，今天我实在是忍不了了。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>想了想，最简单的解决方案就是我写个定时脚本去定时重启项目。这下我管你正不正常，直接给你重启了。通过网上资料的搜集和我自己的测试，不一会就搞定了，问题不大（以前也就懒，早应该弄了）。</p>\n<p>实现脚本具体如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;===start===&quot;</span><br><span class=\"line\">tt=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class=\"line\">echo $tt</span><br><span class=\"line\"></span><br><span class=\"line\"># kill</span><br><span class=\"line\">faceshow_pid=$(ps -ef | grep &#x27;faceshow.jar&#x27; | grep -v grep |  awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\">if [ -z $faceshow_pid ] ;then</span><br><span class=\"line\">    echo &quot;faceshow not exist&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;faceshow_pid: $faceshow_pid&quot;</span><br><span class=\"line\">    kill -9 $&#123;faceshow_pid&#125;</span><br><span class=\"line\">    echo &quot;faceshow killed&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\">mishow_pid=$(ps -ef | grep &#x27;mishow.jar&#x27; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class=\"line\">if [ -z $mishow_pid ] ;then</span><br><span class=\"line\">    echo &quot;mishow not exist&quot;</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo &quot;mishow_pid: $mishow_pid&quot;</span><br><span class=\"line\">    kill -9 $&#123;mishow_pid&#125;</span><br><span class=\"line\">    echo &quot;mishow killed&quot;</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\"># start</span><br><span class=\"line\">nohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/faceshow.jar &gt;/usr/local/jar/log/faceshow.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo &quot;faceshow restarted&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">nohup /usr/local/java/jdk1.8.0_171/bin/java -jar /usr/local/jar/mishow.jar &gt;/usr/local/jar/log/mishow.log 2&gt;&amp;1 &amp;</span><br><span class=\"line\">echo &quot;mishow restarted&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;===end===&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当然还有很多可以简洁的地方，可以慢慢搞。</p>\n<p><strong>说明点：</strong></p>\n<ul>\n<li><code>$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</code> 格式化当前时间 如：2020-11-29 16:45:01</li>\n<li><code>grep -v grep</code> 过滤 <code>grep</code> 自身进程</li>\n<li>空格该有的有，不该有的不要有</li>\n<li>执行脚本内指定需要写全路径，不然可能会报错找不到某某指令</li>\n</ul>\n<blockquote>\n<p>脚本写好后 用 <a href=\"https://www.runoob.com/linux/linux-comm-crontab.html\">crontab </a> 定时执行就可以了。</p>\n</blockquote>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>脚本还是很重要的，平时绝大多数事情脚本都可以帮我们实现，科技不就是脚本实现化吗。</p>\n"},{"title":"常用排序算法","date":"2018-08-10T01:21:51.000Z","_content":"\n在这里做个记录，将常用的三大排序算法列出来，方便查看复习，算法主要是理清思路，最近在刷leetcode发现自己脑子是有点笨的。 For Java.\n\n---\n\n## 冒泡排序\n冒泡是我觉得最简单的一个排序算法了，也是我记的最早的一个排序算法。\n\n**冒泡，顾名思义，泡泡往上冒，也就是每次都将最大值放在末尾，剩余值继续冒泡。**\n\n其时间复杂度为O（n²）。详解：[冒泡排序](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin)\n\n`参考代码：`\n```\n    /**\n     * 冒泡排序\n     * \n     * @param arr\n     * @return\n     */\n    public static int[] MPSort(int[] arr) {\n        // 外循环一次就将最大的值放最后\n        for (int i = 1; i < arr.length; i++) {\n            // 内循环剩余值比较 找出最大值\n            for (int j = 0; j < arr.length - i; j++) {\n                // 比较 满足条件互换\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        return arr;\n\n    }\n```\n\n## 插入排序\n\n插入排序也是比较好理解的一个排序算法，别看这名字挺粗鲁的，其实它还就那么回事。\n\n**插入排序，挨个遍历，发现比前数值还要小的数就把该数前移比较并换值，直到满足的位置为止。**\n\n是挺粗鲁的一个算法，不过这很直接，我喜欢。其时间复杂度为O（n²）。详解：[插入排序](https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)\n\n`参考代码：`\n```\n    /**\n     * 插入排序\n     * \n     * @param arr\n     * @return\n     */\n    public static int[] insertSort(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n        // j = ++i 保证了i和j两个数一样\n        for (int i = 0, j = i; i < arr.length - 1; j = ++i) {\n            int num = arr[i + 1];\n            // 有较小值就前移并换值\n            while (arr[j] > num) {\n                arr[j + 1] = arr[j];\n                // 使下标递减去比较\n                if (j-- == 0) {\n                    break;\n                }\n            }\n            // 较小值新赋值\n            arr[j + 1] = num;\n\n        }\n        return arr;\n    }\n```\n\n## 快速排序\n\n快排就是比较经典了，快排是对冒泡的一种改进，由C. A. R. Hoare在1962年提出。\n\n**它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。**\n\n详解：[快速排序](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)\n\n`参考代码：`\n```\n    /**\n     * 快速排序\n     * \n     * @param arr\n     * @param lo\n     * @param hi\n     * @return\n     */\n    public static int[] quickSort(int[] arr, int lo, int hi) {\n        if (lo >= hi)\n            return arr;\n        int num = partition(arr, lo, hi);\n        quickSort(arr, lo, num - 1);\n        quickSort(arr, num + 1, hi);\n        return arr;\n    }\n\n    /**\n     * 排序数组 返回基准值\n     * \n     * @param arr\n     * @param lo\n     * @param hi\n     * @return\n     */\n    public static int partition(int[] arr, int lo, int hi) {\n        int num = arr[lo];\n        if (lo >= hi)\n            return 0;\n        while (lo < hi) {\n            while (hi > lo && arr[hi] >= num) {\n                hi--;\n            }\n            arr[lo] = arr[hi];\n            while (hi > lo && arr[lo] <= num) {\n                lo++;\n            }\n            arr[hi] = arr[lo];\n        }\n        arr[hi] = num;\n        return hi;\n    }\n```\n\n---\n End.","source":"_posts/sort-algorithm.md","raw":"---\ntitle: 常用排序算法\ndate: 2018-8-10 09:21:51\ncategories: [开发,总结]\ntags: [Java,算法]\n---\n\n在这里做个记录，将常用的三大排序算法列出来，方便查看复习，算法主要是理清思路，最近在刷leetcode发现自己脑子是有点笨的。 For Java.\n\n---\n\n## 冒泡排序\n冒泡是我觉得最简单的一个排序算法了，也是我记的最早的一个排序算法。\n\n**冒泡，顾名思义，泡泡往上冒，也就是每次都将最大值放在末尾，剩余值继续冒泡。**\n\n其时间复杂度为O（n²）。详解：[冒泡排序](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin)\n\n`参考代码：`\n```\n    /**\n     * 冒泡排序\n     * \n     * @param arr\n     * @return\n     */\n    public static int[] MPSort(int[] arr) {\n        // 外循环一次就将最大的值放最后\n        for (int i = 1; i < arr.length; i++) {\n            // 内循环剩余值比较 找出最大值\n            for (int j = 0; j < arr.length - i; j++) {\n                // 比较 满足条件互换\n                if (arr[j] > arr[j + 1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        return arr;\n\n    }\n```\n\n## 插入排序\n\n插入排序也是比较好理解的一个排序算法，别看这名字挺粗鲁的，其实它还就那么回事。\n\n**插入排序，挨个遍历，发现比前数值还要小的数就把该数前移比较并换值，直到满足的位置为止。**\n\n是挺粗鲁的一个算法，不过这很直接，我喜欢。其时间复杂度为O（n²）。详解：[插入排序](https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)\n\n`参考代码：`\n```\n    /**\n     * 插入排序\n     * \n     * @param arr\n     * @return\n     */\n    public static int[] insertSort(int[] arr) {\n        System.out.println(Arrays.toString(arr));\n        // j = ++i 保证了i和j两个数一样\n        for (int i = 0, j = i; i < arr.length - 1; j = ++i) {\n            int num = arr[i + 1];\n            // 有较小值就前移并换值\n            while (arr[j] > num) {\n                arr[j + 1] = arr[j];\n                // 使下标递减去比较\n                if (j-- == 0) {\n                    break;\n                }\n            }\n            // 较小值新赋值\n            arr[j + 1] = num;\n\n        }\n        return arr;\n    }\n```\n\n## 快速排序\n\n快排就是比较经典了，快排是对冒泡的一种改进，由C. A. R. Hoare在1962年提出。\n\n**它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。**\n\n详解：[快速排序](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)\n\n`参考代码：`\n```\n    /**\n     * 快速排序\n     * \n     * @param arr\n     * @param lo\n     * @param hi\n     * @return\n     */\n    public static int[] quickSort(int[] arr, int lo, int hi) {\n        if (lo >= hi)\n            return arr;\n        int num = partition(arr, lo, hi);\n        quickSort(arr, lo, num - 1);\n        quickSort(arr, num + 1, hi);\n        return arr;\n    }\n\n    /**\n     * 排序数组 返回基准值\n     * \n     * @param arr\n     * @param lo\n     * @param hi\n     * @return\n     */\n    public static int partition(int[] arr, int lo, int hi) {\n        int num = arr[lo];\n        if (lo >= hi)\n            return 0;\n        while (lo < hi) {\n            while (hi > lo && arr[hi] >= num) {\n                hi--;\n            }\n            arr[lo] = arr[hi];\n            while (hi > lo && arr[lo] <= num) {\n                lo++;\n            }\n            arr[hi] = arr[lo];\n        }\n        arr[hi] = num;\n        return hi;\n    }\n```\n\n---\n End.","slug":"sort-algorithm","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjho00alk9i1502t3ywu","content":"<p>在这里做个记录，将常用的三大排序算法列出来，方便查看复习，算法主要是理清思路，最近在刷leetcode发现自己脑子是有点笨的。 For Java.</p>\n<hr>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡是我觉得最简单的一个排序算法了，也是我记的最早的一个排序算法。</p>\n<p><strong>冒泡，顾名思义，泡泡往上冒，也就是每次都将最大值放在末尾，剩余值继续冒泡。</strong></p>\n<p>其时间复杂度为O（n²）。详解：<a href=\"https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin\">冒泡排序</a></p>\n<p><code>参考代码：</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 冒泡排序</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int[] MPSort(int[] arr) &#123;</span><br><span class=\"line\">    // 外循环一次就将最大的值放最后</span><br><span class=\"line\">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        // 内循环剩余值比较 找出最大值</span><br><span class=\"line\">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class=\"line\">            // 比较 满足条件互换</span><br><span class=\"line\">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class=\"line\">                int temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j + 1];</span><br><span class=\"line\">                arr[j + 1] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序也是比较好理解的一个排序算法，别看这名字挺粗鲁的，其实它还就那么回事。</p>\n<p><strong>插入排序，挨个遍历，发现比前数值还要小的数就把该数前移比较并换值，直到满足的位置为止。</strong></p>\n<p>是挺粗鲁的一个算法，不过这很直接，我喜欢。其时间复杂度为O（n²）。详解：<a href=\"https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序</a></p>\n<p><code>参考代码：</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 插入排序</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int[] insertSort(int[] arr) &#123;</span><br><span class=\"line\">    System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    // j = ++i 保证了i和j两个数一样</span><br><span class=\"line\">    for (int i = 0, j = i; i &lt; arr.length - 1; j = ++i) &#123;</span><br><span class=\"line\">        int num = arr[i + 1];</span><br><span class=\"line\">        // 有较小值就前移并换值</span><br><span class=\"line\">        while (arr[j] &gt; num) &#123;</span><br><span class=\"line\">            arr[j + 1] = arr[j];</span><br><span class=\"line\">            // 使下标递减去比较</span><br><span class=\"line\">            if (j-- == 0) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 较小值新赋值</span><br><span class=\"line\">        arr[j + 1] = num;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快排就是比较经典了，快排是对冒泡的一种改进，由C. A. R. Hoare在1962年提出。</p>\n<p><strong>它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</strong></p>\n<p>详解：<a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\">快速排序</a></p>\n<p><code>参考代码：</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 快速排序</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @param lo</span><br><span class=\"line\"> * @param hi</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int[] quickSort(int[] arr, int lo, int hi) &#123;</span><br><span class=\"line\">    if (lo &gt;= hi)</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    int num = partition(arr, lo, hi);</span><br><span class=\"line\">    quickSort(arr, lo, num - 1);</span><br><span class=\"line\">    quickSort(arr, num + 1, hi);</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 排序数组 返回基准值</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @param lo</span><br><span class=\"line\"> * @param hi</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int partition(int[] arr, int lo, int hi) &#123;</span><br><span class=\"line\">    int num = arr[lo];</span><br><span class=\"line\">    if (lo &gt;= hi)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    while (lo &lt; hi) &#123;</span><br><span class=\"line\">        while (hi &gt; lo &amp;&amp; arr[hi] &gt;= num) &#123;</span><br><span class=\"line\">            hi--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[lo] = arr[hi];</span><br><span class=\"line\">        while (hi &gt; lo &amp;&amp; arr[lo] &lt;= num) &#123;</span><br><span class=\"line\">            lo++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[hi] = arr[lo];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[hi] = num;</span><br><span class=\"line\">    return hi;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p> End.</p>\n","excerpt":"","more":"<p>在这里做个记录，将常用的三大排序算法列出来，方便查看复习，算法主要是理清思路，最近在刷leetcode发现自己脑子是有点笨的。 For Java.</p>\n<hr>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡是我觉得最简单的一个排序算法了，也是我记的最早的一个排序算法。</p>\n<p><strong>冒泡，顾名思义，泡泡往上冒，也就是每次都将最大值放在末尾，剩余值继续冒泡。</strong></p>\n<p>其时间复杂度为O（n²）。详解：<a href=\"https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin\">冒泡排序</a></p>\n<p><code>参考代码：</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 冒泡排序</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int[] MPSort(int[] arr) &#123;</span><br><span class=\"line\">    // 外循环一次就将最大的值放最后</span><br><span class=\"line\">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        // 内循环剩余值比较 找出最大值</span><br><span class=\"line\">        for (int j = 0; j &lt; arr.length - i; j++) &#123;</span><br><span class=\"line\">            // 比较 满足条件互换</span><br><span class=\"line\">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class=\"line\">                int temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j + 1];</span><br><span class=\"line\">                arr[j + 1] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序也是比较好理解的一个排序算法，别看这名字挺粗鲁的，其实它还就那么回事。</p>\n<p><strong>插入排序，挨个遍历，发现比前数值还要小的数就把该数前移比较并换值，直到满足的位置为止。</strong></p>\n<p>是挺粗鲁的一个算法，不过这很直接，我喜欢。其时间复杂度为O（n²）。详解：<a href=\"https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序</a></p>\n<p><code>参考代码：</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 插入排序</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int[] insertSort(int[] arr) &#123;</span><br><span class=\"line\">    System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    // j = ++i 保证了i和j两个数一样</span><br><span class=\"line\">    for (int i = 0, j = i; i &lt; arr.length - 1; j = ++i) &#123;</span><br><span class=\"line\">        int num = arr[i + 1];</span><br><span class=\"line\">        // 有较小值就前移并换值</span><br><span class=\"line\">        while (arr[j] &gt; num) &#123;</span><br><span class=\"line\">            arr[j + 1] = arr[j];</span><br><span class=\"line\">            // 使下标递减去比较</span><br><span class=\"line\">            if (j-- == 0) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 较小值新赋值</span><br><span class=\"line\">        arr[j + 1] = num;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快排就是比较经典了，快排是对冒泡的一种改进，由C. A. R. Hoare在1962年提出。</p>\n<p><strong>它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</strong></p>\n<p>详解：<a href=\"https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\">快速排序</a></p>\n<p><code>参考代码：</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 快速排序</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @param lo</span><br><span class=\"line\"> * @param hi</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int[] quickSort(int[] arr, int lo, int hi) &#123;</span><br><span class=\"line\">    if (lo &gt;= hi)</span><br><span class=\"line\">        return arr;</span><br><span class=\"line\">    int num = partition(arr, lo, hi);</span><br><span class=\"line\">    quickSort(arr, lo, num - 1);</span><br><span class=\"line\">    quickSort(arr, num + 1, hi);</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 排序数组 返回基准值</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param arr</span><br><span class=\"line\"> * @param lo</span><br><span class=\"line\"> * @param hi</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">public static int partition(int[] arr, int lo, int hi) &#123;</span><br><span class=\"line\">    int num = arr[lo];</span><br><span class=\"line\">    if (lo &gt;= hi)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    while (lo &lt; hi) &#123;</span><br><span class=\"line\">        while (hi &gt; lo &amp;&amp; arr[hi] &gt;= num) &#123;</span><br><span class=\"line\">            hi--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[lo] = arr[hi];</span><br><span class=\"line\">        while (hi &gt; lo &amp;&amp; arr[lo] &lt;= num) &#123;</span><br><span class=\"line\">            lo++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[hi] = arr[lo];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[hi] = num;</span><br><span class=\"line\">    return hi;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p> End.</p>\n"},{"title":"精神八月（2020）","date":"2020-08-29T08:10:55.000Z","_content":"\n> 这期是精神八月，不是八月神经，去他的八月。\n\n过得很快，一月四星期，晃晃悠悠。\n\n衣服还是不合身，赤裸上阵。\n\n---\n\n从苗子开始养的小鳄，三年了，最近感觉情况不太好，一天到晚扒拉缸，一个劲往上扑腾。\n\n好像快要养不下去了。\n\n有时候会感觉这样对它是不是也太束缚了，不是没想过放生，可惜是外来生物不能放走去破坏生态。\n\n从小就生活在玻璃缸中（除了刚买来那会有一次逃出去一星期后才在门后发现），也不知道它这种举动是不是在渴望自由，反正肯定不是由于饥饿。\n\n这就产生了一个两难境地，放了不是，不放看它好像有点难受。而我，照样好吃好喝供着它，还没个好果子吃。\n\n---\n\n最近入了手办的坑，刚入坑，买了几个百来块的，感觉不是很满意。网上逛了一圈，看着有质感，很想买的都是上千的，尤其是看到了个悟空的，帅得不得了，将近两千，规格还不小，买来暂时好像也没有地方放，也是有点舍不得花这个钱。\n\n立个 flag，以后自己的房子一定要有一个大柜子，放书和手办。\n\n一分钱一分货，入坑慢慢交学费了。看来以后会慢慢攒精美手办了，精神食粮。\n\n这钱花在自己喜欢的东西上它不香吗，至少自己看着开心。\n\n---\n\n今天，漫威电影《黑豹》演员 Chadwick Boseman 去世，死于结肠癌，年仅43岁。\n\n如今世界连流行性病毒都没办法根治，要想能治疗癌症，不知道在我有生之年可否看到这一医学突破。\n\n虽然最近医药医疗股价涨得可怕，但是只要没有解决人们的痛点，这些一直会是刚需存在，一直会需要发展。\n\n随着理想、小鹏相继上市，新能源行业的竞争也越来越激烈，不可否认，这条路已经是很清晰了，只是什么时候技术成熟能普及大众。\n\n---\n\n今晚去看今年第一场 live house，AR 刘夫阳上海站。\n\n继续 摇 头 治 大 病。\n\n---\n\nPeace & love.","source":"_posts/spirit-august.md","raw":"---\ntitle: 精神八月（2020）\ndate: 2020-08-29 16:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这期是精神八月，不是八月神经，去他的八月。\n\n过得很快，一月四星期，晃晃悠悠。\n\n衣服还是不合身，赤裸上阵。\n\n---\n\n从苗子开始养的小鳄，三年了，最近感觉情况不太好，一天到晚扒拉缸，一个劲往上扑腾。\n\n好像快要养不下去了。\n\n有时候会感觉这样对它是不是也太束缚了，不是没想过放生，可惜是外来生物不能放走去破坏生态。\n\n从小就生活在玻璃缸中（除了刚买来那会有一次逃出去一星期后才在门后发现），也不知道它这种举动是不是在渴望自由，反正肯定不是由于饥饿。\n\n这就产生了一个两难境地，放了不是，不放看它好像有点难受。而我，照样好吃好喝供着它，还没个好果子吃。\n\n---\n\n最近入了手办的坑，刚入坑，买了几个百来块的，感觉不是很满意。网上逛了一圈，看着有质感，很想买的都是上千的，尤其是看到了个悟空的，帅得不得了，将近两千，规格还不小，买来暂时好像也没有地方放，也是有点舍不得花这个钱。\n\n立个 flag，以后自己的房子一定要有一个大柜子，放书和手办。\n\n一分钱一分货，入坑慢慢交学费了。看来以后会慢慢攒精美手办了，精神食粮。\n\n这钱花在自己喜欢的东西上它不香吗，至少自己看着开心。\n\n---\n\n今天，漫威电影《黑豹》演员 Chadwick Boseman 去世，死于结肠癌，年仅43岁。\n\n如今世界连流行性病毒都没办法根治，要想能治疗癌症，不知道在我有生之年可否看到这一医学突破。\n\n虽然最近医药医疗股价涨得可怕，但是只要没有解决人们的痛点，这些一直会是刚需存在，一直会需要发展。\n\n随着理想、小鹏相继上市，新能源行业的竞争也越来越激烈，不可否认，这条路已经是很清晰了，只是什么时候技术成熟能普及大众。\n\n---\n\n今晚去看今年第一场 live house，AR 刘夫阳上海站。\n\n继续 摇 头 治 大 病。\n\n---\n\nPeace & love.","slug":"spirit-august","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhp00apk9i1bspt4gdw","content":"<blockquote>\n<p>这期是精神八月，不是八月神经，去他的八月。</p>\n</blockquote>\n<p>过得很快，一月四星期，晃晃悠悠。</p>\n<p>衣服还是不合身，赤裸上阵。</p>\n<hr>\n<p>从苗子开始养的小鳄，三年了，最近感觉情况不太好，一天到晚扒拉缸，一个劲往上扑腾。</p>\n<p>好像快要养不下去了。</p>\n<p>有时候会感觉这样对它是不是也太束缚了，不是没想过放生，可惜是外来生物不能放走去破坏生态。</p>\n<p>从小就生活在玻璃缸中（除了刚买来那会有一次逃出去一星期后才在门后发现），也不知道它这种举动是不是在渴望自由，反正肯定不是由于饥饿。</p>\n<p>这就产生了一个两难境地，放了不是，不放看它好像有点难受。而我，照样好吃好喝供着它，还没个好果子吃。</p>\n<hr>\n<p>最近入了手办的坑，刚入坑，买了几个百来块的，感觉不是很满意。网上逛了一圈，看着有质感，很想买的都是上千的，尤其是看到了个悟空的，帅得不得了，将近两千，规格还不小，买来暂时好像也没有地方放，也是有点舍不得花这个钱。</p>\n<p>立个 flag，以后自己的房子一定要有一个大柜子，放书和手办。</p>\n<p>一分钱一分货，入坑慢慢交学费了。看来以后会慢慢攒精美手办了，精神食粮。</p>\n<p>这钱花在自己喜欢的东西上它不香吗，至少自己看着开心。</p>\n<hr>\n<p>今天，漫威电影《黑豹》演员 Chadwick Boseman 去世，死于结肠癌，年仅43岁。</p>\n<p>如今世界连流行性病毒都没办法根治，要想能治疗癌症，不知道在我有生之年可否看到这一医学突破。</p>\n<p>虽然最近医药医疗股价涨得可怕，但是只要没有解决人们的痛点，这些一直会是刚需存在，一直会需要发展。</p>\n<p>随着理想、小鹏相继上市，新能源行业的竞争也越来越激烈，不可否认，这条路已经是很清晰了，只是什么时候技术成熟能普及大众。</p>\n<hr>\n<p>今晚去看今年第一场 live house，AR 刘夫阳上海站。</p>\n<p>继续 摇 头 治 大 病。</p>\n<hr>\n<p>Peace &amp; love.</p>\n","excerpt":"","more":"<blockquote>\n<p>这期是精神八月，不是八月神经，去他的八月。</p>\n</blockquote>\n<p>过得很快，一月四星期，晃晃悠悠。</p>\n<p>衣服还是不合身，赤裸上阵。</p>\n<hr>\n<p>从苗子开始养的小鳄，三年了，最近感觉情况不太好，一天到晚扒拉缸，一个劲往上扑腾。</p>\n<p>好像快要养不下去了。</p>\n<p>有时候会感觉这样对它是不是也太束缚了，不是没想过放生，可惜是外来生物不能放走去破坏生态。</p>\n<p>从小就生活在玻璃缸中（除了刚买来那会有一次逃出去一星期后才在门后发现），也不知道它这种举动是不是在渴望自由，反正肯定不是由于饥饿。</p>\n<p>这就产生了一个两难境地，放了不是，不放看它好像有点难受。而我，照样好吃好喝供着它，还没个好果子吃。</p>\n<hr>\n<p>最近入了手办的坑，刚入坑，买了几个百来块的，感觉不是很满意。网上逛了一圈，看着有质感，很想买的都是上千的，尤其是看到了个悟空的，帅得不得了，将近两千，规格还不小，买来暂时好像也没有地方放，也是有点舍不得花这个钱。</p>\n<p>立个 flag，以后自己的房子一定要有一个大柜子，放书和手办。</p>\n<p>一分钱一分货，入坑慢慢交学费了。看来以后会慢慢攒精美手办了，精神食粮。</p>\n<p>这钱花在自己喜欢的东西上它不香吗，至少自己看着开心。</p>\n<hr>\n<p>今天，漫威电影《黑豹》演员 Chadwick Boseman 去世，死于结肠癌，年仅43岁。</p>\n<p>如今世界连流行性病毒都没办法根治，要想能治疗癌症，不知道在我有生之年可否看到这一医学突破。</p>\n<p>虽然最近医药医疗股价涨得可怕，但是只要没有解决人们的痛点，这些一直会是刚需存在，一直会需要发展。</p>\n<p>随着理想、小鹏相继上市，新能源行业的竞争也越来越激烈，不可否认，这条路已经是很清晰了，只是什么时候技术成熟能普及大众。</p>\n<hr>\n<p>今晚去看今年第一场 live house，AR 刘夫阳上海站。</p>\n<p>继续 摇 头 治 大 病。</p>\n<hr>\n<p>Peace &amp; love.</p>\n"},{"title":"Spring Data JPA 初次使用心得","date":"2018-06-21T02:53:20.000Z","_content":"## 前言\n- 最近在给公司的老项目换个架构，之前的架构太繁琐古老了些，用的是SSH，还是老版的Hibernate3，配置文件看花眼还有Struts2确实看着不习惯，感觉有点费眼，不过在改的过程我觉得它能共享参数有时候还是挺便捷的。\n-  因为之前用的是Hibernate所以我决定用Spring Data JPA,对了，今天我要说下有关于JPA的一些注意点，也是我亲自踩完后发现的，因为之前没有接触过它。\n-  Entity实体类与Hibernate没有多大区别@Entity定义实体 @Table定义表明 @Id定义主键 @Column定义数据库中字段映射\n```\n@Entity\n@Table(name = \"alarmtable\")\npublic class AlarmEntity {\n    private String channelNumber;\n    private double alarmValue;\n\n    @Id\n    @Column(name = \"channelNumber\", length = 20, nullable = false)\n    public String getChannelNumber() {\n        return this.channelNumber;\n    }\n\n    public void setChannelNumber(String channelNumber) {\n        this.channelNumber = channelNumber;\n    }\n\n    @Column(name = \"alarmValue\", nullable = false)\n    public double getAlarmValue() {\n        return this.alarmValue;\n    }\n\n    public void setAlarmValue(double alarmValue) {\n        this.alarmValue = alarmValue;\n    }\n}\n```\n\n**这里注意的是当你用驼峰命名字段时会自动用下划线分割，如`alarmValue`会变成`alarm_value`**\n\n## JPA优点\n- 很多人喜欢用JPA的原因是什么，不就是它能省事么，一些基本的CRUD都能替你完成只需要调其方法即可。不过JPA它有特定的命名规则，不能瞎写，写之前还是要去网上看看，这里就不贴示例了。\n- 首先需要先添加依赖，我用的是maven：\n```\n    <!-- JPA依赖 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n```\n- 如果你要自定义方法SQL查询，直接使用@Query注解即可，示例：\n```\n    /**\n     * 查询所有的端口号\n     * \n     * @return\n     */\n    @Query(value = \"select distinct port from relationtable order by port\", nativeQuery = true)\n    List<Integer> getAllPort();\n\n    /**\n     * 根据设备号删除数据\n     * \n     * @param instru_serial\n     */\n    @Transactional\n    @Modifying\n    @Query(value = \"delete from relationTable where instru_serial = :instru_serial\", nativeQuery = true)\n    void deleteByInstru_serial(@Param(\"instru_serial\") String instru_serial);\n```\n`nativeQuery = true`说明该sql为原生sql，本地sql查询。\n> 所谓本地查询，就是使用原生的sql语句（根据数据库的不同，在sql的语法或结构方面可能有所区别）进行查询数据库的操作。\n\n`做删除操作时记得加上这两个注解 @Transactional @Modifying`\n\n**Query的写法有很多种，我这只是其中一种个人认为较为不错的写法，其余可以自行搜索。**\n\n## Dao层\n- 这里我还是习惯称之为Dao，也就是Repository。如果要使用JPA来操作实体映射类的方法时，你需要继承JpaRepository。JpaRepository有两个参数，第一个是相对于的Entity类即映射实体类，第二个为主键类。\n\n`JpaRepository<RelationEntity, Integer>` 第一个参数好理解，第二个参数就是对应Entity中用@Id注解表示的字段的类型，若是int则为Integer，String则为String等等。\n\n- 不过这里我要说的是复合主键，就是当你一个表中存在多个主键的时候。通过查找许多资料后得出方法。`@IdClass`可以解决我们的问题。把Entity中用`@Id`定义的字段重新建一个class来制定。请看示例：\n\n**Entity Class :**\n```\npackage com.tonglei.aiot.entity;\n\nimport java.io.Serializable;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.IdClass;\nimport javax.persistence.Table;\n\nimport com.tonglei.aiot.entity.idclass.DVWIdClass;\n/**\n * 应变映射实体类\n * \n * @author ffj\n *\n */\n@Entity\n@IdClass(DVWIdClass.class)\n@Table(name = \"dvw16_instrument_Info\")\npublic class DVWInstrumentInfoEntity implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String instruSerial;\n    /**\n     * 通道\n     */\n    private int channel;\n    /**\n     * 采样率\n     */\n    private String ratio;\n    private String channelNumber;\n\n    @Id\n    @Column(name = \"Instru_serial\", length = 8, nullable = false)\n    public String getInstruSerial() {\n        return this.instruSerial;\n    }\n\n    public void setInstruSerial(String instru_serial) {\n        this.instruSerial = instru_serial;\n    }\n\n    @Id\n    @Column(name = \"channel\", length = 11, nullable = false)\n    public int getChannel() {\n        return this.channel;\n    }\n\n    public void setChannel(int channel) {\n        this.channel = channel;\n    }\n\n    @Column(name = \"ratio\", length = 30, nullable = false)\n    public String getRatio() {\n        return this.ratio;\n    }\n\n    public void setRatio(String ratio) {\n        this.ratio = ratio;\n    }\n\n    @Column(name = \"number\", length = 20, nullable = false)\n    public String getChannelNumber() {\n        return this.channelNumber;\n    }\n\n    public void setChannelNumber(String channelNumber) {\n        this.channelNumber = channelNumber;\n    }\n}\n```\n\n**Id Class :**\n```\npackage com.tonglei.aiot.entity.idclass;\n\nimport java.io.Serializable;\n/**\n * 应变复合主键类\n * \n * @author ffj\n *\n */\npublic class DVWIdClass implements Serializable {\n    /**\n     * \n     */\n    private static final long serialVersionUID = 1L;\n    String instruSerial;\n    int channel;\n\n    public String getInstruSerial() {\n        return instruSerial;\n    }\n\n    public void setInstruSerial(String instruSerial) {\n        this.instruSerial = instruSerial;\n    }\n\n    public int getChannel() {\n        return channel;\n    }\n\n    public void setChannel(int channel) {\n        this.channel = channel;\n    }\n\n}\n```\n\n**Dao ：**\n```\npackage com.tonglei.aiot.dao;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport com.tonglei.aiot.entity.DVWInstrumentInfoEntity;\nimport com.tonglei.aiot.entity.idclass.DVWIdClass;\n/**\n * 应变Dao层接口\n * \n * @author ffj\n *\n */\npublic interface DVWInstrumentInfoDao extends JpaRepository<DVWInstrumentInfoEntity, DVWIdClass> {\n\n    DVWInstrumentInfoEntity findByInstruSerialAndChannel(String instruSerial, int channel);\n}\n```\n\n**需要注意的是，复合主键类必须实现Serializable接口不然启动会报错。**\n\n## 总结\n- 由于也是第一次使用Spring Data JPA，之前都是用Mybatis的比较多。通过这次的使用发现如果业务上都是一些不太复杂的增删改的话确实能提高不少的效率的。\n- 相对于Mybatis节省了许多配置，懒人首选。\n- 现在还没有用到它的一些复杂的操作，比如多表联查，多表关联什么的，后面用到再详细说明。\n- 通过这次框架的重构也使得我对于其内部方法的调用更加熟悉，虽然还有好多方法我觉得可以更加简单，这个慢慢再优化吧。\n- 终于不用看那一大堆配置文件了。\n\n## 参考资料\n- [Spring Data JPA - Reference Documentation](https://docs.spring.io/spring-data/jpa/docs/2.1.0.M3/reference/html/)\n- [Spring Data Jpa 复合主键](https://blog.csdn.net/qq_35056292/article/details/77892012)\n- [Spring Data系列四 @Query注解及@Modifying注解](https://www.cnblogs.com/zhaobingqing/p/6864223.html)\n","source":"_posts/spring-data-jpa.md","raw":"---\ntitle: Spring Data JPA 初次使用心得\ndate: 2018-6-21 10:53:20\ncategories: [开发,总结]\ntags: [Spring Data JPA,Java]\n---\n## 前言\n- 最近在给公司的老项目换个架构，之前的架构太繁琐古老了些，用的是SSH，还是老版的Hibernate3，配置文件看花眼还有Struts2确实看着不习惯，感觉有点费眼，不过在改的过程我觉得它能共享参数有时候还是挺便捷的。\n-  因为之前用的是Hibernate所以我决定用Spring Data JPA,对了，今天我要说下有关于JPA的一些注意点，也是我亲自踩完后发现的，因为之前没有接触过它。\n-  Entity实体类与Hibernate没有多大区别@Entity定义实体 @Table定义表明 @Id定义主键 @Column定义数据库中字段映射\n```\n@Entity\n@Table(name = \"alarmtable\")\npublic class AlarmEntity {\n    private String channelNumber;\n    private double alarmValue;\n\n    @Id\n    @Column(name = \"channelNumber\", length = 20, nullable = false)\n    public String getChannelNumber() {\n        return this.channelNumber;\n    }\n\n    public void setChannelNumber(String channelNumber) {\n        this.channelNumber = channelNumber;\n    }\n\n    @Column(name = \"alarmValue\", nullable = false)\n    public double getAlarmValue() {\n        return this.alarmValue;\n    }\n\n    public void setAlarmValue(double alarmValue) {\n        this.alarmValue = alarmValue;\n    }\n}\n```\n\n**这里注意的是当你用驼峰命名字段时会自动用下划线分割，如`alarmValue`会变成`alarm_value`**\n\n## JPA优点\n- 很多人喜欢用JPA的原因是什么，不就是它能省事么，一些基本的CRUD都能替你完成只需要调其方法即可。不过JPA它有特定的命名规则，不能瞎写，写之前还是要去网上看看，这里就不贴示例了。\n- 首先需要先添加依赖，我用的是maven：\n```\n    <!-- JPA依赖 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n    </dependency>\n```\n- 如果你要自定义方法SQL查询，直接使用@Query注解即可，示例：\n```\n    /**\n     * 查询所有的端口号\n     * \n     * @return\n     */\n    @Query(value = \"select distinct port from relationtable order by port\", nativeQuery = true)\n    List<Integer> getAllPort();\n\n    /**\n     * 根据设备号删除数据\n     * \n     * @param instru_serial\n     */\n    @Transactional\n    @Modifying\n    @Query(value = \"delete from relationTable where instru_serial = :instru_serial\", nativeQuery = true)\n    void deleteByInstru_serial(@Param(\"instru_serial\") String instru_serial);\n```\n`nativeQuery = true`说明该sql为原生sql，本地sql查询。\n> 所谓本地查询，就是使用原生的sql语句（根据数据库的不同，在sql的语法或结构方面可能有所区别）进行查询数据库的操作。\n\n`做删除操作时记得加上这两个注解 @Transactional @Modifying`\n\n**Query的写法有很多种，我这只是其中一种个人认为较为不错的写法，其余可以自行搜索。**\n\n## Dao层\n- 这里我还是习惯称之为Dao，也就是Repository。如果要使用JPA来操作实体映射类的方法时，你需要继承JpaRepository。JpaRepository有两个参数，第一个是相对于的Entity类即映射实体类，第二个为主键类。\n\n`JpaRepository<RelationEntity, Integer>` 第一个参数好理解，第二个参数就是对应Entity中用@Id注解表示的字段的类型，若是int则为Integer，String则为String等等。\n\n- 不过这里我要说的是复合主键，就是当你一个表中存在多个主键的时候。通过查找许多资料后得出方法。`@IdClass`可以解决我们的问题。把Entity中用`@Id`定义的字段重新建一个class来制定。请看示例：\n\n**Entity Class :**\n```\npackage com.tonglei.aiot.entity;\n\nimport java.io.Serializable;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.IdClass;\nimport javax.persistence.Table;\n\nimport com.tonglei.aiot.entity.idclass.DVWIdClass;\n/**\n * 应变映射实体类\n * \n * @author ffj\n *\n */\n@Entity\n@IdClass(DVWIdClass.class)\n@Table(name = \"dvw16_instrument_Info\")\npublic class DVWInstrumentInfoEntity implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String instruSerial;\n    /**\n     * 通道\n     */\n    private int channel;\n    /**\n     * 采样率\n     */\n    private String ratio;\n    private String channelNumber;\n\n    @Id\n    @Column(name = \"Instru_serial\", length = 8, nullable = false)\n    public String getInstruSerial() {\n        return this.instruSerial;\n    }\n\n    public void setInstruSerial(String instru_serial) {\n        this.instruSerial = instru_serial;\n    }\n\n    @Id\n    @Column(name = \"channel\", length = 11, nullable = false)\n    public int getChannel() {\n        return this.channel;\n    }\n\n    public void setChannel(int channel) {\n        this.channel = channel;\n    }\n\n    @Column(name = \"ratio\", length = 30, nullable = false)\n    public String getRatio() {\n        return this.ratio;\n    }\n\n    public void setRatio(String ratio) {\n        this.ratio = ratio;\n    }\n\n    @Column(name = \"number\", length = 20, nullable = false)\n    public String getChannelNumber() {\n        return this.channelNumber;\n    }\n\n    public void setChannelNumber(String channelNumber) {\n        this.channelNumber = channelNumber;\n    }\n}\n```\n\n**Id Class :**\n```\npackage com.tonglei.aiot.entity.idclass;\n\nimport java.io.Serializable;\n/**\n * 应变复合主键类\n * \n * @author ffj\n *\n */\npublic class DVWIdClass implements Serializable {\n    /**\n     * \n     */\n    private static final long serialVersionUID = 1L;\n    String instruSerial;\n    int channel;\n\n    public String getInstruSerial() {\n        return instruSerial;\n    }\n\n    public void setInstruSerial(String instruSerial) {\n        this.instruSerial = instruSerial;\n    }\n\n    public int getChannel() {\n        return channel;\n    }\n\n    public void setChannel(int channel) {\n        this.channel = channel;\n    }\n\n}\n```\n\n**Dao ：**\n```\npackage com.tonglei.aiot.dao;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport com.tonglei.aiot.entity.DVWInstrumentInfoEntity;\nimport com.tonglei.aiot.entity.idclass.DVWIdClass;\n/**\n * 应变Dao层接口\n * \n * @author ffj\n *\n */\npublic interface DVWInstrumentInfoDao extends JpaRepository<DVWInstrumentInfoEntity, DVWIdClass> {\n\n    DVWInstrumentInfoEntity findByInstruSerialAndChannel(String instruSerial, int channel);\n}\n```\n\n**需要注意的是，复合主键类必须实现Serializable接口不然启动会报错。**\n\n## 总结\n- 由于也是第一次使用Spring Data JPA，之前都是用Mybatis的比较多。通过这次的使用发现如果业务上都是一些不太复杂的增删改的话确实能提高不少的效率的。\n- 相对于Mybatis节省了许多配置，懒人首选。\n- 现在还没有用到它的一些复杂的操作，比如多表联查，多表关联什么的，后面用到再详细说明。\n- 通过这次框架的重构也使得我对于其内部方法的调用更加熟悉，虽然还有好多方法我觉得可以更加简单，这个慢慢再优化吧。\n- 终于不用看那一大堆配置文件了。\n\n## 参考资料\n- [Spring Data JPA - Reference Documentation](https://docs.spring.io/spring-data/jpa/docs/2.1.0.M3/reference/html/)\n- [Spring Data Jpa 复合主键](https://blog.csdn.net/qq_35056292/article/details/77892012)\n- [Spring Data系列四 @Query注解及@Modifying注解](https://www.cnblogs.com/zhaobingqing/p/6864223.html)\n","slug":"spring-data-jpa","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhp00atk9i1eclmbj1o","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>最近在给公司的老项目换个架构，之前的架构太繁琐古老了些，用的是SSH，还是老版的Hibernate3，配置文件看花眼还有Struts2确实看着不习惯，感觉有点费眼，不过在改的过程我觉得它能共享参数有时候还是挺便捷的。</li>\n<li>因为之前用的是Hibernate所以我决定用Spring Data JPA,对了，今天我要说下有关于JPA的一些注意点，也是我亲自踩完后发现的，因为之前没有接触过它。</li>\n<li>Entity实体类与Hibernate没有多大区别@Entity定义实体 @Table定义表明 @Id定义主键 @Column定义数据库中字段映射<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Entity</span><br><span class=\"line\">@Table(name = &quot;alarmtable&quot;)</span><br><span class=\"line\">public class AlarmEntity &#123;</span><br><span class=\"line\">    private String channelNumber;</span><br><span class=\"line\">    private double alarmValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @Column(name = &quot;channelNumber&quot;, length = 20, nullable = false)</span><br><span class=\"line\">    public String getChannelNumber() &#123;</span><br><span class=\"line\">        return this.channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannelNumber(String channelNumber) &#123;</span><br><span class=\"line\">        this.channelNumber = channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;alarmValue&quot;, nullable = false)</span><br><span class=\"line\">    public double getAlarmValue() &#123;</span><br><span class=\"line\">        return this.alarmValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAlarmValue(double alarmValue) &#123;</span><br><span class=\"line\">        this.alarmValue = alarmValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>这里注意的是当你用驼峰命名字段时会自动用下划线分割，如<code>alarmValue</code>会变成<code>alarm_value</code></strong></p>\n<h2 id=\"JPA优点\"><a href=\"#JPA优点\" class=\"headerlink\" title=\"JPA优点\"></a>JPA优点</h2><ul>\n<li>很多人喜欢用JPA的原因是什么，不就是它能省事么，一些基本的CRUD都能替你完成只需要调其方法即可。不过JPA它有特定的命名规则，不能瞎写，写之前还是要去网上看看，这里就不贴示例了。</li>\n<li>首先需要先添加依赖，我用的是maven：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- JPA依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>\n<li>如果你要自定义方法SQL查询，直接使用@Query注解即可，示例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 查询所有的端口号</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Query(value = &quot;select distinct port from relationtable order by port&quot;, nativeQuery = true)</span><br><span class=\"line\">List&lt;Integer&gt; getAllPort();</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 根据设备号删除数据</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param instru_serial</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">@Modifying</span><br><span class=\"line\">@Query(value = &quot;delete from relationTable where instru_serial = :instru_serial&quot;, nativeQuery = true)</span><br><span class=\"line\">void deleteByInstru_serial(@Param(&quot;instru_serial&quot;) String instru_serial);</span><br></pre></td></tr></table></figure>\n<code>nativeQuery = true</code>说明该sql为原生sql，本地sql查询。<blockquote>\n<p>所谓本地查询，就是使用原生的sql语句（根据数据库的不同，在sql的语法或结构方面可能有所区别）进行查询数据库的操作。</p>\n</blockquote>\n</li>\n</ul>\n<p><code>做删除操作时记得加上这两个注解 @Transactional @Modifying</code></p>\n<p><strong>Query的写法有很多种，我这只是其中一种个人认为较为不错的写法，其余可以自行搜索。</strong></p>\n<h2 id=\"Dao层\"><a href=\"#Dao层\" class=\"headerlink\" title=\"Dao层\"></a>Dao层</h2><ul>\n<li>这里我还是习惯称之为Dao，也就是Repository。如果要使用JPA来操作实体映射类的方法时，你需要继承JpaRepository。JpaRepository有两个参数，第一个是相对于的Entity类即映射实体类，第二个为主键类。</li>\n</ul>\n<p><code>JpaRepository&lt;RelationEntity, Integer&gt;</code> 第一个参数好理解，第二个参数就是对应Entity中用@Id注解表示的字段的类型，若是int则为Integer，String则为String等等。</p>\n<ul>\n<li>不过这里我要说的是复合主键，就是当你一个表中存在多个主键的时候。通过查找许多资料后得出方法。<code>@IdClass</code>可以解决我们的问题。把Entity中用<code>@Id</code>定义的字段重新建一个class来制定。请看示例：</li>\n</ul>\n<p><strong>Entity Class :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.aiot.entity;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.persistence.Column;</span><br><span class=\"line\">import javax.persistence.Entity;</span><br><span class=\"line\">import javax.persistence.Id;</span><br><span class=\"line\">import javax.persistence.IdClass;</span><br><span class=\"line\">import javax.persistence.Table;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.tonglei.aiot.entity.idclass.DVWIdClass;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 应变映射实体类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Entity</span><br><span class=\"line\">@IdClass(DVWIdClass.class)</span><br><span class=\"line\">@Table(name = &quot;dvw16_instrument_Info&quot;)</span><br><span class=\"line\">public class DVWInstrumentInfoEntity implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    private String instruSerial;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 通道</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private int channel;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 采样率</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String ratio;</span><br><span class=\"line\">    private String channelNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @Column(name = &quot;Instru_serial&quot;, length = 8, nullable = false)</span><br><span class=\"line\">    public String getInstruSerial() &#123;</span><br><span class=\"line\">        return this.instruSerial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setInstruSerial(String instru_serial) &#123;</span><br><span class=\"line\">        this.instruSerial = instru_serial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @Column(name = &quot;channel&quot;, length = 11, nullable = false)</span><br><span class=\"line\">    public int getChannel() &#123;</span><br><span class=\"line\">        return this.channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannel(int channel) &#123;</span><br><span class=\"line\">        this.channel = channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;ratio&quot;, length = 30, nullable = false)</span><br><span class=\"line\">    public String getRatio() &#123;</span><br><span class=\"line\">        return this.ratio;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRatio(String ratio) &#123;</span><br><span class=\"line\">        this.ratio = ratio;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;number&quot;, length = 20, nullable = false)</span><br><span class=\"line\">    public String getChannelNumber() &#123;</span><br><span class=\"line\">        return this.channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannelNumber(String channelNumber) &#123;</span><br><span class=\"line\">        this.channelNumber = channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Id Class :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.aiot.entity.idclass;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 应变复合主键类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class DVWIdClass implements Serializable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    String instruSerial;</span><br><span class=\"line\">    int channel;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getInstruSerial() &#123;</span><br><span class=\"line\">        return instruSerial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setInstruSerial(String instruSerial) &#123;</span><br><span class=\"line\">        this.instruSerial = instruSerial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getChannel() &#123;</span><br><span class=\"line\">        return channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannel(int channel) &#123;</span><br><span class=\"line\">        this.channel = channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Dao ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.aiot.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.tonglei.aiot.entity.DVWInstrumentInfoEntity;</span><br><span class=\"line\">import com.tonglei.aiot.entity.idclass.DVWIdClass;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 应变Dao层接口</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface DVWInstrumentInfoDao extends JpaRepository&lt;DVWInstrumentInfoEntity, DVWIdClass&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DVWInstrumentInfoEntity findByInstruSerialAndChannel(String instruSerial, int channel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意的是，复合主键类必须实现Serializable接口不然启动会报错。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>由于也是第一次使用Spring Data JPA，之前都是用Mybatis的比较多。通过这次的使用发现如果业务上都是一些不太复杂的增删改的话确实能提高不少的效率的。</li>\n<li>相对于Mybatis节省了许多配置，懒人首选。</li>\n<li>现在还没有用到它的一些复杂的操作，比如多表联查，多表关联什么的，后面用到再详细说明。</li>\n<li>通过这次框架的重构也使得我对于其内部方法的调用更加熟悉，虽然还有好多方法我觉得可以更加简单，这个慢慢再优化吧。</li>\n<li>终于不用看那一大堆配置文件了。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-data/jpa/docs/2.1.0.M3/reference/html/\">Spring Data JPA - Reference Documentation</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35056292/article/details/77892012\">Spring Data Jpa 复合主键</a></li>\n<li><a href=\"https://www.cnblogs.com/zhaobingqing/p/6864223.html\">Spring Data系列四 @Query注解及@Modifying注解</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><ul>\n<li>最近在给公司的老项目换个架构，之前的架构太繁琐古老了些，用的是SSH，还是老版的Hibernate3，配置文件看花眼还有Struts2确实看着不习惯，感觉有点费眼，不过在改的过程我觉得它能共享参数有时候还是挺便捷的。</li>\n<li>因为之前用的是Hibernate所以我决定用Spring Data JPA,对了，今天我要说下有关于JPA的一些注意点，也是我亲自踩完后发现的，因为之前没有接触过它。</li>\n<li>Entity实体类与Hibernate没有多大区别@Entity定义实体 @Table定义表明 @Id定义主键 @Column定义数据库中字段映射<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Entity</span><br><span class=\"line\">@Table(name = &quot;alarmtable&quot;)</span><br><span class=\"line\">public class AlarmEntity &#123;</span><br><span class=\"line\">    private String channelNumber;</span><br><span class=\"line\">    private double alarmValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @Column(name = &quot;channelNumber&quot;, length = 20, nullable = false)</span><br><span class=\"line\">    public String getChannelNumber() &#123;</span><br><span class=\"line\">        return this.channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannelNumber(String channelNumber) &#123;</span><br><span class=\"line\">        this.channelNumber = channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;alarmValue&quot;, nullable = false)</span><br><span class=\"line\">    public double getAlarmValue() &#123;</span><br><span class=\"line\">        return this.alarmValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAlarmValue(double alarmValue) &#123;</span><br><span class=\"line\">        this.alarmValue = alarmValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>这里注意的是当你用驼峰命名字段时会自动用下划线分割，如<code>alarmValue</code>会变成<code>alarm_value</code></strong></p>\n<h2 id=\"JPA优点\"><a href=\"#JPA优点\" class=\"headerlink\" title=\"JPA优点\"></a>JPA优点</h2><ul>\n<li>很多人喜欢用JPA的原因是什么，不就是它能省事么，一些基本的CRUD都能替你完成只需要调其方法即可。不过JPA它有特定的命名规则，不能瞎写，写之前还是要去网上看看，这里就不贴示例了。</li>\n<li>首先需要先添加依赖，我用的是maven：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- JPA依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>\n<li>如果你要自定义方法SQL查询，直接使用@Query注解即可，示例：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 查询所有的端口号</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Query(value = &quot;select distinct port from relationtable order by port&quot;, nativeQuery = true)</span><br><span class=\"line\">List&lt;Integer&gt; getAllPort();</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 根据设备号删除数据</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param instru_serial</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">@Modifying</span><br><span class=\"line\">@Query(value = &quot;delete from relationTable where instru_serial = :instru_serial&quot;, nativeQuery = true)</span><br><span class=\"line\">void deleteByInstru_serial(@Param(&quot;instru_serial&quot;) String instru_serial);</span><br></pre></td></tr></table></figure>\n<code>nativeQuery = true</code>说明该sql为原生sql，本地sql查询。<blockquote>\n<p>所谓本地查询，就是使用原生的sql语句（根据数据库的不同，在sql的语法或结构方面可能有所区别）进行查询数据库的操作。</p>\n</blockquote>\n</li>\n</ul>\n<p><code>做删除操作时记得加上这两个注解 @Transactional @Modifying</code></p>\n<p><strong>Query的写法有很多种，我这只是其中一种个人认为较为不错的写法，其余可以自行搜索。</strong></p>\n<h2 id=\"Dao层\"><a href=\"#Dao层\" class=\"headerlink\" title=\"Dao层\"></a>Dao层</h2><ul>\n<li>这里我还是习惯称之为Dao，也就是Repository。如果要使用JPA来操作实体映射类的方法时，你需要继承JpaRepository。JpaRepository有两个参数，第一个是相对于的Entity类即映射实体类，第二个为主键类。</li>\n</ul>\n<p><code>JpaRepository&lt;RelationEntity, Integer&gt;</code> 第一个参数好理解，第二个参数就是对应Entity中用@Id注解表示的字段的类型，若是int则为Integer，String则为String等等。</p>\n<ul>\n<li>不过这里我要说的是复合主键，就是当你一个表中存在多个主键的时候。通过查找许多资料后得出方法。<code>@IdClass</code>可以解决我们的问题。把Entity中用<code>@Id</code>定义的字段重新建一个class来制定。请看示例：</li>\n</ul>\n<p><strong>Entity Class :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.aiot.entity;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.persistence.Column;</span><br><span class=\"line\">import javax.persistence.Entity;</span><br><span class=\"line\">import javax.persistence.Id;</span><br><span class=\"line\">import javax.persistence.IdClass;</span><br><span class=\"line\">import javax.persistence.Table;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.tonglei.aiot.entity.idclass.DVWIdClass;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 应变映射实体类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Entity</span><br><span class=\"line\">@IdClass(DVWIdClass.class)</span><br><span class=\"line\">@Table(name = &quot;dvw16_instrument_Info&quot;)</span><br><span class=\"line\">public class DVWInstrumentInfoEntity implements Serializable &#123;</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    private String instruSerial;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 通道</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private int channel;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 采样率</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private String ratio;</span><br><span class=\"line\">    private String channelNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @Column(name = &quot;Instru_serial&quot;, length = 8, nullable = false)</span><br><span class=\"line\">    public String getInstruSerial() &#123;</span><br><span class=\"line\">        return this.instruSerial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setInstruSerial(String instru_serial) &#123;</span><br><span class=\"line\">        this.instruSerial = instru_serial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    @Column(name = &quot;channel&quot;, length = 11, nullable = false)</span><br><span class=\"line\">    public int getChannel() &#123;</span><br><span class=\"line\">        return this.channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannel(int channel) &#123;</span><br><span class=\"line\">        this.channel = channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;ratio&quot;, length = 30, nullable = false)</span><br><span class=\"line\">    public String getRatio() &#123;</span><br><span class=\"line\">        return this.ratio;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setRatio(String ratio) &#123;</span><br><span class=\"line\">        this.ratio = ratio;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Column(name = &quot;number&quot;, length = 20, nullable = false)</span><br><span class=\"line\">    public String getChannelNumber() &#123;</span><br><span class=\"line\">        return this.channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannelNumber(String channelNumber) &#123;</span><br><span class=\"line\">        this.channelNumber = channelNumber;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Id Class :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.aiot.entity.idclass;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 应变复合主键类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class DVWIdClass implements Serializable &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static final long serialVersionUID = 1L;</span><br><span class=\"line\">    String instruSerial;</span><br><span class=\"line\">    int channel;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getInstruSerial() &#123;</span><br><span class=\"line\">        return instruSerial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setInstruSerial(String instruSerial) &#123;</span><br><span class=\"line\">        this.instruSerial = instruSerial;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getChannel() &#123;</span><br><span class=\"line\">        return channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setChannel(int channel) &#123;</span><br><span class=\"line\">        this.channel = channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Dao ：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.tonglei.aiot.dao;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.tonglei.aiot.entity.DVWInstrumentInfoEntity;</span><br><span class=\"line\">import com.tonglei.aiot.entity.idclass.DVWIdClass;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 应变Dao层接口</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface DVWInstrumentInfoDao extends JpaRepository&lt;DVWInstrumentInfoEntity, DVWIdClass&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DVWInstrumentInfoEntity findByInstruSerialAndChannel(String instruSerial, int channel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意的是，复合主键类必须实现Serializable接口不然启动会报错。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>由于也是第一次使用Spring Data JPA，之前都是用Mybatis的比较多。通过这次的使用发现如果业务上都是一些不太复杂的增删改的话确实能提高不少的效率的。</li>\n<li>相对于Mybatis节省了许多配置，懒人首选。</li>\n<li>现在还没有用到它的一些复杂的操作，比如多表联查，多表关联什么的，后面用到再详细说明。</li>\n<li>通过这次框架的重构也使得我对于其内部方法的调用更加熟悉，虽然还有好多方法我觉得可以更加简单，这个慢慢再优化吧。</li>\n<li>终于不用看那一大堆配置文件了。</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://docs.spring.io/spring-data/jpa/docs/2.1.0.M3/reference/html/\">Spring Data JPA - Reference Documentation</a></li>\n<li><a href=\"https://blog.csdn.net/qq_35056292/article/details/77892012\">Spring Data Jpa 复合主键</a></li>\n<li><a href=\"https://www.cnblogs.com/zhaobingqing/p/6864223.html\">Spring Data系列四 @Query注解及@Modifying注解</a></li>\n</ul>\n"},{"title":"入春二月（2023）","date":"2023-03-08T13:10:55.000Z","_content":"\n> 到了二月，眼瞅着温度慢慢回升，大家的旅游热情也是十分高涨。\n\n\n前段时间趁着周末去了趟苏州，景点那个人啊，在路上真的是被推着走。西园寺的素面排了半小时左右吃上了，还好去的早不然排得更久。\n\n很明显能感觉到，不止景点，各大商场的人也多了很多。一到饭点，只要是稍大点的商场，没有一个吃饭的店是不用排队的，这消费能力真是杠杠的。\n\n前几天我们大学寝室的几个终于又聚到了一起，不容易啊，上次聚一起还是五年前。这次刚好其中一个室友结婚，于是找了个周末大家一起聚了一下，隔得也都不是很远，路程还可以。包吃住还带洗脚搓澡，这一趟没白走。下次再聚就不知道是什么时候了，也可能是下半年等我结婚吧。\n\n---\n\n当然也有伤心的事，我17年开始养的小鳄龟苗，这次给他找了个新主人。养了这么多年了，突然离去，说不伤感肯定是不可能的，不过还是介于自己现在的居住环境，也是迫不得已，希望他能更加愉快得生长吧。\n\n入春了，温度上升，疫情褪去。美好的事情一定会接踵而至，期待未来！","source":"_posts/spring-february.md","raw":"---\ntitle: 入春二月（2023）\ndate: 2023-03-08 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 到了二月，眼瞅着温度慢慢回升，大家的旅游热情也是十分高涨。\n\n\n前段时间趁着周末去了趟苏州，景点那个人啊，在路上真的是被推着走。西园寺的素面排了半小时左右吃上了，还好去的早不然排得更久。\n\n很明显能感觉到，不止景点，各大商场的人也多了很多。一到饭点，只要是稍大点的商场，没有一个吃饭的店是不用排队的，这消费能力真是杠杠的。\n\n前几天我们大学寝室的几个终于又聚到了一起，不容易啊，上次聚一起还是五年前。这次刚好其中一个室友结婚，于是找了个周末大家一起聚了一下，隔得也都不是很远，路程还可以。包吃住还带洗脚搓澡，这一趟没白走。下次再聚就不知道是什么时候了，也可能是下半年等我结婚吧。\n\n---\n\n当然也有伤心的事，我17年开始养的小鳄龟苗，这次给他找了个新主人。养了这么多年了，突然离去，说不伤感肯定是不可能的，不过还是介于自己现在的居住环境，也是迫不得已，希望他能更加愉快得生长吧。\n\n入春了，温度上升，疫情褪去。美好的事情一定会接踵而至，期待未来！","slug":"spring-february","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhp00axk9i178zogx8x","content":"<blockquote>\n<p>到了二月，眼瞅着温度慢慢回升，大家的旅游热情也是十分高涨。</p>\n</blockquote>\n<p>前段时间趁着周末去了趟苏州，景点那个人啊，在路上真的是被推着走。西园寺的素面排了半小时左右吃上了，还好去的早不然排得更久。</p>\n<p>很明显能感觉到，不止景点，各大商场的人也多了很多。一到饭点，只要是稍大点的商场，没有一个吃饭的店是不用排队的，这消费能力真是杠杠的。</p>\n<p>前几天我们大学寝室的几个终于又聚到了一起，不容易啊，上次聚一起还是五年前。这次刚好其中一个室友结婚，于是找了个周末大家一起聚了一下，隔得也都不是很远，路程还可以。包吃住还带洗脚搓澡，这一趟没白走。下次再聚就不知道是什么时候了，也可能是下半年等我结婚吧。</p>\n<hr>\n<p>当然也有伤心的事，我17年开始养的小鳄龟苗，这次给他找了个新主人。养了这么多年了，突然离去，说不伤感肯定是不可能的，不过还是介于自己现在的居住环境，也是迫不得已，希望他能更加愉快得生长吧。</p>\n<p>入春了，温度上升，疫情褪去。美好的事情一定会接踵而至，期待未来！</p>\n","excerpt":"","more":"<blockquote>\n<p>到了二月，眼瞅着温度慢慢回升，大家的旅游热情也是十分高涨。</p>\n</blockquote>\n<p>前段时间趁着周末去了趟苏州，景点那个人啊，在路上真的是被推着走。西园寺的素面排了半小时左右吃上了，还好去的早不然排得更久。</p>\n<p>很明显能感觉到，不止景点，各大商场的人也多了很多。一到饭点，只要是稍大点的商场，没有一个吃饭的店是不用排队的，这消费能力真是杠杠的。</p>\n<p>前几天我们大学寝室的几个终于又聚到了一起，不容易啊，上次聚一起还是五年前。这次刚好其中一个室友结婚，于是找了个周末大家一起聚了一下，隔得也都不是很远，路程还可以。包吃住还带洗脚搓澡，这一趟没白走。下次再聚就不知道是什么时候了，也可能是下半年等我结婚吧。</p>\n<hr>\n<p>当然也有伤心的事，我17年开始养的小鳄龟苗，这次给他找了个新主人。养了这么多年了，突然离去，说不伤感肯定是不可能的，不过还是介于自己现在的居住环境，也是迫不得已，希望他能更加愉快得生长吧。</p>\n<p>入春了，温度上升，疫情褪去。美好的事情一定会接踵而至，期待未来！</p>\n"},{"title":"阳春三月（2020）","date":"2020-03-24T02:10:55.000Z","_content":"\n> 春风拂面 绿意盎然啊\n\n每天还是戴着口罩过日子，还是吃着面过日子，还是一个人过日子……\n\n最近气温有时上 20℃，有时又急速转下到了 10℃，有时白天出门望着蓝天白云暖阳照面，下班时便是顶着肆虐妖风寒颤不断……\n\n难啊难啊……\n\n---\n\n前几个周末趁着天儿还不错便跟一个不靠谱同事去河边钓鱼，第一次钓上来一只鳖（听说是前几天别人放生了很多），第二次钓上来一条浪里白条，做了搁在冰箱里等以后凑一盘。每次去都是去看别人钓鱼去了，隔壁老头一会来一条一会来一条，那叫一个羡慕啊。\n\n鳖不会做，跟鳄龟放着一起，过了三天，鳖卒。\n\n截至 2020-3-24 11:41:33，国外确诊 293598 人，国内确诊 81749 人，扩散真的是太厉害了，中国当时要是不采取封城，想想后怕啊。\n\n前几天帮大老板扣了几分驾照分，说起来也难以置信。不过我这驾照考了好几年了，一年也就回家时候开几回车，每年都有十二分好像都这么没掉，有点浪费啊。这也是我头一回去交警支队处理违规，按道理一般办理的话网上都可在线处理，我这次是以公司员工身份去处理可能只能线下，但也还是相对蛮方便的。登记下后直接去柜台资料一给就给你个处罚单签个字之后自己去交钱就完事了。科技便民。\n\n有个大学同学之前去寺庙当过几个月义工，之后跟他也探讨过一些自己对佛理的理解。经他推荐，买了圣严法师所著的三本入门书，至今还未观摩，待我研读之后便会写一些自己对其新的理解与感悟。对此，我还是比较感兴趣的。\n\n《软技能 代码之外的生存指南》这本书我断断续续看了好几个月了，最近终于看完了。我表示强烈推荐。此前我也已经推荐给许多朋友过了。这本书书名虽然提到了代码，但是里面的内容除了几个专用名词之外，完全没有一行代码，且我认为不仅适合程序员，也适合其他人在这字里行间寻到启发，有所感悟。**技术最多只是你生存的工具，而不是你生活的所有。**做事多从一些其他的角度看待，会有不一样的发现。同样，今天也把电视剧《安家》给看完了，刚好我也身处大上海，很多事情感同身受。剧里的许多平凡人，那就是千千万万的你和我的缩影，虽然平凡但是心要有所追寻。生活虽然有时真的很操蛋，但这时候问问自己，这难道就是坏事吗？弹指一瞬，我来到大上海也有三年了，这三年间我从最开始的一个人顶风冒雨找工作，一天只吃一袋面包，与同学背贴背睡一张小破床到中途找到了个稳定的工作，找到了个关心我的人，找到了一群有趣有才的同事再到此刻我在租的小房间里独自静静地敲着这些个文字（其实楼上在搞装修，电钻兹兹得兹了好几天了……）。也算是站稳了迈出的第一步，道路且长且艰，共勉。\n\n这几年没挣几个臭钱，看着同学朋友一个个买房的买房结婚的结婚，羡煞老傅也！不过每个人有其自己独一无二的人生，不可胡乱作比较，该祝福的真心祝福，该舍弃的果断舍弃，过好自己就行。\n\n这场战疫，估计还得要一段时间，有些计划都被强行打乱了。\n\n不管怎样，首先，活着。","source":"_posts/spring-march.md","raw":"---\ntitle: 阳春三月（2020）\ndate: 2020-03-24 10:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 春风拂面 绿意盎然啊\n\n每天还是戴着口罩过日子，还是吃着面过日子，还是一个人过日子……\n\n最近气温有时上 20℃，有时又急速转下到了 10℃，有时白天出门望着蓝天白云暖阳照面，下班时便是顶着肆虐妖风寒颤不断……\n\n难啊难啊……\n\n---\n\n前几个周末趁着天儿还不错便跟一个不靠谱同事去河边钓鱼，第一次钓上来一只鳖（听说是前几天别人放生了很多），第二次钓上来一条浪里白条，做了搁在冰箱里等以后凑一盘。每次去都是去看别人钓鱼去了，隔壁老头一会来一条一会来一条，那叫一个羡慕啊。\n\n鳖不会做，跟鳄龟放着一起，过了三天，鳖卒。\n\n截至 2020-3-24 11:41:33，国外确诊 293598 人，国内确诊 81749 人，扩散真的是太厉害了，中国当时要是不采取封城，想想后怕啊。\n\n前几天帮大老板扣了几分驾照分，说起来也难以置信。不过我这驾照考了好几年了，一年也就回家时候开几回车，每年都有十二分好像都这么没掉，有点浪费啊。这也是我头一回去交警支队处理违规，按道理一般办理的话网上都可在线处理，我这次是以公司员工身份去处理可能只能线下，但也还是相对蛮方便的。登记下后直接去柜台资料一给就给你个处罚单签个字之后自己去交钱就完事了。科技便民。\n\n有个大学同学之前去寺庙当过几个月义工，之后跟他也探讨过一些自己对佛理的理解。经他推荐，买了圣严法师所著的三本入门书，至今还未观摩，待我研读之后便会写一些自己对其新的理解与感悟。对此，我还是比较感兴趣的。\n\n《软技能 代码之外的生存指南》这本书我断断续续看了好几个月了，最近终于看完了。我表示强烈推荐。此前我也已经推荐给许多朋友过了。这本书书名虽然提到了代码，但是里面的内容除了几个专用名词之外，完全没有一行代码，且我认为不仅适合程序员，也适合其他人在这字里行间寻到启发，有所感悟。**技术最多只是你生存的工具，而不是你生活的所有。**做事多从一些其他的角度看待，会有不一样的发现。同样，今天也把电视剧《安家》给看完了，刚好我也身处大上海，很多事情感同身受。剧里的许多平凡人，那就是千千万万的你和我的缩影，虽然平凡但是心要有所追寻。生活虽然有时真的很操蛋，但这时候问问自己，这难道就是坏事吗？弹指一瞬，我来到大上海也有三年了，这三年间我从最开始的一个人顶风冒雨找工作，一天只吃一袋面包，与同学背贴背睡一张小破床到中途找到了个稳定的工作，找到了个关心我的人，找到了一群有趣有才的同事再到此刻我在租的小房间里独自静静地敲着这些个文字（其实楼上在搞装修，电钻兹兹得兹了好几天了……）。也算是站稳了迈出的第一步，道路且长且艰，共勉。\n\n这几年没挣几个臭钱，看着同学朋友一个个买房的买房结婚的结婚，羡煞老傅也！不过每个人有其自己独一无二的人生，不可胡乱作比较，该祝福的真心祝福，该舍弃的果断舍弃，过好自己就行。\n\n这场战疫，估计还得要一段时间，有些计划都被强行打乱了。\n\n不管怎样，首先，活着。","slug":"spring-march","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhp00b1k9i19u0d4bi3","content":"<blockquote>\n<p>春风拂面 绿意盎然啊</p>\n</blockquote>\n<p>每天还是戴着口罩过日子，还是吃着面过日子，还是一个人过日子……</p>\n<p>最近气温有时上 20℃，有时又急速转下到了 10℃，有时白天出门望着蓝天白云暖阳照面，下班时便是顶着肆虐妖风寒颤不断……</p>\n<p>难啊难啊……</p>\n<hr>\n<p>前几个周末趁着天儿还不错便跟一个不靠谱同事去河边钓鱼，第一次钓上来一只鳖（听说是前几天别人放生了很多），第二次钓上来一条浪里白条，做了搁在冰箱里等以后凑一盘。每次去都是去看别人钓鱼去了，隔壁老头一会来一条一会来一条，那叫一个羡慕啊。</p>\n<p>鳖不会做，跟鳄龟放着一起，过了三天，鳖卒。</p>\n<p>截至 2020-3-24 11:41:33，国外确诊 293598 人，国内确诊 81749 人，扩散真的是太厉害了，中国当时要是不采取封城，想想后怕啊。</p>\n<p>前几天帮大老板扣了几分驾照分，说起来也难以置信。不过我这驾照考了好几年了，一年也就回家时候开几回车，每年都有十二分好像都这么没掉，有点浪费啊。这也是我头一回去交警支队处理违规，按道理一般办理的话网上都可在线处理，我这次是以公司员工身份去处理可能只能线下，但也还是相对蛮方便的。登记下后直接去柜台资料一给就给你个处罚单签个字之后自己去交钱就完事了。科技便民。</p>\n<p>有个大学同学之前去寺庙当过几个月义工，之后跟他也探讨过一些自己对佛理的理解。经他推荐，买了圣严法师所著的三本入门书，至今还未观摩，待我研读之后便会写一些自己对其新的理解与感悟。对此，我还是比较感兴趣的。</p>\n<p>《软技能 代码之外的生存指南》这本书我断断续续看了好几个月了，最近终于看完了。我表示强烈推荐。此前我也已经推荐给许多朋友过了。这本书书名虽然提到了代码，但是里面的内容除了几个专用名词之外，完全没有一行代码，且我认为不仅适合程序员，也适合其他人在这字里行间寻到启发，有所感悟。<strong>技术最多只是你生存的工具，而不是你生活的所有。</strong>做事多从一些其他的角度看待，会有不一样的发现。同样，今天也把电视剧《安家》给看完了，刚好我也身处大上海，很多事情感同身受。剧里的许多平凡人，那就是千千万万的你和我的缩影，虽然平凡但是心要有所追寻。生活虽然有时真的很操蛋，但这时候问问自己，这难道就是坏事吗？弹指一瞬，我来到大上海也有三年了，这三年间我从最开始的一个人顶风冒雨找工作，一天只吃一袋面包，与同学背贴背睡一张小破床到中途找到了个稳定的工作，找到了个关心我的人，找到了一群有趣有才的同事再到此刻我在租的小房间里独自静静地敲着这些个文字（其实楼上在搞装修，电钻兹兹得兹了好几天了……）。也算是站稳了迈出的第一步，道路且长且艰，共勉。</p>\n<p>这几年没挣几个臭钱，看着同学朋友一个个买房的买房结婚的结婚，羡煞老傅也！不过每个人有其自己独一无二的人生，不可胡乱作比较，该祝福的真心祝福，该舍弃的果断舍弃，过好自己就行。</p>\n<p>这场战疫，估计还得要一段时间，有些计划都被强行打乱了。</p>\n<p>不管怎样，首先，活着。</p>\n","excerpt":"","more":"<blockquote>\n<p>春风拂面 绿意盎然啊</p>\n</blockquote>\n<p>每天还是戴着口罩过日子，还是吃着面过日子，还是一个人过日子……</p>\n<p>最近气温有时上 20℃，有时又急速转下到了 10℃，有时白天出门望着蓝天白云暖阳照面，下班时便是顶着肆虐妖风寒颤不断……</p>\n<p>难啊难啊……</p>\n<hr>\n<p>前几个周末趁着天儿还不错便跟一个不靠谱同事去河边钓鱼，第一次钓上来一只鳖（听说是前几天别人放生了很多），第二次钓上来一条浪里白条，做了搁在冰箱里等以后凑一盘。每次去都是去看别人钓鱼去了，隔壁老头一会来一条一会来一条，那叫一个羡慕啊。</p>\n<p>鳖不会做，跟鳄龟放着一起，过了三天，鳖卒。</p>\n<p>截至 2020-3-24 11:41:33，国外确诊 293598 人，国内确诊 81749 人，扩散真的是太厉害了，中国当时要是不采取封城，想想后怕啊。</p>\n<p>前几天帮大老板扣了几分驾照分，说起来也难以置信。不过我这驾照考了好几年了，一年也就回家时候开几回车，每年都有十二分好像都这么没掉，有点浪费啊。这也是我头一回去交警支队处理违规，按道理一般办理的话网上都可在线处理，我这次是以公司员工身份去处理可能只能线下，但也还是相对蛮方便的。登记下后直接去柜台资料一给就给你个处罚单签个字之后自己去交钱就完事了。科技便民。</p>\n<p>有个大学同学之前去寺庙当过几个月义工，之后跟他也探讨过一些自己对佛理的理解。经他推荐，买了圣严法师所著的三本入门书，至今还未观摩，待我研读之后便会写一些自己对其新的理解与感悟。对此，我还是比较感兴趣的。</p>\n<p>《软技能 代码之外的生存指南》这本书我断断续续看了好几个月了，最近终于看完了。我表示强烈推荐。此前我也已经推荐给许多朋友过了。这本书书名虽然提到了代码，但是里面的内容除了几个专用名词之外，完全没有一行代码，且我认为不仅适合程序员，也适合其他人在这字里行间寻到启发，有所感悟。<strong>技术最多只是你生存的工具，而不是你生活的所有。</strong>做事多从一些其他的角度看待，会有不一样的发现。同样，今天也把电视剧《安家》给看完了，刚好我也身处大上海，很多事情感同身受。剧里的许多平凡人，那就是千千万万的你和我的缩影，虽然平凡但是心要有所追寻。生活虽然有时真的很操蛋，但这时候问问自己，这难道就是坏事吗？弹指一瞬，我来到大上海也有三年了，这三年间我从最开始的一个人顶风冒雨找工作，一天只吃一袋面包，与同学背贴背睡一张小破床到中途找到了个稳定的工作，找到了个关心我的人，找到了一群有趣有才的同事再到此刻我在租的小房间里独自静静地敲着这些个文字（其实楼上在搞装修，电钻兹兹得兹了好几天了……）。也算是站稳了迈出的第一步，道路且长且艰，共勉。</p>\n<p>这几年没挣几个臭钱，看着同学朋友一个个买房的买房结婚的结婚，羡煞老傅也！不过每个人有其自己独一无二的人生，不可胡乱作比较，该祝福的真心祝福，该舍弃的果断舍弃，过好自己就行。</p>\n<p>这场战疫，估计还得要一段时间，有些计划都被强行打乱了。</p>\n<p>不管怎样，首先，活着。</p>\n"},{"title":"Spring JPA Data with REST","date":"2019-08-24T02:59:49.000Z","_content":"\n> 逛 Spring 官网学习总结\n\n---\n\n`@RepositoryRestResource` 看到这个注解，之前一直没有用到过，所以想要自己试试效果，顺道做下总结。\n\n**不想要看我废话想要直接看官网的** → [Accessing JPA Data with REST](https://spring.io/guides/gs/accessing-data-rest/)\n\n**不想要看我废话想看大佬的** → [Spring Boot之@RepositoryRestResource注解入门使用教程](https://www.jianshu.com/p/3423fa97d185)\n\n---\n\n## 构建项目\n\n用 Maven 构建项目，建一个 `Person` 实体类，再建一个 `PersonRepository` 接口，这个是关键。\n\n```\npackage hello;\n\nimport java.util.List;\n\nimport org.springframework.data.repository.PagingAndSortingRepository;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(collectionResourceRel = \"people\", path = \"people\")\npublic interface PersonRepository extends PagingAndSortingRepository<Person, Long> {\n\n    List<Person> findByLastName(@Param(\"name\") String name);\n\n}\n```\n\n官网是这么介绍的：\n```\nAt runtime, Spring Data REST will create an implementation of this interface automatically. Then it will use the @RepositoryRestResource annotation to direct Spring MVC to create RESTful endpoints at /people.\n```\n\n我们翻译过来就是：\n```\n在运行时，Spring Data REST将自动创建此接口的实现。然后它将会在使用 @RepositoryRestResource 注解的 Spring MVC 在 /people 创建 RESTful 端点。\n```\n\n点进 `PagingAndSortingRepository` 接口看：\n```\n@NoRepositoryBean\npublic interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {\n    Iterable<T> findAll(Sort var1);\n\n    Page<T> findAll(Pageable var1);\n}\n```\n看到该接口还是继承了平时常使用的 `CrudRepository`，这就说明那些基本的增删改查方法也都有。\n\n为了方便，我还写了一个接口用来保存 `Person` 实体，为后续测试使用。\n\n```\n@Service\npublic class PersonService {\n\n    @Autowired\n    PersonRepository personRepository;\n\n    public void savePerson(Person person){\n        personRepository.save(person);\n    }\n}\n```\n\n```\n@RestController\n@RequestMapping(\"/person\")\npublic class PersonController {\n\n    @Autowired\n    PersonService personService;\n\n    @PutMapping(\"/save\")\n    public String savePerson(Person person){\n        personService.savePerson(person);\n        return \"success\";\n    }\n}\n```\n\n很简单的一个映射。\n\n到这为止，我们的项目就全构建好了。\n\n**嫌麻烦不想自己动手建项目的** → [GitHub](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest)\n\n## 测试功能\n\n我这里为了方便，用的是 `Postman` 进行测试。\n\n首先访问 `http://localhost:8080`，返回的是：\n```\n{\n    \"_links\": {\n        \"people\": {\n            \"href\": \"http://localhost:8080/people{?page,size,sort}\",\n            \"templated\": true\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile\"\n        }\n    }\n}\n```\n\n再访问 `http://localhost:8080/people`，返回的是：\n```\n{\n    \"_embedded\": {\n        \"people\": []\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people{?page,size,sort}\",\n            \"templated\": true\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile/people\"\n        },\n        \"search\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    },\n    \"page\": {\n        \"size\": 20,\n        \"totalElements\": 0,\n        \"totalPages\": 0,\n        \"number\": 0\n    }\n}\n```\n\n因为里面没有数据，我们先塞几个数据进去，这时候就利用我们之前写的接口来操作。如下：\n```\n我们用 PUT 方式去请求 http://localhost:8080/person/save?firstName=aaa&lastName=bbb\n\n返回 success 就说明操作成功，成功塞入。\n```\n\n同样的方式我们再多塞几个。\n\n塞完值之后我们接着去访问 `http://localhost:8080/people`，这时候发现结果与之前的稍有不同了：\n```\n{\n    \"_embedded\": {\n        \"people\": [\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"bbb\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"ccc\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"jay\",\n                \"lastName\": \"folger\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    }\n                }\n            }\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people{?page,size,sort}\",\n            \"templated\": true\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile/people\"\n        },\n        \"search\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    },\n    \"page\": {\n        \"size\": 20,\n        \"totalElements\": 3,\n        \"totalPages\": 1,\n        \"number\": 0\n    }\n}\n```\n是的，我们刚塞的值都查出来了。\n\n接着测试，访问 `http://localhost:8080/people/1`，返回结果为：\n```\n{\n    \"firstName\": \"aaa\",\n    \"lastName\": \"bbb\",\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people/1\"\n        },\n        \"person\": {\n            \"href\": \"http://localhost:8080/people/1\"\n        }\n    }\n}\n```\n是的，就是第一条数据被查出来了，同理 /2 /3 也是。\n\n访问 `http://localhost:8080/people/search`，返回结果为：\n```\n{\n    \"_links\": {\n        \"findByLastName\": {\n            \"href\": \"http://localhost:8080/people/search/findByLastName{?name}\",\n            \"templated\": true\n        },\n        \"self\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    }\n}\n```\n对的，`findByLastName{?name}` 就是我们在里面新增的那个接口，那就顺着这个意思咱们继续来。\n\n访问 `http://localhost:8080/people/search/findByLastName?name=folger`，返回结果为：\n```\n{\n    \"_embedded\": {\n        \"people\": [\n            {\n                \"firstName\": \"jay\",\n                \"lastName\": \"folger\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    }\n                }\n            }\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people/search/findByLastName?name=folger\"\n        }\n    }\n}\n```\n与我们猜测无二。接口写的返回是集合，所以就返回了一个集合。\n\n之前还看到了这么一条 link `\"href\": \"http://localhost:8080/people{?page,size,sort}\"`\n\n有经验的程序员一眼就肯定知道这些个参数都是干什么用的，是啊，就是分页用的。\n\n我们访问这个 url ： `http://localhost:8080/people?page=0&size=4&sort=lastName`，返回的结果为：\n```\n{\n    \"_embedded\": {\n        \"people\": [\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"bbb\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"ccc\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"ccc\",\n                \"lastName\": \"ccc\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/4\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/4\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"jay\",\n                \"lastName\": \"folger\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    }\n                }\n            }\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people\"\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile/people\"\n        },\n        \"search\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    },\n    \"page\": {\n        \"size\": 4,\n        \"totalElements\": 4,\n        \"totalPages\": 1,\n        \"number\": 0\n    }\n}\n```\n\n从返回的数据我们可以看出： page 当然是页数，size 就是每一页的个数，sort 就是排序的字段，默认为 asc。\n\n这一波测试下来发现这样封装之后之前需要一大堆代码才能实现的分页，这里只需要一个注解即可。妙啊妙不可言。\n\n## 相关链接\n\n- [Accessing JPA Data with REST](https://spring.io/guides/gs/accessing-data-rest/)\n- [Spring Boot之@RepositoryRestResource注解入门使用教程](https://www.jianshu.com/p/3423fa97d185)\n- [GitHub](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest)","source":"_posts/springboot2-datajpa-rest.md","raw":"---\ntitle: Spring JPA Data with REST\ndate: 2019-8-24 10:59:49\ncategories: [开发,总结]\ntags: [Java,SpringBoot2,JPA,REST]\n---\n\n> 逛 Spring 官网学习总结\n\n---\n\n`@RepositoryRestResource` 看到这个注解，之前一直没有用到过，所以想要自己试试效果，顺道做下总结。\n\n**不想要看我废话想要直接看官网的** → [Accessing JPA Data with REST](https://spring.io/guides/gs/accessing-data-rest/)\n\n**不想要看我废话想看大佬的** → [Spring Boot之@RepositoryRestResource注解入门使用教程](https://www.jianshu.com/p/3423fa97d185)\n\n---\n\n## 构建项目\n\n用 Maven 构建项目，建一个 `Person` 实体类，再建一个 `PersonRepository` 接口，这个是关键。\n\n```\npackage hello;\n\nimport java.util.List;\n\nimport org.springframework.data.repository.PagingAndSortingRepository;\nimport org.springframework.data.repository.query.Param;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\n@RepositoryRestResource(collectionResourceRel = \"people\", path = \"people\")\npublic interface PersonRepository extends PagingAndSortingRepository<Person, Long> {\n\n    List<Person> findByLastName(@Param(\"name\") String name);\n\n}\n```\n\n官网是这么介绍的：\n```\nAt runtime, Spring Data REST will create an implementation of this interface automatically. Then it will use the @RepositoryRestResource annotation to direct Spring MVC to create RESTful endpoints at /people.\n```\n\n我们翻译过来就是：\n```\n在运行时，Spring Data REST将自动创建此接口的实现。然后它将会在使用 @RepositoryRestResource 注解的 Spring MVC 在 /people 创建 RESTful 端点。\n```\n\n点进 `PagingAndSortingRepository` 接口看：\n```\n@NoRepositoryBean\npublic interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {\n    Iterable<T> findAll(Sort var1);\n\n    Page<T> findAll(Pageable var1);\n}\n```\n看到该接口还是继承了平时常使用的 `CrudRepository`，这就说明那些基本的增删改查方法也都有。\n\n为了方便，我还写了一个接口用来保存 `Person` 实体，为后续测试使用。\n\n```\n@Service\npublic class PersonService {\n\n    @Autowired\n    PersonRepository personRepository;\n\n    public void savePerson(Person person){\n        personRepository.save(person);\n    }\n}\n```\n\n```\n@RestController\n@RequestMapping(\"/person\")\npublic class PersonController {\n\n    @Autowired\n    PersonService personService;\n\n    @PutMapping(\"/save\")\n    public String savePerson(Person person){\n        personService.savePerson(person);\n        return \"success\";\n    }\n}\n```\n\n很简单的一个映射。\n\n到这为止，我们的项目就全构建好了。\n\n**嫌麻烦不想自己动手建项目的** → [GitHub](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest)\n\n## 测试功能\n\n我这里为了方便，用的是 `Postman` 进行测试。\n\n首先访问 `http://localhost:8080`，返回的是：\n```\n{\n    \"_links\": {\n        \"people\": {\n            \"href\": \"http://localhost:8080/people{?page,size,sort}\",\n            \"templated\": true\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile\"\n        }\n    }\n}\n```\n\n再访问 `http://localhost:8080/people`，返回的是：\n```\n{\n    \"_embedded\": {\n        \"people\": []\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people{?page,size,sort}\",\n            \"templated\": true\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile/people\"\n        },\n        \"search\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    },\n    \"page\": {\n        \"size\": 20,\n        \"totalElements\": 0,\n        \"totalPages\": 0,\n        \"number\": 0\n    }\n}\n```\n\n因为里面没有数据，我们先塞几个数据进去，这时候就利用我们之前写的接口来操作。如下：\n```\n我们用 PUT 方式去请求 http://localhost:8080/person/save?firstName=aaa&lastName=bbb\n\n返回 success 就说明操作成功，成功塞入。\n```\n\n同样的方式我们再多塞几个。\n\n塞完值之后我们接着去访问 `http://localhost:8080/people`，这时候发现结果与之前的稍有不同了：\n```\n{\n    \"_embedded\": {\n        \"people\": [\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"bbb\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"ccc\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"jay\",\n                \"lastName\": \"folger\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    }\n                }\n            }\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people{?page,size,sort}\",\n            \"templated\": true\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile/people\"\n        },\n        \"search\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    },\n    \"page\": {\n        \"size\": 20,\n        \"totalElements\": 3,\n        \"totalPages\": 1,\n        \"number\": 0\n    }\n}\n```\n是的，我们刚塞的值都查出来了。\n\n接着测试，访问 `http://localhost:8080/people/1`，返回结果为：\n```\n{\n    \"firstName\": \"aaa\",\n    \"lastName\": \"bbb\",\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people/1\"\n        },\n        \"person\": {\n            \"href\": \"http://localhost:8080/people/1\"\n        }\n    }\n}\n```\n是的，就是第一条数据被查出来了，同理 /2 /3 也是。\n\n访问 `http://localhost:8080/people/search`，返回结果为：\n```\n{\n    \"_links\": {\n        \"findByLastName\": {\n            \"href\": \"http://localhost:8080/people/search/findByLastName{?name}\",\n            \"templated\": true\n        },\n        \"self\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    }\n}\n```\n对的，`findByLastName{?name}` 就是我们在里面新增的那个接口，那就顺着这个意思咱们继续来。\n\n访问 `http://localhost:8080/people/search/findByLastName?name=folger`，返回结果为：\n```\n{\n    \"_embedded\": {\n        \"people\": [\n            {\n                \"firstName\": \"jay\",\n                \"lastName\": \"folger\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    }\n                }\n            }\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people/search/findByLastName?name=folger\"\n        }\n    }\n}\n```\n与我们猜测无二。接口写的返回是集合，所以就返回了一个集合。\n\n之前还看到了这么一条 link `\"href\": \"http://localhost:8080/people{?page,size,sort}\"`\n\n有经验的程序员一眼就肯定知道这些个参数都是干什么用的，是啊，就是分页用的。\n\n我们访问这个 url ： `http://localhost:8080/people?page=0&size=4&sort=lastName`，返回的结果为：\n```\n{\n    \"_embedded\": {\n        \"people\": [\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"bbb\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/1\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"aaa\",\n                \"lastName\": \"ccc\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/2\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"ccc\",\n                \"lastName\": \"ccc\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/4\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/4\"\n                    }\n                }\n            },\n            {\n                \"firstName\": \"jay\",\n                \"lastName\": \"folger\",\n                \"_links\": {\n                    \"self\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    },\n                    \"person\": {\n                        \"href\": \"http://localhost:8080/people/3\"\n                    }\n                }\n            }\n        ]\n    },\n    \"_links\": {\n        \"self\": {\n            \"href\": \"http://localhost:8080/people\"\n        },\n        \"profile\": {\n            \"href\": \"http://localhost:8080/profile/people\"\n        },\n        \"search\": {\n            \"href\": \"http://localhost:8080/people/search\"\n        }\n    },\n    \"page\": {\n        \"size\": 4,\n        \"totalElements\": 4,\n        \"totalPages\": 1,\n        \"number\": 0\n    }\n}\n```\n\n从返回的数据我们可以看出： page 当然是页数，size 就是每一页的个数，sort 就是排序的字段，默认为 asc。\n\n这一波测试下来发现这样封装之后之前需要一大堆代码才能实现的分页，这里只需要一个注解即可。妙啊妙不可言。\n\n## 相关链接\n\n- [Accessing JPA Data with REST](https://spring.io/guides/gs/accessing-data-rest/)\n- [Spring Boot之@RepositoryRestResource注解入门使用教程](https://www.jianshu.com/p/3423fa97d185)\n- [GitHub](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest)","slug":"springboot2-datajpa-rest","published":1,"updated":"2023-12-23T15:35:23.823Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhq00b5k9i1ctps2q57","content":"<blockquote>\n<p>逛 Spring 官网学习总结</p>\n</blockquote>\n<hr>\n<p><code>@RepositoryRestResource</code> 看到这个注解，之前一直没有用到过，所以想要自己试试效果，顺道做下总结。</p>\n<p><strong>不想要看我废话想要直接看官网的</strong> → <a href=\"https://spring.io/guides/gs/accessing-data-rest/\">Accessing JPA Data with REST</a></p>\n<p><strong>不想要看我废话想看大佬的</strong> → <a href=\"https://www.jianshu.com/p/3423fa97d185\">Spring Boot之@RepositoryRestResource注解入门使用教程</a></p>\n<hr>\n<h2 id=\"构建项目\"><a href=\"#构建项目\" class=\"headerlink\" title=\"构建项目\"></a>构建项目</h2><p>用 Maven 构建项目，建一个 <code>Person</code> 实体类，再建一个 <code>PersonRepository</code> 接口，这个是关键。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package hello;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.data.repository.PagingAndSortingRepository;</span><br><span class=\"line\">import org.springframework.data.repository.query.Param;</span><br><span class=\"line\">import org.springframework.data.rest.core.annotation.RepositoryRestResource;</span><br><span class=\"line\"></span><br><span class=\"line\">@RepositoryRestResource(collectionResourceRel = &quot;people&quot;, path = &quot;people&quot;)</span><br><span class=\"line\">public interface PersonRepository extends PagingAndSortingRepository&lt;Person, Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Person&gt; findByLastName(@Param(&quot;name&quot;) String name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>官网是这么介绍的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">At runtime, Spring Data REST will create an implementation of this interface automatically. Then it will use the @RepositoryRestResource annotation to direct Spring MVC to create RESTful endpoints at /people.</span><br></pre></td></tr></table></figure>\n\n<p>我们翻译过来就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在运行时，Spring Data REST将自动创建此接口的实现。然后它将会在使用 @RepositoryRestResource 注解的 Spring MVC 在 /people 创建 RESTful 端点。</span><br></pre></td></tr></table></figure>\n\n<p>点进 <code>PagingAndSortingRepository</code> 接口看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NoRepositoryBean</span><br><span class=\"line\">public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123;</span><br><span class=\"line\">    Iterable&lt;T&gt; findAll(Sort var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Page&lt;T&gt; findAll(Pageable var1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到该接口还是继承了平时常使用的 <code>CrudRepository</code>，这就说明那些基本的增删改查方法也都有。</p>\n<p>为了方便，我还写了一个接口用来保存 <code>Person</code> 实体，为后续测试使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class PersonService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    PersonRepository personRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void savePerson(Person person)&#123;</span><br><span class=\"line\">        personRepository.save(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/person&quot;)</span><br><span class=\"line\">public class PersonController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PutMapping(&quot;/save&quot;)</span><br><span class=\"line\">    public String savePerson(Person person)&#123;</span><br><span class=\"line\">        personService.savePerson(person);</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单的一个映射。</p>\n<p>到这为止，我们的项目就全构建好了。</p>\n<p><strong>嫌麻烦不想自己动手建项目的</strong> → <a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest\">GitHub</a></p>\n<h2 id=\"测试功能\"><a href=\"#测试功能\" class=\"headerlink\" title=\"测试功能\"></a>测试功能</h2><p>我这里为了方便，用的是 <code>Postman</code> 进行测试。</p>\n<p>首先访问 <code>http://localhost:8080</code>，返回的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再访问 <code>http://localhost:8080/people</code>，返回的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: []</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;search&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;page&quot;: &#123;</span><br><span class=\"line\">        &quot;size&quot;: 20,</span><br><span class=\"line\">        &quot;totalElements&quot;: 0,</span><br><span class=\"line\">        &quot;totalPages&quot;: 0,</span><br><span class=\"line\">        &quot;number&quot;: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为里面没有数据，我们先塞几个数据进去，这时候就利用我们之前写的接口来操作。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们用 PUT 方式去请求 http://localhost:8080/person/save?firstName=aaa&amp;lastName=bbb</span><br><span class=\"line\"></span><br><span class=\"line\">返回 success 就说明操作成功，成功塞入。</span><br></pre></td></tr></table></figure>\n\n<p>同样的方式我们再多塞几个。</p>\n<p>塞完值之后我们接着去访问 <code>http://localhost:8080/people</code>，这时候发现结果与之前的稍有不同了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;bbb&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;jay&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;folger&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;search&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;page&quot;: &#123;</span><br><span class=\"line\">        &quot;size&quot;: 20,</span><br><span class=\"line\">        &quot;totalElements&quot;: 3,</span><br><span class=\"line\">        &quot;totalPages&quot;: 1,</span><br><span class=\"line\">        &quot;number&quot;: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是的，我们刚塞的值都查出来了。</p>\n<p>接着测试，访问 <code>http://localhost:8080/people/1</code>，返回结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">    &quot;lastName&quot;: &quot;bbb&quot;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;person&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是的，就是第一条数据被查出来了，同理 &#x2F;2 &#x2F;3 也是。</p>\n<p>访问 <code>http://localhost:8080/people/search</code>，返回结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;findByLastName&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search/findByLastName&#123;?name&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对的，<code>findByLastName&#123;?name&#125;</code> 就是我们在里面新增的那个接口，那就顺着这个意思咱们继续来。</p>\n<p>访问 <code>http://localhost:8080/people/search/findByLastName?name=folger</code>，返回结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;jay&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;folger&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search/findByLastName?name=folger&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与我们猜测无二。接口写的返回是集合，所以就返回了一个集合。</p>\n<p>之前还看到了这么一条 link <code>&quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;</code></p>\n<p>有经验的程序员一眼就肯定知道这些个参数都是干什么用的，是啊，就是分页用的。</p>\n<p>我们访问这个 url ： <code>http://localhost:8080/people?page=0&amp;size=4&amp;sort=lastName</code>，返回的结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;bbb&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/4&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/4&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;jay&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;folger&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;search&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;page&quot;: &#123;</span><br><span class=\"line\">        &quot;size&quot;: 4,</span><br><span class=\"line\">        &quot;totalElements&quot;: 4,</span><br><span class=\"line\">        &quot;totalPages&quot;: 1,</span><br><span class=\"line\">        &quot;number&quot;: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从返回的数据我们可以看出： page 当然是页数，size 就是每一页的个数，sort 就是排序的字段，默认为 asc。</p>\n<p>这一波测试下来发现这样封装之后之前需要一大堆代码才能实现的分页，这里只需要一个注解即可。妙啊妙不可言。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><ul>\n<li><a href=\"https://spring.io/guides/gs/accessing-data-rest/\">Accessing JPA Data with REST</a></li>\n<li><a href=\"https://www.jianshu.com/p/3423fa97d185\">Spring Boot之@RepositoryRestResource注解入门使用教程</a></li>\n<li><a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest\">GitHub</a></li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>逛 Spring 官网学习总结</p>\n</blockquote>\n<hr>\n<p><code>@RepositoryRestResource</code> 看到这个注解，之前一直没有用到过，所以想要自己试试效果，顺道做下总结。</p>\n<p><strong>不想要看我废话想要直接看官网的</strong> → <a href=\"https://spring.io/guides/gs/accessing-data-rest/\">Accessing JPA Data with REST</a></p>\n<p><strong>不想要看我废话想看大佬的</strong> → <a href=\"https://www.jianshu.com/p/3423fa97d185\">Spring Boot之@RepositoryRestResource注解入门使用教程</a></p>\n<hr>\n<h2 id=\"构建项目\"><a href=\"#构建项目\" class=\"headerlink\" title=\"构建项目\"></a>构建项目</h2><p>用 Maven 构建项目，建一个 <code>Person</code> 实体类，再建一个 <code>PersonRepository</code> 接口，这个是关键。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package hello;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.data.repository.PagingAndSortingRepository;</span><br><span class=\"line\">import org.springframework.data.repository.query.Param;</span><br><span class=\"line\">import org.springframework.data.rest.core.annotation.RepositoryRestResource;</span><br><span class=\"line\"></span><br><span class=\"line\">@RepositoryRestResource(collectionResourceRel = &quot;people&quot;, path = &quot;people&quot;)</span><br><span class=\"line\">public interface PersonRepository extends PagingAndSortingRepository&lt;Person, Long&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Person&gt; findByLastName(@Param(&quot;name&quot;) String name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>官网是这么介绍的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">At runtime, Spring Data REST will create an implementation of this interface automatically. Then it will use the @RepositoryRestResource annotation to direct Spring MVC to create RESTful endpoints at /people.</span><br></pre></td></tr></table></figure>\n\n<p>我们翻译过来就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在运行时，Spring Data REST将自动创建此接口的实现。然后它将会在使用 @RepositoryRestResource 注解的 Spring MVC 在 /people 创建 RESTful 端点。</span><br></pre></td></tr></table></figure>\n\n<p>点进 <code>PagingAndSortingRepository</code> 接口看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@NoRepositoryBean</span><br><span class=\"line\">public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123;</span><br><span class=\"line\">    Iterable&lt;T&gt; findAll(Sort var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Page&lt;T&gt; findAll(Pageable var1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看到该接口还是继承了平时常使用的 <code>CrudRepository</code>，这就说明那些基本的增删改查方法也都有。</p>\n<p>为了方便，我还写了一个接口用来保存 <code>Person</code> 实体，为后续测试使用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Service</span><br><span class=\"line\">public class PersonService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    PersonRepository personRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void savePerson(Person person)&#123;</span><br><span class=\"line\">        personRepository.save(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/person&quot;)</span><br><span class=\"line\">public class PersonController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PutMapping(&quot;/save&quot;)</span><br><span class=\"line\">    public String savePerson(Person person)&#123;</span><br><span class=\"line\">        personService.savePerson(person);</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很简单的一个映射。</p>\n<p>到这为止，我们的项目就全构建好了。</p>\n<p><strong>嫌麻烦不想自己动手建项目的</strong> → <a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest\">GitHub</a></p>\n<h2 id=\"测试功能\"><a href=\"#测试功能\" class=\"headerlink\" title=\"测试功能\"></a>测试功能</h2><p>我这里为了方便，用的是 <code>Postman</code> 进行测试。</p>\n<p>首先访问 <code>http://localhost:8080</code>，返回的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再访问 <code>http://localhost:8080/people</code>，返回的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: []</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;search&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;page&quot;: &#123;</span><br><span class=\"line\">        &quot;size&quot;: 20,</span><br><span class=\"line\">        &quot;totalElements&quot;: 0,</span><br><span class=\"line\">        &quot;totalPages&quot;: 0,</span><br><span class=\"line\">        &quot;number&quot;: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为里面没有数据，我们先塞几个数据进去，这时候就利用我们之前写的接口来操作。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们用 PUT 方式去请求 http://localhost:8080/person/save?firstName=aaa&amp;lastName=bbb</span><br><span class=\"line\"></span><br><span class=\"line\">返回 success 就说明操作成功，成功塞入。</span><br></pre></td></tr></table></figure>\n\n<p>同样的方式我们再多塞几个。</p>\n<p>塞完值之后我们接着去访问 <code>http://localhost:8080/people</code>，这时候发现结果与之前的稍有不同了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;bbb&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;jay&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;folger&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;search&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;page&quot;: &#123;</span><br><span class=\"line\">        &quot;size&quot;: 20,</span><br><span class=\"line\">        &quot;totalElements&quot;: 3,</span><br><span class=\"line\">        &quot;totalPages&quot;: 1,</span><br><span class=\"line\">        &quot;number&quot;: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是的，我们刚塞的值都查出来了。</p>\n<p>接着测试，访问 <code>http://localhost:8080/people/1</code>，返回结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">    &quot;lastName&quot;: &quot;bbb&quot;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;person&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>是的，就是第一条数据被查出来了，同理 &#x2F;2 &#x2F;3 也是。</p>\n<p>访问 <code>http://localhost:8080/people/search</code>，返回结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;findByLastName&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search/findByLastName&#123;?name&#125;&quot;,</span><br><span class=\"line\">            &quot;templated&quot;: true</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对的，<code>findByLastName&#123;?name&#125;</code> 就是我们在里面新增的那个接口，那就顺着这个意思咱们继续来。</p>\n<p>访问 <code>http://localhost:8080/people/search/findByLastName?name=folger</code>，返回结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;jay&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;folger&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search/findByLastName?name=folger&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与我们猜测无二。接口写的返回是集合，所以就返回了一个集合。</p>\n<p>之前还看到了这么一条 link <code>&quot;href&quot;: &quot;http://localhost:8080/people&#123;?page,size,sort&#125;&quot;</code></p>\n<p>有经验的程序员一眼就肯定知道这些个参数都是干什么用的，是啊，就是分页用的。</p>\n<p>我们访问这个 url ： <code>http://localhost:8080/people?page=0&amp;size=4&amp;sort=lastName</code>，返回的结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;_embedded&quot;: &#123;</span><br><span class=\"line\">        &quot;people&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;bbb&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/1&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;aaa&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/2&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;ccc&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/4&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/4&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;firstName&quot;: &quot;jay&quot;,</span><br><span class=\"line\">                &quot;lastName&quot;: &quot;folger&quot;,</span><br><span class=\"line\">                &quot;_links&quot;: &#123;</span><br><span class=\"line\">                    &quot;self&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    &quot;person&quot;: &#123;</span><br><span class=\"line\">                        &quot;href&quot;: &quot;http://localhost:8080/people/3&quot;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;_links&quot;: &#123;</span><br><span class=\"line\">        &quot;self&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;profile&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/profile/people&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;search&quot;: &#123;</span><br><span class=\"line\">            &quot;href&quot;: &quot;http://localhost:8080/people/search&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;page&quot;: &#123;</span><br><span class=\"line\">        &quot;size&quot;: 4,</span><br><span class=\"line\">        &quot;totalElements&quot;: 4,</span><br><span class=\"line\">        &quot;totalPages&quot;: 1,</span><br><span class=\"line\">        &quot;number&quot;: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从返回的数据我们可以看出： page 当然是页数，size 就是每一页的个数，sort 就是排序的字段，默认为 asc。</p>\n<p>这一波测试下来发现这样封装之后之前需要一大堆代码才能实现的分页，这里只需要一个注解即可。妙啊妙不可言。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><ul>\n<li><a href=\"https://spring.io/guides/gs/accessing-data-rest/\">Accessing JPA Data with REST</a></li>\n<li><a href=\"https://www.jianshu.com/p/3423fa97d185\">Spring Boot之@RepositoryRestResource注解入门使用教程</a></li>\n<li><a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-jpadata-rest\">GitHub</a></li>\n</ul>\n"},{"title":"SpringBoot2 实现邮件发送功能","date":"2019-06-04T08:53:42.000Z","_content":"\n> springboot2 实现邮件发送功能，QQ/Gmail/163/126..\n> \n> 个人博客：[DoubleFJ の Blog](http://putop.top/2019/06/04/springboot2-mail/)\n\n\n效果图如下：![springboot 实现邮件发送](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/spring-boot-mail.png)\n\n### 技术选型\n- **Spring Boot 2.1.3.RELEASE** （原本官网推荐 2.1.5.RELEASE，可是搭建途中发现部分注解未生效，故改之）\n- **Thymeleaf** (用作邮件模板)\n- **JDK 1.8**\n\n### 简要讲解\n#### 依赖以及配置\n这里还是用的 Spring Boot 来整合，自带了模块依赖\n```\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n随着 Spring Boot 热度越来越大，现在从事 Java 的要是不知道 Spring Boot 的存在那就真的很不应该了。本来只是为了取代繁琐的 EJB，一直发展到了如今无所不在的地步。\n\n然后在配置文件中进行对应的配置\n```\nserver:\n  port: 8887\n\nspring:\n  mail:\n    host: smtp.163.com\n    username: ffj0721@163.com\n    password: xxxx # 授权码\n    protocol: smtp\n    properties.mail.smtp.auth: true\n    properties.mail.smtp.port: 994\n    properties.mail.display.sendmail: DoubleFJ\n    properties.mail.display.sendname: Spring Boot Email\n    properties.mail.smtp.starttls.enable: true\n    properties.mail.smtp.starttls.required: true\n    properties.mail.smtp.ssl.enable: true\n    default-encoding: utf-8\n    from: ffj0721@163.com\n```\n一切就是这样的简单清晰。不同的邮件个别配置数据不同，请自行查阅，这里只用 163 做测试。\n\n配置了之后我们开始操刀敲代码，其实只需要调用 JavaMailSender 接口即可，传参实现，已经给我们封装好了。\n\n#### 常用邮件接口\n这里是几个常用的邮件接口：\n```\npackage com.example.springbootmail.service;\nimport javax.mail.MessagingException;\n\n/**\n * 常用邮件接口\n */\npublic interface IMailService {\n    /**\n     * 发送文本邮件\n     * @param to\n     * @param subject\n     * @param content\n     */\n    public void sendSimpleMail(String to, String subject, String content);\n\n    public void sendSimpleMail(String to, String subject, String content, String... cc);\n\n    /**\n     * 发送HTML邮件\n     * @param to\n     * @param subject\n     * @param content\n     * @throws MessagingException\n     */\n    public void sendHtmlMail(String to, String subject, String content) throws MessagingException;\n\n    public void sendHtmlMail(String to, String subject, String content, String... cc);\n\n    /**\n     * 发送带附件的邮件\n     * @param to\n     * @param subject\n     * @param content\n     * @param filePath\n     * @throws MessagingException\n     */\n    public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException;\n\n    public void sendAttachmentsMail(String to, String subject, String content, String filePath, String... cc);\n\n    /**\n     * 发送正文中有静态资源的邮件\n     * @param to\n     * @param subject\n     * @param content\n     * @param rscPath\n     * @param rscId\n     * @throws MessagingException\n     */\n    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException;\n\n    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId, String... cc);\n\n}\n```\n\n#### 接口实现类注入 JavaMailSender\n实现类分别实现上述接口 注入 JavaMailSender\n```\n/**\n * 发送邮件实现类\n */\n@Service\npublic class IMailServiceImpl implements IMailService {\n\n    @Autowired\n    private JavaMailSender mailSender;\n\n    @Value(\"${spring.mail.from}\")\n    private String from;\n```\n其中 `from` 就是配置中我们配置的发送方，直接读取使用。\n\n#### 实现发送文本邮件\n```\n   /**\n     * 发送文本邮件\n     *\n     * @param to\n     *          邮件接收方\n     * @param subject\n     *          邮件标题\n     * @param content\n     *          邮件内容\n     */\n    @Override\n    public void sendSimpleMail(String to, String subject, String content) {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from);\n        message.setTo(to);\n        message.setSubject(subject);\n        message.setText(content);\n        mailSender.send(message);\n    }\n\n    /**\n     *\n     * @param to\n     *          邮件接收方\n     * @param subject\n     *          邮件标题\n     * @param content\n     *          邮件内容\n     * @param cc\n     *          抄送方\n     */\n    @Override\n    public void sendSimpleMail(String to, String subject, String content, String... cc) {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from);\n        message.setTo(to);\n        message.setCc(cc);\n        message.setSubject(subject);\n        message.setText(content);\n        mailSender.send(message);\n    }\n```\n如上所示，三个参数的，第一个是你要发邮件的对象，第二个是邮件标题，第三个是邮件发送的内容，第二个 cc 字符串数组就是需要抄送的对象。\n\n#### 实现发送 HTML 邮件\n```\n/**\n     * 发送 HTML 邮件\n     *\n     * @param to\n     * @param subject\n     * @param content\n     */\n    @Override\n    public void sendHtmlMail(String to, String subject, String content) throws MessagingException {\n        MimeMessage message = mailSender.createMimeMessage();\n\n        // true 表示需要创建一个multipart message\n        MimeMessageHelper helper = new MimeMessageHelper(message, true);\n        helper.setFrom(from);\n        helper.setTo(to);\n        helper.setSubject(subject);\n        helper.setText(content, true);\n\n        mailSender.send(message);\n    }\n```\n\n官网 [MimeMessageHelper](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html) 使用介绍。\n\n#### 实现发送带附件邮件\n```\n    /**\n     * 发送带附件的邮件\n     *\n     * @param to\n     * @param subject\n     * @param content\n     * @param filePath\n     */\n    public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException {\n        MimeMessage message = mailSender.createMimeMessage();\n\n        MimeMessageHelper helper = new MimeMessageHelper(message, true);\n        helper.setFrom(from);\n        helper.setTo(to);\n        helper.setSubject(subject);\n        helper.setText(content, true);\n\n        FileSystemResource file = new FileSystemResource(new File(filePath));\n        // 截取附件名\n        String fileName = filePath.substring(filePath.lastIndexOf(\"/\") + 1);\n        helper.addAttachment(fileName, file);\n\n        mailSender.send(message);\n    }\n```\n这里附件名的截取要按照自己的实际需求来，有人喜欢用 `\\\\`，有人喜欢用 `/`，看具体情况具体分析了。\n\n#### 实现发送正文中有静态资源邮件\n```\n    /**\n     * 发送正文中有静态资源（图片）的邮件\n     *\n     * @param to\n     * @param subject\n     * @param content\n     * @param rscPath\n     * @param rscId\n     */\n    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException {\n        MimeMessage message = mailSender.createMimeMessage();\n\n        MimeMessageHelper helper = new MimeMessageHelper(message, true);\n        helper.setFrom(from);\n        helper.setTo(to);\n        helper.setSubject(subject);\n        helper.setText(content, true);\n\n        FileSystemResource res = new FileSystemResource(new File(rscPath));\n        helper.addInline(rscId, res);\n\n        mailSender.send(message);\n    }\n```\n其中 rscId 是资源的唯一 id，rscPath 就是对应资源的路径。具体待会我们看 Controller 调用方法。\n\n#### 实现发送模板邮件\n前面说了我们选择使用 `Thymeleaf` 作为邮件的模板，那就需要在 POM 文件中加入对应依赖。 \n```\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n然后在 templates 文件夹下新建 mailTemplate.html 页面，我的内容如下：\n```\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>spring-boot-mail test</title>\n    <style>\n        body {\n            text-align: center;\n            margin-left: auto;\n            margin-right: auto;\n        }\n        #welcome {\n            text-align: center;\n        }\n    </style>\n</head>\n<body>\n<div id=\"welcome\">\n    <h3>Welcome To My Friend!</h3>\n\n    GitHub：\n        <a href=\"#\" th:href=\"@{${github_url}}\" target=\"_bank\">\n            <strong>GitHub</strong>\n        </a>\n    <br />\n    <br />\n    个人博客：\n        <a href=\"#\" th:href=\"@{${blog_url}}\" target=\"_bank\">\n            <strong>DoubleFJ の Blog</strong>\n        </a>\n    <br />\n    <br />\n    <img width=\"258px\" height=\"258px\"\n         src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\">\n    <br />微信公众号（诗词鉴赏）\n</div>\n</body>\n</html>\n```\n这个模板自己 DIY 即可，不过对应填充参数不可弄错。例如我上面的是 `github_url` 和 `blog_url`。\n\n[Thymeleaf 官网](https://www.thymeleaf.org/)\n\n#### 调用实现\n\n**MailController.java**\n```\npackage com.example.springbootmail.controller;\n\nimport com.example.springbootmail.service.impl.IMailServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.thymeleaf.TemplateEngine;\nimport org.thymeleaf.context.Context;\n\n@RestController\n@RequestMapping(\"/Mail\")\npublic class MailController {\n\n    private static final String SUCC_MAIL = \"邮件发送成功！\";\n    private static final String FAIL_MAIL = \"邮件发送失败！\";\n\n    // 图片路径\n    private static final String IMG_PATH = \"C:/Users/zjj/Desktop/github/materials/blog/img/WC-GZH.jpg\";\n    // 发送对象\n    private static final String MAIL_TO = \"folgerjun@gmail.com\";\n\n    @Autowired\n    private IMailServiceImpl mailService;\n    @Autowired\n    private TemplateEngine templateEngine;\n\n    @RequestMapping(\"/Email\")\n    public String index(){\n        try {\n            mailService.sendSimpleMail(MAIL_TO,\"这是一封普通的邮件\",\"这是一封普通的SpringBoot测试邮件\");\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/htmlEmail\")\n    public String htmlEmail(){\n        try {\n            mailService.sendHtmlMail(MAIL_TO,\"这是一HTML的邮件\",\"<body>\\n\" +\n                    \"<div id=\\\"welcome\\\">\\n\" +\n                    \"    <h3>Welcome To My Friend!</h3>\\n\" +\n                    \"\\n\" +\n                    \"    GitHub：\\n\" +\n                    \"        <a href=\\\"#\\\" th:href=\\\"@{${github_url}}\\\" target=\\\"_bank\\\">\\n\" +\n                    \"            <strong>GitHub</strong>\\n\" +\n                    \"        </a>\\n\" +\n                    \"    <br />\\n\" +\n                    \"    <br />\\n\" +\n                    \"    个人博客：\\n\" +\n                    \"        <a href=\\\"#\\\" th:href=\\\"@{${blog_url}}\\\" target=\\\"_bank\\\">\\n\" +\n                    \"            <strong>DoubleFJ の Blog</strong>\\n\" +\n                    \"        </a>\\n\" +\n                    \"    <br />\\n\" +\n                    \"    <br />\\n\" +\n                    \"    <img width=\\\"258px\\\" height=\\\"258px\\\"\\n\" +\n                    \"         src=\\\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\\\">\\n\" +\n                    \"    <br />微信公众号（诗词鉴赏）\\n\" +\n                    \"</div>\\n\" +\n                    \"</body>\");\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/attachmentsMail\")\n    public String attachmentsMail(){\n        try {\n            mailService.sendAttachmentsMail(MAIL_TO, \"这是一封带附件的邮件\", \"邮件中有附件，请注意查收！\", IMG_PATH);\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/resourceMail\")\n    public String resourceMail(){\n        try {\n            String rscId = \"DoubleFJ\";\n            String content = \"<html><body>这是有图片的邮件<br/><img src=\\'cid:\" + rscId + \"\\' ></body></html>\";\n            mailService.sendResourceMail(MAIL_TO, \"这邮件中含有图片\", content, IMG_PATH, rscId);\n\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/templateMail\")\n    public String templateMail(){\n        try {\n            Context context = new Context();\n            context.setVariable(\"github_url\", \"https://github.com/Folgerjun\");\n            context.setVariable(\"blog_url\", \"http://putop.top/\");\n            String emailContent = templateEngine.process(\"mailTemplate\", context);\n\n            mailService.sendHtmlMail(MAIL_TO, \"这是模板邮件\", emailContent);\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n}\n```\n\n程序运行后若访问 http://localhost:8887/Mail/Email 页面出现`邮件发送成功！`字样就说明邮件发送已经实现了。\n\n### 相关链接\n\n- [SpringBoot 升级到 2.1.5.RELEASE 后 pom.xml 报 Unknown错误](http://www.wangwenhui.com.cn/archives/232)\n- [SpringBoot 2.x 集成QQ邮箱、网易系邮箱、Gmail邮箱发送邮件](https://blog.csdn.net/zyw_java/article/details/81635375)\n- [Thymeleaf](https://www.thymeleaf.org/)\n- [MimeMessageHelper](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html)","source":"_posts/springboot2-mail.md","raw":"---\ntitle: SpringBoot2 实现邮件发送功能\ndate: 2019-06-04 16:53:42\ncategories: [开发,总结]\ntags: [SpingBoot2,Java]\n---\n\n> springboot2 实现邮件发送功能，QQ/Gmail/163/126..\n> \n> 个人博客：[DoubleFJ の Blog](http://putop.top/2019/06/04/springboot2-mail/)\n\n\n效果图如下：![springboot 实现邮件发送](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/spring-boot-mail.png)\n\n### 技术选型\n- **Spring Boot 2.1.3.RELEASE** （原本官网推荐 2.1.5.RELEASE，可是搭建途中发现部分注解未生效，故改之）\n- **Thymeleaf** (用作邮件模板)\n- **JDK 1.8**\n\n### 简要讲解\n#### 依赖以及配置\n这里还是用的 Spring Boot 来整合，自带了模块依赖\n```\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n随着 Spring Boot 热度越来越大，现在从事 Java 的要是不知道 Spring Boot 的存在那就真的很不应该了。本来只是为了取代繁琐的 EJB，一直发展到了如今无所不在的地步。\n\n然后在配置文件中进行对应的配置\n```\nserver:\n  port: 8887\n\nspring:\n  mail:\n    host: smtp.163.com\n    username: ffj0721@163.com\n    password: xxxx # 授权码\n    protocol: smtp\n    properties.mail.smtp.auth: true\n    properties.mail.smtp.port: 994\n    properties.mail.display.sendmail: DoubleFJ\n    properties.mail.display.sendname: Spring Boot Email\n    properties.mail.smtp.starttls.enable: true\n    properties.mail.smtp.starttls.required: true\n    properties.mail.smtp.ssl.enable: true\n    default-encoding: utf-8\n    from: ffj0721@163.com\n```\n一切就是这样的简单清晰。不同的邮件个别配置数据不同，请自行查阅，这里只用 163 做测试。\n\n配置了之后我们开始操刀敲代码，其实只需要调用 JavaMailSender 接口即可，传参实现，已经给我们封装好了。\n\n#### 常用邮件接口\n这里是几个常用的邮件接口：\n```\npackage com.example.springbootmail.service;\nimport javax.mail.MessagingException;\n\n/**\n * 常用邮件接口\n */\npublic interface IMailService {\n    /**\n     * 发送文本邮件\n     * @param to\n     * @param subject\n     * @param content\n     */\n    public void sendSimpleMail(String to, String subject, String content);\n\n    public void sendSimpleMail(String to, String subject, String content, String... cc);\n\n    /**\n     * 发送HTML邮件\n     * @param to\n     * @param subject\n     * @param content\n     * @throws MessagingException\n     */\n    public void sendHtmlMail(String to, String subject, String content) throws MessagingException;\n\n    public void sendHtmlMail(String to, String subject, String content, String... cc);\n\n    /**\n     * 发送带附件的邮件\n     * @param to\n     * @param subject\n     * @param content\n     * @param filePath\n     * @throws MessagingException\n     */\n    public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException;\n\n    public void sendAttachmentsMail(String to, String subject, String content, String filePath, String... cc);\n\n    /**\n     * 发送正文中有静态资源的邮件\n     * @param to\n     * @param subject\n     * @param content\n     * @param rscPath\n     * @param rscId\n     * @throws MessagingException\n     */\n    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException;\n\n    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId, String... cc);\n\n}\n```\n\n#### 接口实现类注入 JavaMailSender\n实现类分别实现上述接口 注入 JavaMailSender\n```\n/**\n * 发送邮件实现类\n */\n@Service\npublic class IMailServiceImpl implements IMailService {\n\n    @Autowired\n    private JavaMailSender mailSender;\n\n    @Value(\"${spring.mail.from}\")\n    private String from;\n```\n其中 `from` 就是配置中我们配置的发送方，直接读取使用。\n\n#### 实现发送文本邮件\n```\n   /**\n     * 发送文本邮件\n     *\n     * @param to\n     *          邮件接收方\n     * @param subject\n     *          邮件标题\n     * @param content\n     *          邮件内容\n     */\n    @Override\n    public void sendSimpleMail(String to, String subject, String content) {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from);\n        message.setTo(to);\n        message.setSubject(subject);\n        message.setText(content);\n        mailSender.send(message);\n    }\n\n    /**\n     *\n     * @param to\n     *          邮件接收方\n     * @param subject\n     *          邮件标题\n     * @param content\n     *          邮件内容\n     * @param cc\n     *          抄送方\n     */\n    @Override\n    public void sendSimpleMail(String to, String subject, String content, String... cc) {\n        SimpleMailMessage message = new SimpleMailMessage();\n        message.setFrom(from);\n        message.setTo(to);\n        message.setCc(cc);\n        message.setSubject(subject);\n        message.setText(content);\n        mailSender.send(message);\n    }\n```\n如上所示，三个参数的，第一个是你要发邮件的对象，第二个是邮件标题，第三个是邮件发送的内容，第二个 cc 字符串数组就是需要抄送的对象。\n\n#### 实现发送 HTML 邮件\n```\n/**\n     * 发送 HTML 邮件\n     *\n     * @param to\n     * @param subject\n     * @param content\n     */\n    @Override\n    public void sendHtmlMail(String to, String subject, String content) throws MessagingException {\n        MimeMessage message = mailSender.createMimeMessage();\n\n        // true 表示需要创建一个multipart message\n        MimeMessageHelper helper = new MimeMessageHelper(message, true);\n        helper.setFrom(from);\n        helper.setTo(to);\n        helper.setSubject(subject);\n        helper.setText(content, true);\n\n        mailSender.send(message);\n    }\n```\n\n官网 [MimeMessageHelper](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html) 使用介绍。\n\n#### 实现发送带附件邮件\n```\n    /**\n     * 发送带附件的邮件\n     *\n     * @param to\n     * @param subject\n     * @param content\n     * @param filePath\n     */\n    public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException {\n        MimeMessage message = mailSender.createMimeMessage();\n\n        MimeMessageHelper helper = new MimeMessageHelper(message, true);\n        helper.setFrom(from);\n        helper.setTo(to);\n        helper.setSubject(subject);\n        helper.setText(content, true);\n\n        FileSystemResource file = new FileSystemResource(new File(filePath));\n        // 截取附件名\n        String fileName = filePath.substring(filePath.lastIndexOf(\"/\") + 1);\n        helper.addAttachment(fileName, file);\n\n        mailSender.send(message);\n    }\n```\n这里附件名的截取要按照自己的实际需求来，有人喜欢用 `\\\\`，有人喜欢用 `/`，看具体情况具体分析了。\n\n#### 实现发送正文中有静态资源邮件\n```\n    /**\n     * 发送正文中有静态资源（图片）的邮件\n     *\n     * @param to\n     * @param subject\n     * @param content\n     * @param rscPath\n     * @param rscId\n     */\n    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException {\n        MimeMessage message = mailSender.createMimeMessage();\n\n        MimeMessageHelper helper = new MimeMessageHelper(message, true);\n        helper.setFrom(from);\n        helper.setTo(to);\n        helper.setSubject(subject);\n        helper.setText(content, true);\n\n        FileSystemResource res = new FileSystemResource(new File(rscPath));\n        helper.addInline(rscId, res);\n\n        mailSender.send(message);\n    }\n```\n其中 rscId 是资源的唯一 id，rscPath 就是对应资源的路径。具体待会我们看 Controller 调用方法。\n\n#### 实现发送模板邮件\n前面说了我们选择使用 `Thymeleaf` 作为邮件的模板，那就需要在 POM 文件中加入对应依赖。 \n```\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n然后在 templates 文件夹下新建 mailTemplate.html 页面，我的内容如下：\n```\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>spring-boot-mail test</title>\n    <style>\n        body {\n            text-align: center;\n            margin-left: auto;\n            margin-right: auto;\n        }\n        #welcome {\n            text-align: center;\n        }\n    </style>\n</head>\n<body>\n<div id=\"welcome\">\n    <h3>Welcome To My Friend!</h3>\n\n    GitHub：\n        <a href=\"#\" th:href=\"@{${github_url}}\" target=\"_bank\">\n            <strong>GitHub</strong>\n        </a>\n    <br />\n    <br />\n    个人博客：\n        <a href=\"#\" th:href=\"@{${blog_url}}\" target=\"_bank\">\n            <strong>DoubleFJ の Blog</strong>\n        </a>\n    <br />\n    <br />\n    <img width=\"258px\" height=\"258px\"\n         src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\">\n    <br />微信公众号（诗词鉴赏）\n</div>\n</body>\n</html>\n```\n这个模板自己 DIY 即可，不过对应填充参数不可弄错。例如我上面的是 `github_url` 和 `blog_url`。\n\n[Thymeleaf 官网](https://www.thymeleaf.org/)\n\n#### 调用实现\n\n**MailController.java**\n```\npackage com.example.springbootmail.controller;\n\nimport com.example.springbootmail.service.impl.IMailServiceImpl;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.thymeleaf.TemplateEngine;\nimport org.thymeleaf.context.Context;\n\n@RestController\n@RequestMapping(\"/Mail\")\npublic class MailController {\n\n    private static final String SUCC_MAIL = \"邮件发送成功！\";\n    private static final String FAIL_MAIL = \"邮件发送失败！\";\n\n    // 图片路径\n    private static final String IMG_PATH = \"C:/Users/zjj/Desktop/github/materials/blog/img/WC-GZH.jpg\";\n    // 发送对象\n    private static final String MAIL_TO = \"folgerjun@gmail.com\";\n\n    @Autowired\n    private IMailServiceImpl mailService;\n    @Autowired\n    private TemplateEngine templateEngine;\n\n    @RequestMapping(\"/Email\")\n    public String index(){\n        try {\n            mailService.sendSimpleMail(MAIL_TO,\"这是一封普通的邮件\",\"这是一封普通的SpringBoot测试邮件\");\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/htmlEmail\")\n    public String htmlEmail(){\n        try {\n            mailService.sendHtmlMail(MAIL_TO,\"这是一HTML的邮件\",\"<body>\\n\" +\n                    \"<div id=\\\"welcome\\\">\\n\" +\n                    \"    <h3>Welcome To My Friend!</h3>\\n\" +\n                    \"\\n\" +\n                    \"    GitHub：\\n\" +\n                    \"        <a href=\\\"#\\\" th:href=\\\"@{${github_url}}\\\" target=\\\"_bank\\\">\\n\" +\n                    \"            <strong>GitHub</strong>\\n\" +\n                    \"        </a>\\n\" +\n                    \"    <br />\\n\" +\n                    \"    <br />\\n\" +\n                    \"    个人博客：\\n\" +\n                    \"        <a href=\\\"#\\\" th:href=\\\"@{${blog_url}}\\\" target=\\\"_bank\\\">\\n\" +\n                    \"            <strong>DoubleFJ の Blog</strong>\\n\" +\n                    \"        </a>\\n\" +\n                    \"    <br />\\n\" +\n                    \"    <br />\\n\" +\n                    \"    <img width=\\\"258px\\\" height=\\\"258px\\\"\\n\" +\n                    \"         src=\\\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\\\">\\n\" +\n                    \"    <br />微信公众号（诗词鉴赏）\\n\" +\n                    \"</div>\\n\" +\n                    \"</body>\");\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/attachmentsMail\")\n    public String attachmentsMail(){\n        try {\n            mailService.sendAttachmentsMail(MAIL_TO, \"这是一封带附件的邮件\", \"邮件中有附件，请注意查收！\", IMG_PATH);\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/resourceMail\")\n    public String resourceMail(){\n        try {\n            String rscId = \"DoubleFJ\";\n            String content = \"<html><body>这是有图片的邮件<br/><img src=\\'cid:\" + rscId + \"\\' ></body></html>\";\n            mailService.sendResourceMail(MAIL_TO, \"这邮件中含有图片\", content, IMG_PATH, rscId);\n\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n\n    @RequestMapping(\"/templateMail\")\n    public String templateMail(){\n        try {\n            Context context = new Context();\n            context.setVariable(\"github_url\", \"https://github.com/Folgerjun\");\n            context.setVariable(\"blog_url\", \"http://putop.top/\");\n            String emailContent = templateEngine.process(\"mailTemplate\", context);\n\n            mailService.sendHtmlMail(MAIL_TO, \"这是模板邮件\", emailContent);\n        }catch (Exception ex){\n            ex.printStackTrace();\n            return FAIL_MAIL;\n        }\n        return SUCC_MAIL;\n    }\n}\n```\n\n程序运行后若访问 http://localhost:8887/Mail/Email 页面出现`邮件发送成功！`字样就说明邮件发送已经实现了。\n\n### 相关链接\n\n- [SpringBoot 升级到 2.1.5.RELEASE 后 pom.xml 报 Unknown错误](http://www.wangwenhui.com.cn/archives/232)\n- [SpringBoot 2.x 集成QQ邮箱、网易系邮箱、Gmail邮箱发送邮件](https://blog.csdn.net/zyw_java/article/details/81635375)\n- [Thymeleaf](https://www.thymeleaf.org/)\n- [MimeMessageHelper](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html)","slug":"springboot2-mail","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhq00b9k9i16uupgwsb","content":"<blockquote>\n<p>springboot2 实现邮件发送功能，QQ&#x2F;Gmail&#x2F;163&#x2F;126..</p>\n<p>个人博客：<a href=\"http://putop.top/2019/06/04/springboot2-mail/\">DoubleFJ の Blog</a></p>\n</blockquote>\n<p>效果图如下：<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/spring-boot-mail.png\" alt=\"springboot 实现邮件发送\"></p>\n<h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><ul>\n<li><strong>Spring Boot 2.1.3.RELEASE</strong> （原本官网推荐 2.1.5.RELEASE，可是搭建途中发现部分注解未生效，故改之）</li>\n<li><strong>Thymeleaf</strong> (用作邮件模板)</li>\n<li><strong>JDK 1.8</strong></li>\n</ul>\n<h3 id=\"简要讲解\"><a href=\"#简要讲解\" class=\"headerlink\" title=\"简要讲解\"></a>简要讲解</h3><h4 id=\"依赖以及配置\"><a href=\"#依赖以及配置\" class=\"headerlink\" title=\"依赖以及配置\"></a>依赖以及配置</h4><p>这里还是用的 Spring Boot 来整合，自带了模块依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>随着 Spring Boot 热度越来越大，现在从事 Java 的要是不知道 Spring Boot 的存在那就真的很不应该了。本来只是为了取代繁琐的 EJB，一直发展到了如今无所不在的地步。</p>\n<p>然后在配置文件中进行对应的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 8887</span><br><span class=\"line\"></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  mail:</span><br><span class=\"line\">    host: smtp.163.com</span><br><span class=\"line\">    username: ffj0721@163.com</span><br><span class=\"line\">    password: xxxx # 授权码</span><br><span class=\"line\">    protocol: smtp</span><br><span class=\"line\">    properties.mail.smtp.auth: true</span><br><span class=\"line\">    properties.mail.smtp.port: 994</span><br><span class=\"line\">    properties.mail.display.sendmail: DoubleFJ</span><br><span class=\"line\">    properties.mail.display.sendname: Spring Boot Email</span><br><span class=\"line\">    properties.mail.smtp.starttls.enable: true</span><br><span class=\"line\">    properties.mail.smtp.starttls.required: true</span><br><span class=\"line\">    properties.mail.smtp.ssl.enable: true</span><br><span class=\"line\">    default-encoding: utf-8</span><br><span class=\"line\">    from: ffj0721@163.com</span><br></pre></td></tr></table></figure>\n<p>一切就是这样的简单清晰。不同的邮件个别配置数据不同，请自行查阅，这里只用 163 做测试。</p>\n<p>配置了之后我们开始操刀敲代码，其实只需要调用 JavaMailSender 接口即可，传参实现，已经给我们封装好了。</p>\n<h4 id=\"常用邮件接口\"><a href=\"#常用邮件接口\" class=\"headerlink\" title=\"常用邮件接口\"></a>常用邮件接口</h4><p>这里是几个常用的邮件接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.springbootmail.service;</span><br><span class=\"line\">import javax.mail.MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 常用邮件接口</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface IMailService &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送文本邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendSimpleMail(String to, String subject, String content);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendSimpleMail(String to, String subject, String content, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送HTML邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     * @throws MessagingException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendHtmlMail(String to, String subject, String content) throws MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendHtmlMail(String to, String subject, String content, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送带附件的邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     * @param filePath</span><br><span class=\"line\">     * @throws MessagingException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendAttachmentsMail(String to, String subject, String content, String filePath, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送正文中有静态资源的邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     * @param rscPath</span><br><span class=\"line\">     * @param rscId</span><br><span class=\"line\">     * @throws MessagingException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"接口实现类注入-JavaMailSender\"><a href=\"#接口实现类注入-JavaMailSender\" class=\"headerlink\" title=\"接口实现类注入 JavaMailSender\"></a>接口实现类注入 JavaMailSender</h4><p>实现类分别实现上述接口 注入 JavaMailSender</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 发送邮件实现类</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class IMailServiceImpl implements IMailService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private JavaMailSender mailSender;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;spring.mail.from&#125;&quot;)</span><br><span class=\"line\">    private String from;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>from</code> 就是配置中我们配置的发送方，直接读取使用。</p>\n<h4 id=\"实现发送文本邮件\"><a href=\"#实现发送文本邮件\" class=\"headerlink\" title=\"实现发送文本邮件\"></a>实现发送文本邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">  * 发送文本邮件</span><br><span class=\"line\">  *</span><br><span class=\"line\">  * @param to</span><br><span class=\"line\">  *          邮件接收方</span><br><span class=\"line\">  * @param subject</span><br><span class=\"line\">  *          邮件标题</span><br><span class=\"line\">  * @param content</span><br><span class=\"line\">  *          邮件内容</span><br><span class=\"line\">  */</span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> public void sendSimpleMail(String to, String subject, String content) &#123;</span><br><span class=\"line\">     SimpleMailMessage message = new SimpleMailMessage();</span><br><span class=\"line\">     message.setFrom(from);</span><br><span class=\"line\">     message.setTo(to);</span><br><span class=\"line\">     message.setSubject(subject);</span><br><span class=\"line\">     message.setText(content);</span><br><span class=\"line\">     mailSender.send(message);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> /**</span><br><span class=\"line\">  *</span><br><span class=\"line\">  * @param to</span><br><span class=\"line\">  *          邮件接收方</span><br><span class=\"line\">  * @param subject</span><br><span class=\"line\">  *          邮件标题</span><br><span class=\"line\">  * @param content</span><br><span class=\"line\">  *          邮件内容</span><br><span class=\"line\">  * @param cc</span><br><span class=\"line\">  *          抄送方</span><br><span class=\"line\">  */</span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> public void sendSimpleMail(String to, String subject, String content, String... cc) &#123;</span><br><span class=\"line\">     SimpleMailMessage message = new SimpleMailMessage();</span><br><span class=\"line\">     message.setFrom(from);</span><br><span class=\"line\">     message.setTo(to);</span><br><span class=\"line\">     message.setCc(cc);</span><br><span class=\"line\">     message.setSubject(subject);</span><br><span class=\"line\">     message.setText(content);</span><br><span class=\"line\">     mailSender.send(message);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>如上所示，三个参数的，第一个是你要发邮件的对象，第二个是邮件标题，第三个是邮件发送的内容，第二个 cc 字符串数组就是需要抄送的对象。</p>\n<h4 id=\"实现发送-HTML-邮件\"><a href=\"#实现发送-HTML-邮件\" class=\"headerlink\" title=\"实现发送 HTML 邮件\"></a>实现发送 HTML 邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 发送 HTML 邮件</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sendHtmlMail(String to, String subject, String content) throws MessagingException &#123;</span><br><span class=\"line\">        MimeMessage message = mailSender.createMimeMessage();</span><br><span class=\"line\"></span><br><span class=\"line\">        // true 表示需要创建一个multipart message</span><br><span class=\"line\">        MimeMessageHelper helper = new MimeMessageHelper(message, true);</span><br><span class=\"line\">        helper.setFrom(from);</span><br><span class=\"line\">        helper.setTo(to);</span><br><span class=\"line\">        helper.setSubject(subject);</span><br><span class=\"line\">        helper.setText(content, true);</span><br><span class=\"line\"></span><br><span class=\"line\">        mailSender.send(message);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>官网 <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html\">MimeMessageHelper</a> 使用介绍。</p>\n<h4 id=\"实现发送带附件邮件\"><a href=\"#实现发送带附件邮件\" class=\"headerlink\" title=\"实现发送带附件邮件\"></a>实现发送带附件邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 发送带附件的邮件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param to</span><br><span class=\"line\"> * @param subject</span><br><span class=\"line\"> * @param content</span><br><span class=\"line\"> * @param filePath</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException &#123;</span><br><span class=\"line\">    MimeMessage message = mailSender.createMimeMessage();</span><br><span class=\"line\"></span><br><span class=\"line\">    MimeMessageHelper helper = new MimeMessageHelper(message, true);</span><br><span class=\"line\">    helper.setFrom(from);</span><br><span class=\"line\">    helper.setTo(to);</span><br><span class=\"line\">    helper.setSubject(subject);</span><br><span class=\"line\">    helper.setText(content, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    FileSystemResource file = new FileSystemResource(new File(filePath));</span><br><span class=\"line\">    // 截取附件名</span><br><span class=\"line\">    String fileName = filePath.substring(filePath.lastIndexOf(&quot;/&quot;) + 1);</span><br><span class=\"line\">    helper.addAttachment(fileName, file);</span><br><span class=\"line\"></span><br><span class=\"line\">    mailSender.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里附件名的截取要按照自己的实际需求来，有人喜欢用 <code>\\\\</code>，有人喜欢用 <code>/</code>，看具体情况具体分析了。</p>\n<h4 id=\"实现发送正文中有静态资源邮件\"><a href=\"#实现发送正文中有静态资源邮件\" class=\"headerlink\" title=\"实现发送正文中有静态资源邮件\"></a>实现发送正文中有静态资源邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 发送正文中有静态资源（图片）的邮件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param to</span><br><span class=\"line\"> * @param subject</span><br><span class=\"line\"> * @param content</span><br><span class=\"line\"> * @param rscPath</span><br><span class=\"line\"> * @param rscId</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException &#123;</span><br><span class=\"line\">    MimeMessage message = mailSender.createMimeMessage();</span><br><span class=\"line\"></span><br><span class=\"line\">    MimeMessageHelper helper = new MimeMessageHelper(message, true);</span><br><span class=\"line\">    helper.setFrom(from);</span><br><span class=\"line\">    helper.setTo(to);</span><br><span class=\"line\">    helper.setSubject(subject);</span><br><span class=\"line\">    helper.setText(content, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    FileSystemResource res = new FileSystemResource(new File(rscPath));</span><br><span class=\"line\">    helper.addInline(rscId, res);</span><br><span class=\"line\"></span><br><span class=\"line\">    mailSender.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 rscId 是资源的唯一 id，rscPath 就是对应资源的路径。具体待会我们看 Controller 调用方法。</p>\n<h4 id=\"实现发送模板邮件\"><a href=\"#实现发送模板邮件\" class=\"headerlink\" title=\"实现发送模板邮件\"></a>实现发送模板邮件</h4><p>前面说了我们选择使用 <code>Thymeleaf</code> 作为邮件的模板，那就需要在 POM 文件中加入对应依赖。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在 templates 文件夹下新建 mailTemplate.html 页面，我的内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;spring-boot-mail test&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        body &#123;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">            margin-left: auto;</span><br><span class=\"line\">            margin-right: auto;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #welcome &#123;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div id=&quot;welcome&quot;&gt;</span><br><span class=\"line\">    &lt;h3&gt;Welcome To My Friend!&lt;/h3&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    GitHub：</span><br><span class=\"line\">        &lt;a href=&quot;#&quot; th:href=&quot;@&#123;$&#123;github_url&#125;&#125;&quot; target=&quot;_bank&quot;&gt;</span><br><span class=\"line\">            &lt;strong&gt;GitHub&lt;/strong&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    个人博客：</span><br><span class=\"line\">        &lt;a href=&quot;#&quot; th:href=&quot;@&#123;$&#123;blog_url&#125;&#125;&quot; target=&quot;_bank&quot;&gt;</span><br><span class=\"line\">            &lt;strong&gt;DoubleFJ の Blog&lt;/strong&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    &lt;img width=&quot;258px&quot; height=&quot;258px&quot;</span><br><span class=\"line\">         src=&quot;https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg&quot;&gt;</span><br><span class=\"line\">    &lt;br /&gt;微信公众号（诗词鉴赏）</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>这个模板自己 DIY 即可，不过对应填充参数不可弄错。例如我上面的是 <code>github_url</code> 和 <code>blog_url</code>。</p>\n<p><a href=\"https://www.thymeleaf.org/\">Thymeleaf 官网</a></p>\n<h4 id=\"调用实现\"><a href=\"#调用实现\" class=\"headerlink\" title=\"调用实现\"></a>调用实现</h4><p><strong>MailController.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.springbootmail.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.example.springbootmail.service.impl.IMailServiceImpl;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\">import org.thymeleaf.TemplateEngine;</span><br><span class=\"line\">import org.thymeleaf.context.Context;</span><br><span class=\"line\"></span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/Mail&quot;)</span><br><span class=\"line\">public class MailController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final String SUCC_MAIL = &quot;邮件发送成功！&quot;;</span><br><span class=\"line\">    private static final String FAIL_MAIL = &quot;邮件发送失败！&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 图片路径</span><br><span class=\"line\">    private static final String IMG_PATH = &quot;C:/Users/zjj/Desktop/github/materials/blog/img/WC-GZH.jpg&quot;;</span><br><span class=\"line\">    // 发送对象</span><br><span class=\"line\">    private static final String MAIL_TO = &quot;folgerjun@gmail.com&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private IMailServiceImpl mailService;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private TemplateEngine templateEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/Email&quot;)</span><br><span class=\"line\">    public String index()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mailService.sendSimpleMail(MAIL_TO,&quot;这是一封普通的邮件&quot;,&quot;这是一封普通的SpringBoot测试邮件&quot;);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/htmlEmail&quot;)</span><br><span class=\"line\">    public String htmlEmail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mailService.sendHtmlMail(MAIL_TO,&quot;这是一HTML的邮件&quot;,&quot;&lt;body&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;&lt;div id=\\&quot;welcome\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;h3&gt;Welcome To My Friend!&lt;/h3&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;\\n&quot; +</span><br><span class=\"line\">                    &quot;    GitHub：\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;a href=\\&quot;#\\&quot; th:href=\\&quot;@&#123;$&#123;github_url&#125;&#125;\\&quot; target=\\&quot;_bank\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;            &lt;strong&gt;GitHub&lt;/strong&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;/a&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    个人博客：\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;a href=\\&quot;#\\&quot; th:href=\\&quot;@&#123;$&#123;blog_url&#125;&#125;\\&quot; target=\\&quot;_bank\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;            &lt;strong&gt;DoubleFJ の Blog&lt;/strong&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;/a&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;img width=\\&quot;258px\\&quot; height=\\&quot;258px\\&quot;\\n&quot; +</span><br><span class=\"line\">                    &quot;         src=\\&quot;https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;微信公众号（诗词鉴赏）\\n&quot; +</span><br><span class=\"line\">                    &quot;&lt;/div&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;&lt;/body&gt;&quot;);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/attachmentsMail&quot;)</span><br><span class=\"line\">    public String attachmentsMail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mailService.sendAttachmentsMail(MAIL_TO, &quot;这是一封带附件的邮件&quot;, &quot;邮件中有附件，请注意查收！&quot;, IMG_PATH);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/resourceMail&quot;)</span><br><span class=\"line\">    public String resourceMail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String rscId = &quot;DoubleFJ&quot;;</span><br><span class=\"line\">            String content = &quot;&lt;html&gt;&lt;body&gt;这是有图片的邮件&lt;br/&gt;&lt;img src=\\&#x27;cid:&quot; + rscId + &quot;\\&#x27; &gt;&lt;/body&gt;&lt;/html&gt;&quot;;</span><br><span class=\"line\">            mailService.sendResourceMail(MAIL_TO, &quot;这邮件中含有图片&quot;, content, IMG_PATH, rscId);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/templateMail&quot;)</span><br><span class=\"line\">    public String templateMail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Context context = new Context();</span><br><span class=\"line\">            context.setVariable(&quot;github_url&quot;, &quot;https://github.com/Folgerjun&quot;);</span><br><span class=\"line\">            context.setVariable(&quot;blog_url&quot;, &quot;http://putop.top/&quot;);</span><br><span class=\"line\">            String emailContent = templateEngine.process(&quot;mailTemplate&quot;, context);</span><br><span class=\"line\"></span><br><span class=\"line\">            mailService.sendHtmlMail(MAIL_TO, &quot;这是模板邮件&quot;, emailContent);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序运行后若访问 <a href=\"http://localhost:8887/Mail/Email\">http://localhost:8887/Mail/Email</a> 页面出现<code>邮件发送成功！</code>字样就说明邮件发送已经实现了。</p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"http://www.wangwenhui.com.cn/archives/232\">SpringBoot 升级到 2.1.5.RELEASE 后 pom.xml 报 Unknown错误</a></li>\n<li><a href=\"https://blog.csdn.net/zyw_java/article/details/81635375\">SpringBoot 2.x 集成QQ邮箱、网易系邮箱、Gmail邮箱发送邮件</a></li>\n<li><a href=\"https://www.thymeleaf.org/\">Thymeleaf</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html\">MimeMessageHelper</a></li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>springboot2 实现邮件发送功能，QQ&#x2F;Gmail&#x2F;163&#x2F;126..</p>\n<p>个人博客：<a href=\"http://putop.top/2019/06/04/springboot2-mail/\">DoubleFJ の Blog</a></p>\n</blockquote>\n<p>效果图如下：<img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/spring-boot-mail.png\" alt=\"springboot 实现邮件发送\"></p>\n<h3 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h3><ul>\n<li><strong>Spring Boot 2.1.3.RELEASE</strong> （原本官网推荐 2.1.5.RELEASE，可是搭建途中发现部分注解未生效，故改之）</li>\n<li><strong>Thymeleaf</strong> (用作邮件模板)</li>\n<li><strong>JDK 1.8</strong></li>\n</ul>\n<h3 id=\"简要讲解\"><a href=\"#简要讲解\" class=\"headerlink\" title=\"简要讲解\"></a>简要讲解</h3><h4 id=\"依赖以及配置\"><a href=\"#依赖以及配置\" class=\"headerlink\" title=\"依赖以及配置\"></a>依赖以及配置</h4><p>这里还是用的 Spring Boot 来整合，自带了模块依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>随着 Spring Boot 热度越来越大，现在从事 Java 的要是不知道 Spring Boot 的存在那就真的很不应该了。本来只是为了取代繁琐的 EJB，一直发展到了如今无所不在的地步。</p>\n<p>然后在配置文件中进行对应的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 8887</span><br><span class=\"line\"></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  mail:</span><br><span class=\"line\">    host: smtp.163.com</span><br><span class=\"line\">    username: ffj0721@163.com</span><br><span class=\"line\">    password: xxxx # 授权码</span><br><span class=\"line\">    protocol: smtp</span><br><span class=\"line\">    properties.mail.smtp.auth: true</span><br><span class=\"line\">    properties.mail.smtp.port: 994</span><br><span class=\"line\">    properties.mail.display.sendmail: DoubleFJ</span><br><span class=\"line\">    properties.mail.display.sendname: Spring Boot Email</span><br><span class=\"line\">    properties.mail.smtp.starttls.enable: true</span><br><span class=\"line\">    properties.mail.smtp.starttls.required: true</span><br><span class=\"line\">    properties.mail.smtp.ssl.enable: true</span><br><span class=\"line\">    default-encoding: utf-8</span><br><span class=\"line\">    from: ffj0721@163.com</span><br></pre></td></tr></table></figure>\n<p>一切就是这样的简单清晰。不同的邮件个别配置数据不同，请自行查阅，这里只用 163 做测试。</p>\n<p>配置了之后我们开始操刀敲代码，其实只需要调用 JavaMailSender 接口即可，传参实现，已经给我们封装好了。</p>\n<h4 id=\"常用邮件接口\"><a href=\"#常用邮件接口\" class=\"headerlink\" title=\"常用邮件接口\"></a>常用邮件接口</h4><p>这里是几个常用的邮件接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.springbootmail.service;</span><br><span class=\"line\">import javax.mail.MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 常用邮件接口</span><br><span class=\"line\"> */</span><br><span class=\"line\">public interface IMailService &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送文本邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendSimpleMail(String to, String subject, String content);</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendSimpleMail(String to, String subject, String content, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送HTML邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     * @throws MessagingException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendHtmlMail(String to, String subject, String content) throws MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendHtmlMail(String to, String subject, String content, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送带附件的邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     * @param filePath</span><br><span class=\"line\">     * @throws MessagingException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendAttachmentsMail(String to, String subject, String content, String filePath, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发送正文中有静态资源的邮件</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     * @param rscPath</span><br><span class=\"line\">     * @param rscId</span><br><span class=\"line\">     * @throws MessagingException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId, String... cc);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"接口实现类注入-JavaMailSender\"><a href=\"#接口实现类注入-JavaMailSender\" class=\"headerlink\" title=\"接口实现类注入 JavaMailSender\"></a>接口实现类注入 JavaMailSender</h4><p>实现类分别实现上述接口 注入 JavaMailSender</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 发送邮件实现类</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class IMailServiceImpl implements IMailService &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private JavaMailSender mailSender;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;spring.mail.from&#125;&quot;)</span><br><span class=\"line\">    private String from;</span><br></pre></td></tr></table></figure>\n<p>其中 <code>from</code> 就是配置中我们配置的发送方，直接读取使用。</p>\n<h4 id=\"实现发送文本邮件\"><a href=\"#实现发送文本邮件\" class=\"headerlink\" title=\"实现发送文本邮件\"></a>实现发送文本邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">  * 发送文本邮件</span><br><span class=\"line\">  *</span><br><span class=\"line\">  * @param to</span><br><span class=\"line\">  *          邮件接收方</span><br><span class=\"line\">  * @param subject</span><br><span class=\"line\">  *          邮件标题</span><br><span class=\"line\">  * @param content</span><br><span class=\"line\">  *          邮件内容</span><br><span class=\"line\">  */</span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> public void sendSimpleMail(String to, String subject, String content) &#123;</span><br><span class=\"line\">     SimpleMailMessage message = new SimpleMailMessage();</span><br><span class=\"line\">     message.setFrom(from);</span><br><span class=\"line\">     message.setTo(to);</span><br><span class=\"line\">     message.setSubject(subject);</span><br><span class=\"line\">     message.setText(content);</span><br><span class=\"line\">     mailSender.send(message);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> /**</span><br><span class=\"line\">  *</span><br><span class=\"line\">  * @param to</span><br><span class=\"line\">  *          邮件接收方</span><br><span class=\"line\">  * @param subject</span><br><span class=\"line\">  *          邮件标题</span><br><span class=\"line\">  * @param content</span><br><span class=\"line\">  *          邮件内容</span><br><span class=\"line\">  * @param cc</span><br><span class=\"line\">  *          抄送方</span><br><span class=\"line\">  */</span><br><span class=\"line\"> @Override</span><br><span class=\"line\"> public void sendSimpleMail(String to, String subject, String content, String... cc) &#123;</span><br><span class=\"line\">     SimpleMailMessage message = new SimpleMailMessage();</span><br><span class=\"line\">     message.setFrom(from);</span><br><span class=\"line\">     message.setTo(to);</span><br><span class=\"line\">     message.setCc(cc);</span><br><span class=\"line\">     message.setSubject(subject);</span><br><span class=\"line\">     message.setText(content);</span><br><span class=\"line\">     mailSender.send(message);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>如上所示，三个参数的，第一个是你要发邮件的对象，第二个是邮件标题，第三个是邮件发送的内容，第二个 cc 字符串数组就是需要抄送的对象。</p>\n<h4 id=\"实现发送-HTML-邮件\"><a href=\"#实现发送-HTML-邮件\" class=\"headerlink\" title=\"实现发送 HTML 邮件\"></a>实现发送 HTML 邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">     * 发送 HTML 邮件</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param to</span><br><span class=\"line\">     * @param subject</span><br><span class=\"line\">     * @param content</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sendHtmlMail(String to, String subject, String content) throws MessagingException &#123;</span><br><span class=\"line\">        MimeMessage message = mailSender.createMimeMessage();</span><br><span class=\"line\"></span><br><span class=\"line\">        // true 表示需要创建一个multipart message</span><br><span class=\"line\">        MimeMessageHelper helper = new MimeMessageHelper(message, true);</span><br><span class=\"line\">        helper.setFrom(from);</span><br><span class=\"line\">        helper.setTo(to);</span><br><span class=\"line\">        helper.setSubject(subject);</span><br><span class=\"line\">        helper.setText(content, true);</span><br><span class=\"line\"></span><br><span class=\"line\">        mailSender.send(message);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>官网 <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html\">MimeMessageHelper</a> 使用介绍。</p>\n<h4 id=\"实现发送带附件邮件\"><a href=\"#实现发送带附件邮件\" class=\"headerlink\" title=\"实现发送带附件邮件\"></a>实现发送带附件邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 发送带附件的邮件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param to</span><br><span class=\"line\"> * @param subject</span><br><span class=\"line\"> * @param content</span><br><span class=\"line\"> * @param filePath</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void sendAttachmentsMail(String to, String subject, String content, String filePath) throws MessagingException &#123;</span><br><span class=\"line\">    MimeMessage message = mailSender.createMimeMessage();</span><br><span class=\"line\"></span><br><span class=\"line\">    MimeMessageHelper helper = new MimeMessageHelper(message, true);</span><br><span class=\"line\">    helper.setFrom(from);</span><br><span class=\"line\">    helper.setTo(to);</span><br><span class=\"line\">    helper.setSubject(subject);</span><br><span class=\"line\">    helper.setText(content, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    FileSystemResource file = new FileSystemResource(new File(filePath));</span><br><span class=\"line\">    // 截取附件名</span><br><span class=\"line\">    String fileName = filePath.substring(filePath.lastIndexOf(&quot;/&quot;) + 1);</span><br><span class=\"line\">    helper.addAttachment(fileName, file);</span><br><span class=\"line\"></span><br><span class=\"line\">    mailSender.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里附件名的截取要按照自己的实际需求来，有人喜欢用 <code>\\\\</code>，有人喜欢用 <code>/</code>，看具体情况具体分析了。</p>\n<h4 id=\"实现发送正文中有静态资源邮件\"><a href=\"#实现发送正文中有静态资源邮件\" class=\"headerlink\" title=\"实现发送正文中有静态资源邮件\"></a>实现发送正文中有静态资源邮件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 发送正文中有静态资源（图片）的邮件</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param to</span><br><span class=\"line\"> * @param subject</span><br><span class=\"line\"> * @param content</span><br><span class=\"line\"> * @param rscPath</span><br><span class=\"line\"> * @param rscId</span><br><span class=\"line\"> */</span><br><span class=\"line\">public void sendResourceMail(String to, String subject, String content, String rscPath, String rscId) throws MessagingException &#123;</span><br><span class=\"line\">    MimeMessage message = mailSender.createMimeMessage();</span><br><span class=\"line\"></span><br><span class=\"line\">    MimeMessageHelper helper = new MimeMessageHelper(message, true);</span><br><span class=\"line\">    helper.setFrom(from);</span><br><span class=\"line\">    helper.setTo(to);</span><br><span class=\"line\">    helper.setSubject(subject);</span><br><span class=\"line\">    helper.setText(content, true);</span><br><span class=\"line\"></span><br><span class=\"line\">    FileSystemResource res = new FileSystemResource(new File(rscPath));</span><br><span class=\"line\">    helper.addInline(rscId, res);</span><br><span class=\"line\"></span><br><span class=\"line\">    mailSender.send(message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中 rscId 是资源的唯一 id，rscPath 就是对应资源的路径。具体待会我们看 Controller 调用方法。</p>\n<h4 id=\"实现发送模板邮件\"><a href=\"#实现发送模板邮件\" class=\"headerlink\" title=\"实现发送模板邮件\"></a>实现发送模板邮件</h4><p>前面说了我们选择使用 <code>Thymeleaf</code> 作为邮件的模板，那就需要在 POM 文件中加入对应依赖。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>然后在 templates 文件夹下新建 mailTemplate.html 页面，我的内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;spring-boot-mail test&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        body &#123;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">            margin-left: auto;</span><br><span class=\"line\">            margin-right: auto;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #welcome &#123;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div id=&quot;welcome&quot;&gt;</span><br><span class=\"line\">    &lt;h3&gt;Welcome To My Friend!&lt;/h3&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    GitHub：</span><br><span class=\"line\">        &lt;a href=&quot;#&quot; th:href=&quot;@&#123;$&#123;github_url&#125;&#125;&quot; target=&quot;_bank&quot;&gt;</span><br><span class=\"line\">            &lt;strong&gt;GitHub&lt;/strong&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    个人博客：</span><br><span class=\"line\">        &lt;a href=&quot;#&quot; th:href=&quot;@&#123;$&#123;blog_url&#125;&#125;&quot; target=&quot;_bank&quot;&gt;</span><br><span class=\"line\">            &lt;strong&gt;DoubleFJ の Blog&lt;/strong&gt;</span><br><span class=\"line\">        &lt;/a&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    &lt;br /&gt;</span><br><span class=\"line\">    &lt;img width=&quot;258px&quot; height=&quot;258px&quot;</span><br><span class=\"line\">         src=&quot;https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg&quot;&gt;</span><br><span class=\"line\">    &lt;br /&gt;微信公众号（诗词鉴赏）</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>这个模板自己 DIY 即可，不过对应填充参数不可弄错。例如我上面的是 <code>github_url</code> 和 <code>blog_url</code>。</p>\n<p><a href=\"https://www.thymeleaf.org/\">Thymeleaf 官网</a></p>\n<h4 id=\"调用实现\"><a href=\"#调用实现\" class=\"headerlink\" title=\"调用实现\"></a>调用实现</h4><p><strong>MailController.java</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.springbootmail.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.example.springbootmail.service.impl.IMailServiceImpl;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\">import org.thymeleaf.TemplateEngine;</span><br><span class=\"line\">import org.thymeleaf.context.Context;</span><br><span class=\"line\"></span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/Mail&quot;)</span><br><span class=\"line\">public class MailController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final String SUCC_MAIL = &quot;邮件发送成功！&quot;;</span><br><span class=\"line\">    private static final String FAIL_MAIL = &quot;邮件发送失败！&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 图片路径</span><br><span class=\"line\">    private static final String IMG_PATH = &quot;C:/Users/zjj/Desktop/github/materials/blog/img/WC-GZH.jpg&quot;;</span><br><span class=\"line\">    // 发送对象</span><br><span class=\"line\">    private static final String MAIL_TO = &quot;folgerjun@gmail.com&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private IMailServiceImpl mailService;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private TemplateEngine templateEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/Email&quot;)</span><br><span class=\"line\">    public String index()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mailService.sendSimpleMail(MAIL_TO,&quot;这是一封普通的邮件&quot;,&quot;这是一封普通的SpringBoot测试邮件&quot;);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/htmlEmail&quot;)</span><br><span class=\"line\">    public String htmlEmail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mailService.sendHtmlMail(MAIL_TO,&quot;这是一HTML的邮件&quot;,&quot;&lt;body&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;&lt;div id=\\&quot;welcome\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;h3&gt;Welcome To My Friend!&lt;/h3&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;\\n&quot; +</span><br><span class=\"line\">                    &quot;    GitHub：\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;a href=\\&quot;#\\&quot; th:href=\\&quot;@&#123;$&#123;github_url&#125;&#125;\\&quot; target=\\&quot;_bank\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;            &lt;strong&gt;GitHub&lt;/strong&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;/a&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    个人博客：\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;a href=\\&quot;#\\&quot; th:href=\\&quot;@&#123;$&#123;blog_url&#125;&#125;\\&quot; target=\\&quot;_bank\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;            &lt;strong&gt;DoubleFJ の Blog&lt;/strong&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;        &lt;/a&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;img width=\\&quot;258px\\&quot; height=\\&quot;258px\\&quot;\\n&quot; +</span><br><span class=\"line\">                    &quot;         src=\\&quot;https://raw.githubusercontent.com/Folgerjun/materials/master/blog/img/WC-GZH.jpg\\&quot;&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;    &lt;br /&gt;微信公众号（诗词鉴赏）\\n&quot; +</span><br><span class=\"line\">                    &quot;&lt;/div&gt;\\n&quot; +</span><br><span class=\"line\">                    &quot;&lt;/body&gt;&quot;);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/attachmentsMail&quot;)</span><br><span class=\"line\">    public String attachmentsMail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mailService.sendAttachmentsMail(MAIL_TO, &quot;这是一封带附件的邮件&quot;, &quot;邮件中有附件，请注意查收！&quot;, IMG_PATH);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/resourceMail&quot;)</span><br><span class=\"line\">    public String resourceMail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String rscId = &quot;DoubleFJ&quot;;</span><br><span class=\"line\">            String content = &quot;&lt;html&gt;&lt;body&gt;这是有图片的邮件&lt;br/&gt;&lt;img src=\\&#x27;cid:&quot; + rscId + &quot;\\&#x27; &gt;&lt;/body&gt;&lt;/html&gt;&quot;;</span><br><span class=\"line\">            mailService.sendResourceMail(MAIL_TO, &quot;这邮件中含有图片&quot;, content, IMG_PATH, rscId);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/templateMail&quot;)</span><br><span class=\"line\">    public String templateMail()&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Context context = new Context();</span><br><span class=\"line\">            context.setVariable(&quot;github_url&quot;, &quot;https://github.com/Folgerjun&quot;);</span><br><span class=\"line\">            context.setVariable(&quot;blog_url&quot;, &quot;http://putop.top/&quot;);</span><br><span class=\"line\">            String emailContent = templateEngine.process(&quot;mailTemplate&quot;, context);</span><br><span class=\"line\"></span><br><span class=\"line\">            mailService.sendHtmlMail(MAIL_TO, &quot;这是模板邮件&quot;, emailContent);</span><br><span class=\"line\">        &#125;catch (Exception ex)&#123;</span><br><span class=\"line\">            ex.printStackTrace();</span><br><span class=\"line\">            return FAIL_MAIL;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SUCC_MAIL;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序运行后若访问 <a href=\"http://localhost:8887/Mail/Email\">http://localhost:8887/Mail/Email</a> 页面出现<code>邮件发送成功！</code>字样就说明邮件发送已经实现了。</p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"http://www.wangwenhui.com.cn/archives/232\">SpringBoot 升级到 2.1.5.RELEASE 后 pom.xml 报 Unknown错误</a></li>\n<li><a href=\"https://blog.csdn.net/zyw_java/article/details/81635375\">SpringBoot 2.x 集成QQ邮箱、网易系邮箱、Gmail邮箱发送邮件</a></li>\n<li><a href=\"https://www.thymeleaf.org/\">Thymeleaf</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/mail/javamail/MimeMessageHelper.html\">MimeMessageHelper</a></li>\n</ul>\n"},{"title":"SpringBoot2 整合 Sharding JDBC 实现 Mysql 读写分离","date":"2018-12-27T07:20:34.000Z","_content":"\n> 想直接要源码的，[点这里](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-sharding-jdbc)。\n\n---\n\n## 简介\nSharding-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。\n\n- 适用于任何基于 Java 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC\n- 基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等\n- 支持任意实现JDBC规范的数据库。目前支持 MySQL，Oracle，SQLServer 和 PostgreSQL\n\n## 前言\n本例只是简单实现了 Sharding-JDBC 中的读写分离功能，请注意。\n\n**所用到的技术栈及版本：**\n\n- SpringBoot 2.0.4\n    + Spring Data JPA\n    + HikariDataSource\n    + Gson 2.8.5\n    + lombok 1.16.22\n    + mysql-connector-java 5.1.46\n- sharding-jdbc-core 2.0.3\n\n## 主要部分\n\n### 配置文件：application.yml\n```\n# JPA\nspring:\n  jpa:\n    show-sql: true\n    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect\n    hibernate:\n      ddl-auto: create\n\n# Server\nserver:\n  port: 8888\n\n# Sharding JDBC\nsharding:\n  jdbc:\n    data-sources:\n      ds_master:\n        type: com.zaxxer.hikari.HikariDataSource\n        driver-class-name: com.mysql.jdbc.Driver\n        jdbc-url: jdbc:mysql://localhost:3306/master?characterEncoding=utf8&useSSL=false\n        username: root\n        password: root\n      ds_slave:\n        type: com.zaxxer.hikari.HikariDataSource\n        driver-class-name: com.mysql.jdbc.Driver\n        jdbc-url: jdbc:mysql://localhost:3306/slave?characterEncoding=utf8&useSSL=false\n        username: root\n        password: root\n    master-slave-rule:\n      name: ds_ms\n      master-data-source-name: ds_master\n      slave-data-source-names: ds_slave\n      load-balance-algorithm-type: round-robin\n\n```\n这里用的是 springboot2.0 默认的数据库连接池 HikariDataSource\n\n- `load-balance-algorithm-type`：\n查询时的负载均衡算法，目前有2种算法，round_robin（轮询）和random（随机）\n- `master-data-source-name`： 主数据源名称\n- `slave-data-source-names`： 从数据源名称 多个用逗号隔开\n\n### 存放数据源数据：ShardingMasterSlaveConfig.java\n```\npackage com.example.shardingjdbc.config;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport io.shardingjdbc.core.api.config.MasterSlaveRuleConfiguration;\nimport lombok.Data;\n\n/**\n * 存放数据源\n * \n * @author ffj\n *\n */\n@Data\n@ConfigurationProperties(prefix = \"sharding.jdbc\")\npublic class ShardingMasterSlaveConfig {\n\n    private Map<String, HikariDataSource> dataSources = new HashMap<>();\n\n    private MasterSlaveRuleConfiguration masterSlaveRule;\n}\n```\n用了 Lombok 显得简便了些\n\n### 配置数据源：ShardingDataSourceConfig.java\n```\npackage com.example.shardingjdbc.config;\n\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.sql.DataSource;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport io.shardingjdbc.core.api.MasterSlaveDataSourceFactory;\n\n/**\n * 配置数据源详细信息\n * \n * @author ffj\n *\n */\n@Configuration\n@EnableConfigurationProperties(ShardingMasterSlaveConfig.class)\n@ConditionalOnProperty({ \"sharding.jdbc.data-sources.ds_master.jdbc-url\",\n        \"sharding.jdbc.master-slave-rule.master-data-source-name\" })\npublic class ShardingDataSourceConfig {\n\n    private static final Logger log = LoggerFactory.getLogger(ShardingDataSourceConfig.class);\n\n    @Autowired(required = false)\n    private ShardingMasterSlaveConfig shardingMasterSlaveConfig;\n\n    /**\n     * 配置数据源\n     * \n     * @return\n     * @throws SQLException\n     */\n    @Bean(\"dataSource\")\n    public DataSource masterSlaveDataSource() throws SQLException {\n        shardingMasterSlaveConfig.getDataSources().forEach((k, v) -> configDataSource(v));\n        Map<String, DataSource> dataSourceMap = new HashMap<>();\n        dataSourceMap.putAll(shardingMasterSlaveConfig.getDataSources());\n        DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap,\n                shardingMasterSlaveConfig.getMasterSlaveRule(), new HashMap<>());\n        log.info(\"masterSlaveDataSource config complete！！\");\n        return dataSource;\n    }\n\n    /**\n     * 可添加数据源一些配置信息\n     * \n     * @param dataSource\n     */\n    private void configDataSource(HikariDataSource dataSource) {\n        dataSource.setMaximumPoolSize(20);\n        dataSource.setMinimumIdle(5);\n    }\n}\n\n```\n主要的配置内容就是这些了，接下来我们编写几个方法来测试。\n\n## 测试\n- 先创建一个实体类\n\n大众测试实体类，我选 `UserEntity`:\n```\npackage com.example.shardingjdbc.entity;\n\nimport java.io.Serializable;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * 测试用户类\n * \n * @author ffj\n *\n */\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@Entity(name = \"user\")\npublic class UserEntity implements Serializable {\n\n    /**\n     * \n     */\n    private static final long serialVersionUID = -6171110531081112401L;\n    @Id\n    private int id;\n    @Column(length = 32)\n    private String name;\n    @Column(length = 16)\n    private int age;\n\n}\n```\n同样，Lombok 不可少。由于之前 `application.yml` 中 `ddl-auto` 设置的是 `create`，所以每次重启程序都会重新生成空表。\n\n- 我选择 `JPA` 的原因就是它作为简单测试最适合不过了\n```\npackage com.example.shardingjdbc.repository;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport com.example.shardingjdbc.entity.UserEntity;\n\npublic interface UserRepository extends JpaRepository<UserEntity, Integer> {\n\n}\n\n```\n只要继承 `JpaRepository` 就可以了，我们只需要使用它的基本方法即可。\n\n- 写个 `Controller` 类\n```\npackage com.example.shardingjdbc.controller;\n\nimport java.util.List;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.example.shardingjdbc.entity.UserEntity;\nimport com.example.shardingjdbc.service.UserService;\nimport com.google.gson.Gson;\n\n/**\n * 用户测试类\n * \n * @author ffj\n *\n */\n@RestController\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    @PostMapping(\"/save\")\n    public String saveUser() {\n        UserEntity user = new UserEntity(1, \"张三\", 22);\n        userService.saveUser(user);\n        return \"success\";\n    }\n\n    @PostMapping(\"/getUser\")\n    public String getUsers() {\n        List<UserEntity> users = userService.getUsers();\n        return new Gson().toJson(users);\n    }\n\n}\n```\nService 就不贴了，就是简单调用。\n\n方便查看测试结果，这里用 `Gson` 来转化为 `Json` 输出。\n\n- 启动程序\n\n从上到下看启动日志：\n```\n2018-12-27 15:16:12.907  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2018-12-27 15:16:13.132  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2018-12-27 15:16:13.141  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...\n2018-12-27 15:16:13.147  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.\n2018-12-27 15:16:13.148  INFO 2940 --- [           main] c.e.s.config.ShardingDataSourceConfig    : masterSlaveDataSource config complete\n```\n可以看出有两个数据源，没毛病。\n```\nHibernate: drop table if exists user\nHibernate: create table user (id integer not null, age integer, name varchar(32), primary key (id)) engine=InnoDB\n```\n程序启动 `user` 表重建，没毛病。\n```\n2018-12-27 15:16:15.198  INFO 2940 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2018-12-27 15:16:15.550  INFO 2940 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2018-12-27 15:16:15.587  INFO 2940 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''\n2018-12-27 15:16:15.591  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : Started ShardingJdbcApplication in 5.36 seconds (JVM running for 5.725)\n2018-12-27 15:16:15.592  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : ----------启动成功----------\n```\n端口为配置文件中指定的 `8888`，启动成功日志打印，也没毛病，成功。\n\n**注意：启动程序前别忘了先自行创建数据库！**\n\n现在我们在 `slave` 库中执行以下提供的 `sql` 文件，或者自行创建对应表（表结构必须一致，可以先建库然后从主库中复制已生成的表），并在其中添加数据。\n```\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50720\nSource Host           : localhost:3306\nSource Database       : slave\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50720\nFile Encoding         : 65001\n\nDate: 2018-12-27 16:23:00\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL,\n  `age` int(11) DEFAULT NULL,\n  `name` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\nINSERT INTO `user` VALUES ('2', '23', '李四');\n```\n好了，从库中表和数据都有了，进入正题。\n\n- 测试主库插入数据\n我用的是 `Postman` ：选择 `POST` 方式，url：localhost:8888/save，点击 `Send`。\n```\nHibernate: insert into user (age, name, id) values (?, ?, ?) // 打印出这条日志\n```\n返回 `success`，成功执行。查看主数据库中 `user` 表数据，确实插入，成功！\n\n- 测试从库查询数据\n还是 `Postman` ：选择 `POST` 方式，url：localhost:8888/getUser，点击 `Send`。\n```\nHibernate: select userentity0_.id as id1_0_, userentity0_.age as age2_0_, userentity0_.name as name3_0_ from user userentity0_ // 打印出这条日志\n```\n返回： `[{\"id\":2,\"name\":\"李四\",\"age\":23}]`，数据正确，成功！\n\n以上就是 SpringBoot2.0 + ShardingJDBC 实现数据库读写分离的全部内容了。\n\n## 参考博文\n- [springboot2.0中用sharding-jdbc实现读写分离，集成Druid](https://blog.csdn.net/vipbupafeng/article/details/80256958)\n- [Spring Boot中整合Sharding-JDBC读写分离示例](https://juejin.im/post/5b88979bf265da435944018c)","source":"_posts/springboot2-sharding-jdbc.md","raw":"---\ntitle: SpringBoot2 整合 Sharding JDBC 实现 Mysql 读写分离\ndate: 2018-12-27 15:20:34\ncategories: [开发,总结]\ntags: [SpingBoot2,Java,ShardingJDBC]\n---\n\n> 想直接要源码的，[点这里](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-sharding-jdbc)。\n\n---\n\n## 简介\nSharding-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。\n\n- 适用于任何基于 Java 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC\n- 基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等\n- 支持任意实现JDBC规范的数据库。目前支持 MySQL，Oracle，SQLServer 和 PostgreSQL\n\n## 前言\n本例只是简单实现了 Sharding-JDBC 中的读写分离功能，请注意。\n\n**所用到的技术栈及版本：**\n\n- SpringBoot 2.0.4\n    + Spring Data JPA\n    + HikariDataSource\n    + Gson 2.8.5\n    + lombok 1.16.22\n    + mysql-connector-java 5.1.46\n- sharding-jdbc-core 2.0.3\n\n## 主要部分\n\n### 配置文件：application.yml\n```\n# JPA\nspring:\n  jpa:\n    show-sql: true\n    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect\n    hibernate:\n      ddl-auto: create\n\n# Server\nserver:\n  port: 8888\n\n# Sharding JDBC\nsharding:\n  jdbc:\n    data-sources:\n      ds_master:\n        type: com.zaxxer.hikari.HikariDataSource\n        driver-class-name: com.mysql.jdbc.Driver\n        jdbc-url: jdbc:mysql://localhost:3306/master?characterEncoding=utf8&useSSL=false\n        username: root\n        password: root\n      ds_slave:\n        type: com.zaxxer.hikari.HikariDataSource\n        driver-class-name: com.mysql.jdbc.Driver\n        jdbc-url: jdbc:mysql://localhost:3306/slave?characterEncoding=utf8&useSSL=false\n        username: root\n        password: root\n    master-slave-rule:\n      name: ds_ms\n      master-data-source-name: ds_master\n      slave-data-source-names: ds_slave\n      load-balance-algorithm-type: round-robin\n\n```\n这里用的是 springboot2.0 默认的数据库连接池 HikariDataSource\n\n- `load-balance-algorithm-type`：\n查询时的负载均衡算法，目前有2种算法，round_robin（轮询）和random（随机）\n- `master-data-source-name`： 主数据源名称\n- `slave-data-source-names`： 从数据源名称 多个用逗号隔开\n\n### 存放数据源数据：ShardingMasterSlaveConfig.java\n```\npackage com.example.shardingjdbc.config;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport io.shardingjdbc.core.api.config.MasterSlaveRuleConfiguration;\nimport lombok.Data;\n\n/**\n * 存放数据源\n * \n * @author ffj\n *\n */\n@Data\n@ConfigurationProperties(prefix = \"sharding.jdbc\")\npublic class ShardingMasterSlaveConfig {\n\n    private Map<String, HikariDataSource> dataSources = new HashMap<>();\n\n    private MasterSlaveRuleConfiguration masterSlaveRule;\n}\n```\n用了 Lombok 显得简便了些\n\n### 配置数据源：ShardingDataSourceConfig.java\n```\npackage com.example.shardingjdbc.config;\n\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.sql.DataSource;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport com.zaxxer.hikari.HikariDataSource;\n\nimport io.shardingjdbc.core.api.MasterSlaveDataSourceFactory;\n\n/**\n * 配置数据源详细信息\n * \n * @author ffj\n *\n */\n@Configuration\n@EnableConfigurationProperties(ShardingMasterSlaveConfig.class)\n@ConditionalOnProperty({ \"sharding.jdbc.data-sources.ds_master.jdbc-url\",\n        \"sharding.jdbc.master-slave-rule.master-data-source-name\" })\npublic class ShardingDataSourceConfig {\n\n    private static final Logger log = LoggerFactory.getLogger(ShardingDataSourceConfig.class);\n\n    @Autowired(required = false)\n    private ShardingMasterSlaveConfig shardingMasterSlaveConfig;\n\n    /**\n     * 配置数据源\n     * \n     * @return\n     * @throws SQLException\n     */\n    @Bean(\"dataSource\")\n    public DataSource masterSlaveDataSource() throws SQLException {\n        shardingMasterSlaveConfig.getDataSources().forEach((k, v) -> configDataSource(v));\n        Map<String, DataSource> dataSourceMap = new HashMap<>();\n        dataSourceMap.putAll(shardingMasterSlaveConfig.getDataSources());\n        DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap,\n                shardingMasterSlaveConfig.getMasterSlaveRule(), new HashMap<>());\n        log.info(\"masterSlaveDataSource config complete！！\");\n        return dataSource;\n    }\n\n    /**\n     * 可添加数据源一些配置信息\n     * \n     * @param dataSource\n     */\n    private void configDataSource(HikariDataSource dataSource) {\n        dataSource.setMaximumPoolSize(20);\n        dataSource.setMinimumIdle(5);\n    }\n}\n\n```\n主要的配置内容就是这些了，接下来我们编写几个方法来测试。\n\n## 测试\n- 先创建一个实体类\n\n大众测试实体类，我选 `UserEntity`:\n```\npackage com.example.shardingjdbc.entity;\n\nimport java.io.Serializable;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n/**\n * 测试用户类\n * \n * @author ffj\n *\n */\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\n@Entity(name = \"user\")\npublic class UserEntity implements Serializable {\n\n    /**\n     * \n     */\n    private static final long serialVersionUID = -6171110531081112401L;\n    @Id\n    private int id;\n    @Column(length = 32)\n    private String name;\n    @Column(length = 16)\n    private int age;\n\n}\n```\n同样，Lombok 不可少。由于之前 `application.yml` 中 `ddl-auto` 设置的是 `create`，所以每次重启程序都会重新生成空表。\n\n- 我选择 `JPA` 的原因就是它作为简单测试最适合不过了\n```\npackage com.example.shardingjdbc.repository;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport com.example.shardingjdbc.entity.UserEntity;\n\npublic interface UserRepository extends JpaRepository<UserEntity, Integer> {\n\n}\n\n```\n只要继承 `JpaRepository` 就可以了，我们只需要使用它的基本方法即可。\n\n- 写个 `Controller` 类\n```\npackage com.example.shardingjdbc.controller;\n\nimport java.util.List;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.example.shardingjdbc.entity.UserEntity;\nimport com.example.shardingjdbc.service.UserService;\nimport com.google.gson.Gson;\n\n/**\n * 用户测试类\n * \n * @author ffj\n *\n */\n@RestController\npublic class UserController {\n\n    @Resource\n    private UserService userService;\n\n    @PostMapping(\"/save\")\n    public String saveUser() {\n        UserEntity user = new UserEntity(1, \"张三\", 22);\n        userService.saveUser(user);\n        return \"success\";\n    }\n\n    @PostMapping(\"/getUser\")\n    public String getUsers() {\n        List<UserEntity> users = userService.getUsers();\n        return new Gson().toJson(users);\n    }\n\n}\n```\nService 就不贴了，就是简单调用。\n\n方便查看测试结果，这里用 `Gson` 来转化为 `Json` 输出。\n\n- 启动程序\n\n从上到下看启动日志：\n```\n2018-12-27 15:16:12.907  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...\n2018-12-27 15:16:13.132  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.\n2018-12-27 15:16:13.141  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...\n2018-12-27 15:16:13.147  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.\n2018-12-27 15:16:13.148  INFO 2940 --- [           main] c.e.s.config.ShardingDataSourceConfig    : masterSlaveDataSource config complete\n```\n可以看出有两个数据源，没毛病。\n```\nHibernate: drop table if exists user\nHibernate: create table user (id integer not null, age integer, name varchar(32), primary key (id)) engine=InnoDB\n```\n程序启动 `user` 表重建，没毛病。\n```\n2018-12-27 15:16:15.198  INFO 2940 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2018-12-27 15:16:15.550  INFO 2940 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2018-12-27 15:16:15.587  INFO 2940 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''\n2018-12-27 15:16:15.591  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : Started ShardingJdbcApplication in 5.36 seconds (JVM running for 5.725)\n2018-12-27 15:16:15.592  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : ----------启动成功----------\n```\n端口为配置文件中指定的 `8888`，启动成功日志打印，也没毛病，成功。\n\n**注意：启动程序前别忘了先自行创建数据库！**\n\n现在我们在 `slave` 库中执行以下提供的 `sql` 文件，或者自行创建对应表（表结构必须一致，可以先建库然后从主库中复制已生成的表），并在其中添加数据。\n```\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50720\nSource Host           : localhost:3306\nSource Database       : slave\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50720\nFile Encoding         : 65001\n\nDate: 2018-12-27 16:23:00\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL,\n  `age` int(11) DEFAULT NULL,\n  `name` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\nINSERT INTO `user` VALUES ('2', '23', '李四');\n```\n好了，从库中表和数据都有了，进入正题。\n\n- 测试主库插入数据\n我用的是 `Postman` ：选择 `POST` 方式，url：localhost:8888/save，点击 `Send`。\n```\nHibernate: insert into user (age, name, id) values (?, ?, ?) // 打印出这条日志\n```\n返回 `success`，成功执行。查看主数据库中 `user` 表数据，确实插入，成功！\n\n- 测试从库查询数据\n还是 `Postman` ：选择 `POST` 方式，url：localhost:8888/getUser，点击 `Send`。\n```\nHibernate: select userentity0_.id as id1_0_, userentity0_.age as age2_0_, userentity0_.name as name3_0_ from user userentity0_ // 打印出这条日志\n```\n返回： `[{\"id\":2,\"name\":\"李四\",\"age\":23}]`，数据正确，成功！\n\n以上就是 SpringBoot2.0 + ShardingJDBC 实现数据库读写分离的全部内容了。\n\n## 参考博文\n- [springboot2.0中用sharding-jdbc实现读写分离，集成Druid](https://blog.csdn.net/vipbupafeng/article/details/80256958)\n- [Spring Boot中整合Sharding-JDBC读写分离示例](https://juejin.im/post/5b88979bf265da435944018c)","slug":"springboot2-sharding-jdbc","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhq00bck9i1gjd9e45f","content":"<blockquote>\n<p>想直接要源码的，<a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-sharding-jdbc\">点这里</a>。</p>\n</blockquote>\n<hr>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sharding-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p>\n<ul>\n<li>适用于任何基于 Java 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC</li>\n<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等</li>\n<li>支持任意实现JDBC规范的数据库。目前支持 MySQL，Oracle，SQLServer 和 PostgreSQL</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本例只是简单实现了 Sharding-JDBC 中的读写分离功能，请注意。</p>\n<p><strong>所用到的技术栈及版本：</strong></p>\n<ul>\n<li>SpringBoot 2.0.4<ul>\n<li>Spring Data JPA</li>\n<li>HikariDataSource</li>\n<li>Gson 2.8.5</li>\n<li>lombok 1.16.22</li>\n<li>mysql-connector-java 5.1.46</li>\n</ul>\n</li>\n<li>sharding-jdbc-core 2.0.3</li>\n</ul>\n<h2 id=\"主要部分\"><a href=\"#主要部分\" class=\"headerlink\" title=\"主要部分\"></a>主要部分</h2><h3 id=\"配置文件：application-yml\"><a href=\"#配置文件：application-yml\" class=\"headerlink\" title=\"配置文件：application.yml\"></a>配置文件：application.yml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># JPA</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  jpa:</span><br><span class=\"line\">    show-sql: true</span><br><span class=\"line\">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class=\"line\">    hibernate:</span><br><span class=\"line\">      ddl-auto: create</span><br><span class=\"line\"></span><br><span class=\"line\"># Server</span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 8888</span><br><span class=\"line\"></span><br><span class=\"line\"># Sharding JDBC</span><br><span class=\"line\">sharding:</span><br><span class=\"line\">  jdbc:</span><br><span class=\"line\">    data-sources:</span><br><span class=\"line\">      ds_master:</span><br><span class=\"line\">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class=\"line\">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\">        jdbc-url: jdbc:mysql://localhost:3306/master?characterEncoding=utf8&amp;useSSL=false</span><br><span class=\"line\">        username: root</span><br><span class=\"line\">        password: root</span><br><span class=\"line\">      ds_slave:</span><br><span class=\"line\">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class=\"line\">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\">        jdbc-url: jdbc:mysql://localhost:3306/slave?characterEncoding=utf8&amp;useSSL=false</span><br><span class=\"line\">        username: root</span><br><span class=\"line\">        password: root</span><br><span class=\"line\">    master-slave-rule:</span><br><span class=\"line\">      name: ds_ms</span><br><span class=\"line\">      master-data-source-name: ds_master</span><br><span class=\"line\">      slave-data-source-names: ds_slave</span><br><span class=\"line\">      load-balance-algorithm-type: round-robin</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里用的是 springboot2.0 默认的数据库连接池 HikariDataSource</p>\n<ul>\n<li><code>load-balance-algorithm-type</code>：<br>查询时的负载均衡算法，目前有2种算法，round_robin（轮询）和random（随机）</li>\n<li><code>master-data-source-name</code>： 主数据源名称</li>\n<li><code>slave-data-source-names</code>： 从数据源名称 多个用逗号隔开</li>\n</ul>\n<h3 id=\"存放数据源数据：ShardingMasterSlaveConfig-java\"><a href=\"#存放数据源数据：ShardingMasterSlaveConfig-java\" class=\"headerlink\" title=\"存放数据源数据：ShardingMasterSlaveConfig.java\"></a>存放数据源数据：ShardingMasterSlaveConfig.java</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.config;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zaxxer.hikari.HikariDataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">import io.shardingjdbc.core.api.config.MasterSlaveRuleConfiguration;</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 存放数据源</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Data</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;sharding.jdbc&quot;)</span><br><span class=\"line\">public class ShardingMasterSlaveConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Map&lt;String, HikariDataSource&gt; dataSources = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private MasterSlaveRuleConfiguration masterSlaveRule;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用了 Lombok 显得简便了些</p>\n<h3 id=\"配置数据源：ShardingDataSourceConfig-java\"><a href=\"#配置数据源：ShardingDataSourceConfig-java\" class=\"headerlink\" title=\"配置数据源：ShardingDataSourceConfig.java\"></a>配置数据源：ShardingDataSourceConfig.java</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.config;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.sql.SQLException;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.slf4j.Logger;</span><br><span class=\"line\">import org.slf4j.LoggerFactory;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class=\"line\">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class=\"line\">import org.springframework.context.annotation.Bean;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zaxxer.hikari.HikariDataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">import io.shardingjdbc.core.api.MasterSlaveDataSourceFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 配置数据源详细信息</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableConfigurationProperties(ShardingMasterSlaveConfig.class)</span><br><span class=\"line\">@ConditionalOnProperty(&#123; &quot;sharding.jdbc.data-sources.ds_master.jdbc-url&quot;,</span><br><span class=\"line\">        &quot;sharding.jdbc.master-slave-rule.master-data-source-name&quot; &#125;)</span><br><span class=\"line\">public class ShardingDataSourceConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Logger log = LoggerFactory.getLogger(ShardingDataSourceConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired(required = false)</span><br><span class=\"line\">    private ShardingMasterSlaveConfig shardingMasterSlaveConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 配置数据源</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws SQLException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;dataSource&quot;)</span><br><span class=\"line\">    public DataSource masterSlaveDataSource() throws SQLException &#123;</span><br><span class=\"line\">        shardingMasterSlaveConfig.getDataSources().forEach((k, v) -&gt; configDataSource(v));</span><br><span class=\"line\">        Map&lt;String, DataSource&gt; dataSourceMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">        dataSourceMap.putAll(shardingMasterSlaveConfig.getDataSources());</span><br><span class=\"line\">        DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap,</span><br><span class=\"line\">                shardingMasterSlaveConfig.getMasterSlaveRule(), new HashMap&lt;&gt;());</span><br><span class=\"line\">        log.info(&quot;masterSlaveDataSource config complete！！&quot;);</span><br><span class=\"line\">        return dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 可添加数据源一些配置信息</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param dataSource</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void configDataSource(HikariDataSource dataSource) &#123;</span><br><span class=\"line\">        dataSource.setMaximumPoolSize(20);</span><br><span class=\"line\">        dataSource.setMinimumIdle(5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>主要的配置内容就是这些了，接下来我们编写几个方法来测试。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ul>\n<li>先创建一个实体类</li>\n</ul>\n<p>大众测试实体类，我选 <code>UserEntity</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.entity;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.persistence.Column;</span><br><span class=\"line\">import javax.persistence.Entity;</span><br><span class=\"line\">import javax.persistence.Id;</span><br><span class=\"line\"></span><br><span class=\"line\">import lombok.AllArgsConstructor;</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import lombok.NoArgsConstructor;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 测试用户类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@AllArgsConstructor</span><br><span class=\"line\">@NoArgsConstructor</span><br><span class=\"line\">@Data</span><br><span class=\"line\">@Entity(name = &quot;user&quot;)</span><br><span class=\"line\">public class UserEntity implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static final long serialVersionUID = -6171110531081112401L;</span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    @Column(length = 32)</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    @Column(length = 16)</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，Lombok 不可少。由于之前 <code>application.yml</code> 中 <code>ddl-auto</code> 设置的是 <code>create</code>，所以每次重启程序都会重新生成空表。</p>\n<ul>\n<li><p>我选择 <code>JPA</code> 的原因就是它作为简单测试最适合不过了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.repository;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.example.shardingjdbc.entity.UserEntity;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface UserRepository extends JpaRepository&lt;UserEntity, Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>只要继承 <code>JpaRepository</code> 就可以了，我们只需要使用它的基本方法即可。</p>\n</li>\n<li><p>写个 <code>Controller</code> 类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.annotation.Resource;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.example.shardingjdbc.entity.UserEntity;</span><br><span class=\"line\">import com.example.shardingjdbc.service.UserService;</span><br><span class=\"line\">import com.google.gson.Gson;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 用户测试类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/save&quot;)</span><br><span class=\"line\">    public String saveUser() &#123;</span><br><span class=\"line\">        UserEntity user = new UserEntity(1, &quot;张三&quot;, 22);</span><br><span class=\"line\">        userService.saveUser(user);</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/getUser&quot;)</span><br><span class=\"line\">    public String getUsers() &#123;</span><br><span class=\"line\">        List&lt;UserEntity&gt; users = userService.getUsers();</span><br><span class=\"line\">        return new Gson().toJson(users);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 就不贴了，就是简单调用。</p>\n</li>\n</ul>\n<p>方便查看测试结果，这里用 <code>Gson</code> 来转化为 <code>Json</code> 输出。</p>\n<ul>\n<li>启动程序</li>\n</ul>\n<p>从上到下看启动日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-12-27 15:16:12.907  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class=\"line\">2018-12-27 15:16:13.132  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class=\"line\">2018-12-27 15:16:13.141  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...</span><br><span class=\"line\">2018-12-27 15:16:13.147  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.</span><br><span class=\"line\">2018-12-27 15:16:13.148  INFO 2940 --- [           main] c.e.s.config.ShardingDataSourceConfig    : masterSlaveDataSource config complete</span><br></pre></td></tr></table></figure>\n<p>可以看出有两个数据源，没毛病。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hibernate: drop table if exists user</span><br><span class=\"line\">Hibernate: create table user (id integer not null, age integer, name varchar(32), primary key (id)) engine=InnoDB</span><br></pre></td></tr></table></figure>\n<p>程序启动 <code>user</code> 表重建，没毛病。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-12-27 15:16:15.198  INFO 2940 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span><br><span class=\"line\">2018-12-27 15:16:15.550  INFO 2940 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span><br><span class=\"line\">2018-12-27 15:16:15.587  INFO 2940 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path &#x27;&#x27;</span><br><span class=\"line\">2018-12-27 15:16:15.591  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : Started ShardingJdbcApplication in 5.36 seconds (JVM running for 5.725)</span><br><span class=\"line\">2018-12-27 15:16:15.592  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : ----------启动成功----------</span><br></pre></td></tr></table></figure>\n<p>端口为配置文件中指定的 <code>8888</code>，启动成功日志打印，也没毛病，成功。</p>\n<p><strong>注意：启动程序前别忘了先自行创建数据库！</strong></p>\n<p>现在我们在 <code>slave</code> 库中执行以下提供的 <code>sql</code> 文件，或者自行创建对应表（表结构必须一致，可以先建库然后从主库中复制已生成的表），并在其中添加数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">Navicat MySQL Data Transfer</span><br><span class=\"line\"></span><br><span class=\"line\">Source Server         : localhost</span><br><span class=\"line\">Source Server Version : 50720</span><br><span class=\"line\">Source Host           : localhost:3306</span><br><span class=\"line\">Source Database       : slave</span><br><span class=\"line\"></span><br><span class=\"line\">Target Server Type    : MYSQL</span><br><span class=\"line\">Target Server Version : 50720</span><br><span class=\"line\">File Encoding         : 65001</span><br><span class=\"line\"></span><br><span class=\"line\">Date: 2018-12-27 16:23:00</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">SET FOREIGN_KEY_CHECKS=0;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Table structure for user</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">DROP TABLE IF EXISTS `user`;</span><br><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` int(11) NOT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  `name` varchar(32) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Records of user</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">INSERT INTO `user` VALUES (&#x27;2&#x27;, &#x27;23&#x27;, &#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>\n<p>好了，从库中表和数据都有了，进入正题。</p>\n<ul>\n<li><p>测试主库插入数据<br>我用的是 <code>Postman</code> ：选择 <code>POST</code> 方式，url：localhost:8888&#x2F;save，点击 <code>Send</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hibernate: insert into user (age, name, id) values (?, ?, ?) // 打印出这条日志</span><br></pre></td></tr></table></figure>\n<p>返回 <code>success</code>，成功执行。查看主数据库中 <code>user</code> 表数据，确实插入，成功！</p>\n</li>\n<li><p>测试从库查询数据<br>还是 <code>Postman</code> ：选择 <code>POST</code> 方式，url：localhost:8888&#x2F;getUser，点击 <code>Send</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hibernate: select userentity0_.id as id1_0_, userentity0_.age as age2_0_, userentity0_.name as name3_0_ from user userentity0_ // 打印出这条日志</span><br></pre></td></tr></table></figure>\n<p>返回： <code>[&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:23&#125;]</code>，数据正确，成功！</p>\n</li>\n</ul>\n<p>以上就是 SpringBoot2.0 + ShardingJDBC 实现数据库读写分离的全部内容了。</p>\n<h2 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h2><ul>\n<li><a href=\"https://blog.csdn.net/vipbupafeng/article/details/80256958\">springboot2.0中用sharding-jdbc实现读写分离，集成Druid</a></li>\n<li><a href=\"https://juejin.im/post/5b88979bf265da435944018c\">Spring Boot中整合Sharding-JDBC读写分离示例</a></li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>想直接要源码的，<a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-sharding-jdbc\">点这里</a>。</p>\n</blockquote>\n<hr>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Sharding-JDBC 定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p>\n<ul>\n<li>适用于任何基于 Java 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC</li>\n<li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等</li>\n<li>支持任意实现JDBC规范的数据库。目前支持 MySQL，Oracle，SQLServer 和 PostgreSQL</li>\n</ul>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本例只是简单实现了 Sharding-JDBC 中的读写分离功能，请注意。</p>\n<p><strong>所用到的技术栈及版本：</strong></p>\n<ul>\n<li>SpringBoot 2.0.4<ul>\n<li>Spring Data JPA</li>\n<li>HikariDataSource</li>\n<li>Gson 2.8.5</li>\n<li>lombok 1.16.22</li>\n<li>mysql-connector-java 5.1.46</li>\n</ul>\n</li>\n<li>sharding-jdbc-core 2.0.3</li>\n</ul>\n<h2 id=\"主要部分\"><a href=\"#主要部分\" class=\"headerlink\" title=\"主要部分\"></a>主要部分</h2><h3 id=\"配置文件：application-yml\"><a href=\"#配置文件：application-yml\" class=\"headerlink\" title=\"配置文件：application.yml\"></a>配置文件：application.yml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># JPA</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  jpa:</span><br><span class=\"line\">    show-sql: true</span><br><span class=\"line\">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class=\"line\">    hibernate:</span><br><span class=\"line\">      ddl-auto: create</span><br><span class=\"line\"></span><br><span class=\"line\"># Server</span><br><span class=\"line\">server:</span><br><span class=\"line\">  port: 8888</span><br><span class=\"line\"></span><br><span class=\"line\"># Sharding JDBC</span><br><span class=\"line\">sharding:</span><br><span class=\"line\">  jdbc:</span><br><span class=\"line\">    data-sources:</span><br><span class=\"line\">      ds_master:</span><br><span class=\"line\">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class=\"line\">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\">        jdbc-url: jdbc:mysql://localhost:3306/master?characterEncoding=utf8&amp;useSSL=false</span><br><span class=\"line\">        username: root</span><br><span class=\"line\">        password: root</span><br><span class=\"line\">      ds_slave:</span><br><span class=\"line\">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class=\"line\">        driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\">        jdbc-url: jdbc:mysql://localhost:3306/slave?characterEncoding=utf8&amp;useSSL=false</span><br><span class=\"line\">        username: root</span><br><span class=\"line\">        password: root</span><br><span class=\"line\">    master-slave-rule:</span><br><span class=\"line\">      name: ds_ms</span><br><span class=\"line\">      master-data-source-name: ds_master</span><br><span class=\"line\">      slave-data-source-names: ds_slave</span><br><span class=\"line\">      load-balance-algorithm-type: round-robin</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里用的是 springboot2.0 默认的数据库连接池 HikariDataSource</p>\n<ul>\n<li><code>load-balance-algorithm-type</code>：<br>查询时的负载均衡算法，目前有2种算法，round_robin（轮询）和random（随机）</li>\n<li><code>master-data-source-name</code>： 主数据源名称</li>\n<li><code>slave-data-source-names</code>： 从数据源名称 多个用逗号隔开</li>\n</ul>\n<h3 id=\"存放数据源数据：ShardingMasterSlaveConfig-java\"><a href=\"#存放数据源数据：ShardingMasterSlaveConfig-java\" class=\"headerlink\" title=\"存放数据源数据：ShardingMasterSlaveConfig.java\"></a>存放数据源数据：ShardingMasterSlaveConfig.java</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.config;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zaxxer.hikari.HikariDataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">import io.shardingjdbc.core.api.config.MasterSlaveRuleConfiguration;</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 存放数据源</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Data</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;sharding.jdbc&quot;)</span><br><span class=\"line\">public class ShardingMasterSlaveConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Map&lt;String, HikariDataSource&gt; dataSources = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    private MasterSlaveRuleConfiguration masterSlaveRule;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用了 Lombok 显得简便了些</p>\n<h3 id=\"配置数据源：ShardingDataSourceConfig-java\"><a href=\"#配置数据源：ShardingDataSourceConfig-java\" class=\"headerlink\" title=\"配置数据源：ShardingDataSourceConfig.java\"></a>配置数据源：ShardingDataSourceConfig.java</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.config;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.sql.SQLException;</span><br><span class=\"line\">import java.util.HashMap;</span><br><span class=\"line\">import java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.sql.DataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.slf4j.Logger;</span><br><span class=\"line\">import org.slf4j.LoggerFactory;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class=\"line\">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class=\"line\">import org.springframework.context.annotation.Bean;</span><br><span class=\"line\">import org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.zaxxer.hikari.HikariDataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">import io.shardingjdbc.core.api.MasterSlaveDataSourceFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 配置数据源详细信息</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">@EnableConfigurationProperties(ShardingMasterSlaveConfig.class)</span><br><span class=\"line\">@ConditionalOnProperty(&#123; &quot;sharding.jdbc.data-sources.ds_master.jdbc-url&quot;,</span><br><span class=\"line\">        &quot;sharding.jdbc.master-slave-rule.master-data-source-name&quot; &#125;)</span><br><span class=\"line\">public class ShardingDataSourceConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Logger log = LoggerFactory.getLogger(ShardingDataSourceConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired(required = false)</span><br><span class=\"line\">    private ShardingMasterSlaveConfig shardingMasterSlaveConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 配置数据源</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     * @throws SQLException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;dataSource&quot;)</span><br><span class=\"line\">    public DataSource masterSlaveDataSource() throws SQLException &#123;</span><br><span class=\"line\">        shardingMasterSlaveConfig.getDataSources().forEach((k, v) -&gt; configDataSource(v));</span><br><span class=\"line\">        Map&lt;String, DataSource&gt; dataSourceMap = new HashMap&lt;&gt;();</span><br><span class=\"line\">        dataSourceMap.putAll(shardingMasterSlaveConfig.getDataSources());</span><br><span class=\"line\">        DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap,</span><br><span class=\"line\">                shardingMasterSlaveConfig.getMasterSlaveRule(), new HashMap&lt;&gt;());</span><br><span class=\"line\">        log.info(&quot;masterSlaveDataSource config complete！！&quot;);</span><br><span class=\"line\">        return dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 可添加数据源一些配置信息</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @param dataSource</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private void configDataSource(HikariDataSource dataSource) &#123;</span><br><span class=\"line\">        dataSource.setMaximumPoolSize(20);</span><br><span class=\"line\">        dataSource.setMinimumIdle(5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>主要的配置内容就是这些了，接下来我们编写几个方法来测试。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><ul>\n<li>先创建一个实体类</li>\n</ul>\n<p>大众测试实体类，我选 <code>UserEntity</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.entity;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.io.Serializable;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.persistence.Column;</span><br><span class=\"line\">import javax.persistence.Entity;</span><br><span class=\"line\">import javax.persistence.Id;</span><br><span class=\"line\"></span><br><span class=\"line\">import lombok.AllArgsConstructor;</span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import lombok.NoArgsConstructor;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 测试用户类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@AllArgsConstructor</span><br><span class=\"line\">@NoArgsConstructor</span><br><span class=\"line\">@Data</span><br><span class=\"line\">@Entity(name = &quot;user&quot;)</span><br><span class=\"line\">public class UserEntity implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static final long serialVersionUID = -6171110531081112401L;</span><br><span class=\"line\">    @Id</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    @Column(length = 32)</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    @Column(length = 16)</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，Lombok 不可少。由于之前 <code>application.yml</code> 中 <code>ddl-auto</code> 设置的是 <code>create</code>，所以每次重启程序都会重新生成空表。</p>\n<ul>\n<li><p>我选择 <code>JPA</code> 的原因就是它作为简单测试最适合不过了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.repository;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.example.shardingjdbc.entity.UserEntity;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface UserRepository extends JpaRepository&lt;UserEntity, Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>只要继承 <code>JpaRepository</code> 就可以了，我们只需要使用它的基本方法即可。</p>\n</li>\n<li><p>写个 <code>Controller</code> 类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.example.shardingjdbc.controller;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">import javax.annotation.Resource;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.example.shardingjdbc.entity.UserEntity;</span><br><span class=\"line\">import com.example.shardingjdbc.service.UserService;</span><br><span class=\"line\">import com.google.gson.Gson;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 用户测试类</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @author ffj</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/save&quot;)</span><br><span class=\"line\">    public String saveUser() &#123;</span><br><span class=\"line\">        UserEntity user = new UserEntity(1, &quot;张三&quot;, 22);</span><br><span class=\"line\">        userService.saveUser(user);</span><br><span class=\"line\">        return &quot;success&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @PostMapping(&quot;/getUser&quot;)</span><br><span class=\"line\">    public String getUsers() &#123;</span><br><span class=\"line\">        List&lt;UserEntity&gt; users = userService.getUsers();</span><br><span class=\"line\">        return new Gson().toJson(users);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Service 就不贴了，就是简单调用。</p>\n</li>\n</ul>\n<p>方便查看测试结果，这里用 <code>Gson</code> 来转化为 <code>Json</code> 输出。</p>\n<ul>\n<li>启动程序</li>\n</ul>\n<p>从上到下看启动日志：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-12-27 15:16:12.907  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class=\"line\">2018-12-27 15:16:13.132  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class=\"line\">2018-12-27 15:16:13.141  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Starting...</span><br><span class=\"line\">2018-12-27 15:16:13.147  INFO 2940 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Start completed.</span><br><span class=\"line\">2018-12-27 15:16:13.148  INFO 2940 --- [           main] c.e.s.config.ShardingDataSourceConfig    : masterSlaveDataSource config complete</span><br></pre></td></tr></table></figure>\n<p>可以看出有两个数据源，没毛病。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hibernate: drop table if exists user</span><br><span class=\"line\">Hibernate: create table user (id integer not null, age integer, name varchar(32), primary key (id)) engine=InnoDB</span><br></pre></td></tr></table></figure>\n<p>程序启动 <code>user</code> 表重建，没毛病。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-12-27 15:16:15.198  INFO 2940 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span><br><span class=\"line\">2018-12-27 15:16:15.550  INFO 2940 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span><br><span class=\"line\">2018-12-27 15:16:15.587  INFO 2940 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path &#x27;&#x27;</span><br><span class=\"line\">2018-12-27 15:16:15.591  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : Started ShardingJdbcApplication in 5.36 seconds (JVM running for 5.725)</span><br><span class=\"line\">2018-12-27 15:16:15.592  INFO 2940 --- [           main] c.e.s.ShardingJdbcApplication            : ----------启动成功----------</span><br></pre></td></tr></table></figure>\n<p>端口为配置文件中指定的 <code>8888</code>，启动成功日志打印，也没毛病，成功。</p>\n<p><strong>注意：启动程序前别忘了先自行创建数据库！</strong></p>\n<p>现在我们在 <code>slave</code> 库中执行以下提供的 <code>sql</code> 文件，或者自行创建对应表（表结构必须一致，可以先建库然后从主库中复制已生成的表），并在其中添加数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">Navicat MySQL Data Transfer</span><br><span class=\"line\"></span><br><span class=\"line\">Source Server         : localhost</span><br><span class=\"line\">Source Server Version : 50720</span><br><span class=\"line\">Source Host           : localhost:3306</span><br><span class=\"line\">Source Database       : slave</span><br><span class=\"line\"></span><br><span class=\"line\">Target Server Type    : MYSQL</span><br><span class=\"line\">Target Server Version : 50720</span><br><span class=\"line\">File Encoding         : 65001</span><br><span class=\"line\"></span><br><span class=\"line\">Date: 2018-12-27 16:23:00</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">SET FOREIGN_KEY_CHECKS=0;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Table structure for user</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">DROP TABLE IF EXISTS `user`;</span><br><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` int(11) NOT NULL,</span><br><span class=\"line\">  `age` int(11) DEFAULT NULL,</span><br><span class=\"line\">  `name` varchar(32) DEFAULT NULL,</span><br><span class=\"line\">  PRIMARY KEY (`id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">-- Records of user</span><br><span class=\"line\">-- ----------------------------</span><br><span class=\"line\">INSERT INTO `user` VALUES (&#x27;2&#x27;, &#x27;23&#x27;, &#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>\n<p>好了，从库中表和数据都有了，进入正题。</p>\n<ul>\n<li><p>测试主库插入数据<br>我用的是 <code>Postman</code> ：选择 <code>POST</code> 方式，url：localhost:8888&#x2F;save，点击 <code>Send</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hibernate: insert into user (age, name, id) values (?, ?, ?) // 打印出这条日志</span><br></pre></td></tr></table></figure>\n<p>返回 <code>success</code>，成功执行。查看主数据库中 <code>user</code> 表数据，确实插入，成功！</p>\n</li>\n<li><p>测试从库查询数据<br>还是 <code>Postman</code> ：选择 <code>POST</code> 方式，url：localhost:8888&#x2F;getUser，点击 <code>Send</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hibernate: select userentity0_.id as id1_0_, userentity0_.age as age2_0_, userentity0_.name as name3_0_ from user userentity0_ // 打印出这条日志</span><br></pre></td></tr></table></figure>\n<p>返回： <code>[&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:23&#125;]</code>，数据正确，成功！</p>\n</li>\n</ul>\n<p>以上就是 SpringBoot2.0 + ShardingJDBC 实现数据库读写分离的全部内容了。</p>\n<h2 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h2><ul>\n<li><a href=\"https://blog.csdn.net/vipbupafeng/article/details/80256958\">springboot2.0中用sharding-jdbc实现读写分离，集成Druid</a></li>\n<li><a href=\"https://juejin.im/post/5b88979bf265da435944018c\">Spring Boot中整合Sharding-JDBC读写分离示例</a></li>\n</ul>\n"},{"title":"SpringBoot2 整合 WebSocket 简单实现聊天室功能","date":"2018-09-11T08:59:25.000Z","_content":"\n>一个很简单的 Demo，可以用 WebSocket 实现简易的聊天室功能\n\n**一反常态，我们先来看一下效果，如下：**\n\n![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/gif/springboot2-websocket-result.gif)\n\n> 嫌麻烦的可以直接去[我的 GitHub ](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-websocket)获取完整无码 Demo。\n\n## 概述\n\n- WebSocket 是什么？\n\nWebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。\n\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\n\n- 为什么需要 WebSocket ？\n\n了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。\n\n这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。\n\n- WebSocket 如何工作？\n\nWeb浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。\n\n基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。\n\n## 实现\n\n首先去 [start.spring.io](https://start.spring.io/) 快速下载一个 springboot Demo，记得选中 `Websocket` 依赖。\n\n然后将项目导入你的 IDE 中。\n\n新建一个 config 类用来注册我们的 websocket bean。\n\n我的是 `WebSocketConfig.java` :\n\n```\n@Configuration\npublic class WebSocketConfig {\n\n    /**\n     * 自动注册使用了@ServerEndpoint注解声明的Websocket endpoint\n     * \n     * @return\n     */\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n\n}\n```\n\n**该加上的注解别忘了加，项目启动时 springboot 会自动去扫描注解的类。**\n\n然后是消息接收处理 websocket 连接、关闭等钩子。\n\n`MyWebSocket.java` :\n\n```\n@ServerEndpoint(value = \"/websocket\")\n@Component\npublic class MyWebSocket {\n\n    // 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static int onlineCount = 0;\n\n    // concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<MyWebSocket>();\n\n    // 与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        webSocketSet.add(this); // 加入set中\n        addOnlineCount(); // 在线数加1\n        System.out.println(\"有新连接加入！当前在线人数为 : \" + getOnlineCount());\n        try {\n            sendMessage(\"您已成功连接！\");\n        } catch (IOException e) {\n            System.out.println(\"IO异常\");\n        }\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this); // 从set中删除\n        subOnlineCount(); // 在线数减1\n        System.out.println(\"有一连接关闭！当前在线人数为 : \" + getOnlineCount());\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     *\n     * @param message\n     *            客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"来自客户端的消息:\" + message);\n\n        // 群发消息\n        for (MyWebSocket item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 发生错误时调用\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        System.out.println(\"发生错误\");\n        error.printStackTrace();\n    }\n\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n        // this.session.getAsyncRemote().sendText(message);\n    }\n\n    /**\n     * 群发自定义消息\n     */\n    public static void sendInfo(String message) throws IOException {\n        for (MyWebSocket item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                continue;\n            }\n        }\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        MyWebSocket.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        MyWebSocket.onlineCount--;\n    }\n}\n\n```\n\n关键就是`@OnOpen`、`@OnClose`等这几个注解了。每个对象有着各自的 session，其中可以存放个人信息。当收到一个客户端消息时，往所有维护着的对象循环 send 了消息，这就简单实现了聊天室的聊天功能了。\n\n其中 websocket session 发送文本消息有两个方法：getAsyncRemote()和 getBasicRemote()。 getAsyncRemote 是非阻塞式的，getBasicRemote 是阻塞式的。\n\n然后我用了 Controller 来简单跳转测试页面，也可以直接访问页面。\n\n`InitController.java` :\n\n```\n@Controller\npublic class InitController {\n\n    @RequestMapping(\"/websocket\")\n    public String init() {\n        return \"websocket.html\";\n    }\n\n}\n```\n\n`websocket.html` :\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>My WebSocket Test</title>\n</head>\n<body>\n\nWelcome<br/>\n<input id=\"text\" type=\"text\" />\n<button onclick=\"send()\">Send</button>\n<button onclick=\"closeWebSocket()\">Close</button>\n<div id=\"message\">\n</div>\n\n</body>\n\n<script type=\"text/javascript\">\n\n    var websocket = null;\n\n    //判断当前浏览器是否支持WebSocket\n    if('WebSocket' in window){\n        websocket = new WebSocket(\"ws://localhost:8080/websocket\");\n    }\n    else{\n        alert('Not support websocket')\n    }\n\n    //连接发生错误的回调方法\n    websocket.onerror = function(){\n        setMessageInnerHTML(\"error\");\n    };\n\n    //连接成功建立的回调方法\n    websocket.onopen = function(event){\n        setMessageInnerHTML(\"open\");\n    }\n\n    //接收到消息的回调方法\n    websocket.onmessage = function(event){\n        setMessageInnerHTML(event.data);\n    }\n\n    //连接关闭的回调方法\n    websocket.onclose = function(){\n        setMessageInnerHTML(\"close\");\n    }\n\n    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n    window.onbeforeunload = function(){\n        websocket.close();\n    }\n\n    //将消息显示在网页上\n    function setMessageInnerHTML(innerHTML){\n        document.getElementById('message').innerHTML += innerHTML + '<br/>';\n    }\n\n    //关闭连接\n    function closeWebSocket(){\n        websocket.close();\n    }\n\n    //发送消息\n    function send(){\n        var message = document.getElementById('text').value;\n        websocket.send(message);\n    }\n</script>\n</html>\n```\n\n要注意，这里没有用到任何模板引擎，所有直接把 `websocket.html` 放在 static 文件夹下就可以访问了。\n\n所有的这些搞好就可以运行了，一个简单的效果就能出来。\n\nEnd.\n\n## 参考\n\n- [WebSocket 详解教程](https://www.cnblogs.com/jingmoxukong/p/7755643.html#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B)\n- [spring boot Websocket（使用笔记）](https://www.cnblogs.com/bianzy/p/5822426.html)\n- [官方 sample](https://github.com/spring-projects/spring-boot/tree/3be3743c90127c4295031e974e570ffb1b9d7fb0/spring-boot-samples/spring-boot-sample-websocket-tomcat)","source":"_posts/springboot2-websocket.md","raw":"---\ntitle: SpringBoot2 整合 WebSocket 简单实现聊天室功能\ndate: 2018-9-11 16:59:25\ncategories: [开发,总结]\ntags: [SpingBoot2,Java,WebSocket]\n---\n\n>一个很简单的 Demo，可以用 WebSocket 实现简易的聊天室功能\n\n**一反常态，我们先来看一下效果，如下：**\n\n![](https://raw.githubusercontent.com/Folgerjun/materials/master/blog/gif/springboot2-websocket-result.gif)\n\n> 嫌麻烦的可以直接去[我的 GitHub ](https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-websocket)获取完整无码 Demo。\n\n## 概述\n\n- WebSocket 是什么？\n\nWebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。\n\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。\n\n- 为什么需要 WebSocket ？\n\n了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。\n\n这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。\n\n- WebSocket 如何工作？\n\nWeb浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。\n\n基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。\n\n## 实现\n\n首先去 [start.spring.io](https://start.spring.io/) 快速下载一个 springboot Demo，记得选中 `Websocket` 依赖。\n\n然后将项目导入你的 IDE 中。\n\n新建一个 config 类用来注册我们的 websocket bean。\n\n我的是 `WebSocketConfig.java` :\n\n```\n@Configuration\npublic class WebSocketConfig {\n\n    /**\n     * 自动注册使用了@ServerEndpoint注解声明的Websocket endpoint\n     * \n     * @return\n     */\n    @Bean\n    public ServerEndpointExporter serverEndpointExporter() {\n        return new ServerEndpointExporter();\n    }\n\n}\n```\n\n**该加上的注解别忘了加，项目启动时 springboot 会自动去扫描注解的类。**\n\n然后是消息接收处理 websocket 连接、关闭等钩子。\n\n`MyWebSocket.java` :\n\n```\n@ServerEndpoint(value = \"/websocket\")\n@Component\npublic class MyWebSocket {\n\n    // 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。\n    private static int onlineCount = 0;\n\n    // concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。\n    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<MyWebSocket>();\n\n    // 与某个客户端的连接会话，需要通过它来给客户端发送数据\n    private Session session;\n\n    /**\n     * 连接建立成功调用的方法\n     */\n    @OnOpen\n    public void onOpen(Session session) {\n        this.session = session;\n        webSocketSet.add(this); // 加入set中\n        addOnlineCount(); // 在线数加1\n        System.out.println(\"有新连接加入！当前在线人数为 : \" + getOnlineCount());\n        try {\n            sendMessage(\"您已成功连接！\");\n        } catch (IOException e) {\n            System.out.println(\"IO异常\");\n        }\n    }\n\n    /**\n     * 连接关闭调用的方法\n     */\n    @OnClose\n    public void onClose() {\n        webSocketSet.remove(this); // 从set中删除\n        subOnlineCount(); // 在线数减1\n        System.out.println(\"有一连接关闭！当前在线人数为 : \" + getOnlineCount());\n    }\n\n    /**\n     * 收到客户端消息后调用的方法\n     *\n     * @param message\n     *            客户端发送过来的消息\n     */\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"来自客户端的消息:\" + message);\n\n        // 群发消息\n        for (MyWebSocket item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    /**\n     * 发生错误时调用\n     */\n    @OnError\n    public void onError(Session session, Throwable error) {\n        System.out.println(\"发生错误\");\n        error.printStackTrace();\n    }\n\n    public void sendMessage(String message) throws IOException {\n        this.session.getBasicRemote().sendText(message);\n        // this.session.getAsyncRemote().sendText(message);\n    }\n\n    /**\n     * 群发自定义消息\n     */\n    public static void sendInfo(String message) throws IOException {\n        for (MyWebSocket item : webSocketSet) {\n            try {\n                item.sendMessage(message);\n            } catch (IOException e) {\n                continue;\n            }\n        }\n    }\n\n    public static synchronized int getOnlineCount() {\n        return onlineCount;\n    }\n\n    public static synchronized void addOnlineCount() {\n        MyWebSocket.onlineCount++;\n    }\n\n    public static synchronized void subOnlineCount() {\n        MyWebSocket.onlineCount--;\n    }\n}\n\n```\n\n关键就是`@OnOpen`、`@OnClose`等这几个注解了。每个对象有着各自的 session，其中可以存放个人信息。当收到一个客户端消息时，往所有维护着的对象循环 send 了消息，这就简单实现了聊天室的聊天功能了。\n\n其中 websocket session 发送文本消息有两个方法：getAsyncRemote()和 getBasicRemote()。 getAsyncRemote 是非阻塞式的，getBasicRemote 是阻塞式的。\n\n然后我用了 Controller 来简单跳转测试页面，也可以直接访问页面。\n\n`InitController.java` :\n\n```\n@Controller\npublic class InitController {\n\n    @RequestMapping(\"/websocket\")\n    public String init() {\n        return \"websocket.html\";\n    }\n\n}\n```\n\n`websocket.html` :\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>My WebSocket Test</title>\n</head>\n<body>\n\nWelcome<br/>\n<input id=\"text\" type=\"text\" />\n<button onclick=\"send()\">Send</button>\n<button onclick=\"closeWebSocket()\">Close</button>\n<div id=\"message\">\n</div>\n\n</body>\n\n<script type=\"text/javascript\">\n\n    var websocket = null;\n\n    //判断当前浏览器是否支持WebSocket\n    if('WebSocket' in window){\n        websocket = new WebSocket(\"ws://localhost:8080/websocket\");\n    }\n    else{\n        alert('Not support websocket')\n    }\n\n    //连接发生错误的回调方法\n    websocket.onerror = function(){\n        setMessageInnerHTML(\"error\");\n    };\n\n    //连接成功建立的回调方法\n    websocket.onopen = function(event){\n        setMessageInnerHTML(\"open\");\n    }\n\n    //接收到消息的回调方法\n    websocket.onmessage = function(event){\n        setMessageInnerHTML(event.data);\n    }\n\n    //连接关闭的回调方法\n    websocket.onclose = function(){\n        setMessageInnerHTML(\"close\");\n    }\n\n    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。\n    window.onbeforeunload = function(){\n        websocket.close();\n    }\n\n    //将消息显示在网页上\n    function setMessageInnerHTML(innerHTML){\n        document.getElementById('message').innerHTML += innerHTML + '<br/>';\n    }\n\n    //关闭连接\n    function closeWebSocket(){\n        websocket.close();\n    }\n\n    //发送消息\n    function send(){\n        var message = document.getElementById('text').value;\n        websocket.send(message);\n    }\n</script>\n</html>\n```\n\n要注意，这里没有用到任何模板引擎，所有直接把 `websocket.html` 放在 static 文件夹下就可以访问了。\n\n所有的这些搞好就可以运行了，一个简单的效果就能出来。\n\nEnd.\n\n## 参考\n\n- [WebSocket 详解教程](https://www.cnblogs.com/jingmoxukong/p/7755643.html#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B)\n- [spring boot Websocket（使用笔记）](https://www.cnblogs.com/bianzy/p/5822426.html)\n- [官方 sample](https://github.com/spring-projects/spring-boot/tree/3be3743c90127c4295031e974e570ffb1b9d7fb0/spring-boot-samples/spring-boot-sample-websocket-tomcat)","slug":"springboot2-websocket","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhq00bhk9i18x317jke","content":"<blockquote>\n<p>一个很简单的 Demo，可以用 WebSocket 实现简易的聊天室功能</p>\n</blockquote>\n<p><strong>一反常态，我们先来看一下效果，如下：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/gif/springboot2-websocket-result.gif\"></p>\n<blockquote>\n<p>嫌麻烦的可以直接去<a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-websocket\">我的 GitHub </a>获取完整无码 Demo。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>WebSocket 是什么？</li>\n</ul>\n<p>WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。</p>\n<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>\n<ul>\n<li>为什么需要 WebSocket ？</li>\n</ul>\n<p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求&#x2F;响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p>\n<p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>\n<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>\n<ul>\n<li>WebSocket 如何工作？</li>\n</ul>\n<p>Web浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>\n<p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>首先去 <a href=\"https://start.spring.io/\">start.spring.io</a> 快速下载一个 springboot Demo，记得选中 <code>Websocket</code> 依赖。</p>\n<p>然后将项目导入你的 IDE 中。</p>\n<p>新建一个 config 类用来注册我们的 websocket bean。</p>\n<p>我的是 <code>WebSocketConfig.java</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class WebSocketConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 自动注册使用了@ServerEndpoint注解声明的Websocket endpoint</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class=\"line\">        return new ServerEndpointExporter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>该加上的注解别忘了加，项目启动时 springboot 会自动去扫描注解的类。</strong></p>\n<p>然后是消息接收处理 websocket 连接、关闭等钩子。</p>\n<p><code>MyWebSocket.java</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ServerEndpoint(value = &quot;/websocket&quot;)</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class MyWebSocket &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span><br><span class=\"line\">    private static int onlineCount = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span><br><span class=\"line\">    private static CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;MyWebSocket&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br><span class=\"line\">    private Session session;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 连接建立成功调用的方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnOpen</span><br><span class=\"line\">    public void onOpen(Session session) &#123;</span><br><span class=\"line\">        this.session = session;</span><br><span class=\"line\">        webSocketSet.add(this); // 加入set中</span><br><span class=\"line\">        addOnlineCount(); // 在线数加1</span><br><span class=\"line\">        System.out.println(&quot;有新连接加入！当前在线人数为 : &quot; + getOnlineCount());</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            sendMessage(&quot;您已成功连接！&quot;);</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            System.out.println(&quot;IO异常&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 连接关闭调用的方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnClose</span><br><span class=\"line\">    public void onClose() &#123;</span><br><span class=\"line\">        webSocketSet.remove(this); // 从set中删除</span><br><span class=\"line\">        subOnlineCount(); // 在线数减1</span><br><span class=\"line\">        System.out.println(&quot;有一连接关闭！当前在线人数为 : &quot; + getOnlineCount());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 收到客户端消息后调用的方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param message</span><br><span class=\"line\">     *            客户端发送过来的消息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnMessage</span><br><span class=\"line\">    public void onMessage(String message, Session session) &#123;</span><br><span class=\"line\">        System.out.println(&quot;来自客户端的消息:&quot; + message);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 群发消息</span><br><span class=\"line\">        for (MyWebSocket item : webSocketSet) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                item.sendMessage(message);</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发生错误时调用</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnError</span><br><span class=\"line\">    public void onError(Session session, Throwable error) &#123;</span><br><span class=\"line\">        System.out.println(&quot;发生错误&quot;);</span><br><span class=\"line\">        error.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendMessage(String message) throws IOException &#123;</span><br><span class=\"line\">        this.session.getBasicRemote().sendText(message);</span><br><span class=\"line\">        // this.session.getAsyncRemote().sendText(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 群发自定义消息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void sendInfo(String message) throws IOException &#123;</span><br><span class=\"line\">        for (MyWebSocket item : webSocketSet) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                item.sendMessage(message);</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static synchronized int getOnlineCount() &#123;</span><br><span class=\"line\">        return onlineCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static synchronized void addOnlineCount() &#123;</span><br><span class=\"line\">        MyWebSocket.onlineCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static synchronized void subOnlineCount() &#123;</span><br><span class=\"line\">        MyWebSocket.onlineCount--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>关键就是<code>@OnOpen</code>、<code>@OnClose</code>等这几个注解了。每个对象有着各自的 session，其中可以存放个人信息。当收到一个客户端消息时，往所有维护着的对象循环 send 了消息，这就简单实现了聊天室的聊天功能了。</p>\n<p>其中 websocket session 发送文本消息有两个方法：getAsyncRemote()和 getBasicRemote()。 getAsyncRemote 是非阻塞式的，getBasicRemote 是阻塞式的。</p>\n<p>然后我用了 Controller 来简单跳转测试页面，也可以直接访问页面。</p>\n<p><code>InitController.java</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class InitController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/websocket&quot;)</span><br><span class=\"line\">    public String init() &#123;</span><br><span class=\"line\">        return &quot;websocket.html&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>websocket.html</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;My WebSocket Test&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome&lt;br/&gt;</span><br><span class=\"line\">&lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;</span><br><span class=\"line\">&lt;button onclick=&quot;send()&quot;&gt;Send&lt;/button&gt;</span><br><span class=\"line\">&lt;button onclick=&quot;closeWebSocket()&quot;&gt;Close&lt;/button&gt;</span><br><span class=\"line\">&lt;div id=&quot;message&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    var websocket = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    //判断当前浏览器是否支持WebSocket</span><br><span class=\"line\">    if(&#x27;WebSocket&#x27; in window)&#123;</span><br><span class=\"line\">        websocket = new WebSocket(&quot;ws://localhost:8080/websocket&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        alert(&#x27;Not support websocket&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接发生错误的回调方法</span><br><span class=\"line\">    websocket.onerror = function()&#123;</span><br><span class=\"line\">        setMessageInnerHTML(&quot;error&quot;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接成功建立的回调方法</span><br><span class=\"line\">    websocket.onopen = function(event)&#123;</span><br><span class=\"line\">        setMessageInnerHTML(&quot;open&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //接收到消息的回调方法</span><br><span class=\"line\">    websocket.onmessage = function(event)&#123;</span><br><span class=\"line\">        setMessageInnerHTML(event.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接关闭的回调方法</span><br><span class=\"line\">    websocket.onclose = function()&#123;</span><br><span class=\"line\">        setMessageInnerHTML(&quot;close&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span><br><span class=\"line\">    window.onbeforeunload = function()&#123;</span><br><span class=\"line\">        websocket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //将消息显示在网页上</span><br><span class=\"line\">    function setMessageInnerHTML(innerHTML)&#123;</span><br><span class=\"line\">        document.getElementById(&#x27;message&#x27;).innerHTML += innerHTML + &#x27;&lt;br/&gt;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭连接</span><br><span class=\"line\">    function closeWebSocket()&#123;</span><br><span class=\"line\">        websocket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //发送消息</span><br><span class=\"line\">    function send()&#123;</span><br><span class=\"line\">        var message = document.getElementById(&#x27;text&#x27;).value;</span><br><span class=\"line\">        websocket.send(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>要注意，这里没有用到任何模板引擎，所有直接把 <code>websocket.html</code> 放在 static 文件夹下就可以访问了。</p>\n<p>所有的这些搞好就可以运行了，一个简单的效果就能出来。</p>\n<p>End.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jingmoxukong/p/7755643.html#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\">WebSocket 详解教程</a></li>\n<li><a href=\"https://www.cnblogs.com/bianzy/p/5822426.html\">spring boot Websocket（使用笔记）</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-boot/tree/3be3743c90127c4295031e974e570ffb1b9d7fb0/spring-boot-samples/spring-boot-sample-websocket-tomcat\">官方 sample</a></li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>一个很简单的 Demo，可以用 WebSocket 实现简易的聊天室功能</p>\n</blockquote>\n<p><strong>一反常态，我们先来看一下效果，如下：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Folgerjun/materials/master/blog/gif/springboot2-websocket-result.gif\"></p>\n<blockquote>\n<p>嫌麻烦的可以直接去<a href=\"https://github.com/Folgerjun/various-simple-examples/tree/master/spring-boot-websocket\">我的 GitHub </a>获取完整无码 Demo。</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li>WebSocket 是什么？</li>\n</ul>\n<p>WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。</p>\n<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>\n<ul>\n<li>为什么需要 WebSocket ？</li>\n</ul>\n<p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求&#x2F;响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p>\n<p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>\n<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步 JavaScript 和 XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p>\n<ul>\n<li>WebSocket 如何工作？</li>\n</ul>\n<p>Web浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>\n<p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>首先去 <a href=\"https://start.spring.io/\">start.spring.io</a> 快速下载一个 springboot Demo，记得选中 <code>Websocket</code> 依赖。</p>\n<p>然后将项目导入你的 IDE 中。</p>\n<p>新建一个 config 类用来注册我们的 websocket bean。</p>\n<p>我的是 <code>WebSocketConfig.java</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">public class WebSocketConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 自动注册使用了@ServerEndpoint注解声明的Websocket endpoint</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class=\"line\">        return new ServerEndpointExporter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>该加上的注解别忘了加，项目启动时 springboot 会自动去扫描注解的类。</strong></p>\n<p>然后是消息接收处理 websocket 连接、关闭等钩子。</p>\n<p><code>MyWebSocket.java</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ServerEndpoint(value = &quot;/websocket&quot;)</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class MyWebSocket &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span><br><span class=\"line\">    private static int onlineCount = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    // concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span><br><span class=\"line\">    private static CopyOnWriteArraySet&lt;MyWebSocket&gt; webSocketSet = new CopyOnWriteArraySet&lt;MyWebSocket&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br><span class=\"line\">    private Session session;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 连接建立成功调用的方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnOpen</span><br><span class=\"line\">    public void onOpen(Session session) &#123;</span><br><span class=\"line\">        this.session = session;</span><br><span class=\"line\">        webSocketSet.add(this); // 加入set中</span><br><span class=\"line\">        addOnlineCount(); // 在线数加1</span><br><span class=\"line\">        System.out.println(&quot;有新连接加入！当前在线人数为 : &quot; + getOnlineCount());</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            sendMessage(&quot;您已成功连接！&quot;);</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            System.out.println(&quot;IO异常&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 连接关闭调用的方法</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnClose</span><br><span class=\"line\">    public void onClose() &#123;</span><br><span class=\"line\">        webSocketSet.remove(this); // 从set中删除</span><br><span class=\"line\">        subOnlineCount(); // 在线数减1</span><br><span class=\"line\">        System.out.println(&quot;有一连接关闭！当前在线人数为 : &quot; + getOnlineCount());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 收到客户端消息后调用的方法</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param message</span><br><span class=\"line\">     *            客户端发送过来的消息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnMessage</span><br><span class=\"line\">    public void onMessage(String message, Session session) &#123;</span><br><span class=\"line\">        System.out.println(&quot;来自客户端的消息:&quot; + message);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 群发消息</span><br><span class=\"line\">        for (MyWebSocket item : webSocketSet) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                item.sendMessage(message);</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 发生错误时调用</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @OnError</span><br><span class=\"line\">    public void onError(Session session, Throwable error) &#123;</span><br><span class=\"line\">        System.out.println(&quot;发生错误&quot;);</span><br><span class=\"line\">        error.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void sendMessage(String message) throws IOException &#123;</span><br><span class=\"line\">        this.session.getBasicRemote().sendText(message);</span><br><span class=\"line\">        // this.session.getAsyncRemote().sendText(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 群发自定义消息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void sendInfo(String message) throws IOException &#123;</span><br><span class=\"line\">        for (MyWebSocket item : webSocketSet) &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                item.sendMessage(message);</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static synchronized int getOnlineCount() &#123;</span><br><span class=\"line\">        return onlineCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static synchronized void addOnlineCount() &#123;</span><br><span class=\"line\">        MyWebSocket.onlineCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static synchronized void subOnlineCount() &#123;</span><br><span class=\"line\">        MyWebSocket.onlineCount--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>关键就是<code>@OnOpen</code>、<code>@OnClose</code>等这几个注解了。每个对象有着各自的 session，其中可以存放个人信息。当收到一个客户端消息时，往所有维护着的对象循环 send 了消息，这就简单实现了聊天室的聊天功能了。</p>\n<p>其中 websocket session 发送文本消息有两个方法：getAsyncRemote()和 getBasicRemote()。 getAsyncRemote 是非阻塞式的，getBasicRemote 是阻塞式的。</p>\n<p>然后我用了 Controller 来简单跳转测试页面，也可以直接访问页面。</p>\n<p><code>InitController.java</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public class InitController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/websocket&quot;)</span><br><span class=\"line\">    public String init() &#123;</span><br><span class=\"line\">        return &quot;websocket.html&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>websocket.html</code> :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">&lt;title&gt;My WebSocket Test&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome&lt;br/&gt;</span><br><span class=\"line\">&lt;input id=&quot;text&quot; type=&quot;text&quot; /&gt;</span><br><span class=\"line\">&lt;button onclick=&quot;send()&quot;&gt;Send&lt;/button&gt;</span><br><span class=\"line\">&lt;button onclick=&quot;closeWebSocket()&quot;&gt;Close&lt;/button&gt;</span><br><span class=\"line\">&lt;div id=&quot;message&quot;&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    var websocket = null;</span><br><span class=\"line\"></span><br><span class=\"line\">    //判断当前浏览器是否支持WebSocket</span><br><span class=\"line\">    if(&#x27;WebSocket&#x27; in window)&#123;</span><br><span class=\"line\">        websocket = new WebSocket(&quot;ws://localhost:8080/websocket&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        alert(&#x27;Not support websocket&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接发生错误的回调方法</span><br><span class=\"line\">    websocket.onerror = function()&#123;</span><br><span class=\"line\">        setMessageInnerHTML(&quot;error&quot;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接成功建立的回调方法</span><br><span class=\"line\">    websocket.onopen = function(event)&#123;</span><br><span class=\"line\">        setMessageInnerHTML(&quot;open&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //接收到消息的回调方法</span><br><span class=\"line\">    websocket.onmessage = function(event)&#123;</span><br><span class=\"line\">        setMessageInnerHTML(event.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //连接关闭的回调方法</span><br><span class=\"line\">    websocket.onclose = function()&#123;</span><br><span class=\"line\">        setMessageInnerHTML(&quot;close&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span><br><span class=\"line\">    window.onbeforeunload = function()&#123;</span><br><span class=\"line\">        websocket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //将消息显示在网页上</span><br><span class=\"line\">    function setMessageInnerHTML(innerHTML)&#123;</span><br><span class=\"line\">        document.getElementById(&#x27;message&#x27;).innerHTML += innerHTML + &#x27;&lt;br/&gt;&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //关闭连接</span><br><span class=\"line\">    function closeWebSocket()&#123;</span><br><span class=\"line\">        websocket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //发送消息</span><br><span class=\"line\">    function send()&#123;</span><br><span class=\"line\">        var message = document.getElementById(&#x27;text&#x27;).value;</span><br><span class=\"line\">        websocket.send(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>要注意，这里没有用到任何模板引擎，所有直接把 <code>websocket.html</code> 放在 static 文件夹下就可以访问了。</p>\n<p>所有的这些搞好就可以运行了，一个简单的效果就能出来。</p>\n<p>End.</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jingmoxukong/p/7755643.html#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B\">WebSocket 详解教程</a></li>\n<li><a href=\"https://www.cnblogs.com/bianzy/p/5822426.html\">spring boot Websocket（使用笔记）</a></li>\n<li><a href=\"https://github.com/spring-projects/spring-boot/tree/3be3743c90127c4295031e974e570ffb1b9d7fb0/spring-boot-samples/spring-boot-sample-websocket-tomcat\">官方 sample</a></li>\n</ul>\n"},{"title":"使用 ssh 反向隧道穿透 NAT 访问 Linux 内网主机","date":"2018-11-03T03:15:10.000Z","_content":"\n# 使用 ssh 反向隧道穿透 NAT 访问内网主机\n\n## 前言\n由于公司经常会有项目需要去业主那边搭建服务器，基本不需要什么流量所以就准备用 4G 网卡搭建。而该网卡无固定公网 ip，只有内网 ip，我们目的就是为了可以远程操控以避免有时因业务需要往业主那边跑，要是地方比较远来回一趟也得花个把星期，不划算。所以就研究了下 ssh 隧道穿透来满足我们的需求。\n\n## 场景\n\n现在我们有三台机子：\n\n- A：公司内网电脑（Win 10）\n- B：公司内网服务器（Linux，固定外网 ip：58.247.33.44，ssh 开放端口：8862）\n- C：业主那边 4G 网卡搭建的服务器（Linux，无固定外网 ip，ssh 开放端口：22）\n\n操作前：A 可以访问 B，C 能上网也能访问 B，但是 B 不能访问 C，A 不能访问 C\n我们需要满足：A 可以访问 C\n\n**当然，很多远程桌面软件可以满足我们这个需求，但是由于太不方便和不稳定，还是考虑 ssh。（安装 ssh 可见底文的[附加安装指令](#附加安装)）**\n\n## 配置\n\n### 配置 B 服务器\n\n- 修改服务器上的 sshd 设置\n\n`vim /etc/ssh/shhd_config` 建议使用 vim，vim 比 vi 更强大（安装 vim 可见底文的[附加安装指令](#附加安装)）\n\n- 把 GatewayPorts 打开(去掉前面的 # 号注释，没有就直接在底下添加)\n\n`GatewayPorts yes` 打开允许映射端口\n\n- 存盘后退出，并重新启动 sshd (不知如何操作文件的自行上网查阅)\n\n`service ssh restart` 这个具体得看你 service 的实际名字（Ubuntu 下 `service --status-all` 可以查看所有服务状态）\n\n### 配置 C 服务器\n\n#### 可以进行映射操作了\n\n`ssh -NfR 1234:localhost:22 user@58.247.33.44 -p8862`\n\n>N 参数，表示只连接远程主机，不打开远程shell。<br>\n>f 参数，表示后台运行。<br>\n>R 参数接受三个值，分别是\"远程主机端口:目标主机:目标主机端口\"。<br>\n>p 参数，表示指定 ssh 对外开放的端口号。<br>\n>user 是 B 服务器的用户。<br>\n>这条命令的意思，就是让 B 服务器监听它自己的 1234 端口，然后将所有数据经由 B 服务器转发到 C 服务器的 22 端口。这就被称为\"远程端口绑定\"。\n\n这里每次连接需要输入 B 服务器的密码，不太方便，待会再详细介绍。\n\n映射操作后我们可以发现在 B 服务器上已经开启了 1234 端口的监听，已经可以通过 1234 端口进行 ssh 连接到 C 服务器了。\n\n#### 密钥验证，直接登录\n\n接回上面说的每次需要输入密码的问题，我们可以用 ssh 密钥来实现自动登录。\n\n**在 C 服务器上生成公钥和私钥**\n\n`ssh-keygen` （一直 enter）\n\n`ls ~ /.ssh/` 查看是否生成，显示如下\n\n>id_rsa id_rsa.pub known_hosts\n\n`ssh-copy-id user@58.247.33.44` 复制到 B 服务器中\n\n好了，这样就不需要每次都输入 B 服务器密码了。\n\n#### autossh 实现自动重连\n\n由于上述的 ssh 反向连接十分不稳定，可能随时断开，一旦断开就无法进行访问了。所以我们需要 autossh，它可以实现自动重连。（安装 autossh 可见底文的[附加安装指令](#附加安装)）\n\n`autossh -M 5678 -NR 1234:localhost:22 user@58.247.33.44 -p8862`\n\n>M 参数，指定了 autossh 的监听端口，监听是否断开然后进行重连操作<br>\n>autossh 本身就是后台执行，所以就省去了 f 参数。\n\n到这里就很完美了，可是还不够。要是 C 服务器宕机重启了怎么办，autossh 又不会自动执行。\n\n#### 实现开机自启\n\n这里以 Ubuntu 18.04 为例。\n\n`ls /lib/systemd/system` 执行该指令我们可以看到许多启动脚本，我们需要操作的就是 **rc.local.service**\n\n打开脚本内容，我们在最后面加上一段：\n```\n[Install]  \nWantedBy=multi-user.target  \nAlias=rc-local.service\n```\n\n保存退出。\n\n由于 ubuntu-18.04 默认是没有 /etc/rc.local 这个文件的，需要自己创建。\n\n```\nsudo touch /etc/rc.local\nchmod 755 /etc/rc.local\n```\n\n**这里千万别忘记给 rc.local 文件设置可执行权限，不然没用。**\n\n在 `rc.local` 中你就可以编写脚本了。**注意开头 #!/bin/bash 不可少**\n\n例如我的是：\n```\n#!/bin/bash\nLOG_TIME=`date \"+%Y-%m-%d %H:%M:%S\"`\necho '123456' | sudo -S autossh -M 5678 -NR 1234:localhost:2223 user@58.247.33.44 -p8862\necho \"autossh restart:\"$LOG_TIME >>/usr/local/autossh.log\n```\n\n这里我是用 root 权限执行，123456 是 C 服务器的用户密码。 `>>` 表示追加，不覆盖。同时打印了执行的时间。\n\n最后一步，前面我们说 systemd 默认读取 /etc/systemd/system 下的配置文件, 所以还需要在 /etc/systemd/system 目录下创建软链接。\n\n`ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/`\n\n可以了，重启系统查看脚本是否执行，日志中是否有内容。\n\n## 参考博文\n\n笔者参考了如下博文并进行了整理实验：\n\n- [使用ssh隧道穿透NAT访问内网主机(超干货)](https://blog.csdn.net/cayman_mg/article/details/79527207)\n- [SSH反向连接及Autossh](https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html)\n- [ubuntu-18.04 设置开机启动脚本](http://www.r9it.com/20180613/ubuntu-18.04-auto-start.html)\n- [ubuntu 18.04 配置 rc.local](https://blog.csdn.net/a912952381/article/details/81205095)\n\n## 附加安装\n\n- 更新源列表\n\n`sudo apt-get update`\n\n- 安装 ssh\n\n`sudo apt-get install openssh-client` 安装客户端 （反向隧道需要）\n\n`sudo apt-get install openssh-server` 安装服务端\n\n- 安装 vim\n\n```\nsudo apt-get remove vim-common\nsudo apt-get install vim\n```\n\nUbuntu 18.04 中 vi 方向键有点问题，vim 很好用。\n\n- 安装 autossh\n\n`sudo apt-get install autossh`\n\n- 安装 net-tools\n\n当发现输入 `ifconfig` 不可用时\n\n`sudo apt install net-tools` 装之\n\n","source":"_posts/ssh-nat-ubuntu.md","raw":"---\ntitle: 使用 ssh 反向隧道穿透 NAT 访问 Linux 内网主机\ndate: 2018-11-03 11:15:10\ncategories: [开发,运维]\ntags: [Ubuntu,ssh,脚本,开机自启]\n---\n\n# 使用 ssh 反向隧道穿透 NAT 访问内网主机\n\n## 前言\n由于公司经常会有项目需要去业主那边搭建服务器，基本不需要什么流量所以就准备用 4G 网卡搭建。而该网卡无固定公网 ip，只有内网 ip，我们目的就是为了可以远程操控以避免有时因业务需要往业主那边跑，要是地方比较远来回一趟也得花个把星期，不划算。所以就研究了下 ssh 隧道穿透来满足我们的需求。\n\n## 场景\n\n现在我们有三台机子：\n\n- A：公司内网电脑（Win 10）\n- B：公司内网服务器（Linux，固定外网 ip：58.247.33.44，ssh 开放端口：8862）\n- C：业主那边 4G 网卡搭建的服务器（Linux，无固定外网 ip，ssh 开放端口：22）\n\n操作前：A 可以访问 B，C 能上网也能访问 B，但是 B 不能访问 C，A 不能访问 C\n我们需要满足：A 可以访问 C\n\n**当然，很多远程桌面软件可以满足我们这个需求，但是由于太不方便和不稳定，还是考虑 ssh。（安装 ssh 可见底文的[附加安装指令](#附加安装)）**\n\n## 配置\n\n### 配置 B 服务器\n\n- 修改服务器上的 sshd 设置\n\n`vim /etc/ssh/shhd_config` 建议使用 vim，vim 比 vi 更强大（安装 vim 可见底文的[附加安装指令](#附加安装)）\n\n- 把 GatewayPorts 打开(去掉前面的 # 号注释，没有就直接在底下添加)\n\n`GatewayPorts yes` 打开允许映射端口\n\n- 存盘后退出，并重新启动 sshd (不知如何操作文件的自行上网查阅)\n\n`service ssh restart` 这个具体得看你 service 的实际名字（Ubuntu 下 `service --status-all` 可以查看所有服务状态）\n\n### 配置 C 服务器\n\n#### 可以进行映射操作了\n\n`ssh -NfR 1234:localhost:22 user@58.247.33.44 -p8862`\n\n>N 参数，表示只连接远程主机，不打开远程shell。<br>\n>f 参数，表示后台运行。<br>\n>R 参数接受三个值，分别是\"远程主机端口:目标主机:目标主机端口\"。<br>\n>p 参数，表示指定 ssh 对外开放的端口号。<br>\n>user 是 B 服务器的用户。<br>\n>这条命令的意思，就是让 B 服务器监听它自己的 1234 端口，然后将所有数据经由 B 服务器转发到 C 服务器的 22 端口。这就被称为\"远程端口绑定\"。\n\n这里每次连接需要输入 B 服务器的密码，不太方便，待会再详细介绍。\n\n映射操作后我们可以发现在 B 服务器上已经开启了 1234 端口的监听，已经可以通过 1234 端口进行 ssh 连接到 C 服务器了。\n\n#### 密钥验证，直接登录\n\n接回上面说的每次需要输入密码的问题，我们可以用 ssh 密钥来实现自动登录。\n\n**在 C 服务器上生成公钥和私钥**\n\n`ssh-keygen` （一直 enter）\n\n`ls ~ /.ssh/` 查看是否生成，显示如下\n\n>id_rsa id_rsa.pub known_hosts\n\n`ssh-copy-id user@58.247.33.44` 复制到 B 服务器中\n\n好了，这样就不需要每次都输入 B 服务器密码了。\n\n#### autossh 实现自动重连\n\n由于上述的 ssh 反向连接十分不稳定，可能随时断开，一旦断开就无法进行访问了。所以我们需要 autossh，它可以实现自动重连。（安装 autossh 可见底文的[附加安装指令](#附加安装)）\n\n`autossh -M 5678 -NR 1234:localhost:22 user@58.247.33.44 -p8862`\n\n>M 参数，指定了 autossh 的监听端口，监听是否断开然后进行重连操作<br>\n>autossh 本身就是后台执行，所以就省去了 f 参数。\n\n到这里就很完美了，可是还不够。要是 C 服务器宕机重启了怎么办，autossh 又不会自动执行。\n\n#### 实现开机自启\n\n这里以 Ubuntu 18.04 为例。\n\n`ls /lib/systemd/system` 执行该指令我们可以看到许多启动脚本，我们需要操作的就是 **rc.local.service**\n\n打开脚本内容，我们在最后面加上一段：\n```\n[Install]  \nWantedBy=multi-user.target  \nAlias=rc-local.service\n```\n\n保存退出。\n\n由于 ubuntu-18.04 默认是没有 /etc/rc.local 这个文件的，需要自己创建。\n\n```\nsudo touch /etc/rc.local\nchmod 755 /etc/rc.local\n```\n\n**这里千万别忘记给 rc.local 文件设置可执行权限，不然没用。**\n\n在 `rc.local` 中你就可以编写脚本了。**注意开头 #!/bin/bash 不可少**\n\n例如我的是：\n```\n#!/bin/bash\nLOG_TIME=`date \"+%Y-%m-%d %H:%M:%S\"`\necho '123456' | sudo -S autossh -M 5678 -NR 1234:localhost:2223 user@58.247.33.44 -p8862\necho \"autossh restart:\"$LOG_TIME >>/usr/local/autossh.log\n```\n\n这里我是用 root 权限执行，123456 是 C 服务器的用户密码。 `>>` 表示追加，不覆盖。同时打印了执行的时间。\n\n最后一步，前面我们说 systemd 默认读取 /etc/systemd/system 下的配置文件, 所以还需要在 /etc/systemd/system 目录下创建软链接。\n\n`ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/`\n\n可以了，重启系统查看脚本是否执行，日志中是否有内容。\n\n## 参考博文\n\n笔者参考了如下博文并进行了整理实验：\n\n- [使用ssh隧道穿透NAT访问内网主机(超干货)](https://blog.csdn.net/cayman_mg/article/details/79527207)\n- [SSH反向连接及Autossh](https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html)\n- [ubuntu-18.04 设置开机启动脚本](http://www.r9it.com/20180613/ubuntu-18.04-auto-start.html)\n- [ubuntu 18.04 配置 rc.local](https://blog.csdn.net/a912952381/article/details/81205095)\n\n## 附加安装\n\n- 更新源列表\n\n`sudo apt-get update`\n\n- 安装 ssh\n\n`sudo apt-get install openssh-client` 安装客户端 （反向隧道需要）\n\n`sudo apt-get install openssh-server` 安装服务端\n\n- 安装 vim\n\n```\nsudo apt-get remove vim-common\nsudo apt-get install vim\n```\n\nUbuntu 18.04 中 vi 方向键有点问题，vim 很好用。\n\n- 安装 autossh\n\n`sudo apt-get install autossh`\n\n- 安装 net-tools\n\n当发现输入 `ifconfig` 不可用时\n\n`sudo apt install net-tools` 装之\n\n","slug":"ssh-nat-ubuntu","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhr00bkk9i183qm05ac","content":"<h1 id=\"使用-ssh-反向隧道穿透-NAT-访问内网主机\"><a href=\"#使用-ssh-反向隧道穿透-NAT-访问内网主机\" class=\"headerlink\" title=\"使用 ssh 反向隧道穿透 NAT 访问内网主机\"></a>使用 ssh 反向隧道穿透 NAT 访问内网主机</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于公司经常会有项目需要去业主那边搭建服务器，基本不需要什么流量所以就准备用 4G 网卡搭建。而该网卡无固定公网 ip，只有内网 ip，我们目的就是为了可以远程操控以避免有时因业务需要往业主那边跑，要是地方比较远来回一趟也得花个把星期，不划算。所以就研究了下 ssh 隧道穿透来满足我们的需求。</p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>现在我们有三台机子：</p>\n<ul>\n<li>A：公司内网电脑（Win 10）</li>\n<li>B：公司内网服务器（Linux，固定外网 ip：58.247.33.44，ssh 开放端口：8862）</li>\n<li>C：业主那边 4G 网卡搭建的服务器（Linux，无固定外网 ip，ssh 开放端口：22）</li>\n</ul>\n<p>操作前：A 可以访问 B，C 能上网也能访问 B，但是 B 不能访问 C，A 不能访问 C<br>我们需要满足：A 可以访问 C</p>\n<p><strong>当然，很多远程桌面软件可以满足我们这个需求，但是由于太不方便和不稳定，还是考虑 ssh。（安装 ssh 可见底文的<a href=\"#%E9%99%84%E5%8A%A0%E5%AE%89%E8%A3%85\">附加安装指令</a>）</strong></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"配置-B-服务器\"><a href=\"#配置-B-服务器\" class=\"headerlink\" title=\"配置 B 服务器\"></a>配置 B 服务器</h3><ul>\n<li>修改服务器上的 sshd 设置</li>\n</ul>\n<p><code>vim /etc/ssh/shhd_config</code> 建议使用 vim，vim 比 vi 更强大（安装 vim 可见底文的<a href=\"#%E9%99%84%E5%8A%A0%E5%AE%89%E8%A3%85\">附加安装指令</a>）</p>\n<ul>\n<li>把 GatewayPorts 打开(去掉前面的 # 号注释，没有就直接在底下添加)</li>\n</ul>\n<p><code>GatewayPorts yes</code> 打开允许映射端口</p>\n<ul>\n<li>存盘后退出，并重新启动 sshd (不知如何操作文件的自行上网查阅)</li>\n</ul>\n<p><code>service ssh restart</code> 这个具体得看你 service 的实际名字（Ubuntu 下 <code>service --status-all</code> 可以查看所有服务状态）</p>\n<h3 id=\"配置-C-服务器\"><a href=\"#配置-C-服务器\" class=\"headerlink\" title=\"配置 C 服务器\"></a>配置 C 服务器</h3><h4 id=\"可以进行映射操作了\"><a href=\"#可以进行映射操作了\" class=\"headerlink\" title=\"可以进行映射操作了\"></a>可以进行映射操作了</h4><p><code>ssh -NfR 1234:localhost:22 user@58.247.33.44 -p8862</code></p>\n<blockquote>\n<p>N 参数，表示只连接远程主机，不打开远程shell。<br><br>f 参数，表示后台运行。<br><br>R 参数接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。<br><br>p 参数，表示指定 ssh 对外开放的端口号。<br><br>user 是 B 服务器的用户。<br><br>这条命令的意思，就是让 B 服务器监听它自己的 1234 端口，然后将所有数据经由 B 服务器转发到 C 服务器的 22 端口。这就被称为”远程端口绑定”。</p>\n</blockquote>\n<p>这里每次连接需要输入 B 服务器的密码，不太方便，待会再详细介绍。</p>\n<p>映射操作后我们可以发现在 B 服务器上已经开启了 1234 端口的监听，已经可以通过 1234 端口进行 ssh 连接到 C 服务器了。</p>\n<h4 id=\"密钥验证，直接登录\"><a href=\"#密钥验证，直接登录\" class=\"headerlink\" title=\"密钥验证，直接登录\"></a>密钥验证，直接登录</h4><p>接回上面说的每次需要输入密码的问题，我们可以用 ssh 密钥来实现自动登录。</p>\n<p><strong>在 C 服务器上生成公钥和私钥</strong></p>\n<p><code>ssh-keygen</code> （一直 enter）</p>\n<p><code>ls ~ /.ssh/</code> 查看是否生成，显示如下</p>\n<blockquote>\n<p>id_rsa id_rsa.pub known_hosts</p>\n</blockquote>\n<p><code>ssh-copy-id user@58.247.33.44</code> 复制到 B 服务器中</p>\n<p>好了，这样就不需要每次都输入 B 服务器密码了。</p>\n<h4 id=\"autossh-实现自动重连\"><a href=\"#autossh-实现自动重连\" class=\"headerlink\" title=\"autossh 实现自动重连\"></a>autossh 实现自动重连</h4><p>由于上述的 ssh 反向连接十分不稳定，可能随时断开，一旦断开就无法进行访问了。所以我们需要 autossh，它可以实现自动重连。（安装 autossh 可见底文的<a href=\"#%E9%99%84%E5%8A%A0%E5%AE%89%E8%A3%85\">附加安装指令</a>）</p>\n<p><code>autossh -M 5678 -NR 1234:localhost:22 user@58.247.33.44 -p8862</code></p>\n<blockquote>\n<p>M 参数，指定了 autossh 的监听端口，监听是否断开然后进行重连操作<br><br>autossh 本身就是后台执行，所以就省去了 f 参数。</p>\n</blockquote>\n<p>到这里就很完美了，可是还不够。要是 C 服务器宕机重启了怎么办，autossh 又不会自动执行。</p>\n<h4 id=\"实现开机自启\"><a href=\"#实现开机自启\" class=\"headerlink\" title=\"实现开机自启\"></a>实现开机自启</h4><p>这里以 Ubuntu 18.04 为例。</p>\n<p><code>ls /lib/systemd/system</code> 执行该指令我们可以看到许多启动脚本，我们需要操作的就是 <strong>rc.local.service</strong></p>\n<p>打开脚本内容，我们在最后面加上一段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Install]  </span><br><span class=\"line\">WantedBy=multi-user.target  </span><br><span class=\"line\">Alias=rc-local.service</span><br></pre></td></tr></table></figure>\n\n<p>保存退出。</p>\n<p>由于 ubuntu-18.04 默认是没有 &#x2F;etc&#x2F;rc.local 这个文件的，需要自己创建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch /etc/rc.local</span><br><span class=\"line\">chmod 755 /etc/rc.local</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里千万别忘记给 rc.local 文件设置可执行权限，不然没用。</strong></p>\n<p>在 <code>rc.local</code> 中你就可以编写脚本了。<strong>注意开头 #!&#x2F;bin&#x2F;bash 不可少</strong></p>\n<p>例如我的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">LOG_TIME=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`</span><br><span class=\"line\">echo &#x27;123456&#x27; | sudo -S autossh -M 5678 -NR 1234:localhost:2223 user@58.247.33.44 -p8862</span><br><span class=\"line\">echo &quot;autossh restart:&quot;$LOG_TIME &gt;&gt;/usr/local/autossh.log</span><br></pre></td></tr></table></figure>\n\n<p>这里我是用 root 权限执行，123456 是 C 服务器的用户密码。 <code>&gt;&gt;</code> 表示追加，不覆盖。同时打印了执行的时间。</p>\n<p>最后一步，前面我们说 systemd 默认读取 &#x2F;etc&#x2F;systemd&#x2F;system 下的配置文件, 所以还需要在 &#x2F;etc&#x2F;systemd&#x2F;system 目录下创建软链接。</p>\n<p><code>ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/</code></p>\n<p>可以了，重启系统查看脚本是否执行，日志中是否有内容。</p>\n<h2 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h2><p>笔者参考了如下博文并进行了整理实验：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cayman_mg/article/details/79527207\">使用ssh隧道穿透NAT访问内网主机(超干货)</a></li>\n<li><a href=\"https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html\">SSH反向连接及Autossh</a></li>\n<li><a href=\"http://www.r9it.com/20180613/ubuntu-18.04-auto-start.html\">ubuntu-18.04 设置开机启动脚本</a></li>\n<li><a href=\"https://blog.csdn.net/a912952381/article/details/81205095\">ubuntu 18.04 配置 rc.local</a></li>\n</ul>\n<h2 id=\"附加安装\"><a href=\"#附加安装\" class=\"headerlink\" title=\"附加安装\"></a>附加安装</h2><ul>\n<li>更新源列表</li>\n</ul>\n<p><code>sudo apt-get update</code></p>\n<ul>\n<li>安装 ssh</li>\n</ul>\n<p><code>sudo apt-get install openssh-client</code> 安装客户端 （反向隧道需要）</p>\n<p><code>sudo apt-get install openssh-server</code> 安装服务端</p>\n<ul>\n<li>安装 vim</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get remove vim-common</span><br><span class=\"line\">sudo apt-get install vim</span><br></pre></td></tr></table></figure>\n\n<p>Ubuntu 18.04 中 vi 方向键有点问题，vim 很好用。</p>\n<ul>\n<li>安装 autossh</li>\n</ul>\n<p><code>sudo apt-get install autossh</code></p>\n<ul>\n<li>安装 net-tools</li>\n</ul>\n<p>当发现输入 <code>ifconfig</code> 不可用时</p>\n<p><code>sudo apt install net-tools</code> 装之</p>\n","excerpt":"","more":"<h1 id=\"使用-ssh-反向隧道穿透-NAT-访问内网主机\"><a href=\"#使用-ssh-反向隧道穿透-NAT-访问内网主机\" class=\"headerlink\" title=\"使用 ssh 反向隧道穿透 NAT 访问内网主机\"></a>使用 ssh 反向隧道穿透 NAT 访问内网主机</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于公司经常会有项目需要去业主那边搭建服务器，基本不需要什么流量所以就准备用 4G 网卡搭建。而该网卡无固定公网 ip，只有内网 ip，我们目的就是为了可以远程操控以避免有时因业务需要往业主那边跑，要是地方比较远来回一趟也得花个把星期，不划算。所以就研究了下 ssh 隧道穿透来满足我们的需求。</p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>现在我们有三台机子：</p>\n<ul>\n<li>A：公司内网电脑（Win 10）</li>\n<li>B：公司内网服务器（Linux，固定外网 ip：58.247.33.44，ssh 开放端口：8862）</li>\n<li>C：业主那边 4G 网卡搭建的服务器（Linux，无固定外网 ip，ssh 开放端口：22）</li>\n</ul>\n<p>操作前：A 可以访问 B，C 能上网也能访问 B，但是 B 不能访问 C，A 不能访问 C<br>我们需要满足：A 可以访问 C</p>\n<p><strong>当然，很多远程桌面软件可以满足我们这个需求，但是由于太不方便和不稳定，还是考虑 ssh。（安装 ssh 可见底文的<a href=\"#%E9%99%84%E5%8A%A0%E5%AE%89%E8%A3%85\">附加安装指令</a>）</strong></p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h3 id=\"配置-B-服务器\"><a href=\"#配置-B-服务器\" class=\"headerlink\" title=\"配置 B 服务器\"></a>配置 B 服务器</h3><ul>\n<li>修改服务器上的 sshd 设置</li>\n</ul>\n<p><code>vim /etc/ssh/shhd_config</code> 建议使用 vim，vim 比 vi 更强大（安装 vim 可见底文的<a href=\"#%E9%99%84%E5%8A%A0%E5%AE%89%E8%A3%85\">附加安装指令</a>）</p>\n<ul>\n<li>把 GatewayPorts 打开(去掉前面的 # 号注释，没有就直接在底下添加)</li>\n</ul>\n<p><code>GatewayPorts yes</code> 打开允许映射端口</p>\n<ul>\n<li>存盘后退出，并重新启动 sshd (不知如何操作文件的自行上网查阅)</li>\n</ul>\n<p><code>service ssh restart</code> 这个具体得看你 service 的实际名字（Ubuntu 下 <code>service --status-all</code> 可以查看所有服务状态）</p>\n<h3 id=\"配置-C-服务器\"><a href=\"#配置-C-服务器\" class=\"headerlink\" title=\"配置 C 服务器\"></a>配置 C 服务器</h3><h4 id=\"可以进行映射操作了\"><a href=\"#可以进行映射操作了\" class=\"headerlink\" title=\"可以进行映射操作了\"></a>可以进行映射操作了</h4><p><code>ssh -NfR 1234:localhost:22 user@58.247.33.44 -p8862</code></p>\n<blockquote>\n<p>N 参数，表示只连接远程主机，不打开远程shell。<br><br>f 参数，表示后台运行。<br><br>R 参数接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。<br><br>p 参数，表示指定 ssh 对外开放的端口号。<br><br>user 是 B 服务器的用户。<br><br>这条命令的意思，就是让 B 服务器监听它自己的 1234 端口，然后将所有数据经由 B 服务器转发到 C 服务器的 22 端口。这就被称为”远程端口绑定”。</p>\n</blockquote>\n<p>这里每次连接需要输入 B 服务器的密码，不太方便，待会再详细介绍。</p>\n<p>映射操作后我们可以发现在 B 服务器上已经开启了 1234 端口的监听，已经可以通过 1234 端口进行 ssh 连接到 C 服务器了。</p>\n<h4 id=\"密钥验证，直接登录\"><a href=\"#密钥验证，直接登录\" class=\"headerlink\" title=\"密钥验证，直接登录\"></a>密钥验证，直接登录</h4><p>接回上面说的每次需要输入密码的问题，我们可以用 ssh 密钥来实现自动登录。</p>\n<p><strong>在 C 服务器上生成公钥和私钥</strong></p>\n<p><code>ssh-keygen</code> （一直 enter）</p>\n<p><code>ls ~ /.ssh/</code> 查看是否生成，显示如下</p>\n<blockquote>\n<p>id_rsa id_rsa.pub known_hosts</p>\n</blockquote>\n<p><code>ssh-copy-id user@58.247.33.44</code> 复制到 B 服务器中</p>\n<p>好了，这样就不需要每次都输入 B 服务器密码了。</p>\n<h4 id=\"autossh-实现自动重连\"><a href=\"#autossh-实现自动重连\" class=\"headerlink\" title=\"autossh 实现自动重连\"></a>autossh 实现自动重连</h4><p>由于上述的 ssh 反向连接十分不稳定，可能随时断开，一旦断开就无法进行访问了。所以我们需要 autossh，它可以实现自动重连。（安装 autossh 可见底文的<a href=\"#%E9%99%84%E5%8A%A0%E5%AE%89%E8%A3%85\">附加安装指令</a>）</p>\n<p><code>autossh -M 5678 -NR 1234:localhost:22 user@58.247.33.44 -p8862</code></p>\n<blockquote>\n<p>M 参数，指定了 autossh 的监听端口，监听是否断开然后进行重连操作<br><br>autossh 本身就是后台执行，所以就省去了 f 参数。</p>\n</blockquote>\n<p>到这里就很完美了，可是还不够。要是 C 服务器宕机重启了怎么办，autossh 又不会自动执行。</p>\n<h4 id=\"实现开机自启\"><a href=\"#实现开机自启\" class=\"headerlink\" title=\"实现开机自启\"></a>实现开机自启</h4><p>这里以 Ubuntu 18.04 为例。</p>\n<p><code>ls /lib/systemd/system</code> 执行该指令我们可以看到许多启动脚本，我们需要操作的就是 <strong>rc.local.service</strong></p>\n<p>打开脚本内容，我们在最后面加上一段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Install]  </span><br><span class=\"line\">WantedBy=multi-user.target  </span><br><span class=\"line\">Alias=rc-local.service</span><br></pre></td></tr></table></figure>\n\n<p>保存退出。</p>\n<p>由于 ubuntu-18.04 默认是没有 &#x2F;etc&#x2F;rc.local 这个文件的，需要自己创建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo touch /etc/rc.local</span><br><span class=\"line\">chmod 755 /etc/rc.local</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里千万别忘记给 rc.local 文件设置可执行权限，不然没用。</strong></p>\n<p>在 <code>rc.local</code> 中你就可以编写脚本了。<strong>注意开头 #!&#x2F;bin&#x2F;bash 不可少</strong></p>\n<p>例如我的是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">LOG_TIME=`date &quot;+%Y-%m-%d %H:%M:%S&quot;`</span><br><span class=\"line\">echo &#x27;123456&#x27; | sudo -S autossh -M 5678 -NR 1234:localhost:2223 user@58.247.33.44 -p8862</span><br><span class=\"line\">echo &quot;autossh restart:&quot;$LOG_TIME &gt;&gt;/usr/local/autossh.log</span><br></pre></td></tr></table></figure>\n\n<p>这里我是用 root 权限执行，123456 是 C 服务器的用户密码。 <code>&gt;&gt;</code> 表示追加，不覆盖。同时打印了执行的时间。</p>\n<p>最后一步，前面我们说 systemd 默认读取 &#x2F;etc&#x2F;systemd&#x2F;system 下的配置文件, 所以还需要在 &#x2F;etc&#x2F;systemd&#x2F;system 目录下创建软链接。</p>\n<p><code>ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/</code></p>\n<p>可以了，重启系统查看脚本是否执行，日志中是否有内容。</p>\n<h2 id=\"参考博文\"><a href=\"#参考博文\" class=\"headerlink\" title=\"参考博文\"></a>参考博文</h2><p>笔者参考了如下博文并进行了整理实验：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cayman_mg/article/details/79527207\">使用ssh隧道穿透NAT访问内网主机(超干货)</a></li>\n<li><a href=\"https://www.cnblogs.com/eshizhan/archive/2012/07/16/2592902.html\">SSH反向连接及Autossh</a></li>\n<li><a href=\"http://www.r9it.com/20180613/ubuntu-18.04-auto-start.html\">ubuntu-18.04 设置开机启动脚本</a></li>\n<li><a href=\"https://blog.csdn.net/a912952381/article/details/81205095\">ubuntu 18.04 配置 rc.local</a></li>\n</ul>\n<h2 id=\"附加安装\"><a href=\"#附加安装\" class=\"headerlink\" title=\"附加安装\"></a>附加安装</h2><ul>\n<li>更新源列表</li>\n</ul>\n<p><code>sudo apt-get update</code></p>\n<ul>\n<li>安装 ssh</li>\n</ul>\n<p><code>sudo apt-get install openssh-client</code> 安装客户端 （反向隧道需要）</p>\n<p><code>sudo apt-get install openssh-server</code> 安装服务端</p>\n<ul>\n<li>安装 vim</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get remove vim-common</span><br><span class=\"line\">sudo apt-get install vim</span><br></pre></td></tr></table></figure>\n\n<p>Ubuntu 18.04 中 vi 方向键有点问题，vim 很好用。</p>\n<ul>\n<li>安装 autossh</li>\n</ul>\n<p><code>sudo apt-get install autossh</code></p>\n<ul>\n<li>安装 net-tools</li>\n</ul>\n<p>当发现输入 <code>ifconfig</code> 不可用时</p>\n<p><code>sudo apt install net-tools</code> 装之</p>\n"},{"title":"JDK1.8中的Stream详解","date":"2018-07-13T08:38:12.000Z","_content":"> 别处看到的文章，对其再次进行了整理。收获很多。\n\n## Stream简介\nStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。\n\n## 什么是聚合操作\n在传统的J2EE应用中，Java代码经常不得不依赖于关系型数据库的聚合操作来完成某些操作，诸如：\n\n- 客户每月平均消费金额\n- 最昂贵的在售商品\n- 本周完成的有效订单（排除了无效的）\n- 取十个数据样本作为首页推荐\n\n但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离RDBMS,或者以底层返回的数据为基础进行更上层的数据统计。而Java的集合API中，仅仅有极少量的辅助性方法，更多的时候是程序员需要用Iterator来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在Java7中，如果要发现type为grocery的所有交易，然后返回以交易值降序排序好的交易ID集合，我们需要这样写：\n\n### Java7的排序、取值实现\n```\nList<Transaction> groceryTransactions = new Arraylist<>();\n\nfor(Transaction t: transactions){\n\n if(t.getType() == Transaction.GROCERY){\n\n groceryTransactions.add(t);\n\n }\n\n}\n\nCollections.sort(groceryTransactions, new Comparator(){\n\n public int compare(Transaction t1, Transaction t2){\n\n return t2.getValue().compareTo(t1.getValue());\n\n }\n\n});\n\nList<Integer> transactionIds = new ArrayList<>();\n\nfor(Transaction t: groceryTransactions){\n\n transactionsIds.add(t.getId());\n\n}\n```\n\n### Java8的排序、取值实现\nJava8中使用Stream，代码更加简洁易读，而且使用并发模式，程序执行速度更快。\n```\nList<Integer> transactionsIds = transactions.parallelStream().\n\n filter(t -> t.getType() == Transaction.GROCERY).\n\n sorted(comparing(Transaction::getValue).reversed()).\n\n map(Transaction::getId).\n\n collect(toList());\n```\n\n## Stream总览\n### 什么是流\nStream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。\n\nStream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。\n\n而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方法去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork/Join框架（JSR166y）来拆分任务和加速处理过程。Java的并行API演变历程基本如下：\n\n- 1.0-1.4中的java.lang.Thread\n- 5.0中的java.util.concurrent\n- 6.0中的Phasers等\n- 7.0中的Fork/Join框架\n- 8.0中的Lambda\n\n**Stream的另外一大特点是，数据源本身可以是无限的。***\n\n### 流的构成\n当我们使用一个流的时候，通常包括三个基本步骤：\n\n获取一个数据源（source） → 数据转换 → 执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示：\n\n**流管道（Stream Pipeline）的构成**\n\n![](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png)\n\n有多种方式生成 Stream Source：\n\n- 从Collection和数组\n    + Collection.stream()\n    + Collection.parallelStream()\n    + Arrays.stream(T array) or Stream.of()\n\n- 从BufferedReader\n    + java.io.BufferedReader.lines()\\\n\n- 静态工厂\n    + java.util.stream.IntStream.range()\n    + java.nio.file.Files.walk()\n\n- 自己构建\n    + java.util.Spliterator\n\n- 其它\n    + Random.ints()\n    + BitSet.stream()\n    + Pattern.splitAsStream(java.lang.CharSequence)\n    + JarFile.stream()\n\n流的操作类型分为两种：\n\n- Intermediate：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。\n- Terminal：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个side effect。\n\n在对于一个Stream进行多次转换操作（Intermediate操作），每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和么？其实不是这样的，转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。\n\n还有一种操作被称为short-circuiting。用以指：\n\n- 对于一个intermediate操作，如果它接收的是一个无限大（infinite/unbounded）的Stream，但返回一个有限的新Stream。\n- 对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。\n\n当操作一个无限大的Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。\n\n**一个流操作的示例**\n```\nint sum = widgets.stream()\n\n.filter(w -> w.getColor() == RED)\n\n.mapToInt(w -> w.getWeight())\n\n.sum();\n```\nstream()获取当前小物件的source,filter和mapToInt为intermediate操作，进行数据筛选和转换，最后一个sum()为terminal操作，对符合条件的全部小物件作重量求和。\n\n## 流的使用详解\n简单说，对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（side effect）。\n### 流的构造与转换\n下面提供最常见的几种构造Stream的样例。\n\n**构造流的几种常见方法**\n```\n// 1. Individual values\n\nStream stream = Stream.of(\"a\", \"b\", \"c\");\n\n// 2. Arrays\n\nString [] strArray = new String[] {\"a\", \"b\", \"c\"};\n\nstream = Stream.of(strArray);\n\nstream = Arrays.stream(strArray);\n\n// 3. Collections\n\nList<String> list = Arrays.asList(strArray);\n\nstream = list.stream();\n```\n需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：\n\nIntStream、LongStream、DoubleStream。当然我们也可以用Stream<Integer>、Stream<Long>、Stream<Double>，但是boxing和unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。\n\nJava8中还没有提供其它数值型Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种Stream进行。\n\n**数据流的构造**\n```\nIntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);\n\nIntStream.range(1, 3).forEach(System.out::println);\n\nIntStream.rangeClosed(1, 3).forEach(System.out::println);\n```\n\n**流转换为其它数据结构**\n```\n// 1. Array\n\nString[] strArray1 = stream.toArray(String[]::new);\n\n// 2. Collection\n\nList<String> list1 = stream.collect(Collectors.toList());\n\nList<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));\n\nSet set1 = stream.collect(Collectors.toSet());\n\nStack stack1 = stream.collect(Collectors.toCollection(Stack::new));\n\n// 3. String\n\nString str = stream.collect(Collectors.joining()).toString();\n```\n***注：一个Stream只可以使用一个，以上示例只是为了代码简洁而重复使用数次。***\n\n### 流的操作\n接下来，当把一个数据结构包装成Stream后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下：\n\n- Intermediate：map(mapToint，flatMap等)、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered\n- Terminal：forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator\n- Short-circuiting：anyMatch、allMatch、noneMatch、findFirst、findAny、limit\n\n接下来下面看一下Stream的比较典型用法。\n\n- map/flatMap\n\n先来看map。如果熟悉scala这类函数式语言，对这个方法应该很了解，它的作用就是把input Stream的每一个元素，映射成output Stream的另外一个元素。\n\n**转换大写**\n```\nList<String> output = wordList.stream().\n\nmap(String::toUpperCase).\n\ncollect(Collectors.toList());\n```\n\n**平方数**\n```\nList<Integer> nums = Arrays.asList(1, 2, 3, 4);\n\nList<Integer> squareNums = nums.stream().\n\nmap(n -> n * n).\n\ncollect(Collectors.toList());\n```\n\n从上面例子可以看出，map生成的是个1:1映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap。\n\n**一对多**\n```\nStream<List<Integer>> inputStream = Stream.of(\n\n Arrays.asList(1),\n\n Arrays.asList(2, 3),\n\n Arrays.asList(4, 5, 6)\n\n );\n\nStream<Integer> outputStream = inputStream.\n\nflatMap((childList) -> childList.stream());\n```\nflatMap把input Stream中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。\n\n- filter\n\nfilter对原始Stream进行某项测试，通过测试的元素被留下来生成一个新Stream。\n\n**留下偶数**\n```\nInteger[] sixNums = {1, 2, 3, 4, 5, 6};\n\nInteger[] evens =\n\nStream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);\n```\n经过条件“被2整除”的filter，剩下的数字为{2,4,6}。\n\n**把单词挑出来**\n```\nList<String> output = reader.lines().\n\nflatMap(line -> Stream.of(line.split(REGEXP))).\n\nfilter(word -> word.length() > 0).\n\ncollect(Collectors.toList());\n```\n这段代码首先把每行的单词用flatMap整理到新的Stream，然后保留长度不为0的，就是整篇文章中的所有单词了。\n\n- forEach\n\nforEach方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式。\n\n**打印姓名（forEach和pre-java8的对比）**\n```\n// Java 8\n\nroster.stream()\n\n .filter(p -> p.getGender() == Person.Sex.MALE)\n\n .forEach(p -> System.out.println(p.getName()));\n\n// Pre-Java 8\n\nfor (Person p : roster) {\n\n if (p.getGender() == Person.Sex.MALE) {\n\n System.out.println(p.getName());\n\n }\n\n}\n```\n对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach是为Lambda而设计的，保持了最紧凑的风格。而且lambda表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时forEach本身的实现不需要调整，而Java8以前的for循环code可能需要加入额外的多线程逻辑。\n\n但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统Java风格的差别。\n\n另外一点需要注意，forEach是terminal操作，因此它执行后，Stream的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：\n```\nstream.forEach(element -> doOneThing(element));\n\nstream.forEach(element -> doAnotherThing(element));\n```\n相反，具有相似功能的intermediate操作peek可以达到上述目的。如下是出现在该api javadoc上的一个示例。\n\n**peek 对每个元素执行操作并返回一个新的 Stream**\n```\nStream.of(\"one\", \"two\", \"three\", \"four\")\n\n.filter(e -> e.length() > 3)\n\n.peek(e -> System.out.println(\"Filtered value: \" + e))\n\n.map(String::toUpperCase)\n\n.peek(e -> System.out.println(\"Mapped value: \" + e))\n\n.collect(Collectors.toList());\n```\nforEach不能修改自己包含的本地变量值，也不能用break/return之类的关键字提前结束循环。\n\n- findFirst\n\n这是一个terminal兼short-circuiting操作，它总是返回Stream的第一个元素，或者空。\n\n这里比较重点的是它的返回值类型：Optional。这也是一个模仿Scala语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免NullPointerException。\n\n**Optional的两个用例**\n```\nString strA = \" abcd \", strB = null;\n\nprint(strA);\n\nprint(\"\");\n\nprint(strB);\n\ngetLength(strA);\n\ngetLength(\"\");\n\ngetLength(strB);\n\npublic static void print(String text) {\n\n // Java 8\n\n Optional.ofNullable(text).ifPresent(System.out::println);\n\n // Pre-Java 8\n\n if (text != null) {\n\n System.out.println(text);\n\n }\n\n }\n\npublic static int getLength(String text) {\n\n // Java 8\n\nreturn Optional.ofNullable(text).map(String::length).orElse(-1);\n\n // Pre-Java 8\n\n// return if (text != null) ? text.length() : -1;\n\n };\n```\n在更复杂的if(xx != null)的情况中，使用Optional代码的可读性更好，而且它提供的是编译时检查，能极大的降低NPE这种Runtime Exception对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。\n\nStream中的findAny、max/min、reduce等方法返回Optional值。还有例如IntStream.average()返回Optional Double等等。\n\n- reduce\n\n这个方法的主要作用是把Stream元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面Stream的第一个、第二个、第n个元素组合。从这个意义上说，字符串拼接、数值的sum、min、max、average都是特殊的reduce。例如Stream的sum就相当于\n```\nInteger sum = integers.reduce(0,(a,b) -> a+b);\n```\n或\n```\nInteger sum = integers.reduce(0,Integer::sum);\n```\n也有没有起始值的情况，这时会把Stream的前面两个元素组合起来，返回的是Optional。\n\n**reduce的用例**\n```\n// 字符串连接，concat = \"ABCD\"\n\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat);\n\n// 求最小值，minValue = -3.0\n\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);\n\n// 求和，sumValue = 10, 有起始值\n\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n\n// 求和，sumValue = 10, 无起始值\n\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n\n// 过滤，字符串连接，concat = \"ace\"\n\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\n\n filter(x -> x.compareTo(\"Z\") > 0).\n\n reduce(\"\", String::concat);\n```\n上面代码例如第一个示例的reduce(),第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。这类有起始值的reduce()都返回具体的对象。而对于第四个示例没有起始值的reduce(),由于可能没有足够的元素，返回的是Optional，请留意这个区间。\n\n- limit/skip\n\nlimit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫subStream的方法改名而来）。\n\n**limit和skip对运行次数的影响**\n```\npublic void testLimitAndSkip() {\n\n List<Person> persons = new ArrayList();\n\n for (int i = 1; i <= 10000; i++) {\n\n Person person = new Person(i, \"name\" + i);\n\n persons.add(person);\n\n }\n\nList<String> personList2 = persons.stream().\n\nmap(Person::getName).limit(10).skip(3).collect(Collectors.toList());\n\nSystem.out.println(personList2);\n\n}\n\nprivate class Person {\n\n public int no;\n\n private String name;\n\n public Person (int no, String name) {\n\n this.no = no;\n\n this.name = name;\n\n }\n\n public String getName() {\n\n System.out.println(name);\n\n return name;\n\n }\n\n}\n```\n**结果为：**\n```\nname1\n\nname2\n\nname3\n\nname4\n\nname5\n\nname6\n\nname7\n\nname8\n\nname9\n\nname10\n\n[name4, name5, name6, name7, name8, name9, name10]\n```\n\n这是一个有10000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为limit所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。\n\n还有一种情况是limit/skip无法达到short-circuiting目的地，就是把它们放在Stream的排序操作后，原因跟sorted这个intermediate操作有关：此时系统并不知道Stream排序后的次序如何，所以sorted中的操作看上去就像完全没有被limit或者skip一样。\n\n**limit和skip对sorted后的运行次数无影响**\n```\nList<Person> persons = new ArrayList();\n\n for (int i = 1; i <= 5; i++) {\n\n Person person = new Person(i, \"name\" + i);\n\n persons.add(person);\n\n }\n\nList<Person> personList2 = persons.stream().sorted((p1, p2) ->\n\np1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());\n\nSystem.out.println(personList2);\n```\n首先对5个元素的Stream排序，然后进行limit操作。输出结果为：\n```\nname2\n\nname1\n\nname3\n\nname2\n\nname4\n\nname3\n\nname5\n\nname4\n\n[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]\n```\n即虽然最后的返回元素数量是2，但整个管道中的sorted表达式执行次数没有像之前示例一样相应减少。\n\n最后有一种需要注意的是，对一个parallel的Stream管道来说，如果其元素是有序的，那么limit操作的成本会比较大，因为它的返回对象必须是前n个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用parallel Stream。\n\n- sorted\n\n对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。对之前示例可进行优化：\n\n**排序前进行 limit 和 skip**\n```\nList<Person> persons = new ArrayList();\n\n for (int i = 1; i <= 5; i++) {\n\n Person person = new Person(i, \"name\" + i);\n\n persons.add(person);\n\n }\n\nList<Person> personList2 = persons.stream().limit(2).sorted((p1, p2) -> p1.getName().compareTo(p2.getName())).collect(Collectors.toList());\n\nSystem.out.println(personList2);\n```\n**结果为：**\n```\nname2\n\nname1\n\n[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]\n```\n当然这种优化是有business logic上的局限性的：即不要求排序后再取值\n\n- min/max/distinct\n\nmin和max的功能也可以通过对Stream元素先排序，再findFirst来实现，但前者的性能会更好，为O(n)，而sorted的成本是O(n log n)。同时它们作为特殊的reduce方法被独立出来也是因为求最大最小值是很常见的操作。\n\n**找出最长一行的长度**\n```\nBufferedReader br = new BufferedReader(new FileReader(\"c:\\\\SUService.log\"));\n\nint longest = br.lines().\n\n mapToInt(String::length).\n\n max().\n\n getAsInt();\n\nbr.close();\n\nSystem.out.println(longest);\n```\n\n**找出全文的单词，转小写，并排序**\n```\nList<String> words = br.lines().\n\n flatMap(line -> Stream.of(line.split(\" \"))).\n\n filter(word -> word.length() > 0).\n\n map(String::toLowerCase).\n\n distinct().\n\n sorted().\n\n collect(Collectors.toList());\n\nbr.close();\n\nSystem.out.println(words);\n```\n\n- Match\n\nStream有三个match方法，从语义上说：\n\n    allMatch：Stream中全部元素符合传入的predicate，返回true\n    anyMatch：Stream中只要有一个元素符合传入的predicate，返回true\n    noneMatch：Stream中没有一个元素符合传入的predicate，返回true\n\n它们都不是要遍历全部元素才能返回结果。例如allMatch只要一个元素不满足条件，就skip剩下的所有元素，返回false。\n\n**使用Match**\n```\nList<Person> persons = new ArrayList();\n\npersons.add(new Person(1, \"name\" + 1, 10));\n\npersons.add(new Person(2, \"name\" + 2, 21));\n\npersons.add(new Person(3, \"name\" + 3, 34));\n\npersons.add(new Person(4, \"name\" + 4, 6));\n\npersons.add(new Person(5, \"name\" + 5, 55));\n\nboolean isAllAdult = persons.stream().\n\n allMatch(p -> p.getAge() > 18);\n\nSystem.out.println(\"All are adult? \" + isAllAdult);\n\nboolean isThereAnyChild = persons.stream().\n\n anyMatch(p -> p.getAge() < 12);\n\nSystem.out.println(\"Any child? \" + isThereAnyChild);\n```\n\n**输出结果：**\n```\nAll are adult? false\n\nAny child? true\n```\n\n## 进阶：自己生成流\n\n- Stream.generate\n\n通过实现Supplier接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的Stream，或者需要前后元素间维持着某种状态信息的Stream。把Supplier实例传递给Stream.generate()生成的Stream，默认是串行（相对parallel而言）但无序的（相对ordered而言）。由于它是无限的，在管道中，必须利用limit之类的操作限制Stream大小。\n\n**生成10个随机整数**\n```\nRandom seed = new Random();\n\nSupplier<Integer> random = seed::nextInt;\n\nStream.generate(random).limit(10).forEach(System.out::println);\n\n//Another way\n\nIntStream.generate(() -> (int) (System.nanoTime() % 100)).\n\nlimit(10).forEach(System.out::println);\n```\nStream.generate()还接受自己实现的Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算Stream的每个元素值。这些都是维持状态信息的情形。\n\n**自实现Supplier**\n```\nStream.generate(new PersonSupplier()).\n\nlimit(10).\n\nforEach(p -> System.out.println(p.getName() + \", \" + p.getAge()));\n\nprivate class PersonSupplier implements Supplier<Person> {\n\n private int index = 0;\n\n private Random random = new Random();\n\n @Override\n\n public Person get() {\n\n return new Person(index++, \"StormTestUser\" + index, random.nextInt(100));\n\n }\n\n}\n```\n\n**输出结果：**\n```\nStormTestUser1, 9\n\nStormTestUser2, 12\n\nStormTestUser3, 88\n\nStormTestUser4, 51\n\nStormTestUser5, 22\n\nStormTestUser6, 28\n\nStormTestUser7, 81\n\nStormTestUser8, 51\n\nStormTestUser9, 4\n\nStormTestUser10, 76\n```\n\n- Stream.iterate\n\niterate跟reduce操作很像，接受一个种子值，和一个UnaryOperator（例如f）。然后种子值成为Stream的第一个元素，f(seed)为第二个，f(f(seed))第三个，以此类推。\n\n**生成一个等差数列**\n```\nStream.iterate(0, n -> n + 3).limit(10). forEach(x -> System.out.print(x + \" \"));\n```\n\n**输出结果：**\n```\n0 3 6 9 12 15 18 21 24 27\n```\n与Stream.generate相仿，在iterate时候管道必须有limit这样的操作来限制Stream大小。\n\n\n## 进阶：用Collectors来进行reduction操作\n\njava.util.stream.Collectors类的主要作用就是辅助进行各类有用的reduction操作，例如转变输出为Collection，把Stream元素进行归组，\n\n- groupingBy/partitioningBy\n\n**按照年龄归组**\n```\nMap<Integer, List<Person>> personGroups = Stream.generate(new PersonSupplier()).\n\n limit(100).\n\n collect(Collectors.groupingBy(Person::getAge));\n\nIterator it = personGroups.entrySet().iterator();\n\nwhile (it.hasNext()) {\n\n Map.Entry<Integer, List<Person>> persons = (Map.Entry) it.next();\n\n System.out.println(\"Age \" + persons.getKey() + \" = \" + persons.getValue().size());\n\n}\n```\n上面的示例，首先生成100人的信息，然后按照年龄归组，相同年龄的人放到同一个list中，可以看到如下的输出：\n```\nAge 0 = 2\n\nAge 1 = 2\n\nAge 5 = 2\n\nAge 8 = 1\n\nAge 9 = 1\n\nAge 11 = 2\n\n……\n```\n\n**按照未成年人和成年人归组**\n```\nMap<Boolean, List<Person>> children = Stream.generate(new PersonSupplier()).\n\n limit(100).\n\n collect(Collectors.partitioningBy(p -> p.getAge() < 18));\n\nSystem.out.println(\"Children number: \" + children.get(true).size());\n\nSystem.out.println(\"Adult number: \" + children.get(false).size());\n```\n\n**输出结果：**\n```\nChildren number: 23\n\nAdult number: 77\n```\n在使用条件“年龄小于18”进行分组后可以看到，不到18岁的未成年人是一组，成年人是另外一组。partitioningBy其实是一种特殊的groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true)和get(false)能即为全部的元素对象。\n\n## 结束语\n总之，Stream的特性可以归纳为：\n\n- 不是数据结构\n- 它没有内部存储，它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据\n- 它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素\n- 所有Stream的操作必须以lambda表达式为参数\n- 不支持索引访问\n- 你可以请求第一个元素，但无法请求第二个，第三个或者最后一个。不过请参阅下一项\n- 很容易生成数组或者List\n- 惰性化\n- 很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始\n- Intermediate操作永远是惰性化的\n- 并行能力\n- 当一个Stream是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的\n- 可以是无限的\n- 集合有固定大小，Stream则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成","source":"_posts/stream-jdk1.8.md","raw":"---\ntitle: JDK1.8中的Stream详解\ndate: 2018-7-13 16:38:12\ncategories: [开发,总结]\ntags: [Stream,Java]\n---\n> 别处看到的文章，对其再次进行了整理。收获很多。\n\n## Stream简介\nStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。\n\n## 什么是聚合操作\n在传统的J2EE应用中，Java代码经常不得不依赖于关系型数据库的聚合操作来完成某些操作，诸如：\n\n- 客户每月平均消费金额\n- 最昂贵的在售商品\n- 本周完成的有效订单（排除了无效的）\n- 取十个数据样本作为首页推荐\n\n但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离RDBMS,或者以底层返回的数据为基础进行更上层的数据统计。而Java的集合API中，仅仅有极少量的辅助性方法，更多的时候是程序员需要用Iterator来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在Java7中，如果要发现type为grocery的所有交易，然后返回以交易值降序排序好的交易ID集合，我们需要这样写：\n\n### Java7的排序、取值实现\n```\nList<Transaction> groceryTransactions = new Arraylist<>();\n\nfor(Transaction t: transactions){\n\n if(t.getType() == Transaction.GROCERY){\n\n groceryTransactions.add(t);\n\n }\n\n}\n\nCollections.sort(groceryTransactions, new Comparator(){\n\n public int compare(Transaction t1, Transaction t2){\n\n return t2.getValue().compareTo(t1.getValue());\n\n }\n\n});\n\nList<Integer> transactionIds = new ArrayList<>();\n\nfor(Transaction t: groceryTransactions){\n\n transactionsIds.add(t.getId());\n\n}\n```\n\n### Java8的排序、取值实现\nJava8中使用Stream，代码更加简洁易读，而且使用并发模式，程序执行速度更快。\n```\nList<Integer> transactionsIds = transactions.parallelStream().\n\n filter(t -> t.getType() == Transaction.GROCERY).\n\n sorted(comparing(Transaction::getValue).reversed()).\n\n map(Transaction::getId).\n\n collect(toList());\n```\n\n## Stream总览\n### 什么是流\nStream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。\n\nStream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。\n\n而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方法去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork/Join框架（JSR166y）来拆分任务和加速处理过程。Java的并行API演变历程基本如下：\n\n- 1.0-1.4中的java.lang.Thread\n- 5.0中的java.util.concurrent\n- 6.0中的Phasers等\n- 7.0中的Fork/Join框架\n- 8.0中的Lambda\n\n**Stream的另外一大特点是，数据源本身可以是无限的。***\n\n### 流的构成\n当我们使用一个流的时候，通常包括三个基本步骤：\n\n获取一个数据源（source） → 数据转换 → 执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示：\n\n**流管道（Stream Pipeline）的构成**\n\n![](https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png)\n\n有多种方式生成 Stream Source：\n\n- 从Collection和数组\n    + Collection.stream()\n    + Collection.parallelStream()\n    + Arrays.stream(T array) or Stream.of()\n\n- 从BufferedReader\n    + java.io.BufferedReader.lines()\\\n\n- 静态工厂\n    + java.util.stream.IntStream.range()\n    + java.nio.file.Files.walk()\n\n- 自己构建\n    + java.util.Spliterator\n\n- 其它\n    + Random.ints()\n    + BitSet.stream()\n    + Pattern.splitAsStream(java.lang.CharSequence)\n    + JarFile.stream()\n\n流的操作类型分为两种：\n\n- Intermediate：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。\n- Terminal：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个side effect。\n\n在对于一个Stream进行多次转换操作（Intermediate操作），每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和么？其实不是这样的，转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。\n\n还有一种操作被称为short-circuiting。用以指：\n\n- 对于一个intermediate操作，如果它接收的是一个无限大（infinite/unbounded）的Stream，但返回一个有限的新Stream。\n- 对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。\n\n当操作一个无限大的Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。\n\n**一个流操作的示例**\n```\nint sum = widgets.stream()\n\n.filter(w -> w.getColor() == RED)\n\n.mapToInt(w -> w.getWeight())\n\n.sum();\n```\nstream()获取当前小物件的source,filter和mapToInt为intermediate操作，进行数据筛选和转换，最后一个sum()为terminal操作，对符合条件的全部小物件作重量求和。\n\n## 流的使用详解\n简单说，对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（side effect）。\n### 流的构造与转换\n下面提供最常见的几种构造Stream的样例。\n\n**构造流的几种常见方法**\n```\n// 1. Individual values\n\nStream stream = Stream.of(\"a\", \"b\", \"c\");\n\n// 2. Arrays\n\nString [] strArray = new String[] {\"a\", \"b\", \"c\"};\n\nstream = Stream.of(strArray);\n\nstream = Arrays.stream(strArray);\n\n// 3. Collections\n\nList<String> list = Arrays.asList(strArray);\n\nstream = list.stream();\n```\n需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：\n\nIntStream、LongStream、DoubleStream。当然我们也可以用Stream<Integer>、Stream<Long>、Stream<Double>，但是boxing和unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。\n\nJava8中还没有提供其它数值型Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种Stream进行。\n\n**数据流的构造**\n```\nIntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);\n\nIntStream.range(1, 3).forEach(System.out::println);\n\nIntStream.rangeClosed(1, 3).forEach(System.out::println);\n```\n\n**流转换为其它数据结构**\n```\n// 1. Array\n\nString[] strArray1 = stream.toArray(String[]::new);\n\n// 2. Collection\n\nList<String> list1 = stream.collect(Collectors.toList());\n\nList<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));\n\nSet set1 = stream.collect(Collectors.toSet());\n\nStack stack1 = stream.collect(Collectors.toCollection(Stack::new));\n\n// 3. String\n\nString str = stream.collect(Collectors.joining()).toString();\n```\n***注：一个Stream只可以使用一个，以上示例只是为了代码简洁而重复使用数次。***\n\n### 流的操作\n接下来，当把一个数据结构包装成Stream后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下：\n\n- Intermediate：map(mapToint，flatMap等)、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered\n- Terminal：forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator\n- Short-circuiting：anyMatch、allMatch、noneMatch、findFirst、findAny、limit\n\n接下来下面看一下Stream的比较典型用法。\n\n- map/flatMap\n\n先来看map。如果熟悉scala这类函数式语言，对这个方法应该很了解，它的作用就是把input Stream的每一个元素，映射成output Stream的另外一个元素。\n\n**转换大写**\n```\nList<String> output = wordList.stream().\n\nmap(String::toUpperCase).\n\ncollect(Collectors.toList());\n```\n\n**平方数**\n```\nList<Integer> nums = Arrays.asList(1, 2, 3, 4);\n\nList<Integer> squareNums = nums.stream().\n\nmap(n -> n * n).\n\ncollect(Collectors.toList());\n```\n\n从上面例子可以看出，map生成的是个1:1映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap。\n\n**一对多**\n```\nStream<List<Integer>> inputStream = Stream.of(\n\n Arrays.asList(1),\n\n Arrays.asList(2, 3),\n\n Arrays.asList(4, 5, 6)\n\n );\n\nStream<Integer> outputStream = inputStream.\n\nflatMap((childList) -> childList.stream());\n```\nflatMap把input Stream中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。\n\n- filter\n\nfilter对原始Stream进行某项测试，通过测试的元素被留下来生成一个新Stream。\n\n**留下偶数**\n```\nInteger[] sixNums = {1, 2, 3, 4, 5, 6};\n\nInteger[] evens =\n\nStream.of(sixNums).filter(n -> n%2 == 0).toArray(Integer[]::new);\n```\n经过条件“被2整除”的filter，剩下的数字为{2,4,6}。\n\n**把单词挑出来**\n```\nList<String> output = reader.lines().\n\nflatMap(line -> Stream.of(line.split(REGEXP))).\n\nfilter(word -> word.length() > 0).\n\ncollect(Collectors.toList());\n```\n这段代码首先把每行的单词用flatMap整理到新的Stream，然后保留长度不为0的，就是整篇文章中的所有单词了。\n\n- forEach\n\nforEach方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式。\n\n**打印姓名（forEach和pre-java8的对比）**\n```\n// Java 8\n\nroster.stream()\n\n .filter(p -> p.getGender() == Person.Sex.MALE)\n\n .forEach(p -> System.out.println(p.getName()));\n\n// Pre-Java 8\n\nfor (Person p : roster) {\n\n if (p.getGender() == Person.Sex.MALE) {\n\n System.out.println(p.getName());\n\n }\n\n}\n```\n对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach是为Lambda而设计的，保持了最紧凑的风格。而且lambda表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时forEach本身的实现不需要调整，而Java8以前的for循环code可能需要加入额外的多线程逻辑。\n\n但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统Java风格的差别。\n\n另外一点需要注意，forEach是terminal操作，因此它执行后，Stream的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：\n```\nstream.forEach(element -> doOneThing(element));\n\nstream.forEach(element -> doAnotherThing(element));\n```\n相反，具有相似功能的intermediate操作peek可以达到上述目的。如下是出现在该api javadoc上的一个示例。\n\n**peek 对每个元素执行操作并返回一个新的 Stream**\n```\nStream.of(\"one\", \"two\", \"three\", \"four\")\n\n.filter(e -> e.length() > 3)\n\n.peek(e -> System.out.println(\"Filtered value: \" + e))\n\n.map(String::toUpperCase)\n\n.peek(e -> System.out.println(\"Mapped value: \" + e))\n\n.collect(Collectors.toList());\n```\nforEach不能修改自己包含的本地变量值，也不能用break/return之类的关键字提前结束循环。\n\n- findFirst\n\n这是一个terminal兼short-circuiting操作，它总是返回Stream的第一个元素，或者空。\n\n这里比较重点的是它的返回值类型：Optional。这也是一个模仿Scala语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免NullPointerException。\n\n**Optional的两个用例**\n```\nString strA = \" abcd \", strB = null;\n\nprint(strA);\n\nprint(\"\");\n\nprint(strB);\n\ngetLength(strA);\n\ngetLength(\"\");\n\ngetLength(strB);\n\npublic static void print(String text) {\n\n // Java 8\n\n Optional.ofNullable(text).ifPresent(System.out::println);\n\n // Pre-Java 8\n\n if (text != null) {\n\n System.out.println(text);\n\n }\n\n }\n\npublic static int getLength(String text) {\n\n // Java 8\n\nreturn Optional.ofNullable(text).map(String::length).orElse(-1);\n\n // Pre-Java 8\n\n// return if (text != null) ? text.length() : -1;\n\n };\n```\n在更复杂的if(xx != null)的情况中，使用Optional代码的可读性更好，而且它提供的是编译时检查，能极大的降低NPE这种Runtime Exception对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。\n\nStream中的findAny、max/min、reduce等方法返回Optional值。还有例如IntStream.average()返回Optional Double等等。\n\n- reduce\n\n这个方法的主要作用是把Stream元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面Stream的第一个、第二个、第n个元素组合。从这个意义上说，字符串拼接、数值的sum、min、max、average都是特殊的reduce。例如Stream的sum就相当于\n```\nInteger sum = integers.reduce(0,(a,b) -> a+b);\n```\n或\n```\nInteger sum = integers.reduce(0,Integer::sum);\n```\n也有没有起始值的情况，这时会把Stream的前面两个元素组合起来，返回的是Optional。\n\n**reduce的用例**\n```\n// 字符串连接，concat = \"ABCD\"\n\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat);\n\n// 求最小值，minValue = -3.0\n\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);\n\n// 求和，sumValue = 10, 有起始值\n\nint sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);\n\n// 求和，sumValue = 10, 无起始值\n\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n\n// 过滤，字符串连接，concat = \"ace\"\n\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\n\n filter(x -> x.compareTo(\"Z\") > 0).\n\n reduce(\"\", String::concat);\n```\n上面代码例如第一个示例的reduce(),第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。这类有起始值的reduce()都返回具体的对象。而对于第四个示例没有起始值的reduce(),由于可能没有足够的元素，返回的是Optional，请留意这个区间。\n\n- limit/skip\n\nlimit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫subStream的方法改名而来）。\n\n**limit和skip对运行次数的影响**\n```\npublic void testLimitAndSkip() {\n\n List<Person> persons = new ArrayList();\n\n for (int i = 1; i <= 10000; i++) {\n\n Person person = new Person(i, \"name\" + i);\n\n persons.add(person);\n\n }\n\nList<String> personList2 = persons.stream().\n\nmap(Person::getName).limit(10).skip(3).collect(Collectors.toList());\n\nSystem.out.println(personList2);\n\n}\n\nprivate class Person {\n\n public int no;\n\n private String name;\n\n public Person (int no, String name) {\n\n this.no = no;\n\n this.name = name;\n\n }\n\n public String getName() {\n\n System.out.println(name);\n\n return name;\n\n }\n\n}\n```\n**结果为：**\n```\nname1\n\nname2\n\nname3\n\nname4\n\nname5\n\nname6\n\nname7\n\nname8\n\nname9\n\nname10\n\n[name4, name5, name6, name7, name8, name9, name10]\n```\n\n这是一个有10000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为limit所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。\n\n还有一种情况是limit/skip无法达到short-circuiting目的地，就是把它们放在Stream的排序操作后，原因跟sorted这个intermediate操作有关：此时系统并不知道Stream排序后的次序如何，所以sorted中的操作看上去就像完全没有被limit或者skip一样。\n\n**limit和skip对sorted后的运行次数无影响**\n```\nList<Person> persons = new ArrayList();\n\n for (int i = 1; i <= 5; i++) {\n\n Person person = new Person(i, \"name\" + i);\n\n persons.add(person);\n\n }\n\nList<Person> personList2 = persons.stream().sorted((p1, p2) ->\n\np1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());\n\nSystem.out.println(personList2);\n```\n首先对5个元素的Stream排序，然后进行limit操作。输出结果为：\n```\nname2\n\nname1\n\nname3\n\nname2\n\nname4\n\nname3\n\nname5\n\nname4\n\n[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]\n```\n即虽然最后的返回元素数量是2，但整个管道中的sorted表达式执行次数没有像之前示例一样相应减少。\n\n最后有一种需要注意的是，对一个parallel的Stream管道来说，如果其元素是有序的，那么limit操作的成本会比较大，因为它的返回对象必须是前n个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用parallel Stream。\n\n- sorted\n\n对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。对之前示例可进行优化：\n\n**排序前进行 limit 和 skip**\n```\nList<Person> persons = new ArrayList();\n\n for (int i = 1; i <= 5; i++) {\n\n Person person = new Person(i, \"name\" + i);\n\n persons.add(person);\n\n }\n\nList<Person> personList2 = persons.stream().limit(2).sorted((p1, p2) -> p1.getName().compareTo(p2.getName())).collect(Collectors.toList());\n\nSystem.out.println(personList2);\n```\n**结果为：**\n```\nname2\n\nname1\n\n[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]\n```\n当然这种优化是有business logic上的局限性的：即不要求排序后再取值\n\n- min/max/distinct\n\nmin和max的功能也可以通过对Stream元素先排序，再findFirst来实现，但前者的性能会更好，为O(n)，而sorted的成本是O(n log n)。同时它们作为特殊的reduce方法被独立出来也是因为求最大最小值是很常见的操作。\n\n**找出最长一行的长度**\n```\nBufferedReader br = new BufferedReader(new FileReader(\"c:\\\\SUService.log\"));\n\nint longest = br.lines().\n\n mapToInt(String::length).\n\n max().\n\n getAsInt();\n\nbr.close();\n\nSystem.out.println(longest);\n```\n\n**找出全文的单词，转小写，并排序**\n```\nList<String> words = br.lines().\n\n flatMap(line -> Stream.of(line.split(\" \"))).\n\n filter(word -> word.length() > 0).\n\n map(String::toLowerCase).\n\n distinct().\n\n sorted().\n\n collect(Collectors.toList());\n\nbr.close();\n\nSystem.out.println(words);\n```\n\n- Match\n\nStream有三个match方法，从语义上说：\n\n    allMatch：Stream中全部元素符合传入的predicate，返回true\n    anyMatch：Stream中只要有一个元素符合传入的predicate，返回true\n    noneMatch：Stream中没有一个元素符合传入的predicate，返回true\n\n它们都不是要遍历全部元素才能返回结果。例如allMatch只要一个元素不满足条件，就skip剩下的所有元素，返回false。\n\n**使用Match**\n```\nList<Person> persons = new ArrayList();\n\npersons.add(new Person(1, \"name\" + 1, 10));\n\npersons.add(new Person(2, \"name\" + 2, 21));\n\npersons.add(new Person(3, \"name\" + 3, 34));\n\npersons.add(new Person(4, \"name\" + 4, 6));\n\npersons.add(new Person(5, \"name\" + 5, 55));\n\nboolean isAllAdult = persons.stream().\n\n allMatch(p -> p.getAge() > 18);\n\nSystem.out.println(\"All are adult? \" + isAllAdult);\n\nboolean isThereAnyChild = persons.stream().\n\n anyMatch(p -> p.getAge() < 12);\n\nSystem.out.println(\"Any child? \" + isThereAnyChild);\n```\n\n**输出结果：**\n```\nAll are adult? false\n\nAny child? true\n```\n\n## 进阶：自己生成流\n\n- Stream.generate\n\n通过实现Supplier接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的Stream，或者需要前后元素间维持着某种状态信息的Stream。把Supplier实例传递给Stream.generate()生成的Stream，默认是串行（相对parallel而言）但无序的（相对ordered而言）。由于它是无限的，在管道中，必须利用limit之类的操作限制Stream大小。\n\n**生成10个随机整数**\n```\nRandom seed = new Random();\n\nSupplier<Integer> random = seed::nextInt;\n\nStream.generate(random).limit(10).forEach(System.out::println);\n\n//Another way\n\nIntStream.generate(() -> (int) (System.nanoTime() % 100)).\n\nlimit(10).forEach(System.out::println);\n```\nStream.generate()还接受自己实现的Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算Stream的每个元素值。这些都是维持状态信息的情形。\n\n**自实现Supplier**\n```\nStream.generate(new PersonSupplier()).\n\nlimit(10).\n\nforEach(p -> System.out.println(p.getName() + \", \" + p.getAge()));\n\nprivate class PersonSupplier implements Supplier<Person> {\n\n private int index = 0;\n\n private Random random = new Random();\n\n @Override\n\n public Person get() {\n\n return new Person(index++, \"StormTestUser\" + index, random.nextInt(100));\n\n }\n\n}\n```\n\n**输出结果：**\n```\nStormTestUser1, 9\n\nStormTestUser2, 12\n\nStormTestUser3, 88\n\nStormTestUser4, 51\n\nStormTestUser5, 22\n\nStormTestUser6, 28\n\nStormTestUser7, 81\n\nStormTestUser8, 51\n\nStormTestUser9, 4\n\nStormTestUser10, 76\n```\n\n- Stream.iterate\n\niterate跟reduce操作很像，接受一个种子值，和一个UnaryOperator（例如f）。然后种子值成为Stream的第一个元素，f(seed)为第二个，f(f(seed))第三个，以此类推。\n\n**生成一个等差数列**\n```\nStream.iterate(0, n -> n + 3).limit(10). forEach(x -> System.out.print(x + \" \"));\n```\n\n**输出结果：**\n```\n0 3 6 9 12 15 18 21 24 27\n```\n与Stream.generate相仿，在iterate时候管道必须有limit这样的操作来限制Stream大小。\n\n\n## 进阶：用Collectors来进行reduction操作\n\njava.util.stream.Collectors类的主要作用就是辅助进行各类有用的reduction操作，例如转变输出为Collection，把Stream元素进行归组，\n\n- groupingBy/partitioningBy\n\n**按照年龄归组**\n```\nMap<Integer, List<Person>> personGroups = Stream.generate(new PersonSupplier()).\n\n limit(100).\n\n collect(Collectors.groupingBy(Person::getAge));\n\nIterator it = personGroups.entrySet().iterator();\n\nwhile (it.hasNext()) {\n\n Map.Entry<Integer, List<Person>> persons = (Map.Entry) it.next();\n\n System.out.println(\"Age \" + persons.getKey() + \" = \" + persons.getValue().size());\n\n}\n```\n上面的示例，首先生成100人的信息，然后按照年龄归组，相同年龄的人放到同一个list中，可以看到如下的输出：\n```\nAge 0 = 2\n\nAge 1 = 2\n\nAge 5 = 2\n\nAge 8 = 1\n\nAge 9 = 1\n\nAge 11 = 2\n\n……\n```\n\n**按照未成年人和成年人归组**\n```\nMap<Boolean, List<Person>> children = Stream.generate(new PersonSupplier()).\n\n limit(100).\n\n collect(Collectors.partitioningBy(p -> p.getAge() < 18));\n\nSystem.out.println(\"Children number: \" + children.get(true).size());\n\nSystem.out.println(\"Adult number: \" + children.get(false).size());\n```\n\n**输出结果：**\n```\nChildren number: 23\n\nAdult number: 77\n```\n在使用条件“年龄小于18”进行分组后可以看到，不到18岁的未成年人是一组，成年人是另外一组。partitioningBy其实是一种特殊的groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true)和get(false)能即为全部的元素对象。\n\n## 结束语\n总之，Stream的特性可以归纳为：\n\n- 不是数据结构\n- 它没有内部存储，它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据\n- 它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素\n- 所有Stream的操作必须以lambda表达式为参数\n- 不支持索引访问\n- 你可以请求第一个元素，但无法请求第二个，第三个或者最后一个。不过请参阅下一项\n- 很容易生成数组或者List\n- 惰性化\n- 很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始\n- Intermediate操作永远是惰性化的\n- 并行能力\n- 当一个Stream是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的\n- 可以是无限的\n- 集合有固定大小，Stream则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成","slug":"stream-jdk1.8","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhr00bpk9i111ra6a1s","content":"<blockquote>\n<p>别处看到的文章，对其再次进行了整理。收获很多。</p>\n</blockquote>\n<h2 id=\"Stream简介\"><a href=\"#Stream简介\" class=\"headerlink\" title=\"Stream简介\"></a>Stream简介</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork&#x2F;join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>\n<h2 id=\"什么是聚合操作\"><a href=\"#什么是聚合操作\" class=\"headerlink\" title=\"什么是聚合操作\"></a>什么是聚合操作</h2><p>在传统的J2EE应用中，Java代码经常不得不依赖于关系型数据库的聚合操作来完成某些操作，诸如：</p>\n<ul>\n<li>客户每月平均消费金额</li>\n<li>最昂贵的在售商品</li>\n<li>本周完成的有效订单（排除了无效的）</li>\n<li>取十个数据样本作为首页推荐</li>\n</ul>\n<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离RDBMS,或者以底层返回的数据为基础进行更上层的数据统计。而Java的集合API中，仅仅有极少量的辅助性方法，更多的时候是程序员需要用Iterator来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在Java7中，如果要发现type为grocery的所有交易，然后返回以交易值降序排序好的交易ID集合，我们需要这样写：</p>\n<h3 id=\"Java7的排序、取值实现\"><a href=\"#Java7的排序、取值实现\" class=\"headerlink\" title=\"Java7的排序、取值实现\"></a>Java7的排序、取值实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">for(Transaction t: transactions)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(t.getType() == Transaction.GROCERY)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> groceryTransactions.add(t);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Collections.sort(groceryTransactions, new Comparator()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> public int compare(Transaction t1, Transaction t2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> return t2.getValue().compareTo(t1.getValue());</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">for(Transaction t: groceryTransactions)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> transactionsIds.add(t.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java8的排序、取值实现\"><a href=\"#Java8的排序、取值实现\" class=\"headerlink\" title=\"Java8的排序、取值实现\"></a>Java8的排序、取值实现</h3><p>Java8中使用Stream，代码更加简洁易读，而且使用并发模式，程序执行速度更快。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; transactionsIds = transactions.parallelStream().</span><br><span class=\"line\"></span><br><span class=\"line\"> filter(t -&gt; t.getType() == Transaction.GROCERY).</span><br><span class=\"line\"></span><br><span class=\"line\"> sorted(comparing(Transaction::getValue).reversed()).</span><br><span class=\"line\"></span><br><span class=\"line\"> map(Transaction::getId).</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(toList());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream总览\"><a href=\"#Stream总览\" class=\"headerlink\" title=\"Stream总览\"></a>Stream总览</h2><h3 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h3><p>Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>\n<p>而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方法去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork&#x2F;Join框架（JSR166y）来拆分任务和加速处理过程。Java的并行API演变历程基本如下：</p>\n<ul>\n<li>1.0-1.4中的java.lang.Thread</li>\n<li>5.0中的java.util.concurrent</li>\n<li>6.0中的Phasers等</li>\n<li>7.0中的Fork&#x2F;Join框架</li>\n<li>8.0中的Lambda</li>\n</ul>\n<p><strong>Stream的另外一大特点是，数据源本身可以是无限的。</strong>*</p>\n<h3 id=\"流的构成\"><a href=\"#流的构成\" class=\"headerlink\" title=\"流的构成\"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>\n<p>获取一个数据源（source） → 数据转换 → 执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示：</p>\n<p><strong>流管道（Stream Pipeline）的构成</strong></p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png\"></p>\n<p>有多种方式生成 Stream Source：</p>\n<ul>\n<li><p>从Collection和数组</p>\n<ul>\n<li>Collection.stream()</li>\n<li>Collection.parallelStream()</li>\n<li>Arrays.stream(T array) or Stream.of()</li>\n</ul>\n</li>\n<li><p>从BufferedReader</p>\n<ul>\n<li>java.io.BufferedReader.lines()\\</li>\n</ul>\n</li>\n<li><p>静态工厂</p>\n<ul>\n<li>java.util.stream.IntStream.range()</li>\n<li>java.nio.file.Files.walk()</li>\n</ul>\n</li>\n<li><p>自己构建</p>\n<ul>\n<li>java.util.Spliterator</li>\n</ul>\n</li>\n<li><p>其它</p>\n<ul>\n<li>Random.ints()</li>\n<li>BitSet.stream()</li>\n<li>Pattern.splitAsStream(java.lang.CharSequence)</li>\n<li>JarFile.stream()</li>\n</ul>\n</li>\n</ul>\n<p>流的操作类型分为两种：</p>\n<ul>\n<li>Intermediate：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>\n<li>Terminal：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个side effect。</li>\n</ul>\n<p>在对于一个Stream进行多次转换操作（Intermediate操作），每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和么？其实不是这样的，转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。</p>\n<p>还有一种操作被称为short-circuiting。用以指：</p>\n<ul>\n<li>对于一个intermediate操作，如果它接收的是一个无限大（infinite&#x2F;unbounded）的Stream，但返回一个有限的新Stream。</li>\n<li>对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。</li>\n</ul>\n<p>当操作一个无限大的Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。</p>\n<p><strong>一个流操作的示例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sum = widgets.stream()</span><br><span class=\"line\"></span><br><span class=\"line\">.filter(w -&gt; w.getColor() == RED)</span><br><span class=\"line\"></span><br><span class=\"line\">.mapToInt(w -&gt; w.getWeight())</span><br><span class=\"line\"></span><br><span class=\"line\">.sum();</span><br></pre></td></tr></table></figure>\n<p>stream()获取当前小物件的source,filter和mapToInt为intermediate操作，进行数据筛选和转换，最后一个sum()为terminal操作，对符合条件的全部小物件作重量求和。</p>\n<h2 id=\"流的使用详解\"><a href=\"#流的使用详解\" class=\"headerlink\" title=\"流的使用详解\"></a>流的使用详解</h2><p>简单说，对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>\n<h3 id=\"流的构造与转换\"><a href=\"#流的构造与转换\" class=\"headerlink\" title=\"流的构造与转换\"></a>流的构造与转换</h3><p>下面提供最常见的几种构造Stream的样例。</p>\n<p><strong>构造流的几种常见方法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. Individual values</span><br><span class=\"line\"></span><br><span class=\"line\">Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. Arrays</span><br><span class=\"line\"></span><br><span class=\"line\">String [] strArray = new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">stream = Stream.of(strArray);</span><br><span class=\"line\"></span><br><span class=\"line\">stream = Arrays.stream(strArray);</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. Collections</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class=\"line\"></span><br><span class=\"line\">stream = list.stream();</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：</p>\n<p>IntStream、LongStream、DoubleStream。当然我们也可以用Stream<Integer>、Stream<Long>、Stream<Double>，但是boxing和unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。</p>\n<p>Java8中还没有提供其它数值型Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种Stream进行。</p>\n<p><strong>数据流的构造</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">IntStream.range(1, 3).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">IntStream.rangeClosed(1, 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p><strong>流转换为其它数据结构</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. Array</span><br><span class=\"line\"></span><br><span class=\"line\">String[] strArray1 = stream.toArray(String[]::new);</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. Collection</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));</span><br><span class=\"line\"></span><br><span class=\"line\">Set set1 = stream.collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. String</span><br><span class=\"line\"></span><br><span class=\"line\">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure>\n<p><em><strong>注：一个Stream只可以使用一个，以上示例只是为了代码简洁而重复使用数次。</strong></em></p>\n<h3 id=\"流的操作\"><a href=\"#流的操作\" class=\"headerlink\" title=\"流的操作\"></a>流的操作</h3><p>接下来，当把一个数据结构包装成Stream后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下：</p>\n<ul>\n<li>Intermediate：map(mapToint，flatMap等)、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered</li>\n<li>Terminal：forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator</li>\n<li>Short-circuiting：anyMatch、allMatch、noneMatch、findFirst、findAny、limit</li>\n</ul>\n<p>接下来下面看一下Stream的比较典型用法。</p>\n<ul>\n<li>map&#x2F;flatMap</li>\n</ul>\n<p>先来看map。如果熟悉scala这类函数式语言，对这个方法应该很了解，它的作用就是把input Stream的每一个元素，映射成output Stream的另外一个元素。</p>\n<p><strong>转换大写</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = wordList.stream().</span><br><span class=\"line\"></span><br><span class=\"line\">map(String::toUpperCase).</span><br><span class=\"line\"></span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p><strong>平方数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class=\"line\"></span><br><span class=\"line\">map(n -&gt; n * n).</span><br><span class=\"line\"></span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p>从上面例子可以看出，map生成的是个1:1映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap。</p>\n<p><strong>一对多</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class=\"line\"></span><br><span class=\"line\"> Arrays.asList(1),</span><br><span class=\"line\"></span><br><span class=\"line\"> Arrays.asList(2, 3),</span><br><span class=\"line\"></span><br><span class=\"line\"> Arrays.asList(4, 5, 6)</span><br><span class=\"line\"></span><br><span class=\"line\"> );</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class=\"line\"></span><br><span class=\"line\">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>\n<p>flatMap把input Stream中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。</p>\n<ul>\n<li>filter</li>\n</ul>\n<p>filter对原始Stream进行某项测试，通过测试的元素被留下来生成一个新Stream。</p>\n<p><strong>留下偶数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Integer[] evens =</span><br><span class=\"line\"></span><br><span class=\"line\">Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</span><br></pre></td></tr></table></figure>\n<p>经过条件“被2整除”的filter，剩下的数字为{2,4,6}。</p>\n<p><strong>把单词挑出来</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = reader.lines().</span><br><span class=\"line\"></span><br><span class=\"line\">flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class=\"line\"></span><br><span class=\"line\">filter(word -&gt; word.length() &gt; 0).</span><br><span class=\"line\"></span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>这段代码首先把每行的单词用flatMap整理到新的Stream，然后保留长度不为0的，就是整篇文章中的所有单词了。</p>\n<ul>\n<li>forEach</li>\n</ul>\n<p>forEach方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式。</p>\n<p><strong>打印姓名（forEach和pre-java8的对比）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">roster.stream()</span><br><span class=\"line\"></span><br><span class=\"line\"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class=\"line\"></span><br><span class=\"line\"> .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class=\"line\"></span><br><span class=\"line\">// Pre-Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">for (Person p : roster) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> if (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(p.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach是为Lambda而设计的，保持了最紧凑的风格。而且lambda表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时forEach本身的实现不需要调整，而Java8以前的for循环code可能需要加入额外的多线程逻辑。</p>\n<p>但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统Java风格的差别。</p>\n<p>另外一点需要注意，forEach是terminal操作，因此它执行后，Stream的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream.forEach(element -&gt; doOneThing(element));</span><br><span class=\"line\"></span><br><span class=\"line\">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>\n<p>相反，具有相似功能的intermediate操作peek可以达到上述目的。如下是出现在该api javadoc上的一个示例。</p>\n<p><strong>peek 对每个元素执行操作并返回一个新的 Stream</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">.filter(e -&gt; e.length() &gt; 3)</span><br><span class=\"line\"></span><br><span class=\"line\">.peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))</span><br><span class=\"line\"></span><br><span class=\"line\">.map(String::toUpperCase)</span><br><span class=\"line\"></span><br><span class=\"line\">.peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))</span><br><span class=\"line\"></span><br><span class=\"line\">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>forEach不能修改自己包含的本地变量值，也不能用break&#x2F;return之类的关键字提前结束循环。</p>\n<ul>\n<li>findFirst</li>\n</ul>\n<p>这是一个terminal兼short-circuiting操作，它总是返回Stream的第一个元素，或者空。</p>\n<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿Scala语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免NullPointerException。</p>\n<p><strong>Optional的两个用例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String strA = &quot; abcd &quot;, strB = null;</span><br><span class=\"line\"></span><br><span class=\"line\">print(strA);</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">print(strB);</span><br><span class=\"line\"></span><br><span class=\"line\">getLength(strA);</span><br><span class=\"line\"></span><br><span class=\"line\">getLength(&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">getLength(strB);</span><br><span class=\"line\"></span><br><span class=\"line\">public static void print(String text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> // Java 8</span><br><span class=\"line\"></span><br><span class=\"line\"> Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"> // Pre-Java 8</span><br><span class=\"line\"></span><br><span class=\"line\"> if (text != null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(text);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static int getLength(String text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> // Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">return Optional.ofNullable(text).map(String::length).orElse(-1);</span><br><span class=\"line\"></span><br><span class=\"line\"> // Pre-Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">// return if (text != null) ? text.length() : -1;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>在更复杂的if(xx !&#x3D; null)的情况中，使用Optional代码的可读性更好，而且它提供的是编译时检查，能极大的降低NPE这种Runtime Exception对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>\n<p>Stream中的findAny、max&#x2F;min、reduce等方法返回Optional值。还有例如IntStream.average()返回Optional Double等等。</p>\n<ul>\n<li>reduce</li>\n</ul>\n<p>这个方法的主要作用是把Stream元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面Stream的第一个、第二个、第n个元素组合。从这个意义上说，字符串拼接、数值的sum、min、max、average都是特殊的reduce。例如Stream的sum就相当于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer sum = integers.reduce(0,(a,b) -&gt; a+b);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer sum = integers.reduce(0,Integer::sum);</span><br></pre></td></tr></table></figure>\n<p>也有没有起始值的情况，这时会把Stream的前面两个元素组合起来，返回的是Optional。</p>\n<p><strong>reduce的用例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串连接，concat = &quot;ABCD&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat);</span><br><span class=\"line\"></span><br><span class=\"line\">// 求最小值，minValue = -3.0</span><br><span class=\"line\"></span><br><span class=\"line\">double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);</span><br><span class=\"line\"></span><br><span class=\"line\">// 求和，sumValue = 10, 有起始值</span><br><span class=\"line\"></span><br><span class=\"line\">int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">// 求和，sumValue = 10, 无起始值</span><br><span class=\"line\"></span><br><span class=\"line\">sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();</span><br><span class=\"line\"></span><br><span class=\"line\">// 过滤，字符串连接，concat = &quot;ace&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).</span><br><span class=\"line\"></span><br><span class=\"line\"> filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).</span><br><span class=\"line\"></span><br><span class=\"line\"> reduce(&quot;&quot;, String::concat);</span><br></pre></td></tr></table></figure>\n<p>上面代码例如第一个示例的reduce(),第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。这类有起始值的reduce()都返回具体的对象。而对于第四个示例没有起始值的reduce(),由于可能没有足够的元素，返回的是Optional，请留意这个区间。</p>\n<ul>\n<li>limit&#x2F;skip</li>\n</ul>\n<p>limit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫subStream的方法改名而来）。</p>\n<p><strong>limit和skip对运行次数的影响</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void testLimitAndSkip() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"> for (int i = 1; i &lt;= 10000; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class=\"line\"></span><br><span class=\"line\"> persons.add(person);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; personList2 = persons.stream().</span><br><span class=\"line\"></span><br><span class=\"line\">map(Person::getName).limit(10).skip(3).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(personList2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> public int no;</span><br><span class=\"line\"></span><br><span class=\"line\"> private String name;</span><br><span class=\"line\"></span><br><span class=\"line\"> public Person (int no, String name) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> this.no = no;</span><br><span class=\"line\"></span><br><span class=\"line\"> this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> public String getName() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(name);</span><br><span class=\"line\"></span><br><span class=\"line\"> return name;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name1</span><br><span class=\"line\"></span><br><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name3</span><br><span class=\"line\"></span><br><span class=\"line\">name4</span><br><span class=\"line\"></span><br><span class=\"line\">name5</span><br><span class=\"line\"></span><br><span class=\"line\">name6</span><br><span class=\"line\"></span><br><span class=\"line\">name7</span><br><span class=\"line\"></span><br><span class=\"line\">name8</span><br><span class=\"line\"></span><br><span class=\"line\">name9</span><br><span class=\"line\"></span><br><span class=\"line\">name10</span><br><span class=\"line\"></span><br><span class=\"line\">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure>\n\n<p>这是一个有10000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为limit所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。</p>\n<p>还有一种情况是limit&#x2F;skip无法达到short-circuiting目的地，就是把它们放在Stream的排序操作后，原因跟sorted这个intermediate操作有关：此时系统并不知道Stream排序后的次序如何，所以sorted中的操作看上去就像完全没有被limit或者skip一样。</p>\n<p><strong>limit和skip对sorted后的运行次数无影响</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"> for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class=\"line\"></span><br><span class=\"line\"> persons.add(person);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure>\n<p>首先对5个元素的Stream排序，然后进行limit操作。输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name1</span><br><span class=\"line\"></span><br><span class=\"line\">name3</span><br><span class=\"line\"></span><br><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name4</span><br><span class=\"line\"></span><br><span class=\"line\">name3</span><br><span class=\"line\"></span><br><span class=\"line\">name5</span><br><span class=\"line\"></span><br><span class=\"line\">name4</span><br><span class=\"line\"></span><br><span class=\"line\">[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</span><br></pre></td></tr></table></figure>\n<p>即虽然最后的返回元素数量是2，但整个管道中的sorted表达式执行次数没有像之前示例一样相应减少。</p>\n<p>最后有一种需要注意的是，对一个parallel的Stream管道来说，如果其元素是有序的，那么limit操作的成本会比较大，因为它的返回对象必须是前n个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用parallel Stream。</p>\n<ul>\n<li>sorted</li>\n</ul>\n<p>对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。对之前示例可进行优化：</p>\n<p><strong>排序前进行 limit 和 skip</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"> for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class=\"line\"></span><br><span class=\"line\"> persons.add(person);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure>\n<p><strong>结果为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name1</span><br><span class=\"line\"></span><br><span class=\"line\">[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</span><br></pre></td></tr></table></figure>\n<p>当然这种优化是有business logic上的局限性的：即不要求排序后再取值</p>\n<ul>\n<li>min&#x2F;max&#x2F;distinct</li>\n</ul>\n<p>min和max的功能也可以通过对Stream元素先排序，再findFirst来实现，但前者的性能会更好，为O(n)，而sorted的成本是O(n log n)。同时它们作为特殊的reduce方法被独立出来也是因为求最大最小值是很常见的操作。</p>\n<p><strong>找出最长一行的长度</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\\\SUService.log&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">int longest = br.lines().</span><br><span class=\"line\"></span><br><span class=\"line\"> mapToInt(String::length).</span><br><span class=\"line\"></span><br><span class=\"line\"> max().</span><br><span class=\"line\"></span><br><span class=\"line\"> getAsInt();</span><br><span class=\"line\"></span><br><span class=\"line\">br.close();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(longest);</span><br></pre></td></tr></table></figure>\n\n<p><strong>找出全文的单词，转小写，并排序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; words = br.lines().</span><br><span class=\"line\"></span><br><span class=\"line\"> flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).</span><br><span class=\"line\"></span><br><span class=\"line\"> filter(word -&gt; word.length() &gt; 0).</span><br><span class=\"line\"></span><br><span class=\"line\"> map(String::toLowerCase).</span><br><span class=\"line\"></span><br><span class=\"line\"> distinct().</span><br><span class=\"line\"></span><br><span class=\"line\"> sorted().</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">br.close();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(words);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Match</li>\n</ul>\n<p>Stream有三个match方法，从语义上说：</p>\n<pre><code>allMatch：Stream中全部元素符合传入的predicate，返回true\nanyMatch：Stream中只要有一个元素符合传入的predicate，返回true\nnoneMatch：Stream中没有一个元素符合传入的predicate，返回true\n</code></pre>\n<p>它们都不是要遍历全部元素才能返回结果。例如allMatch只要一个元素不满足条件，就skip剩下的所有元素，返回false。</p>\n<p><strong>使用Match</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(1, &quot;name&quot; + 1, 10));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(2, &quot;name&quot; + 2, 21));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(3, &quot;name&quot; + 3, 34));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(4, &quot;name&quot; + 4, 6));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(5, &quot;name&quot; + 5, 55));</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isAllAdult = persons.stream().</span><br><span class=\"line\"></span><br><span class=\"line\"> allMatch(p -&gt; p.getAge() &gt; 18);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;All are adult? &quot; + isAllAdult);</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isThereAnyChild = persons.stream().</span><br><span class=\"line\"></span><br><span class=\"line\"> anyMatch(p -&gt; p.getAge() &lt; 12);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Any child? &quot; + isThereAnyChild);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">All are adult? false</span><br><span class=\"line\"></span><br><span class=\"line\">Any child? true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶：自己生成流\"><a href=\"#进阶：自己生成流\" class=\"headerlink\" title=\"进阶：自己生成流\"></a>进阶：自己生成流</h2><ul>\n<li>Stream.generate</li>\n</ul>\n<p>通过实现Supplier接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的Stream，或者需要前后元素间维持着某种状态信息的Stream。把Supplier实例传递给Stream.generate()生成的Stream，默认是串行（相对parallel而言）但无序的（相对ordered而言）。由于它是无限的，在管道中，必须利用limit之类的操作限制Stream大小。</p>\n<p><strong>生成10个随机整数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random seed = new Random();</span><br><span class=\"line\"></span><br><span class=\"line\">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class=\"line\"></span><br><span class=\"line\">Stream.generate(random).limit(10).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">//Another way</span><br><span class=\"line\"></span><br><span class=\"line\">IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).</span><br><span class=\"line\"></span><br><span class=\"line\">limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>Stream.generate()还接受自己实现的Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算Stream的每个元素值。这些都是维持状态信息的情形。</p>\n<p><strong>自实现Supplier</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.generate(new PersonSupplier()).</span><br><span class=\"line\"></span><br><span class=\"line\">limit(10).</span><br><span class=\"line\"></span><br><span class=\"line\">forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));</span><br><span class=\"line\"></span><br><span class=\"line\">private class PersonSupplier implements Supplier&lt;Person&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> private int index = 0;</span><br><span class=\"line\"></span><br><span class=\"line\"> private Random random = new Random();</span><br><span class=\"line\"></span><br><span class=\"line\"> @Override</span><br><span class=\"line\"></span><br><span class=\"line\"> public Person get() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormTestUser1, 9</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser2, 12</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser3, 88</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser4, 51</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser5, 22</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser6, 28</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser7, 81</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser8, 51</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser9, 4</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser10, 76</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Stream.iterate</li>\n</ul>\n<p>iterate跟reduce操作很像，接受一个种子值，和一个UnaryOperator（例如f）。然后种子值成为Stream的第一个元素，f(seed)为第二个，f(f(seed))第三个，以此类推。</p>\n<p><strong>生成一个等差数列</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 3 6 9 12 15 18 21 24 27</span><br></pre></td></tr></table></figure>\n<p>与Stream.generate相仿，在iterate时候管道必须有limit这样的操作来限制Stream大小。</p>\n<h2 id=\"进阶：用Collectors来进行reduction操作\"><a href=\"#进阶：用Collectors来进行reduction操作\" class=\"headerlink\" title=\"进阶：用Collectors来进行reduction操作\"></a>进阶：用Collectors来进行reduction操作</h2><p>java.util.stream.Collectors类的主要作用就是辅助进行各类有用的reduction操作，例如转变输出为Collection，把Stream元素进行归组，</p>\n<ul>\n<li>groupingBy&#x2F;partitioningBy</li>\n</ul>\n<p><strong>按照年龄归组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()).</span><br><span class=\"line\"></span><br><span class=\"line\"> limit(100).</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(Collectors.groupingBy(Person::getAge));</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator it = personGroups.entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">while (it.hasNext()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的示例，首先生成100人的信息，然后按照年龄归组，相同年龄的人放到同一个list中，可以看到如下的输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Age 0 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">Age 1 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">Age 5 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">Age 8 = 1</span><br><span class=\"line\"></span><br><span class=\"line\">Age 9 = 1</span><br><span class=\"line\"></span><br><span class=\"line\">Age 11 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p><strong>按照未成年人和成年人归组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).</span><br><span class=\"line\"></span><br><span class=\"line\"> limit(100).</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Children number: &quot; + children.get(true).size());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Adult number: &quot; + children.get(false).size());</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Children number: 23</span><br><span class=\"line\"></span><br><span class=\"line\">Adult number: 77</span><br></pre></td></tr></table></figure>\n<p>在使用条件“年龄小于18”进行分组后可以看到，不到18岁的未成年人是一组，成年人是另外一组。partitioningBy其实是一种特殊的groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true)和get(false)能即为全部的元素对象。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>总之，Stream的特性可以归纳为：</p>\n<ul>\n<li>不是数据结构</li>\n<li>它没有内部存储，它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据</li>\n<li>它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素</li>\n<li>所有Stream的操作必须以lambda表达式为参数</li>\n<li>不支持索引访问</li>\n<li>你可以请求第一个元素，但无法请求第二个，第三个或者最后一个。不过请参阅下一项</li>\n<li>很容易生成数组或者List</li>\n<li>惰性化</li>\n<li>很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始</li>\n<li>Intermediate操作永远是惰性化的</li>\n<li>并行能力</li>\n<li>当一个Stream是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的</li>\n<li>可以是无限的</li>\n<li>集合有固定大小，Stream则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>别处看到的文章，对其再次进行了整理。收获很多。</p>\n</blockquote>\n<h2 id=\"Stream简介\"><a href=\"#Stream简介\" class=\"headerlink\" title=\"Stream简介\"></a>Stream简介</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork&#x2F;join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>\n<h2 id=\"什么是聚合操作\"><a href=\"#什么是聚合操作\" class=\"headerlink\" title=\"什么是聚合操作\"></a>什么是聚合操作</h2><p>在传统的J2EE应用中，Java代码经常不得不依赖于关系型数据库的聚合操作来完成某些操作，诸如：</p>\n<ul>\n<li>客户每月平均消费金额</li>\n<li>最昂贵的在售商品</li>\n<li>本周完成的有效订单（排除了无效的）</li>\n<li>取十个数据样本作为首页推荐</li>\n</ul>\n<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离RDBMS,或者以底层返回的数据为基础进行更上层的数据统计。而Java的集合API中，仅仅有极少量的辅助性方法，更多的时候是程序员需要用Iterator来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在Java7中，如果要发现type为grocery的所有交易，然后返回以交易值降序排序好的交易ID集合，我们需要这样写：</p>\n<h3 id=\"Java7的排序、取值实现\"><a href=\"#Java7的排序、取值实现\" class=\"headerlink\" title=\"Java7的排序、取值实现\"></a>Java7的排序、取值实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Transaction&gt; groceryTransactions = new Arraylist&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">for(Transaction t: transactions)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> if(t.getType() == Transaction.GROCERY)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> groceryTransactions.add(t);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Collections.sort(groceryTransactions, new Comparator()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> public int compare(Transaction t1, Transaction t2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> return t2.getValue().compareTo(t1.getValue());</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; transactionIds = new ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">for(Transaction t: groceryTransactions)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> transactionsIds.add(t.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Java8的排序、取值实现\"><a href=\"#Java8的排序、取值实现\" class=\"headerlink\" title=\"Java8的排序、取值实现\"></a>Java8的排序、取值实现</h3><p>Java8中使用Stream，代码更加简洁易读，而且使用并发模式，程序执行速度更快。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; transactionsIds = transactions.parallelStream().</span><br><span class=\"line\"></span><br><span class=\"line\"> filter(t -&gt; t.getType() == Transaction.GROCERY).</span><br><span class=\"line\"></span><br><span class=\"line\"> sorted(comparing(Transaction::getValue).reversed()).</span><br><span class=\"line\"></span><br><span class=\"line\"> map(Transaction::getId).</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(toList());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream总览\"><a href=\"#Stream总览\" class=\"headerlink\" title=\"Stream总览\"></a>Stream总览</h2><h3 id=\"什么是流\"><a href=\"#什么是流\" class=\"headerlink\" title=\"什么是流\"></a>什么是流</h3><p>Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>\n<p>而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方法去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数据会被分成多段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream的并行操作依赖于Java7中引入的Fork&#x2F;Join框架（JSR166y）来拆分任务和加速处理过程。Java的并行API演变历程基本如下：</p>\n<ul>\n<li>1.0-1.4中的java.lang.Thread</li>\n<li>5.0中的java.util.concurrent</li>\n<li>6.0中的Phasers等</li>\n<li>7.0中的Fork&#x2F;Join框架</li>\n<li>8.0中的Lambda</li>\n</ul>\n<p><strong>Stream的另外一大特点是，数据源本身可以是无限的。</strong>*</p>\n<h3 id=\"流的构成\"><a href=\"#流的构成\" class=\"headerlink\" title=\"流的构成\"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>\n<p>获取一个数据源（source） → 数据转换 → 执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示：</p>\n<p><strong>流管道（Stream Pipeline）的构成</strong></p>\n<p><img src=\"https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/img001.png\"></p>\n<p>有多种方式生成 Stream Source：</p>\n<ul>\n<li><p>从Collection和数组</p>\n<ul>\n<li>Collection.stream()</li>\n<li>Collection.parallelStream()</li>\n<li>Arrays.stream(T array) or Stream.of()</li>\n</ul>\n</li>\n<li><p>从BufferedReader</p>\n<ul>\n<li>java.io.BufferedReader.lines()\\</li>\n</ul>\n</li>\n<li><p>静态工厂</p>\n<ul>\n<li>java.util.stream.IntStream.range()</li>\n<li>java.nio.file.Files.walk()</li>\n</ul>\n</li>\n<li><p>自己构建</p>\n<ul>\n<li>java.util.Spliterator</li>\n</ul>\n</li>\n<li><p>其它</p>\n<ul>\n<li>Random.ints()</li>\n<li>BitSet.stream()</li>\n<li>Pattern.splitAsStream(java.lang.CharSequence)</li>\n<li>JarFile.stream()</li>\n</ul>\n</li>\n</ul>\n<p>流的操作类型分为两种：</p>\n<ul>\n<li>Intermediate：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射&#x2F;过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>\n<li>Terminal：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个side effect。</li>\n</ul>\n<p>在对于一个Stream进行多次转换操作（Intermediate操作），每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和么？其实不是这样的，转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。</p>\n<p>还有一种操作被称为short-circuiting。用以指：</p>\n<ul>\n<li>对于一个intermediate操作，如果它接收的是一个无限大（infinite&#x2F;unbounded）的Stream，但返回一个有限的新Stream。</li>\n<li>对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。</li>\n</ul>\n<p>当操作一个无限大的Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。</p>\n<p><strong>一个流操作的示例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sum = widgets.stream()</span><br><span class=\"line\"></span><br><span class=\"line\">.filter(w -&gt; w.getColor() == RED)</span><br><span class=\"line\"></span><br><span class=\"line\">.mapToInt(w -&gt; w.getWeight())</span><br><span class=\"line\"></span><br><span class=\"line\">.sum();</span><br></pre></td></tr></table></figure>\n<p>stream()获取当前小物件的source,filter和mapToInt为intermediate操作，进行数据筛选和转换，最后一个sum()为terminal操作，对符合条件的全部小物件作重量求和。</p>\n<h2 id=\"流的使用详解\"><a href=\"#流的使用详解\" class=\"headerlink\" title=\"流的使用详解\"></a>流的使用详解</h2><p>简单说，对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>\n<h3 id=\"流的构造与转换\"><a href=\"#流的构造与转换\" class=\"headerlink\" title=\"流的构造与转换\"></a>流的构造与转换</h3><p>下面提供最常见的几种构造Stream的样例。</p>\n<p><strong>构造流的几种常见方法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. Individual values</span><br><span class=\"line\"></span><br><span class=\"line\">Stream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. Arrays</span><br><span class=\"line\"></span><br><span class=\"line\">String [] strArray = new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">stream = Stream.of(strArray);</span><br><span class=\"line\"></span><br><span class=\"line\">stream = Arrays.stream(strArray);</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. Collections</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class=\"line\"></span><br><span class=\"line\">stream = list.stream();</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：</p>\n<p>IntStream、LongStream、DoubleStream。当然我们也可以用Stream<Integer>、Stream<Long>、Stream<Double>，但是boxing和unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。</p>\n<p>Java8中还没有提供其它数值型Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种Stream进行。</p>\n<p><strong>数据流的构造</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">IntStream.range(1, 3).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">IntStream.rangeClosed(1, 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p><strong>流转换为其它数据结构</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1. Array</span><br><span class=\"line\"></span><br><span class=\"line\">String[] strArray1 = stream.toArray(String[]::new);</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. Collection</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));</span><br><span class=\"line\"></span><br><span class=\"line\">Set set1 = stream.collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. String</span><br><span class=\"line\"></span><br><span class=\"line\">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure>\n<p><em><strong>注：一个Stream只可以使用一个，以上示例只是为了代码简洁而重复使用数次。</strong></em></p>\n<h3 id=\"流的操作\"><a href=\"#流的操作\" class=\"headerlink\" title=\"流的操作\"></a>流的操作</h3><p>接下来，当把一个数据结构包装成Stream后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下：</p>\n<ul>\n<li>Intermediate：map(mapToint，flatMap等)、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered</li>\n<li>Terminal：forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator</li>\n<li>Short-circuiting：anyMatch、allMatch、noneMatch、findFirst、findAny、limit</li>\n</ul>\n<p>接下来下面看一下Stream的比较典型用法。</p>\n<ul>\n<li>map&#x2F;flatMap</li>\n</ul>\n<p>先来看map。如果熟悉scala这类函数式语言，对这个方法应该很了解，它的作用就是把input Stream的每一个元素，映射成output Stream的另外一个元素。</p>\n<p><strong>转换大写</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = wordList.stream().</span><br><span class=\"line\"></span><br><span class=\"line\">map(String::toUpperCase).</span><br><span class=\"line\"></span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p><strong>平方数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class=\"line\"></span><br><span class=\"line\">map(n -&gt; n * n).</span><br><span class=\"line\"></span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p>从上面例子可以看出，map生成的是个1:1映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap。</p>\n<p><strong>一对多</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class=\"line\"></span><br><span class=\"line\"> Arrays.asList(1),</span><br><span class=\"line\"></span><br><span class=\"line\"> Arrays.asList(2, 3),</span><br><span class=\"line\"></span><br><span class=\"line\"> Arrays.asList(4, 5, 6)</span><br><span class=\"line\"></span><br><span class=\"line\"> );</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class=\"line\"></span><br><span class=\"line\">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>\n<p>flatMap把input Stream中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。</p>\n<ul>\n<li>filter</li>\n</ul>\n<p>filter对原始Stream进行某项测试，通过测试的元素被留下来生成一个新Stream。</p>\n<p><strong>留下偶数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Integer[] evens =</span><br><span class=\"line\"></span><br><span class=\"line\">Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</span><br></pre></td></tr></table></figure>\n<p>经过条件“被2整除”的filter，剩下的数字为{2,4,6}。</p>\n<p><strong>把单词挑出来</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; output = reader.lines().</span><br><span class=\"line\"></span><br><span class=\"line\">flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class=\"line\"></span><br><span class=\"line\">filter(word -&gt; word.length() &gt; 0).</span><br><span class=\"line\"></span><br><span class=\"line\">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>这段代码首先把每行的单词用flatMap整理到新的Stream，然后保留长度不为0的，就是整篇文章中的所有单词了。</p>\n<ul>\n<li>forEach</li>\n</ul>\n<p>forEach方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式。</p>\n<p><strong>打印姓名（forEach和pre-java8的对比）</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">roster.stream()</span><br><span class=\"line\"></span><br><span class=\"line\"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class=\"line\"></span><br><span class=\"line\"> .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class=\"line\"></span><br><span class=\"line\">// Pre-Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">for (Person p : roster) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> if (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(p.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach是为Lambda而设计的，保持了最紧凑的风格。而且lambda表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时forEach本身的实现不需要调整，而Java8以前的for循环code可能需要加入额外的多线程逻辑。</p>\n<p>但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统Java风格的差别。</p>\n<p>另外一点需要注意，forEach是terminal操作，因此它执行后，Stream的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stream.forEach(element -&gt; doOneThing(element));</span><br><span class=\"line\"></span><br><span class=\"line\">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>\n<p>相反，具有相似功能的intermediate操作peek可以达到上述目的。如下是出现在该api javadoc上的一个示例。</p>\n<p><strong>peek 对每个元素执行操作并返回一个新的 Stream</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">.filter(e -&gt; e.length() &gt; 3)</span><br><span class=\"line\"></span><br><span class=\"line\">.peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))</span><br><span class=\"line\"></span><br><span class=\"line\">.map(String::toUpperCase)</span><br><span class=\"line\"></span><br><span class=\"line\">.peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))</span><br><span class=\"line\"></span><br><span class=\"line\">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>forEach不能修改自己包含的本地变量值，也不能用break&#x2F;return之类的关键字提前结束循环。</p>\n<ul>\n<li>findFirst</li>\n</ul>\n<p>这是一个terminal兼short-circuiting操作，它总是返回Stream的第一个元素，或者空。</p>\n<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿Scala语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免NullPointerException。</p>\n<p><strong>Optional的两个用例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String strA = &quot; abcd &quot;, strB = null;</span><br><span class=\"line\"></span><br><span class=\"line\">print(strA);</span><br><span class=\"line\"></span><br><span class=\"line\">print(&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">print(strB);</span><br><span class=\"line\"></span><br><span class=\"line\">getLength(strA);</span><br><span class=\"line\"></span><br><span class=\"line\">getLength(&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">getLength(strB);</span><br><span class=\"line\"></span><br><span class=\"line\">public static void print(String text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> // Java 8</span><br><span class=\"line\"></span><br><span class=\"line\"> Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\"> // Pre-Java 8</span><br><span class=\"line\"></span><br><span class=\"line\"> if (text != null) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(text);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static int getLength(String text) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> // Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">return Optional.ofNullable(text).map(String::length).orElse(-1);</span><br><span class=\"line\"></span><br><span class=\"line\"> // Pre-Java 8</span><br><span class=\"line\"></span><br><span class=\"line\">// return if (text != null) ? text.length() : -1;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>在更复杂的if(xx !&#x3D; null)的情况中，使用Optional代码的可读性更好，而且它提供的是编译时检查，能极大的降低NPE这种Runtime Exception对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>\n<p>Stream中的findAny、max&#x2F;min、reduce等方法返回Optional值。还有例如IntStream.average()返回Optional Double等等。</p>\n<ul>\n<li>reduce</li>\n</ul>\n<p>这个方法的主要作用是把Stream元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面Stream的第一个、第二个、第n个元素组合。从这个意义上说，字符串拼接、数值的sum、min、max、average都是特殊的reduce。例如Stream的sum就相当于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer sum = integers.reduce(0,(a,b) -&gt; a+b);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer sum = integers.reduce(0,Integer::sum);</span><br></pre></td></tr></table></figure>\n<p>也有没有起始值的情况，这时会把Stream的前面两个元素组合起来，返回的是Optional。</p>\n<p><strong>reduce的用例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 字符串连接，concat = &quot;ABCD&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat);</span><br><span class=\"line\"></span><br><span class=\"line\">// 求最小值，minValue = -3.0</span><br><span class=\"line\"></span><br><span class=\"line\">double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);</span><br><span class=\"line\"></span><br><span class=\"line\">// 求和，sumValue = 10, 有起始值</span><br><span class=\"line\"></span><br><span class=\"line\">int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">// 求和，sumValue = 10, 无起始值</span><br><span class=\"line\"></span><br><span class=\"line\">sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();</span><br><span class=\"line\"></span><br><span class=\"line\">// 过滤，字符串连接，concat = &quot;ace&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;).</span><br><span class=\"line\"></span><br><span class=\"line\"> filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0).</span><br><span class=\"line\"></span><br><span class=\"line\"> reduce(&quot;&quot;, String::concat);</span><br></pre></td></tr></table></figure>\n<p>上面代码例如第一个示例的reduce(),第一个参数（空白字符）即为起始值，第二个参数（String::concat）为BinaryOperator。这类有起始值的reduce()都返回具体的对象。而对于第四个示例没有起始值的reduce(),由于可能没有足够的元素，返回的是Optional，请留意这个区间。</p>\n<ul>\n<li>limit&#x2F;skip</li>\n</ul>\n<p>limit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫subStream的方法改名而来）。</p>\n<p><strong>limit和skip对运行次数的影响</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void testLimitAndSkip() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"> for (int i = 1; i &lt;= 10000; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class=\"line\"></span><br><span class=\"line\"> persons.add(person);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; personList2 = persons.stream().</span><br><span class=\"line\"></span><br><span class=\"line\">map(Person::getName).limit(10).skip(3).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(personList2);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private class Person &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> public int no;</span><br><span class=\"line\"></span><br><span class=\"line\"> private String name;</span><br><span class=\"line\"></span><br><span class=\"line\"> public Person (int no, String name) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> this.no = no;</span><br><span class=\"line\"></span><br><span class=\"line\"> this.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> public String getName() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(name);</span><br><span class=\"line\"></span><br><span class=\"line\"> return name;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>结果为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name1</span><br><span class=\"line\"></span><br><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name3</span><br><span class=\"line\"></span><br><span class=\"line\">name4</span><br><span class=\"line\"></span><br><span class=\"line\">name5</span><br><span class=\"line\"></span><br><span class=\"line\">name6</span><br><span class=\"line\"></span><br><span class=\"line\">name7</span><br><span class=\"line\"></span><br><span class=\"line\">name8</span><br><span class=\"line\"></span><br><span class=\"line\">name9</span><br><span class=\"line\"></span><br><span class=\"line\">name10</span><br><span class=\"line\"></span><br><span class=\"line\">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure>\n\n<p>这是一个有10000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为limit所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。</p>\n<p>还有一种情况是limit&#x2F;skip无法达到short-circuiting目的地，就是把它们放在Stream的排序操作后，原因跟sorted这个intermediate操作有关：此时系统并不知道Stream排序后的次序如何，所以sorted中的操作看上去就像完全没有被limit或者skip一样。</p>\n<p><strong>limit和skip对sorted后的运行次数无影响</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"> for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class=\"line\"></span><br><span class=\"line\"> persons.add(person);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure>\n<p>首先对5个元素的Stream排序，然后进行limit操作。输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name1</span><br><span class=\"line\"></span><br><span class=\"line\">name3</span><br><span class=\"line\"></span><br><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name4</span><br><span class=\"line\"></span><br><span class=\"line\">name3</span><br><span class=\"line\"></span><br><span class=\"line\">name5</span><br><span class=\"line\"></span><br><span class=\"line\">name4</span><br><span class=\"line\"></span><br><span class=\"line\">[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</span><br></pre></td></tr></table></figure>\n<p>即虽然最后的返回元素数量是2，但整个管道中的sorted表达式执行次数没有像之前示例一样相应减少。</p>\n<p>最后有一种需要注意的是，对一个parallel的Stream管道来说，如果其元素是有序的，那么limit操作的成本会比较大，因为它的返回对象必须是前n个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用parallel Stream。</p>\n<ul>\n<li>sorted</li>\n</ul>\n<p>对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。对之前示例可进行优化：</p>\n<p><strong>排序前进行 limit 和 skip</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\"> for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Person person = new Person(i, &quot;name&quot; + i);</span><br><span class=\"line\"></span><br><span class=\"line\"> persons.add(person);</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(personList2);</span><br></pre></td></tr></table></figure>\n<p><strong>结果为：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name2</span><br><span class=\"line\"></span><br><span class=\"line\">name1</span><br><span class=\"line\"></span><br><span class=\"line\">[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</span><br></pre></td></tr></table></figure>\n<p>当然这种优化是有business logic上的局限性的：即不要求排序后再取值</p>\n<ul>\n<li>min&#x2F;max&#x2F;distinct</li>\n</ul>\n<p>min和max的功能也可以通过对Stream元素先排序，再findFirst来实现，但前者的性能会更好，为O(n)，而sorted的成本是O(n log n)。同时它们作为特殊的reduce方法被独立出来也是因为求最大最小值是很常见的操作。</p>\n<p><strong>找出最长一行的长度</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\\\SUService.log&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">int longest = br.lines().</span><br><span class=\"line\"></span><br><span class=\"line\"> mapToInt(String::length).</span><br><span class=\"line\"></span><br><span class=\"line\"> max().</span><br><span class=\"line\"></span><br><span class=\"line\"> getAsInt();</span><br><span class=\"line\"></span><br><span class=\"line\">br.close();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(longest);</span><br></pre></td></tr></table></figure>\n\n<p><strong>找出全文的单词，转小写，并排序</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; words = br.lines().</span><br><span class=\"line\"></span><br><span class=\"line\"> flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))).</span><br><span class=\"line\"></span><br><span class=\"line\"> filter(word -&gt; word.length() &gt; 0).</span><br><span class=\"line\"></span><br><span class=\"line\"> map(String::toLowerCase).</span><br><span class=\"line\"></span><br><span class=\"line\"> distinct().</span><br><span class=\"line\"></span><br><span class=\"line\"> sorted().</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">br.close();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(words);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Match</li>\n</ul>\n<p>Stream有三个match方法，从语义上说：</p>\n<pre><code>allMatch：Stream中全部元素符合传入的predicate，返回true\nanyMatch：Stream中只要有一个元素符合传入的predicate，返回true\nnoneMatch：Stream中没有一个元素符合传入的predicate，返回true\n</code></pre>\n<p>它们都不是要遍历全部元素才能返回结果。例如allMatch只要一个元素不满足条件，就skip剩下的所有元素，返回false。</p>\n<p><strong>使用Match</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; persons = new ArrayList();</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(1, &quot;name&quot; + 1, 10));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(2, &quot;name&quot; + 2, 21));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(3, &quot;name&quot; + 3, 34));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(4, &quot;name&quot; + 4, 6));</span><br><span class=\"line\"></span><br><span class=\"line\">persons.add(new Person(5, &quot;name&quot; + 5, 55));</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isAllAdult = persons.stream().</span><br><span class=\"line\"></span><br><span class=\"line\"> allMatch(p -&gt; p.getAge() &gt; 18);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;All are adult? &quot; + isAllAdult);</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isThereAnyChild = persons.stream().</span><br><span class=\"line\"></span><br><span class=\"line\"> anyMatch(p -&gt; p.getAge() &lt; 12);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Any child? &quot; + isThereAnyChild);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">All are adult? false</span><br><span class=\"line\"></span><br><span class=\"line\">Any child? true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进阶：自己生成流\"><a href=\"#进阶：自己生成流\" class=\"headerlink\" title=\"进阶：自己生成流\"></a>进阶：自己生成流</h2><ul>\n<li>Stream.generate</li>\n</ul>\n<p>通过实现Supplier接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的Stream，或者需要前后元素间维持着某种状态信息的Stream。把Supplier实例传递给Stream.generate()生成的Stream，默认是串行（相对parallel而言）但无序的（相对ordered而言）。由于它是无限的，在管道中，必须利用limit之类的操作限制Stream大小。</p>\n<p><strong>生成10个随机整数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random seed = new Random();</span><br><span class=\"line\"></span><br><span class=\"line\">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class=\"line\"></span><br><span class=\"line\">Stream.generate(random).limit(10).forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">//Another way</span><br><span class=\"line\"></span><br><span class=\"line\">IntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).</span><br><span class=\"line\"></span><br><span class=\"line\">limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n<p>Stream.generate()还接受自己实现的Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算Stream的每个元素值。这些都是维持状态信息的情形。</p>\n<p><strong>自实现Supplier</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.generate(new PersonSupplier()).</span><br><span class=\"line\"></span><br><span class=\"line\">limit(10).</span><br><span class=\"line\"></span><br><span class=\"line\">forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));</span><br><span class=\"line\"></span><br><span class=\"line\">private class PersonSupplier implements Supplier&lt;Person&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> private int index = 0;</span><br><span class=\"line\"></span><br><span class=\"line\"> private Random random = new Random();</span><br><span class=\"line\"></span><br><span class=\"line\"> @Override</span><br><span class=\"line\"></span><br><span class=\"line\"> public Person get() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StormTestUser1, 9</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser2, 12</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser3, 88</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser4, 51</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser5, 22</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser6, 28</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser7, 81</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser8, 51</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser9, 4</span><br><span class=\"line\"></span><br><span class=\"line\">StormTestUser10, 76</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Stream.iterate</li>\n</ul>\n<p>iterate跟reduce操作很像，接受一个种子值，和一个UnaryOperator（例如f）。然后种子值成为Stream的第一个元素，f(seed)为第二个，f(f(seed))第三个，以此类推。</p>\n<p><strong>生成一个等差数列</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 3 6 9 12 15 18 21 24 27</span><br></pre></td></tr></table></figure>\n<p>与Stream.generate相仿，在iterate时候管道必须有limit这样的操作来限制Stream大小。</p>\n<h2 id=\"进阶：用Collectors来进行reduction操作\"><a href=\"#进阶：用Collectors来进行reduction操作\" class=\"headerlink\" title=\"进阶：用Collectors来进行reduction操作\"></a>进阶：用Collectors来进行reduction操作</h2><p>java.util.stream.Collectors类的主要作用就是辅助进行各类有用的reduction操作，例如转变输出为Collection，把Stream元素进行归组，</p>\n<ul>\n<li>groupingBy&#x2F;partitioningBy</li>\n</ul>\n<p><strong>按照年龄归组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()).</span><br><span class=\"line\"></span><br><span class=\"line\"> limit(100).</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(Collectors.groupingBy(Person::getAge));</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator it = personGroups.entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">while (it.hasNext()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class=\"line\"></span><br><span class=\"line\"> System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的示例，首先生成100人的信息，然后按照年龄归组，相同年龄的人放到同一个list中，可以看到如下的输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Age 0 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">Age 1 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">Age 5 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">Age 8 = 1</span><br><span class=\"line\"></span><br><span class=\"line\">Age 9 = 1</span><br><span class=\"line\"></span><br><span class=\"line\">Age 11 = 2</span><br><span class=\"line\"></span><br><span class=\"line\">……</span><br></pre></td></tr></table></figure>\n\n<p><strong>按照未成年人和成年人归组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()).</span><br><span class=\"line\"></span><br><span class=\"line\"> limit(100).</span><br><span class=\"line\"></span><br><span class=\"line\"> collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Children number: &quot; + children.get(true).size());</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;Adult number: &quot; + children.get(false).size());</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Children number: 23</span><br><span class=\"line\"></span><br><span class=\"line\">Adult number: 77</span><br></pre></td></tr></table></figure>\n<p>在使用条件“年龄小于18”进行分组后可以看到，不到18岁的未成年人是一组，成年人是另外一组。partitioningBy其实是一种特殊的groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true)和get(false)能即为全部的元素对象。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>总之，Stream的特性可以归纳为：</p>\n<ul>\n<li>不是数据结构</li>\n<li>它没有内部存储，它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据</li>\n<li>它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素</li>\n<li>所有Stream的操作必须以lambda表达式为参数</li>\n<li>不支持索引访问</li>\n<li>你可以请求第一个元素，但无法请求第二个，第三个或者最后一个。不过请参阅下一项</li>\n<li>很容易生成数组或者List</li>\n<li>惰性化</li>\n<li>很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始</li>\n<li>Intermediate操作永远是惰性化的</li>\n<li>并行能力</li>\n<li>当一个Stream是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的</li>\n<li>可以是无限的</li>\n<li>集合有固定大小，Stream则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成</li>\n</ul>\n"},{"title":"闷热七月（2019）","date":"2019-07-24T02:00:51.000Z","_content":"\n> 七月尾上海梅雨季节过去了，这天一下子就闷热起来，温度直逼三十五\n\n## 公司搬家\n公司换了个办公地，原先两个办公地相聚一公里左右，现在联合广场那边的办公地搬到了新纪元国际广场这边，跟原先这边在同一楼，折腾啊，我搬过去才刚刚半年又搬了。\n\n忙了一整天，衣服湿了干干了又湿，老板不愿花钱叫搬家公司的来只能我们自己动手，还有两个大金属屏风从一楼手动搬到十六楼，健身效果不错不错。。\n\n新办公地这边工位比之前的大了点，环境好了点吧，不过最致命的是吃。原先在联合广场那边可以去旁边的设计院食堂吃，一顿饭也就吃个十块出头就有一荤两素，现在这边不行了，生活成本一下子上去了不少。每天还得想着要去哪里吃，骑车去设计院吃的话大夏天热得发毛，一身汗吃饭肯定不爽，难办啊。\n\n今天中午跟着他们去了大食堂吃了顿，划不来，吃个二十几也就那样。\n\n## 出差\n又去潭溪山跑了一趟，一路曲折不说，回来还是凌晨。刚好那几天还上火，去那也只能吃粗粮，那几天身体难受的啊，回来赶紧喝了一顿稀饭补了一觉，身体瞬间焕发青春，难说神奇矣。\n\n周末跟朋友吃了顿烤鸭火锅，看了场鬼卞的现场，回去倒头大睡。\n\n估计过几天又要去昆明了，这项目要么不催不忙，要么一股脑儿一起来。\n\n松江云廊屋盖也得我去一趟。\n\n## 办居住证\n来上海这么多年，终于去办居住证了，现在政策又改了，还要网签备案，真是麻烦到死。以后换个地方住还得再去重新备案，重新办理，折腾啊。\n\n这制度也不合理，我们三人一起合租，其中一个原先办过居住证结果以为备案就不需要去了就没跟我们一起去网签备案。后来去街道办事处办理居住证更改信息时人家说你没备案不能更改办理，瞬间懵逼。之前还是居委会人口登记的那位阿姨跟他说不需要备案的，惨兮兮。这样的话，假如新来的租客要办居住证就必须得所有人一起再去网签备案咯？\n\n我们两人办好了手续等六个月拿居住证，他就只能另想办法了，房东大爷也不会再专门来跑一趟，也七十好几了。\n\n在外面漂终究抵不过各种烦扰。争取早日买房，告别沪漂一族！\n\n## 水果\n今年水果好贵啊，家里葡萄能吃了赶紧寄了一箱过来，都好久没吃水果了。\n\n前几天京东众筹上又买了一箱黑布林十斤二十四，感觉挺便宜的就买了，后来去超市看了下也就这个价，不过送货速度挺快的，口感还不错！\n\n真是不会照顾自己啊。","source":"_posts/sultry-july.md","raw":"---\ntitle: 闷热七月（2019）\ndate: 2019-7-24 10:00:51\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 七月尾上海梅雨季节过去了，这天一下子就闷热起来，温度直逼三十五\n\n## 公司搬家\n公司换了个办公地，原先两个办公地相聚一公里左右，现在联合广场那边的办公地搬到了新纪元国际广场这边，跟原先这边在同一楼，折腾啊，我搬过去才刚刚半年又搬了。\n\n忙了一整天，衣服湿了干干了又湿，老板不愿花钱叫搬家公司的来只能我们自己动手，还有两个大金属屏风从一楼手动搬到十六楼，健身效果不错不错。。\n\n新办公地这边工位比之前的大了点，环境好了点吧，不过最致命的是吃。原先在联合广场那边可以去旁边的设计院食堂吃，一顿饭也就吃个十块出头就有一荤两素，现在这边不行了，生活成本一下子上去了不少。每天还得想着要去哪里吃，骑车去设计院吃的话大夏天热得发毛，一身汗吃饭肯定不爽，难办啊。\n\n今天中午跟着他们去了大食堂吃了顿，划不来，吃个二十几也就那样。\n\n## 出差\n又去潭溪山跑了一趟，一路曲折不说，回来还是凌晨。刚好那几天还上火，去那也只能吃粗粮，那几天身体难受的啊，回来赶紧喝了一顿稀饭补了一觉，身体瞬间焕发青春，难说神奇矣。\n\n周末跟朋友吃了顿烤鸭火锅，看了场鬼卞的现场，回去倒头大睡。\n\n估计过几天又要去昆明了，这项目要么不催不忙，要么一股脑儿一起来。\n\n松江云廊屋盖也得我去一趟。\n\n## 办居住证\n来上海这么多年，终于去办居住证了，现在政策又改了，还要网签备案，真是麻烦到死。以后换个地方住还得再去重新备案，重新办理，折腾啊。\n\n这制度也不合理，我们三人一起合租，其中一个原先办过居住证结果以为备案就不需要去了就没跟我们一起去网签备案。后来去街道办事处办理居住证更改信息时人家说你没备案不能更改办理，瞬间懵逼。之前还是居委会人口登记的那位阿姨跟他说不需要备案的，惨兮兮。这样的话，假如新来的租客要办居住证就必须得所有人一起再去网签备案咯？\n\n我们两人办好了手续等六个月拿居住证，他就只能另想办法了，房东大爷也不会再专门来跑一趟，也七十好几了。\n\n在外面漂终究抵不过各种烦扰。争取早日买房，告别沪漂一族！\n\n## 水果\n今年水果好贵啊，家里葡萄能吃了赶紧寄了一箱过来，都好久没吃水果了。\n\n前几天京东众筹上又买了一箱黑布林十斤二十四，感觉挺便宜的就买了，后来去超市看了下也就这个价，不过送货速度挺快的，口感还不错！\n\n真是不会照顾自己啊。","slug":"sultry-july","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhr00bsk9i1b22m8cwg","content":"<blockquote>\n<p>七月尾上海梅雨季节过去了，这天一下子就闷热起来，温度直逼三十五</p>\n</blockquote>\n<h2 id=\"公司搬家\"><a href=\"#公司搬家\" class=\"headerlink\" title=\"公司搬家\"></a>公司搬家</h2><p>公司换了个办公地，原先两个办公地相聚一公里左右，现在联合广场那边的办公地搬到了新纪元国际广场这边，跟原先这边在同一楼，折腾啊，我搬过去才刚刚半年又搬了。</p>\n<p>忙了一整天，衣服湿了干干了又湿，老板不愿花钱叫搬家公司的来只能我们自己动手，还有两个大金属屏风从一楼手动搬到十六楼，健身效果不错不错。。</p>\n<p>新办公地这边工位比之前的大了点，环境好了点吧，不过最致命的是吃。原先在联合广场那边可以去旁边的设计院食堂吃，一顿饭也就吃个十块出头就有一荤两素，现在这边不行了，生活成本一下子上去了不少。每天还得想着要去哪里吃，骑车去设计院吃的话大夏天热得发毛，一身汗吃饭肯定不爽，难办啊。</p>\n<p>今天中午跟着他们去了大食堂吃了顿，划不来，吃个二十几也就那样。</p>\n<h2 id=\"出差\"><a href=\"#出差\" class=\"headerlink\" title=\"出差\"></a>出差</h2><p>又去潭溪山跑了一趟，一路曲折不说，回来还是凌晨。刚好那几天还上火，去那也只能吃粗粮，那几天身体难受的啊，回来赶紧喝了一顿稀饭补了一觉，身体瞬间焕发青春，难说神奇矣。</p>\n<p>周末跟朋友吃了顿烤鸭火锅，看了场鬼卞的现场，回去倒头大睡。</p>\n<p>估计过几天又要去昆明了，这项目要么不催不忙，要么一股脑儿一起来。</p>\n<p>松江云廊屋盖也得我去一趟。</p>\n<h2 id=\"办居住证\"><a href=\"#办居住证\" class=\"headerlink\" title=\"办居住证\"></a>办居住证</h2><p>来上海这么多年，终于去办居住证了，现在政策又改了，还要网签备案，真是麻烦到死。以后换个地方住还得再去重新备案，重新办理，折腾啊。</p>\n<p>这制度也不合理，我们三人一起合租，其中一个原先办过居住证结果以为备案就不需要去了就没跟我们一起去网签备案。后来去街道办事处办理居住证更改信息时人家说你没备案不能更改办理，瞬间懵逼。之前还是居委会人口登记的那位阿姨跟他说不需要备案的，惨兮兮。这样的话，假如新来的租客要办居住证就必须得所有人一起再去网签备案咯？</p>\n<p>我们两人办好了手续等六个月拿居住证，他就只能另想办法了，房东大爷也不会再专门来跑一趟，也七十好几了。</p>\n<p>在外面漂终究抵不过各种烦扰。争取早日买房，告别沪漂一族！</p>\n<h2 id=\"水果\"><a href=\"#水果\" class=\"headerlink\" title=\"水果\"></a>水果</h2><p>今年水果好贵啊，家里葡萄能吃了赶紧寄了一箱过来，都好久没吃水果了。</p>\n<p>前几天京东众筹上又买了一箱黑布林十斤二十四，感觉挺便宜的就买了，后来去超市看了下也就这个价，不过送货速度挺快的，口感还不错！</p>\n<p>真是不会照顾自己啊。</p>\n","excerpt":"","more":"<blockquote>\n<p>七月尾上海梅雨季节过去了，这天一下子就闷热起来，温度直逼三十五</p>\n</blockquote>\n<h2 id=\"公司搬家\"><a href=\"#公司搬家\" class=\"headerlink\" title=\"公司搬家\"></a>公司搬家</h2><p>公司换了个办公地，原先两个办公地相聚一公里左右，现在联合广场那边的办公地搬到了新纪元国际广场这边，跟原先这边在同一楼，折腾啊，我搬过去才刚刚半年又搬了。</p>\n<p>忙了一整天，衣服湿了干干了又湿，老板不愿花钱叫搬家公司的来只能我们自己动手，还有两个大金属屏风从一楼手动搬到十六楼，健身效果不错不错。。</p>\n<p>新办公地这边工位比之前的大了点，环境好了点吧，不过最致命的是吃。原先在联合广场那边可以去旁边的设计院食堂吃，一顿饭也就吃个十块出头就有一荤两素，现在这边不行了，生活成本一下子上去了不少。每天还得想着要去哪里吃，骑车去设计院吃的话大夏天热得发毛，一身汗吃饭肯定不爽，难办啊。</p>\n<p>今天中午跟着他们去了大食堂吃了顿，划不来，吃个二十几也就那样。</p>\n<h2 id=\"出差\"><a href=\"#出差\" class=\"headerlink\" title=\"出差\"></a>出差</h2><p>又去潭溪山跑了一趟，一路曲折不说，回来还是凌晨。刚好那几天还上火，去那也只能吃粗粮，那几天身体难受的啊，回来赶紧喝了一顿稀饭补了一觉，身体瞬间焕发青春，难说神奇矣。</p>\n<p>周末跟朋友吃了顿烤鸭火锅，看了场鬼卞的现场，回去倒头大睡。</p>\n<p>估计过几天又要去昆明了，这项目要么不催不忙，要么一股脑儿一起来。</p>\n<p>松江云廊屋盖也得我去一趟。</p>\n<h2 id=\"办居住证\"><a href=\"#办居住证\" class=\"headerlink\" title=\"办居住证\"></a>办居住证</h2><p>来上海这么多年，终于去办居住证了，现在政策又改了，还要网签备案，真是麻烦到死。以后换个地方住还得再去重新备案，重新办理，折腾啊。</p>\n<p>这制度也不合理，我们三人一起合租，其中一个原先办过居住证结果以为备案就不需要去了就没跟我们一起去网签备案。后来去街道办事处办理居住证更改信息时人家说你没备案不能更改办理，瞬间懵逼。之前还是居委会人口登记的那位阿姨跟他说不需要备案的，惨兮兮。这样的话，假如新来的租客要办居住证就必须得所有人一起再去网签备案咯？</p>\n<p>我们两人办好了手续等六个月拿居住证，他就只能另想办法了，房东大爷也不会再专门来跑一趟，也七十好几了。</p>\n<p>在外面漂终究抵不过各种烦扰。争取早日买房，告别沪漂一族！</p>\n<h2 id=\"水果\"><a href=\"#水果\" class=\"headerlink\" title=\"水果\"></a>水果</h2><p>今年水果好贵啊，家里葡萄能吃了赶紧寄了一箱过来，都好久没吃水果了。</p>\n<p>前几天京东众筹上又买了一箱黑布林十斤二十四，感觉挺便宜的就买了，后来去超市看了下也就这个价，不过送货速度挺快的，口感还不错！</p>\n<p>真是不会照顾自己啊。</p>\n"},{"title":"Java中一些小知识点","date":"2018-05-31T10:04:46.000Z","_content":"今天来总结一些平时不起眼的东西。For Java.\n\n---\n## for循环进行遍历删除元素\n```\nArrayList<String> list = new ArrayList(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));\n        System.out.println(\"before :\" + list);\n        // 在这个方法中有一个严重的错误。当一个元素被删除时，列表的大小缩小并且下标变化，\n        // 所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。\n        for (int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n            System.out.println(\"s :\" + s);\n            if (\"a\".equals(s)) {\n                list.remove(s);\n            }\n            if (\"b\".equals(s)) {\n                list.remove(s);\n            }\n        }\n        System.out.println(\"after :\" + list);\n```\n上述代码结果不尽人意：\n\n```\nbefore :[a, b, c, d]\ns :a\ns :c\ns :d\nafter :[b, c, d]\n```\n这正是因为注释中说的那样，list.remove()操作完的时候list就已经改变了大小以及下标，故当\"a\"删除后list变成了`[\"b\",\"c\",\"d\"]`,然而下标变成了1，这时候取值就是变成了\"c\",所以\"b\"这个元素就自然跳过了。\n**故我们在进行遍历删除list中元素时要使用Iterator迭代器来操作**\n\n## 变量声明\n今天自己写了几行简单测试了下：\n##### 1.\n```\nSystem.out.println(\"----------------start------------------\");\n        int num = 100000;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 9999999; i++) {\n            num += 20000;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"时间差  >> :\" + (end - start));\n\n```\n结果为：\n```\n----------------start------------------\n时间差  >> :2\n```\n##### 2.\n```\nSystem.out.println(\"----------------start------------------\");\n        Integer num = 100000;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 9999999; i++) {\n            num += 20000;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"时间差  >> :\" + (end - start));\n\n```\n结果为：\n```\n----------------start------------------\n时间差  >> :20\n```\n结果差了整10倍。想必数据一大自动拆装箱也挺累的吧。**故之后变量要多次基本操作声明尽量不用包装类**\n\n## String相关\n- intern()\n```\nString str = \"sss\";\nString str1 = new String(\"sss\");\nString str2 = str1;\n\nSystem.out.println(\"str2.intern() == str1 >>\" + (str2.intern() == str1));\nSystem.out.println(\"str2.intern() == str3 >>\" + (str2.intern() == str));\nSystem.out.println(\"str2.intern().equals(str1) >>\" + str2.intern().equals(str1));\nSystem.out.println(\"str2 == str1 >>\" + (str2 == str1));\nSystem.out.println(\"str2.equals(str1) >>\" + str2.equals(str1));\n```\n结果：\n```\nstr2.intern() == str1 >>false\nstr2.intern() == str3 >>true\nstr2.intern().equals(str1) >>true\nstr2 == str1 >>true\nstr2.equals(str1) >>true\n```\n我个人理解是，str2.intern()即是str1.intern()指向的故是常量池中的\"sss\",常量池中的\"sss\"就是str,str1指向一个String对象，而equals比较大小就不说了。这[里面](https://www.zhihu.com/question/28916657)说得就详细多了。\n\n- new String\n```\nchar[] c = { '1', '2', '3', '4', '5', '6', '7', '8' };\nString strC = new String(c, 2, 3);\nSystem.out.println(\"strC >>\" + strC);\n\nint[] arrInt = { 1, 2, 3, 4, 5, 6, 7, 8 };\nString strI = new String(arrInt, 2, 3);\nSystem.out.println(\"strI >>\" + strI);\n```\n结果：\n```\nstrC >>345\nstrI >>\u0003\u0004\u0005\n```\n从下标2位置（包含）开始截取，数量为3\n\n- join\n```\nString joinS = String.join(\":\", \"e\", \"r\", \"y\");\nSystem.out.println(\"joinS >>\" + joinS);\n```\n结果：\n```\njoinS >>e:r:y\n```\n我们走进join源码看一下：\n```\npublic static String join(CharSequence delimiter, CharSequence... elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        // Number of elements not likely worth Arrays.stream overhead.\n        StringJoiner joiner = new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n```\n发现了StringJoiner\n\n- StringJoiner\n\n所以也可以这么用：\n```\nStringJoiner joiner = new StringJoiner(\",\");\njoiner.add(\"a\").add(\"b\").add(\"c\");\nSystem.out.println(joiner.toString());\n```\n结果：\n```\na,b,c\n```\n\n---\nToday End.","source":"_posts/summary-180531.md","raw":"---\ntitle: Java中一些小知识点\ndate: 2018-5-31 18:04:46\ncategories: [开发,总结]\ntags: [Java]\n---\n今天来总结一些平时不起眼的东西。For Java.\n\n---\n## for循环进行遍历删除元素\n```\nArrayList<String> list = new ArrayList(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));\n        System.out.println(\"before :\" + list);\n        // 在这个方法中有一个严重的错误。当一个元素被删除时，列表的大小缩小并且下标变化，\n        // 所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。\n        for (int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n            System.out.println(\"s :\" + s);\n            if (\"a\".equals(s)) {\n                list.remove(s);\n            }\n            if (\"b\".equals(s)) {\n                list.remove(s);\n            }\n        }\n        System.out.println(\"after :\" + list);\n```\n上述代码结果不尽人意：\n\n```\nbefore :[a, b, c, d]\ns :a\ns :c\ns :d\nafter :[b, c, d]\n```\n这正是因为注释中说的那样，list.remove()操作完的时候list就已经改变了大小以及下标，故当\"a\"删除后list变成了`[\"b\",\"c\",\"d\"]`,然而下标变成了1，这时候取值就是变成了\"c\",所以\"b\"这个元素就自然跳过了。\n**故我们在进行遍历删除list中元素时要使用Iterator迭代器来操作**\n\n## 变量声明\n今天自己写了几行简单测试了下：\n##### 1.\n```\nSystem.out.println(\"----------------start------------------\");\n        int num = 100000;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 9999999; i++) {\n            num += 20000;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"时间差  >> :\" + (end - start));\n\n```\n结果为：\n```\n----------------start------------------\n时间差  >> :2\n```\n##### 2.\n```\nSystem.out.println(\"----------------start------------------\");\n        Integer num = 100000;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 9999999; i++) {\n            num += 20000;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"时间差  >> :\" + (end - start));\n\n```\n结果为：\n```\n----------------start------------------\n时间差  >> :20\n```\n结果差了整10倍。想必数据一大自动拆装箱也挺累的吧。**故之后变量要多次基本操作声明尽量不用包装类**\n\n## String相关\n- intern()\n```\nString str = \"sss\";\nString str1 = new String(\"sss\");\nString str2 = str1;\n\nSystem.out.println(\"str2.intern() == str1 >>\" + (str2.intern() == str1));\nSystem.out.println(\"str2.intern() == str3 >>\" + (str2.intern() == str));\nSystem.out.println(\"str2.intern().equals(str1) >>\" + str2.intern().equals(str1));\nSystem.out.println(\"str2 == str1 >>\" + (str2 == str1));\nSystem.out.println(\"str2.equals(str1) >>\" + str2.equals(str1));\n```\n结果：\n```\nstr2.intern() == str1 >>false\nstr2.intern() == str3 >>true\nstr2.intern().equals(str1) >>true\nstr2 == str1 >>true\nstr2.equals(str1) >>true\n```\n我个人理解是，str2.intern()即是str1.intern()指向的故是常量池中的\"sss\",常量池中的\"sss\"就是str,str1指向一个String对象，而equals比较大小就不说了。这[里面](https://www.zhihu.com/question/28916657)说得就详细多了。\n\n- new String\n```\nchar[] c = { '1', '2', '3', '4', '5', '6', '7', '8' };\nString strC = new String(c, 2, 3);\nSystem.out.println(\"strC >>\" + strC);\n\nint[] arrInt = { 1, 2, 3, 4, 5, 6, 7, 8 };\nString strI = new String(arrInt, 2, 3);\nSystem.out.println(\"strI >>\" + strI);\n```\n结果：\n```\nstrC >>345\nstrI >>\u0003\u0004\u0005\n```\n从下标2位置（包含）开始截取，数量为3\n\n- join\n```\nString joinS = String.join(\":\", \"e\", \"r\", \"y\");\nSystem.out.println(\"joinS >>\" + joinS);\n```\n结果：\n```\njoinS >>e:r:y\n```\n我们走进join源码看一下：\n```\npublic static String join(CharSequence delimiter, CharSequence... elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        // Number of elements not likely worth Arrays.stream overhead.\n        StringJoiner joiner = new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n```\n发现了StringJoiner\n\n- StringJoiner\n\n所以也可以这么用：\n```\nStringJoiner joiner = new StringJoiner(\",\");\njoiner.add(\"a\").add(\"b\").add(\"c\");\nSystem.out.println(joiner.toString());\n```\n结果：\n```\na,b,c\n```\n\n---\nToday End.","slug":"summary-180531","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhr00bxk9i1d5nh2050","content":"<p>今天来总结一些平时不起眼的东西。For Java.</p>\n<hr>\n<h2 id=\"for循环进行遍历删除元素\"><a href=\"#for循环进行遍历删除元素\" class=\"headerlink\" title=\"for循环进行遍历删除元素\"></a>for循环进行遍历删除元素</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));</span><br><span class=\"line\">        System.out.println(&quot;before :&quot; + list);</span><br><span class=\"line\">        // 在这个方法中有一个严重的错误。当一个元素被删除时，列表的大小缩小并且下标变化，</span><br><span class=\"line\">        // 所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。</span><br><span class=\"line\">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">            String s = list.get(i);</span><br><span class=\"line\">            System.out.println(&quot;s :&quot; + s);</span><br><span class=\"line\">            if (&quot;a&quot;.equals(s)) &#123;</span><br><span class=\"line\">                list.remove(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (&quot;b&quot;.equals(s)) &#123;</span><br><span class=\"line\">                list.remove(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;after :&quot; + list);</span><br></pre></td></tr></table></figure>\n<p>上述代码结果不尽人意：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before :[a, b, c, d]</span><br><span class=\"line\">s :a</span><br><span class=\"line\">s :c</span><br><span class=\"line\">s :d</span><br><span class=\"line\">after :[b, c, d]</span><br></pre></td></tr></table></figure>\n<p>这正是因为注释中说的那样，list.remove()操作完的时候list就已经改变了大小以及下标，故当”a”删除后list变成了<code>[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</code>,然而下标变成了1，这时候取值就是变成了”c”,所以”b”这个元素就自然跳过了。<br><strong>故我们在进行遍历删除list中元素时要使用Iterator迭代器来操作</strong></p>\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h2><p>今天自己写了几行简单测试了下：</p>\n<h5 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;----------------start------------------&quot;);</span><br><span class=\"line\">        int num = 100000;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 9999999; i++) &#123;</span><br><span class=\"line\">            num += 20000;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(&quot;时间差  &gt;&gt; :&quot; + (end - start));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------start------------------</span><br><span class=\"line\">时间差  &gt;&gt; :2</span><br></pre></td></tr></table></figure>\n<h5 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;----------------start------------------&quot;);</span><br><span class=\"line\">        Integer num = 100000;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 9999999; i++) &#123;</span><br><span class=\"line\">            num += 20000;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(&quot;时间差  &gt;&gt; :&quot; + (end - start));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------start------------------</span><br><span class=\"line\">时间差  &gt;&gt; :20</span><br></pre></td></tr></table></figure>\n<p>结果差了整10倍。想必数据一大自动拆装箱也挺累的吧。<strong>故之后变量要多次基本操作声明尽量不用包装类</strong></p>\n<h2 id=\"String相关\"><a href=\"#String相关\" class=\"headerlink\" title=\"String相关\"></a>String相关</h2><ul>\n<li><p>intern()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = &quot;sss&quot;;</span><br><span class=\"line\">String str1 = new String(&quot;sss&quot;);</span><br><span class=\"line\">String str2 = str1;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;str2.intern() == str1 &gt;&gt;&quot; + (str2.intern() == str1));</span><br><span class=\"line\">System.out.println(&quot;str2.intern() == str3 &gt;&gt;&quot; + (str2.intern() == str));</span><br><span class=\"line\">System.out.println(&quot;str2.intern().equals(str1) &gt;&gt;&quot; + str2.intern().equals(str1));</span><br><span class=\"line\">System.out.println(&quot;str2 == str1 &gt;&gt;&quot; + (str2 == str1));</span><br><span class=\"line\">System.out.println(&quot;str2.equals(str1) &gt;&gt;&quot; + str2.equals(str1));</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str2.intern() == str1 &gt;&gt;false</span><br><span class=\"line\">str2.intern() == str3 &gt;&gt;true</span><br><span class=\"line\">str2.intern().equals(str1) &gt;&gt;true</span><br><span class=\"line\">str2 == str1 &gt;&gt;true</span><br><span class=\"line\">str2.equals(str1) &gt;&gt;true</span><br></pre></td></tr></table></figure>\n<p>我个人理解是，str2.intern()即是str1.intern()指向的故是常量池中的”sss”,常量池中的”sss”就是str,str1指向一个String对象，而equals比较大小就不说了。这<a href=\"https://www.zhihu.com/question/28916657\">里面</a>说得就详细多了。</p>\n</li>\n<li><p>new String</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char[] c = &#123; &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27; &#125;;</span><br><span class=\"line\">String strC = new String(c, 2, 3);</span><br><span class=\"line\">System.out.println(&quot;strC &gt;&gt;&quot; + strC);</span><br><span class=\"line\"></span><br><span class=\"line\">int[] arrInt = &#123; 1, 2, 3, 4, 5, 6, 7, 8 &#125;;</span><br><span class=\"line\">String strI = new String(arrInt, 2, 3);</span><br><span class=\"line\">System.out.println(&quot;strI &gt;&gt;&quot; + strI);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strC &gt;&gt;345</span><br><span class=\"line\">strI &gt;&gt;\u0003\u0004\u0005</span><br></pre></td></tr></table></figure>\n<p>从下标2位置（包含）开始截取，数量为3</p>\n</li>\n<li><p>join</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String joinS = String.join(&quot;:&quot;, &quot;e&quot;, &quot;r&quot;, &quot;y&quot;);</span><br><span class=\"line\">System.out.println(&quot;joinS &gt;&gt;&quot; + joinS);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">joinS &gt;&gt;e:r:y</span><br></pre></td></tr></table></figure>\n<p>我们走进join源码看一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String join(CharSequence delimiter, CharSequence... elements) &#123;</span><br><span class=\"line\">        Objects.requireNonNull(delimiter);</span><br><span class=\"line\">        Objects.requireNonNull(elements);</span><br><span class=\"line\">        // Number of elements not likely worth Arrays.stream overhead.</span><br><span class=\"line\">        StringJoiner joiner = new StringJoiner(delimiter);</span><br><span class=\"line\">        for (CharSequence cs: elements) &#123;</span><br><span class=\"line\">            joiner.add(cs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return joiner.toString();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>发现了StringJoiner</p>\n</li>\n<li><p>StringJoiner</p>\n</li>\n</ul>\n<p>所以也可以这么用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringJoiner joiner = new StringJoiner(&quot;,&quot;);</span><br><span class=\"line\">joiner.add(&quot;a&quot;).add(&quot;b&quot;).add(&quot;c&quot;);</span><br><span class=\"line\">System.out.println(joiner.toString());</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a,b,c</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>Today End.</p>\n","excerpt":"","more":"<p>今天来总结一些平时不起眼的东西。For Java.</p>\n<hr>\n<h2 id=\"for循环进行遍历删除元素\"><a href=\"#for循环进行遍历删除元素\" class=\"headerlink\" title=\"for循环进行遍历删除元素\"></a>for循环进行遍历删除元素</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = new ArrayList(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;));</span><br><span class=\"line\">        System.out.println(&quot;before :&quot; + list);</span><br><span class=\"line\">        // 在这个方法中有一个严重的错误。当一个元素被删除时，列表的大小缩小并且下标变化，</span><br><span class=\"line\">        // 所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。</span><br><span class=\"line\">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">            String s = list.get(i);</span><br><span class=\"line\">            System.out.println(&quot;s :&quot; + s);</span><br><span class=\"line\">            if (&quot;a&quot;.equals(s)) &#123;</span><br><span class=\"line\">                list.remove(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (&quot;b&quot;.equals(s)) &#123;</span><br><span class=\"line\">                list.remove(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;after :&quot; + list);</span><br></pre></td></tr></table></figure>\n<p>上述代码结果不尽人意：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before :[a, b, c, d]</span><br><span class=\"line\">s :a</span><br><span class=\"line\">s :c</span><br><span class=\"line\">s :d</span><br><span class=\"line\">after :[b, c, d]</span><br></pre></td></tr></table></figure>\n<p>这正是因为注释中说的那样，list.remove()操作完的时候list就已经改变了大小以及下标，故当”a”删除后list变成了<code>[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</code>,然而下标变成了1，这时候取值就是变成了”c”,所以”b”这个元素就自然跳过了。<br><strong>故我们在进行遍历删除list中元素时要使用Iterator迭代器来操作</strong></p>\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h2><p>今天自己写了几行简单测试了下：</p>\n<h5 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;----------------start------------------&quot;);</span><br><span class=\"line\">        int num = 100000;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 9999999; i++) &#123;</span><br><span class=\"line\">            num += 20000;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(&quot;时间差  &gt;&gt; :&quot; + (end - start));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------start------------------</span><br><span class=\"line\">时间差  &gt;&gt; :2</span><br></pre></td></tr></table></figure>\n<h5 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;----------------start------------------&quot;);</span><br><span class=\"line\">        Integer num = 100000;</span><br><span class=\"line\">        long start = System.currentTimeMillis();</span><br><span class=\"line\">        for (int i = 0; i &lt; 9999999; i++) &#123;</span><br><span class=\"line\">            num += 20000;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(&quot;时间差  &gt;&gt; :&quot; + (end - start));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------------start------------------</span><br><span class=\"line\">时间差  &gt;&gt; :20</span><br></pre></td></tr></table></figure>\n<p>结果差了整10倍。想必数据一大自动拆装箱也挺累的吧。<strong>故之后变量要多次基本操作声明尽量不用包装类</strong></p>\n<h2 id=\"String相关\"><a href=\"#String相关\" class=\"headerlink\" title=\"String相关\"></a>String相关</h2><ul>\n<li><p>intern()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = &quot;sss&quot;;</span><br><span class=\"line\">String str1 = new String(&quot;sss&quot;);</span><br><span class=\"line\">String str2 = str1;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(&quot;str2.intern() == str1 &gt;&gt;&quot; + (str2.intern() == str1));</span><br><span class=\"line\">System.out.println(&quot;str2.intern() == str3 &gt;&gt;&quot; + (str2.intern() == str));</span><br><span class=\"line\">System.out.println(&quot;str2.intern().equals(str1) &gt;&gt;&quot; + str2.intern().equals(str1));</span><br><span class=\"line\">System.out.println(&quot;str2 == str1 &gt;&gt;&quot; + (str2 == str1));</span><br><span class=\"line\">System.out.println(&quot;str2.equals(str1) &gt;&gt;&quot; + str2.equals(str1));</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str2.intern() == str1 &gt;&gt;false</span><br><span class=\"line\">str2.intern() == str3 &gt;&gt;true</span><br><span class=\"line\">str2.intern().equals(str1) &gt;&gt;true</span><br><span class=\"line\">str2 == str1 &gt;&gt;true</span><br><span class=\"line\">str2.equals(str1) &gt;&gt;true</span><br></pre></td></tr></table></figure>\n<p>我个人理解是，str2.intern()即是str1.intern()指向的故是常量池中的”sss”,常量池中的”sss”就是str,str1指向一个String对象，而equals比较大小就不说了。这<a href=\"https://www.zhihu.com/question/28916657\">里面</a>说得就详细多了。</p>\n</li>\n<li><p>new String</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char[] c = &#123; &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27; &#125;;</span><br><span class=\"line\">String strC = new String(c, 2, 3);</span><br><span class=\"line\">System.out.println(&quot;strC &gt;&gt;&quot; + strC);</span><br><span class=\"line\"></span><br><span class=\"line\">int[] arrInt = &#123; 1, 2, 3, 4, 5, 6, 7, 8 &#125;;</span><br><span class=\"line\">String strI = new String(arrInt, 2, 3);</span><br><span class=\"line\">System.out.println(&quot;strI &gt;&gt;&quot; + strI);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strC &gt;&gt;345</span><br><span class=\"line\">strI &gt;&gt;\u0003\u0004\u0005</span><br></pre></td></tr></table></figure>\n<p>从下标2位置（包含）开始截取，数量为3</p>\n</li>\n<li><p>join</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String joinS = String.join(&quot;:&quot;, &quot;e&quot;, &quot;r&quot;, &quot;y&quot;);</span><br><span class=\"line\">System.out.println(&quot;joinS &gt;&gt;&quot; + joinS);</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">joinS &gt;&gt;e:r:y</span><br></pre></td></tr></table></figure>\n<p>我们走进join源码看一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String join(CharSequence delimiter, CharSequence... elements) &#123;</span><br><span class=\"line\">        Objects.requireNonNull(delimiter);</span><br><span class=\"line\">        Objects.requireNonNull(elements);</span><br><span class=\"line\">        // Number of elements not likely worth Arrays.stream overhead.</span><br><span class=\"line\">        StringJoiner joiner = new StringJoiner(delimiter);</span><br><span class=\"line\">        for (CharSequence cs: elements) &#123;</span><br><span class=\"line\">            joiner.add(cs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return joiner.toString();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>发现了StringJoiner</p>\n</li>\n<li><p>StringJoiner</p>\n</li>\n</ul>\n<p>所以也可以这么用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringJoiner joiner = new StringJoiner(&quot;,&quot;);</span><br><span class=\"line\">joiner.add(&quot;a&quot;).add(&quot;b&quot;).add(&quot;c&quot;);</span><br><span class=\"line\">System.out.println(joiner.toString());</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a,b,c</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>Today End.</p>\n"},{"title":"Java小知识点整理（二）","date":"2018-07-04T06:55:24.000Z","_content":"有一段时间没有整理了，今天整理一下最近看JDK1.8源码发现的几个不错的function。For Java.\n\n---\n\n## Base64加解密\n```\n    /**\n     * Base64加解密\n     * \n     * @throws UnsupportedEncodingException\n     */\n    static void Base64Test() throws UnsupportedEncodingException {\n        String str = \"Base64加密测试\";\n        byte[] enByt = Base64.getEncoder().encode(str.getBytes());\n        String enStr = new String(enByt, \"utf-8\");\n        System.out.println(\"加密后 ：\" + enStr);\n\n        byte[] decByt = Base64.getDecoder().decode(enStr);\n        String decStr = new String(decByt, \"utf-8\");\n        System.out.println(\"解密后 ：\" + decStr);\n    }\n```\nJDK1.8中util里新增了Base64文件，给我们提供了便捷。上述代码结果为：\n```\n加密后 ：QmFzZTY05Yqg5a+G5rWL6K+V\n解密后 ：Base64加密测试\n```\n\n## rotate\n在看Collections源码时发现的，觉得很妙就记录了下来。\n```\nprivate static <T> void rotate1(List<T> list, int distance) {\n        int size = list.size();     // 获取集合大小\n        if (size == 0)      // 数量为0直接返回\n            return;\n        distance = distance % size;     // 取模\n        if (distance < 0)\n            distance += size;       // 保证不为负数\n        if (distance == 0)\n            return;\n        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {\n            T displaced = list.get(cycleStart);\n            int i = cycleStart;\n            do {\n                i += distance;      // 依次往后递推\n                if (i >= size)\n                    i -= size;      // 一轮赋值后回到原处\n                displaced = list.set(i, displaced);     // 赋值并返回旧值\n                nMoved ++;      // 重新赋值一个数加一\n            } while (i != cycleStart);      // 直到回到初值\n        }\n    }\n```\n看到这个rotate1那肯定其中还有个2咯。\n```\n    private static void rotate2(List<?> list, int distance) {       // {1，2，3，4}  2\n        int size = list.size();     // 4\n        if (size == 0)\n            return;\n        int mid =  -distance % size;\n        if (mid < 0)\n            mid += size;        // 2\n        if (mid == 0)\n            return;\n\n        reverse(list.subList(0, mid));      // {2，1，3，4}\n        reverse(list.subList(mid, size));       // {2，1，4，3}\n        reverse(list);      // {3，4，1，2}\n    }\n```\n这两个方法效果一样，妙不可言啊，一起分享。\n\n## tableSizeFor\n这个是HashMap源码中的一个方法，用来获取一个大于等于该数的二次幂数同时要小于等于给定的最小的二次幂数。\n```\n    /**\n     * 返回给定目标容量的2大小的幂\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;       // 无符号右移，忽略符号位，空位都以0补齐\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n## 插入排序 insertion sort\n这个是在DualPivotQuicksort源码中看到抽取出来的，写法很简洁，精炼。\n```\nint[] arr = {5,1,7,2,4};\nfor(int i = 0,j = i; i < arr.length - 1; j = ++i) {\n    // 保持i 和 j 相等\n    int a = arr[i + 1];\n    while(a < arr[j]) { // 直到找到没有比它还小的值\n        // 如果小于前一个数则将前一个数赋值给它\n        arr[j + 1] = arr[j];\n        if(j-- == 0) {\n            // 执行j-- 若j=0则退出循环\n            break;\n        }\n    }\n    arr[j + 1] = a; // 将较小的值赋值\n}\nSystem.out.println(Arrays.toString(arr));\n```\n输出结果为：\n```\n[1,2,4,5,7]\n```\n\n---\nEnd.","source":"_posts/summary-180704.md","raw":"---\ntitle: Java小知识点整理（二）\ndate: 2018-07-04 14:55:24\ncategories: [开发,总结]\ntags: [Java]\n---\n有一段时间没有整理了，今天整理一下最近看JDK1.8源码发现的几个不错的function。For Java.\n\n---\n\n## Base64加解密\n```\n    /**\n     * Base64加解密\n     * \n     * @throws UnsupportedEncodingException\n     */\n    static void Base64Test() throws UnsupportedEncodingException {\n        String str = \"Base64加密测试\";\n        byte[] enByt = Base64.getEncoder().encode(str.getBytes());\n        String enStr = new String(enByt, \"utf-8\");\n        System.out.println(\"加密后 ：\" + enStr);\n\n        byte[] decByt = Base64.getDecoder().decode(enStr);\n        String decStr = new String(decByt, \"utf-8\");\n        System.out.println(\"解密后 ：\" + decStr);\n    }\n```\nJDK1.8中util里新增了Base64文件，给我们提供了便捷。上述代码结果为：\n```\n加密后 ：QmFzZTY05Yqg5a+G5rWL6K+V\n解密后 ：Base64加密测试\n```\n\n## rotate\n在看Collections源码时发现的，觉得很妙就记录了下来。\n```\nprivate static <T> void rotate1(List<T> list, int distance) {\n        int size = list.size();     // 获取集合大小\n        if (size == 0)      // 数量为0直接返回\n            return;\n        distance = distance % size;     // 取模\n        if (distance < 0)\n            distance += size;       // 保证不为负数\n        if (distance == 0)\n            return;\n        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {\n            T displaced = list.get(cycleStart);\n            int i = cycleStart;\n            do {\n                i += distance;      // 依次往后递推\n                if (i >= size)\n                    i -= size;      // 一轮赋值后回到原处\n                displaced = list.set(i, displaced);     // 赋值并返回旧值\n                nMoved ++;      // 重新赋值一个数加一\n            } while (i != cycleStart);      // 直到回到初值\n        }\n    }\n```\n看到这个rotate1那肯定其中还有个2咯。\n```\n    private static void rotate2(List<?> list, int distance) {       // {1，2，3，4}  2\n        int size = list.size();     // 4\n        if (size == 0)\n            return;\n        int mid =  -distance % size;\n        if (mid < 0)\n            mid += size;        // 2\n        if (mid == 0)\n            return;\n\n        reverse(list.subList(0, mid));      // {2，1，3，4}\n        reverse(list.subList(mid, size));       // {2，1，4，3}\n        reverse(list);      // {3，4，1，2}\n    }\n```\n这两个方法效果一样，妙不可言啊，一起分享。\n\n## tableSizeFor\n这个是HashMap源码中的一个方法，用来获取一个大于等于该数的二次幂数同时要小于等于给定的最小的二次幂数。\n```\n    /**\n     * 返回给定目标容量的2大小的幂\n     */\n    static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;       // 无符号右移，忽略符号位，空位都以0补齐\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n\n## 插入排序 insertion sort\n这个是在DualPivotQuicksort源码中看到抽取出来的，写法很简洁，精炼。\n```\nint[] arr = {5,1,7,2,4};\nfor(int i = 0,j = i; i < arr.length - 1; j = ++i) {\n    // 保持i 和 j 相等\n    int a = arr[i + 1];\n    while(a < arr[j]) { // 直到找到没有比它还小的值\n        // 如果小于前一个数则将前一个数赋值给它\n        arr[j + 1] = arr[j];\n        if(j-- == 0) {\n            // 执行j-- 若j=0则退出循环\n            break;\n        }\n    }\n    arr[j + 1] = a; // 将较小的值赋值\n}\nSystem.out.println(Arrays.toString(arr));\n```\n输出结果为：\n```\n[1,2,4,5,7]\n```\n\n---\nEnd.","slug":"summary-180704","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhr00c0k9i1bec8acco","content":"<p>有一段时间没有整理了，今天整理一下最近看JDK1.8源码发现的几个不错的function。For Java.</p>\n<hr>\n<h2 id=\"Base64加解密\"><a href=\"#Base64加解密\" class=\"headerlink\" title=\"Base64加解密\"></a>Base64加解密</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Base64加解密</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @throws UnsupportedEncodingException</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void Base64Test() throws UnsupportedEncodingException &#123;</span><br><span class=\"line\">    String str = &quot;Base64加密测试&quot;;</span><br><span class=\"line\">    byte[] enByt = Base64.getEncoder().encode(str.getBytes());</span><br><span class=\"line\">    String enStr = new String(enByt, &quot;utf-8&quot;);</span><br><span class=\"line\">    System.out.println(&quot;加密后 ：&quot; + enStr);</span><br><span class=\"line\"></span><br><span class=\"line\">    byte[] decByt = Base64.getDecoder().decode(enStr);</span><br><span class=\"line\">    String decStr = new String(decByt, &quot;utf-8&quot;);</span><br><span class=\"line\">    System.out.println(&quot;解密后 ：&quot; + decStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK1.8中util里新增了Base64文件，给我们提供了便捷。上述代码结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密后 ：QmFzZTY05Yqg5a+G5rWL6K+V</span><br><span class=\"line\">解密后 ：Base64加密测试</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate\"></a>rotate</h2><p>在看Collections源码时发现的，觉得很妙就记录了下来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123;</span><br><span class=\"line\">        int size = list.size();     // 获取集合大小</span><br><span class=\"line\">        if (size == 0)      // 数量为0直接返回</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        distance = distance % size;     // 取模</span><br><span class=\"line\">        if (distance &lt; 0)</span><br><span class=\"line\">            distance += size;       // 保证不为负数</span><br><span class=\"line\">        if (distance == 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123;</span><br><span class=\"line\">            T displaced = list.get(cycleStart);</span><br><span class=\"line\">            int i = cycleStart;</span><br><span class=\"line\">            do &#123;</span><br><span class=\"line\">                i += distance;      // 依次往后递推</span><br><span class=\"line\">                if (i &gt;= size)</span><br><span class=\"line\">                    i -= size;      // 一轮赋值后回到原处</span><br><span class=\"line\">                displaced = list.set(i, displaced);     // 赋值并返回旧值</span><br><span class=\"line\">                nMoved ++;      // 重新赋值一个数加一</span><br><span class=\"line\">            &#125; while (i != cycleStart);      // 直到回到初值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>看到这个rotate1那肯定其中还有个2咯。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void rotate2(List&lt;?&gt; list, int distance) &#123;       // &#123;1，2，3，4&#125;  2</span><br><span class=\"line\">    int size = list.size();     // 4</span><br><span class=\"line\">    if (size == 0)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    int mid =  -distance % size;</span><br><span class=\"line\">    if (mid &lt; 0)</span><br><span class=\"line\">        mid += size;        // 2</span><br><span class=\"line\">    if (mid == 0)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    reverse(list.subList(0, mid));      // &#123;2，1，3，4&#125;</span><br><span class=\"line\">    reverse(list.subList(mid, size));       // &#123;2，1，4，3&#125;</span><br><span class=\"line\">    reverse(list);      // &#123;3，4，1，2&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个方法效果一样，妙不可言啊，一起分享。</p>\n<h2 id=\"tableSizeFor\"><a href=\"#tableSizeFor\" class=\"headerlink\" title=\"tableSizeFor\"></a>tableSizeFor</h2><p>这个是HashMap源码中的一个方法，用来获取一个大于等于该数的二次幂数同时要小于等于给定的最小的二次幂数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 返回给定目标容量的2大小的幂</span><br><span class=\"line\"> */</span><br><span class=\"line\">static final int tableSizeFor(int cap) &#123;</span><br><span class=\"line\">    int n = cap - 1;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 1;       // 无符号右移，忽略符号位，空位都以0补齐</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 2;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 4;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 8;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 16;</span><br><span class=\"line\">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序-insertion-sort\"><a href=\"#插入排序-insertion-sort\" class=\"headerlink\" title=\"插入排序 insertion sort\"></a>插入排序 insertion sort</h2><p>这个是在DualPivotQuicksort源码中看到抽取出来的，写法很简洁，精炼。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] arr = &#123;5,1,7,2,4&#125;;</span><br><span class=\"line\">for(int i = 0,j = i; i &lt; arr.length - 1; j = ++i) &#123;</span><br><span class=\"line\">    // 保持i 和 j 相等</span><br><span class=\"line\">    int a = arr[i + 1];</span><br><span class=\"line\">    while(a &lt; arr[j]) &#123; // 直到找到没有比它还小的值</span><br><span class=\"line\">        // 如果小于前一个数则将前一个数赋值给它</span><br><span class=\"line\">        arr[j + 1] = arr[j];</span><br><span class=\"line\">        if(j-- == 0) &#123;</span><br><span class=\"line\">            // 执行j-- 若j=0则退出循环</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j + 1] = a; // 将较小的值赋值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1,2,4,5,7]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>End.</p>\n","excerpt":"","more":"<p>有一段时间没有整理了，今天整理一下最近看JDK1.8源码发现的几个不错的function。For Java.</p>\n<hr>\n<h2 id=\"Base64加解密\"><a href=\"#Base64加解密\" class=\"headerlink\" title=\"Base64加解密\"></a>Base64加解密</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Base64加解密</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @throws UnsupportedEncodingException</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void Base64Test() throws UnsupportedEncodingException &#123;</span><br><span class=\"line\">    String str = &quot;Base64加密测试&quot;;</span><br><span class=\"line\">    byte[] enByt = Base64.getEncoder().encode(str.getBytes());</span><br><span class=\"line\">    String enStr = new String(enByt, &quot;utf-8&quot;);</span><br><span class=\"line\">    System.out.println(&quot;加密后 ：&quot; + enStr);</span><br><span class=\"line\"></span><br><span class=\"line\">    byte[] decByt = Base64.getDecoder().decode(enStr);</span><br><span class=\"line\">    String decStr = new String(decByt, &quot;utf-8&quot;);</span><br><span class=\"line\">    System.out.println(&quot;解密后 ：&quot; + decStr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK1.8中util里新增了Base64文件，给我们提供了便捷。上述代码结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密后 ：QmFzZTY05Yqg5a+G5rWL6K+V</span><br><span class=\"line\">解密后 ：Base64加密测试</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rotate\"><a href=\"#rotate\" class=\"headerlink\" title=\"rotate\"></a>rotate</h2><p>在看Collections源码时发现的，觉得很妙就记录了下来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123;</span><br><span class=\"line\">        int size = list.size();     // 获取集合大小</span><br><span class=\"line\">        if (size == 0)      // 数量为0直接返回</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        distance = distance % size;     // 取模</span><br><span class=\"line\">        if (distance &lt; 0)</span><br><span class=\"line\">            distance += size;       // 保证不为负数</span><br><span class=\"line\">        if (distance == 0)</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123;</span><br><span class=\"line\">            T displaced = list.get(cycleStart);</span><br><span class=\"line\">            int i = cycleStart;</span><br><span class=\"line\">            do &#123;</span><br><span class=\"line\">                i += distance;      // 依次往后递推</span><br><span class=\"line\">                if (i &gt;= size)</span><br><span class=\"line\">                    i -= size;      // 一轮赋值后回到原处</span><br><span class=\"line\">                displaced = list.set(i, displaced);     // 赋值并返回旧值</span><br><span class=\"line\">                nMoved ++;      // 重新赋值一个数加一</span><br><span class=\"line\">            &#125; while (i != cycleStart);      // 直到回到初值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>看到这个rotate1那肯定其中还有个2咯。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static void rotate2(List&lt;?&gt; list, int distance) &#123;       // &#123;1，2，3，4&#125;  2</span><br><span class=\"line\">    int size = list.size();     // 4</span><br><span class=\"line\">    if (size == 0)</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    int mid =  -distance % size;</span><br><span class=\"line\">    if (mid &lt; 0)</span><br><span class=\"line\">        mid += size;        // 2</span><br><span class=\"line\">    if (mid == 0)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    reverse(list.subList(0, mid));      // &#123;2，1，3，4&#125;</span><br><span class=\"line\">    reverse(list.subList(mid, size));       // &#123;2，1，4，3&#125;</span><br><span class=\"line\">    reverse(list);      // &#123;3，4，1，2&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个方法效果一样，妙不可言啊，一起分享。</p>\n<h2 id=\"tableSizeFor\"><a href=\"#tableSizeFor\" class=\"headerlink\" title=\"tableSizeFor\"></a>tableSizeFor</h2><p>这个是HashMap源码中的一个方法，用来获取一个大于等于该数的二次幂数同时要小于等于给定的最小的二次幂数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 返回给定目标容量的2大小的幂</span><br><span class=\"line\"> */</span><br><span class=\"line\">static final int tableSizeFor(int cap) &#123;</span><br><span class=\"line\">    int n = cap - 1;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 1;       // 无符号右移，忽略符号位，空位都以0补齐</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 2;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 4;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 8;</span><br><span class=\"line\">    n |= n &gt;&gt;&gt; 16;</span><br><span class=\"line\">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插入排序-insertion-sort\"><a href=\"#插入排序-insertion-sort\" class=\"headerlink\" title=\"插入排序 insertion sort\"></a>插入排序 insertion sort</h2><p>这个是在DualPivotQuicksort源码中看到抽取出来的，写法很简洁，精炼。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] arr = &#123;5,1,7,2,4&#125;;</span><br><span class=\"line\">for(int i = 0,j = i; i &lt; arr.length - 1; j = ++i) &#123;</span><br><span class=\"line\">    // 保持i 和 j 相等</span><br><span class=\"line\">    int a = arr[i + 1];</span><br><span class=\"line\">    while(a &lt; arr[j]) &#123; // 直到找到没有比它还小的值</span><br><span class=\"line\">        // 如果小于前一个数则将前一个数赋值给它</span><br><span class=\"line\">        arr[j + 1] = arr[j];</span><br><span class=\"line\">        if(j-- == 0) &#123;</span><br><span class=\"line\">            // 执行j-- 若j=0则退出循环</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j + 1] = a; // 将较小的值赋值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1,2,4,5,7]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>End.</p>\n"},{"title":"懵逼七月（2018）","date":"2018-08-03T07:22:59.000Z","_content":"\n又是一个月过去了，许久不更博客，今日来随意写写最近的状况。\n\n---\n\n- 最近很不太平\n    + 疫苗事件 全国愤怒\n    + 娱乐圈税务事件还在继续\n    + 吴亦凡虎扑有搞头 rapper diss大战\n    + 纪凌尘 阚清子分手事件\n    + 还有最近台风挺多的\n    + ...\n\n- 话说这些大多与我们吃瓜的干系不大，贵圈很乱也不是这一天两天的了。\n\n- 最近在刷leetcode，发现还是很吃力，想想好歹小时候也是参加奥数竞赛的人啊，脑子真的是要多用用，特别是一些思考问题的方式方法，时间久了就没有那么敏感了。还有就是深刻认识到了English的重要性，要是去官网上直接刷题不用翻译的话，怕是题目描述都看不懂。。\n\n- 前几天买了点游泳装备，准备周末找时间去游游泳，锻炼锻炼肺部。当然顺道去看看有没有性感比基尼美女了，这不是重点。游泳 健身 了解一下？\n\n- 周末也找了点话剧、点映、展览什么的看了看，以后周末闲不住了也可以去走一遭，何必一直窝在小小出租屋中呢，还是要多到外面看看景色，呼吸呼吸好空气。\n\n- 发现自己上半身要保持一直笔直有点困难了，特别是肩部、颈部，弯曲程度稍微严重了些。有时候自己会刻意去纠正、扭动，但是无意识状态就又还是异常姿态。长时间坐在工位办公给我们带来了什么，我觉得这伴随着的健康问题在以后科技技术越来越炫酷的时候，找出个解决方案是至关重要的。毕竟这基数也大，而且健康问题是每个人都不可忽视的，也是国家重视的。\n\n- ChinaJoy今天开幕，本来是想看看的，之前也没去过，但是没有人陪同自己一个人我也打消了这个念头，花这个钱我还是去多买几本书多游几次泳来得有价值。\n\n- 买了一个锅专门用来煮鸡胸餐、煎手抓饼，原来的那个锅太小了而且还粘锅。为了健康生活同时减少生活成本，这点投资还是要的。\n\n- 估计是住的地方太潮了再加上还有个大鱼缸，湿气太重，最近十分不得劲，皮肤略微过敏。\n\n\n---\n\n大致就先这样了。\n","source":"_posts/summary-180803.md","raw":"---\ntitle: 懵逼七月（2018）\ndate: 2018-8-3 15:22:59\ncategories: [生活,杂侃]\ntags: []\n---\n\n又是一个月过去了，许久不更博客，今日来随意写写最近的状况。\n\n---\n\n- 最近很不太平\n    + 疫苗事件 全国愤怒\n    + 娱乐圈税务事件还在继续\n    + 吴亦凡虎扑有搞头 rapper diss大战\n    + 纪凌尘 阚清子分手事件\n    + 还有最近台风挺多的\n    + ...\n\n- 话说这些大多与我们吃瓜的干系不大，贵圈很乱也不是这一天两天的了。\n\n- 最近在刷leetcode，发现还是很吃力，想想好歹小时候也是参加奥数竞赛的人啊，脑子真的是要多用用，特别是一些思考问题的方式方法，时间久了就没有那么敏感了。还有就是深刻认识到了English的重要性，要是去官网上直接刷题不用翻译的话，怕是题目描述都看不懂。。\n\n- 前几天买了点游泳装备，准备周末找时间去游游泳，锻炼锻炼肺部。当然顺道去看看有没有性感比基尼美女了，这不是重点。游泳 健身 了解一下？\n\n- 周末也找了点话剧、点映、展览什么的看了看，以后周末闲不住了也可以去走一遭，何必一直窝在小小出租屋中呢，还是要多到外面看看景色，呼吸呼吸好空气。\n\n- 发现自己上半身要保持一直笔直有点困难了，特别是肩部、颈部，弯曲程度稍微严重了些。有时候自己会刻意去纠正、扭动，但是无意识状态就又还是异常姿态。长时间坐在工位办公给我们带来了什么，我觉得这伴随着的健康问题在以后科技技术越来越炫酷的时候，找出个解决方案是至关重要的。毕竟这基数也大，而且健康问题是每个人都不可忽视的，也是国家重视的。\n\n- ChinaJoy今天开幕，本来是想看看的，之前也没去过，但是没有人陪同自己一个人我也打消了这个念头，花这个钱我还是去多买几本书多游几次泳来得有价值。\n\n- 买了一个锅专门用来煮鸡胸餐、煎手抓饼，原来的那个锅太小了而且还粘锅。为了健康生活同时减少生活成本，这点投资还是要的。\n\n- 估计是住的地方太潮了再加上还有个大鱼缸，湿气太重，最近十分不得劲，皮肤略微过敏。\n\n\n---\n\n大致就先这样了。\n","slug":"summary-180803","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhs00c5k9i1315dae8q","content":"<p>又是一个月过去了，许久不更博客，今日来随意写写最近的状况。</p>\n<hr>\n<ul>\n<li><p>最近很不太平</p>\n<ul>\n<li>疫苗事件 全国愤怒</li>\n<li>娱乐圈税务事件还在继续</li>\n<li>吴亦凡虎扑有搞头 rapper diss大战</li>\n<li>纪凌尘 阚清子分手事件</li>\n<li>还有最近台风挺多的</li>\n<li>…</li>\n</ul>\n</li>\n<li><p>话说这些大多与我们吃瓜的干系不大，贵圈很乱也不是这一天两天的了。</p>\n</li>\n<li><p>最近在刷leetcode，发现还是很吃力，想想好歹小时候也是参加奥数竞赛的人啊，脑子真的是要多用用，特别是一些思考问题的方式方法，时间久了就没有那么敏感了。还有就是深刻认识到了English的重要性，要是去官网上直接刷题不用翻译的话，怕是题目描述都看不懂。。</p>\n</li>\n<li><p>前几天买了点游泳装备，准备周末找时间去游游泳，锻炼锻炼肺部。当然顺道去看看有没有性感比基尼美女了，这不是重点。游泳 健身 了解一下？</p>\n</li>\n<li><p>周末也找了点话剧、点映、展览什么的看了看，以后周末闲不住了也可以去走一遭，何必一直窝在小小出租屋中呢，还是要多到外面看看景色，呼吸呼吸好空气。</p>\n</li>\n<li><p>发现自己上半身要保持一直笔直有点困难了，特别是肩部、颈部，弯曲程度稍微严重了些。有时候自己会刻意去纠正、扭动，但是无意识状态就又还是异常姿态。长时间坐在工位办公给我们带来了什么，我觉得这伴随着的健康问题在以后科技技术越来越炫酷的时候，找出个解决方案是至关重要的。毕竟这基数也大，而且健康问题是每个人都不可忽视的，也是国家重视的。</p>\n</li>\n<li><p>ChinaJoy今天开幕，本来是想看看的，之前也没去过，但是没有人陪同自己一个人我也打消了这个念头，花这个钱我还是去多买几本书多游几次泳来得有价值。</p>\n</li>\n<li><p>买了一个锅专门用来煮鸡胸餐、煎手抓饼，原来的那个锅太小了而且还粘锅。为了健康生活同时减少生活成本，这点投资还是要的。</p>\n</li>\n<li><p>估计是住的地方太潮了再加上还有个大鱼缸，湿气太重，最近十分不得劲，皮肤略微过敏。</p>\n</li>\n</ul>\n<hr>\n<p>大致就先这样了。</p>\n","excerpt":"","more":"<p>又是一个月过去了，许久不更博客，今日来随意写写最近的状况。</p>\n<hr>\n<ul>\n<li><p>最近很不太平</p>\n<ul>\n<li>疫苗事件 全国愤怒</li>\n<li>娱乐圈税务事件还在继续</li>\n<li>吴亦凡虎扑有搞头 rapper diss大战</li>\n<li>纪凌尘 阚清子分手事件</li>\n<li>还有最近台风挺多的</li>\n<li>…</li>\n</ul>\n</li>\n<li><p>话说这些大多与我们吃瓜的干系不大，贵圈很乱也不是这一天两天的了。</p>\n</li>\n<li><p>最近在刷leetcode，发现还是很吃力，想想好歹小时候也是参加奥数竞赛的人啊，脑子真的是要多用用，特别是一些思考问题的方式方法，时间久了就没有那么敏感了。还有就是深刻认识到了English的重要性，要是去官网上直接刷题不用翻译的话，怕是题目描述都看不懂。。</p>\n</li>\n<li><p>前几天买了点游泳装备，准备周末找时间去游游泳，锻炼锻炼肺部。当然顺道去看看有没有性感比基尼美女了，这不是重点。游泳 健身 了解一下？</p>\n</li>\n<li><p>周末也找了点话剧、点映、展览什么的看了看，以后周末闲不住了也可以去走一遭，何必一直窝在小小出租屋中呢，还是要多到外面看看景色，呼吸呼吸好空气。</p>\n</li>\n<li><p>发现自己上半身要保持一直笔直有点困难了，特别是肩部、颈部，弯曲程度稍微严重了些。有时候自己会刻意去纠正、扭动，但是无意识状态就又还是异常姿态。长时间坐在工位办公给我们带来了什么，我觉得这伴随着的健康问题在以后科技技术越来越炫酷的时候，找出个解决方案是至关重要的。毕竟这基数也大，而且健康问题是每个人都不可忽视的，也是国家重视的。</p>\n</li>\n<li><p>ChinaJoy今天开幕，本来是想看看的，之前也没去过，但是没有人陪同自己一个人我也打消了这个念头，花这个钱我还是去多买几本书多游几次泳来得有价值。</p>\n</li>\n<li><p>买了一个锅专门用来煮鸡胸餐、煎手抓饼，原来的那个锅太小了而且还粘锅。为了健康生活同时减少生活成本，这点投资还是要的。</p>\n</li>\n<li><p>估计是住的地方太潮了再加上还有个大鱼缸，湿气太重，最近十分不得劲，皮肤略微过敏。</p>\n</li>\n</ul>\n<hr>\n<p>大致就先这样了。</p>\n"},{"title":"惊喜四月（2021）","date":"2021-05-01T12:10:55.000Z","_content":"\n> 这篇总结其实是差不多要五月底才写的……\n\n四月最好的莫过于寻得了一位好伴侣。\n\n她温柔善良，美丽大方，明辨是非，待我极好，也正是因为处于这般幸福的日子里，我才迟迟没有写出对四月的总结。\n\n虽然我们俩认识时间并不长，但我就有一种感觉很温暖舒服，她为人很不错也不喜整那些个花里胡哨的。我也算是个直肠，有很多地方做得不好也会惹她生气，不过好在她气来得快消得也快，不然可真难到我了。\n\n小妹小我几月，着实可爱。好姑娘可不多，我真幸运能够遇见她，必得好好珍惜！\n\n五一果断带她回家见了父母，父母也是十分喜爱她，直夸她好姑娘俊俏懂礼貌。\n\n生活的新篇章开启了，为了未来为了目标还是得努力努力努力啊。\n\n身边相识的同事一个接一个离去，也不知在这家公司还能呆到何时。","source":"_posts/surprise-april.md","raw":"---\ntitle: 惊喜四月（2021）\ndate: 2021-04-31 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这篇总结其实是差不多要五月底才写的……\n\n四月最好的莫过于寻得了一位好伴侣。\n\n她温柔善良，美丽大方，明辨是非，待我极好，也正是因为处于这般幸福的日子里，我才迟迟没有写出对四月的总结。\n\n虽然我们俩认识时间并不长，但我就有一种感觉很温暖舒服，她为人很不错也不喜整那些个花里胡哨的。我也算是个直肠，有很多地方做得不好也会惹她生气，不过好在她气来得快消得也快，不然可真难到我了。\n\n小妹小我几月，着实可爱。好姑娘可不多，我真幸运能够遇见她，必得好好珍惜！\n\n五一果断带她回家见了父母，父母也是十分喜爱她，直夸她好姑娘俊俏懂礼貌。\n\n生活的新篇章开启了，为了未来为了目标还是得努力努力努力啊。\n\n身边相识的同事一个接一个离去，也不知在这家公司还能呆到何时。","slug":"surprise-april","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhs00c8k9i1bzmbcl21","content":"<blockquote>\n<p>这篇总结其实是差不多要五月底才写的……</p>\n</blockquote>\n<p>四月最好的莫过于寻得了一位好伴侣。</p>\n<p>她温柔善良，美丽大方，明辨是非，待我极好，也正是因为处于这般幸福的日子里，我才迟迟没有写出对四月的总结。</p>\n<p>虽然我们俩认识时间并不长，但我就有一种感觉很温暖舒服，她为人很不错也不喜整那些个花里胡哨的。我也算是个直肠，有很多地方做得不好也会惹她生气，不过好在她气来得快消得也快，不然可真难到我了。</p>\n<p>小妹小我几月，着实可爱。好姑娘可不多，我真幸运能够遇见她，必得好好珍惜！</p>\n<p>五一果断带她回家见了父母，父母也是十分喜爱她，直夸她好姑娘俊俏懂礼貌。</p>\n<p>生活的新篇章开启了，为了未来为了目标还是得努力努力努力啊。</p>\n<p>身边相识的同事一个接一个离去，也不知在这家公司还能呆到何时。</p>\n","excerpt":"","more":"<blockquote>\n<p>这篇总结其实是差不多要五月底才写的……</p>\n</blockquote>\n<p>四月最好的莫过于寻得了一位好伴侣。</p>\n<p>她温柔善良，美丽大方，明辨是非，待我极好，也正是因为处于这般幸福的日子里，我才迟迟没有写出对四月的总结。</p>\n<p>虽然我们俩认识时间并不长，但我就有一种感觉很温暖舒服，她为人很不错也不喜整那些个花里胡哨的。我也算是个直肠，有很多地方做得不好也会惹她生气，不过好在她气来得快消得也快，不然可真难到我了。</p>\n<p>小妹小我几月，着实可爱。好姑娘可不多，我真幸运能够遇见她，必得好好珍惜！</p>\n<p>五一果断带她回家见了父母，父母也是十分喜爱她，直夸她好姑娘俊俏懂礼貌。</p>\n<p>生活的新篇章开启了，为了未来为了目标还是得努力努力努力啊。</p>\n<p>身边相识的同事一个接一个离去，也不知在这家公司还能呆到何时。</p>\n"},{"title":"飘摇四月（2020）","date":"2020-04-25T02:10:55.000Z","_content":"\n> 不是风动 不是树动 而是你的心 在动……\n\n何谓六道轮回，何谓六尘不染，何谓六根清净，何谓六神无主，何谓六识。\n\n缘起性空何意，皈依三宝何意，阿弥陀佛何意，出家在家出世入世大乘小乘。\n\n---\n\n如今人们倒是喜欢慢节奏、慢生活，《向往的生活》这类综艺兴起正是源于此。且绝大部分观众都是处于一、二线城市的年轻人。\n\n就好比我公众号的描述“**浮躁的如今，不愿浑噩，不愿沉沦，不愿挣扎……愿寻得共鸣，找得归宿，求得慰藉……**”\n\n不幸，我也是其中之一，极力想要从中拨开，探出我笨重的脑袋，撑着大大的鼻孔，贪婪疯狂地吸。\n\n你我皆是余欢水。\n\n--- \n\n万物归结为一字：空。\n\n空，即是非永恒，有点像我们经常所说的“透过现象看本质”。\n\n肉体，美好吧，尤其是年轻的肉体。本质呢，无非是白骨须肉，结构些许不同。自然这样的说法不免有些无趣，之前跟朋友也对这一看法探讨过。好比一开始从 0 就看到了 1，而忽略了之间的 0.1 0.2 0.3 ... 如此说罢，那人自从一出生就看到了死亡，也就没必要有什么活头了；吃东西还吃什么，不都得拉出来……当然，也不能这样去过分解读。\n\n“**一切恩爱会，无常难得久。生世多畏惧，命危于晨露。由爱故生忧，由爱故生忧。若离于爱者，无忧亦无怖。**”\n\n大实话不假，**无知是最大的幸福**。正是由于世俗种种，才会造就世间七情六欲，人性才会如此丰富多彩。大家都知道那为何千百年来还是这么毅然决然奋不顾身呢？从另一面来看不就是因为这些种种的魅力吗？\n\n情感方面如今也多是在家居士，没有那么多束缚。我更多较感兴趣的是其中对事物的看法和处理，多从不同角度剖析看待，也许一件很棘手很悲观的事情不免也是一件很轻松很积极的事情。久而久之，看待事物，处理事物便会愈发得心应手，淡定从容。\n\n当遇到棘手的事情的时候，我们往往会不自主就把自己放置于一个糟糕的处境去思考去看待。因此便一开始就进入了一个不好的通道，多是不如意或是走弯路。很庆幸身处于这么一个知识交汇的时代，各种途径去获取知识也是相当便利，博爱的环境利于我们可以自主去选择想要吸收的，不愿接受或是与此刻的自己相违和的也可以大方舍弃。\n\n---\n\n说说近来看的《舞蹈风暴》，去年同事推荐的时候没想着去看，今年想着要提升下艺术修养就点开了。\n\n看得我又想“重返舞林”了……怎么说好歹以前也是上过学校舞台的人呐……\n\n总感觉现在的我供不起我所有的爱好，我真的太博爱了，啥啥都想弄一弄。技多不压身？\n\n最近气温开始回升，做一个合格的时间管理者，该开始的就不要再让惰性主宰你了。","source":"_posts/sway-april.md","raw":"---\ntitle: 飘摇四月（2020）\ndate: 2020-04-25 10:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 不是风动 不是树动 而是你的心 在动……\n\n何谓六道轮回，何谓六尘不染，何谓六根清净，何谓六神无主，何谓六识。\n\n缘起性空何意，皈依三宝何意，阿弥陀佛何意，出家在家出世入世大乘小乘。\n\n---\n\n如今人们倒是喜欢慢节奏、慢生活，《向往的生活》这类综艺兴起正是源于此。且绝大部分观众都是处于一、二线城市的年轻人。\n\n就好比我公众号的描述“**浮躁的如今，不愿浑噩，不愿沉沦，不愿挣扎……愿寻得共鸣，找得归宿，求得慰藉……**”\n\n不幸，我也是其中之一，极力想要从中拨开，探出我笨重的脑袋，撑着大大的鼻孔，贪婪疯狂地吸。\n\n你我皆是余欢水。\n\n--- \n\n万物归结为一字：空。\n\n空，即是非永恒，有点像我们经常所说的“透过现象看本质”。\n\n肉体，美好吧，尤其是年轻的肉体。本质呢，无非是白骨须肉，结构些许不同。自然这样的说法不免有些无趣，之前跟朋友也对这一看法探讨过。好比一开始从 0 就看到了 1，而忽略了之间的 0.1 0.2 0.3 ... 如此说罢，那人自从一出生就看到了死亡，也就没必要有什么活头了；吃东西还吃什么，不都得拉出来……当然，也不能这样去过分解读。\n\n“**一切恩爱会，无常难得久。生世多畏惧，命危于晨露。由爱故生忧，由爱故生忧。若离于爱者，无忧亦无怖。**”\n\n大实话不假，**无知是最大的幸福**。正是由于世俗种种，才会造就世间七情六欲，人性才会如此丰富多彩。大家都知道那为何千百年来还是这么毅然决然奋不顾身呢？从另一面来看不就是因为这些种种的魅力吗？\n\n情感方面如今也多是在家居士，没有那么多束缚。我更多较感兴趣的是其中对事物的看法和处理，多从不同角度剖析看待，也许一件很棘手很悲观的事情不免也是一件很轻松很积极的事情。久而久之，看待事物，处理事物便会愈发得心应手，淡定从容。\n\n当遇到棘手的事情的时候，我们往往会不自主就把自己放置于一个糟糕的处境去思考去看待。因此便一开始就进入了一个不好的通道，多是不如意或是走弯路。很庆幸身处于这么一个知识交汇的时代，各种途径去获取知识也是相当便利，博爱的环境利于我们可以自主去选择想要吸收的，不愿接受或是与此刻的自己相违和的也可以大方舍弃。\n\n---\n\n说说近来看的《舞蹈风暴》，去年同事推荐的时候没想着去看，今年想着要提升下艺术修养就点开了。\n\n看得我又想“重返舞林”了……怎么说好歹以前也是上过学校舞台的人呐……\n\n总感觉现在的我供不起我所有的爱好，我真的太博爱了，啥啥都想弄一弄。技多不压身？\n\n最近气温开始回升，做一个合格的时间管理者，该开始的就不要再让惰性主宰你了。","slug":"sway-april","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhs00cdk9i11rz02x3l","content":"<blockquote>\n<p>不是风动 不是树动 而是你的心 在动……</p>\n</blockquote>\n<p>何谓六道轮回，何谓六尘不染，何谓六根清净，何谓六神无主，何谓六识。</p>\n<p>缘起性空何意，皈依三宝何意，阿弥陀佛何意，出家在家出世入世大乘小乘。</p>\n<hr>\n<p>如今人们倒是喜欢慢节奏、慢生活，《向往的生活》这类综艺兴起正是源于此。且绝大部分观众都是处于一、二线城市的年轻人。</p>\n<p>就好比我公众号的描述“<strong>浮躁的如今，不愿浑噩，不愿沉沦，不愿挣扎……愿寻得共鸣，找得归宿，求得慰藉……</strong>”</p>\n<p>不幸，我也是其中之一，极力想要从中拨开，探出我笨重的脑袋，撑着大大的鼻孔，贪婪疯狂地吸。</p>\n<p>你我皆是余欢水。</p>\n<hr>\n<p>万物归结为一字：空。</p>\n<p>空，即是非永恒，有点像我们经常所说的“透过现象看本质”。</p>\n<p>肉体，美好吧，尤其是年轻的肉体。本质呢，无非是白骨须肉，结构些许不同。自然这样的说法不免有些无趣，之前跟朋友也对这一看法探讨过。好比一开始从 0 就看到了 1，而忽略了之间的 0.1 0.2 0.3 … 如此说罢，那人自从一出生就看到了死亡，也就没必要有什么活头了；吃东西还吃什么，不都得拉出来……当然，也不能这样去过分解读。</p>\n<p>“<strong>一切恩爱会，无常难得久。生世多畏惧，命危于晨露。由爱故生忧，由爱故生忧。若离于爱者，无忧亦无怖。</strong>”</p>\n<p>大实话不假，<strong>无知是最大的幸福</strong>。正是由于世俗种种，才会造就世间七情六欲，人性才会如此丰富多彩。大家都知道那为何千百年来还是这么毅然决然奋不顾身呢？从另一面来看不就是因为这些种种的魅力吗？</p>\n<p>情感方面如今也多是在家居士，没有那么多束缚。我更多较感兴趣的是其中对事物的看法和处理，多从不同角度剖析看待，也许一件很棘手很悲观的事情不免也是一件很轻松很积极的事情。久而久之，看待事物，处理事物便会愈发得心应手，淡定从容。</p>\n<p>当遇到棘手的事情的时候，我们往往会不自主就把自己放置于一个糟糕的处境去思考去看待。因此便一开始就进入了一个不好的通道，多是不如意或是走弯路。很庆幸身处于这么一个知识交汇的时代，各种途径去获取知识也是相当便利，博爱的环境利于我们可以自主去选择想要吸收的，不愿接受或是与此刻的自己相违和的也可以大方舍弃。</p>\n<hr>\n<p>说说近来看的《舞蹈风暴》，去年同事推荐的时候没想着去看，今年想着要提升下艺术修养就点开了。</p>\n<p>看得我又想“重返舞林”了……怎么说好歹以前也是上过学校舞台的人呐……</p>\n<p>总感觉现在的我供不起我所有的爱好，我真的太博爱了，啥啥都想弄一弄。技多不压身？</p>\n<p>最近气温开始回升，做一个合格的时间管理者，该开始的就不要再让惰性主宰你了。</p>\n","excerpt":"","more":"<blockquote>\n<p>不是风动 不是树动 而是你的心 在动……</p>\n</blockquote>\n<p>何谓六道轮回，何谓六尘不染，何谓六根清净，何谓六神无主，何谓六识。</p>\n<p>缘起性空何意，皈依三宝何意，阿弥陀佛何意，出家在家出世入世大乘小乘。</p>\n<hr>\n<p>如今人们倒是喜欢慢节奏、慢生活，《向往的生活》这类综艺兴起正是源于此。且绝大部分观众都是处于一、二线城市的年轻人。</p>\n<p>就好比我公众号的描述“<strong>浮躁的如今，不愿浑噩，不愿沉沦，不愿挣扎……愿寻得共鸣，找得归宿，求得慰藉……</strong>”</p>\n<p>不幸，我也是其中之一，极力想要从中拨开，探出我笨重的脑袋，撑着大大的鼻孔，贪婪疯狂地吸。</p>\n<p>你我皆是余欢水。</p>\n<hr>\n<p>万物归结为一字：空。</p>\n<p>空，即是非永恒，有点像我们经常所说的“透过现象看本质”。</p>\n<p>肉体，美好吧，尤其是年轻的肉体。本质呢，无非是白骨须肉，结构些许不同。自然这样的说法不免有些无趣，之前跟朋友也对这一看法探讨过。好比一开始从 0 就看到了 1，而忽略了之间的 0.1 0.2 0.3 … 如此说罢，那人自从一出生就看到了死亡，也就没必要有什么活头了；吃东西还吃什么，不都得拉出来……当然，也不能这样去过分解读。</p>\n<p>“<strong>一切恩爱会，无常难得久。生世多畏惧，命危于晨露。由爱故生忧，由爱故生忧。若离于爱者，无忧亦无怖。</strong>”</p>\n<p>大实话不假，<strong>无知是最大的幸福</strong>。正是由于世俗种种，才会造就世间七情六欲，人性才会如此丰富多彩。大家都知道那为何千百年来还是这么毅然决然奋不顾身呢？从另一面来看不就是因为这些种种的魅力吗？</p>\n<p>情感方面如今也多是在家居士，没有那么多束缚。我更多较感兴趣的是其中对事物的看法和处理，多从不同角度剖析看待，也许一件很棘手很悲观的事情不免也是一件很轻松很积极的事情。久而久之，看待事物，处理事物便会愈发得心应手，淡定从容。</p>\n<p>当遇到棘手的事情的时候，我们往往会不自主就把自己放置于一个糟糕的处境去思考去看待。因此便一开始就进入了一个不好的通道，多是不如意或是走弯路。很庆幸身处于这么一个知识交汇的时代，各种途径去获取知识也是相当便利，博爱的环境利于我们可以自主去选择想要吸收的，不愿接受或是与此刻的自己相违和的也可以大方舍弃。</p>\n<hr>\n<p>说说近来看的《舞蹈风暴》，去年同事推荐的时候没想着去看，今年想着要提升下艺术修养就点开了。</p>\n<p>看得我又想“重返舞林”了……怎么说好歹以前也是上过学校舞台的人呐……</p>\n<p>总感觉现在的我供不起我所有的爱好，我真的太博爱了，啥啥都想弄一弄。技多不压身？</p>\n<p>最近气温开始回升，做一个合格的时间管理者，该开始的就不要再让惰性主宰你了。</p>\n"},{"title":"细聊十一月（2020）","date":"2020-11-29T08:10:55.000Z","_content":"\n> 这个月，让我们来好好聊一聊。\n\n首先第一件事比较伤感，几个月前买的小剃刀在几天前发现丧命在了玻璃缸中。我已经把水位调得很低了而且都已经适应了一两个月，不知道为什么突然就好像是溺水了。而同缸中的两只小麝香一点事都没有，活蹦乱跳的，不知道是麝香比较好养还是这件事与麝香有关。真的很可惜，是只好苗子，我本准备好好培养的，现在就剩下两只小麝香长大不知会变成怎样。\n\n今年双十一还没有开始，我已经花掉了万把块钱了。本来以为 Mate 40 Pro 会一时半会买不到，结果一号凌晨一下子就给抢着了，同时还买了件波司登的羽绒服。第一次买这么贵的衣服，心疼得不得了啊，不过东西到手质感确实有，冬天就指着这件了，明年再给老爸整一件，今年确实有点伤。钱钱赚不着，花钱有一套，要能像我室友一样把持得住不花钱估计还能多攒不少。\n\n去年报名参加的横马跑着了，值啊。赛道差不多把那些个景点都给穿过去了，明清宫苑出发，穿过秦王宫再到清明上河图，再从圆明新园穿过又回到明清宫苑。爽，满足，成绩不重要。8 号开赛，我是先回了趟家顺便把家里老旧电脑换了一下，然后 7 号从义乌坐车去横店。横店离家也不远，但是我以前就是没去过，这次我姐开车来接我回去顺道全家一起过来逛了一下。我跑完往取物点走结果就在路上看到了我老爸老妈老姐还有我那可爱的小外甥女，因为我没有带手机一起跑就没收到信息。集合之后一家人去附近吃了顿潮汕火锅，吃完后我就先回宾馆洗澡换衣服，然后再一起去秦王宫逛了逛，累，但是非常满足。毕竟我们一家人一起出来玩的机会很少，特别是我一年在家也呆不上几天，上次全家出去玩还是那个玻璃栈道，以后真得多找点这种时间去一起逛逛玩玩。\n\n老爸想要我回去可以在义乌找个工作，离家近房价也不至于太高。虽然在上海这几年没赚到什么钱但是回去什么时候都能回去，我给自己的期限是到 2022 年，要是到时候还是看不到希望就回去发展了，毕竟回去环境也不算太差，工作还是能找到的。这几年只想多攒点钱，看能不能赶上什么浪潮。\n\n前段时间买的 911 乐高拼了几天了，下班回来拼一会，拼到七八十的时候发现找不到个零件了，然后就这么先放着，官网自助申补好几次终于成功了，居然一个零件要从丹麦寄过来，不可思议。我只知道至少要搁置个把星期。看着说明一步步零件拼搭，看着底盘座椅方向盘转动轴轮子慢慢完整，成就感还是有的。男人的快乐就是这么简单。\n\n下了一星期雨，温度直线下降到十度以下，还真是不给反应。给自己添置添置衣物，办公室常年空调二十几度，里面短袖外头羽绒服，要那么多衣服何用，脱了穿穿了脱。这种天气还是适合窝在被窝里，看着书或是看着电视剧。说到电视剧，最近在看一部美剧《无耻之徒》，老美还真是什么都敢拍出来，很底层很现实。\n\n今天是 2020-11-29，距离过年还有 74 天。","source":"_posts/talk-november.md","raw":"---\ntitle: 细聊十一月（2020）\ndate: 2020-11-29 16:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个月，让我们来好好聊一聊。\n\n首先第一件事比较伤感，几个月前买的小剃刀在几天前发现丧命在了玻璃缸中。我已经把水位调得很低了而且都已经适应了一两个月，不知道为什么突然就好像是溺水了。而同缸中的两只小麝香一点事都没有，活蹦乱跳的，不知道是麝香比较好养还是这件事与麝香有关。真的很可惜，是只好苗子，我本准备好好培养的，现在就剩下两只小麝香长大不知会变成怎样。\n\n今年双十一还没有开始，我已经花掉了万把块钱了。本来以为 Mate 40 Pro 会一时半会买不到，结果一号凌晨一下子就给抢着了，同时还买了件波司登的羽绒服。第一次买这么贵的衣服，心疼得不得了啊，不过东西到手质感确实有，冬天就指着这件了，明年再给老爸整一件，今年确实有点伤。钱钱赚不着，花钱有一套，要能像我室友一样把持得住不花钱估计还能多攒不少。\n\n去年报名参加的横马跑着了，值啊。赛道差不多把那些个景点都给穿过去了，明清宫苑出发，穿过秦王宫再到清明上河图，再从圆明新园穿过又回到明清宫苑。爽，满足，成绩不重要。8 号开赛，我是先回了趟家顺便把家里老旧电脑换了一下，然后 7 号从义乌坐车去横店。横店离家也不远，但是我以前就是没去过，这次我姐开车来接我回去顺道全家一起过来逛了一下。我跑完往取物点走结果就在路上看到了我老爸老妈老姐还有我那可爱的小外甥女，因为我没有带手机一起跑就没收到信息。集合之后一家人去附近吃了顿潮汕火锅，吃完后我就先回宾馆洗澡换衣服，然后再一起去秦王宫逛了逛，累，但是非常满足。毕竟我们一家人一起出来玩的机会很少，特别是我一年在家也呆不上几天，上次全家出去玩还是那个玻璃栈道，以后真得多找点这种时间去一起逛逛玩玩。\n\n老爸想要我回去可以在义乌找个工作，离家近房价也不至于太高。虽然在上海这几年没赚到什么钱但是回去什么时候都能回去，我给自己的期限是到 2022 年，要是到时候还是看不到希望就回去发展了，毕竟回去环境也不算太差，工作还是能找到的。这几年只想多攒点钱，看能不能赶上什么浪潮。\n\n前段时间买的 911 乐高拼了几天了，下班回来拼一会，拼到七八十的时候发现找不到个零件了，然后就这么先放着，官网自助申补好几次终于成功了，居然一个零件要从丹麦寄过来，不可思议。我只知道至少要搁置个把星期。看着说明一步步零件拼搭，看着底盘座椅方向盘转动轴轮子慢慢完整，成就感还是有的。男人的快乐就是这么简单。\n\n下了一星期雨，温度直线下降到十度以下，还真是不给反应。给自己添置添置衣物，办公室常年空调二十几度，里面短袖外头羽绒服，要那么多衣服何用，脱了穿穿了脱。这种天气还是适合窝在被窝里，看着书或是看着电视剧。说到电视剧，最近在看一部美剧《无耻之徒》，老美还真是什么都敢拍出来，很底层很现实。\n\n今天是 2020-11-29，距离过年还有 74 天。","slug":"talk-november","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhs00cgk9i1g9bm3wab","content":"<blockquote>\n<p>这个月，让我们来好好聊一聊。</p>\n</blockquote>\n<p>首先第一件事比较伤感，几个月前买的小剃刀在几天前发现丧命在了玻璃缸中。我已经把水位调得很低了而且都已经适应了一两个月，不知道为什么突然就好像是溺水了。而同缸中的两只小麝香一点事都没有，活蹦乱跳的，不知道是麝香比较好养还是这件事与麝香有关。真的很可惜，是只好苗子，我本准备好好培养的，现在就剩下两只小麝香长大不知会变成怎样。</p>\n<p>今年双十一还没有开始，我已经花掉了万把块钱了。本来以为 Mate 40 Pro 会一时半会买不到，结果一号凌晨一下子就给抢着了，同时还买了件波司登的羽绒服。第一次买这么贵的衣服，心疼得不得了啊，不过东西到手质感确实有，冬天就指着这件了，明年再给老爸整一件，今年确实有点伤。钱钱赚不着，花钱有一套，要能像我室友一样把持得住不花钱估计还能多攒不少。</p>\n<p>去年报名参加的横马跑着了，值啊。赛道差不多把那些个景点都给穿过去了，明清宫苑出发，穿过秦王宫再到清明上河图，再从圆明新园穿过又回到明清宫苑。爽，满足，成绩不重要。8 号开赛，我是先回了趟家顺便把家里老旧电脑换了一下，然后 7 号从义乌坐车去横店。横店离家也不远，但是我以前就是没去过，这次我姐开车来接我回去顺道全家一起过来逛了一下。我跑完往取物点走结果就在路上看到了我老爸老妈老姐还有我那可爱的小外甥女，因为我没有带手机一起跑就没收到信息。集合之后一家人去附近吃了顿潮汕火锅，吃完后我就先回宾馆洗澡换衣服，然后再一起去秦王宫逛了逛，累，但是非常满足。毕竟我们一家人一起出来玩的机会很少，特别是我一年在家也呆不上几天，上次全家出去玩还是那个玻璃栈道，以后真得多找点这种时间去一起逛逛玩玩。</p>\n<p>老爸想要我回去可以在义乌找个工作，离家近房价也不至于太高。虽然在上海这几年没赚到什么钱但是回去什么时候都能回去，我给自己的期限是到 2022 年，要是到时候还是看不到希望就回去发展了，毕竟回去环境也不算太差，工作还是能找到的。这几年只想多攒点钱，看能不能赶上什么浪潮。</p>\n<p>前段时间买的 911 乐高拼了几天了，下班回来拼一会，拼到七八十的时候发现找不到个零件了，然后就这么先放着，官网自助申补好几次终于成功了，居然一个零件要从丹麦寄过来，不可思议。我只知道至少要搁置个把星期。看着说明一步步零件拼搭，看着底盘座椅方向盘转动轴轮子慢慢完整，成就感还是有的。男人的快乐就是这么简单。</p>\n<p>下了一星期雨，温度直线下降到十度以下，还真是不给反应。给自己添置添置衣物，办公室常年空调二十几度，里面短袖外头羽绒服，要那么多衣服何用，脱了穿穿了脱。这种天气还是适合窝在被窝里，看着书或是看着电视剧。说到电视剧，最近在看一部美剧《无耻之徒》，老美还真是什么都敢拍出来，很底层很现实。</p>\n<p>今天是 2020-11-29，距离过年还有 74 天。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个月，让我们来好好聊一聊。</p>\n</blockquote>\n<p>首先第一件事比较伤感，几个月前买的小剃刀在几天前发现丧命在了玻璃缸中。我已经把水位调得很低了而且都已经适应了一两个月，不知道为什么突然就好像是溺水了。而同缸中的两只小麝香一点事都没有，活蹦乱跳的，不知道是麝香比较好养还是这件事与麝香有关。真的很可惜，是只好苗子，我本准备好好培养的，现在就剩下两只小麝香长大不知会变成怎样。</p>\n<p>今年双十一还没有开始，我已经花掉了万把块钱了。本来以为 Mate 40 Pro 会一时半会买不到，结果一号凌晨一下子就给抢着了，同时还买了件波司登的羽绒服。第一次买这么贵的衣服，心疼得不得了啊，不过东西到手质感确实有，冬天就指着这件了，明年再给老爸整一件，今年确实有点伤。钱钱赚不着，花钱有一套，要能像我室友一样把持得住不花钱估计还能多攒不少。</p>\n<p>去年报名参加的横马跑着了，值啊。赛道差不多把那些个景点都给穿过去了，明清宫苑出发，穿过秦王宫再到清明上河图，再从圆明新园穿过又回到明清宫苑。爽，满足，成绩不重要。8 号开赛，我是先回了趟家顺便把家里老旧电脑换了一下，然后 7 号从义乌坐车去横店。横店离家也不远，但是我以前就是没去过，这次我姐开车来接我回去顺道全家一起过来逛了一下。我跑完往取物点走结果就在路上看到了我老爸老妈老姐还有我那可爱的小外甥女，因为我没有带手机一起跑就没收到信息。集合之后一家人去附近吃了顿潮汕火锅，吃完后我就先回宾馆洗澡换衣服，然后再一起去秦王宫逛了逛，累，但是非常满足。毕竟我们一家人一起出来玩的机会很少，特别是我一年在家也呆不上几天，上次全家出去玩还是那个玻璃栈道，以后真得多找点这种时间去一起逛逛玩玩。</p>\n<p>老爸想要我回去可以在义乌找个工作，离家近房价也不至于太高。虽然在上海这几年没赚到什么钱但是回去什么时候都能回去，我给自己的期限是到 2022 年，要是到时候还是看不到希望就回去发展了，毕竟回去环境也不算太差，工作还是能找到的。这几年只想多攒点钱，看能不能赶上什么浪潮。</p>\n<p>前段时间买的 911 乐高拼了几天了，下班回来拼一会，拼到七八十的时候发现找不到个零件了，然后就这么先放着，官网自助申补好几次终于成功了，居然一个零件要从丹麦寄过来，不可思议。我只知道至少要搁置个把星期。看着说明一步步零件拼搭，看着底盘座椅方向盘转动轴轮子慢慢完整，成就感还是有的。男人的快乐就是这么简单。</p>\n<p>下了一星期雨，温度直线下降到十度以下，还真是不给反应。给自己添置添置衣物，办公室常年空调二十几度，里面短袖外头羽绒服，要那么多衣服何用，脱了穿穿了脱。这种天气还是适合窝在被窝里，看着书或是看着电视剧。说到电视剧，最近在看一部美剧《无耻之徒》，老美还真是什么都敢拍出来，很底层很现实。</p>\n<p>今天是 2020-11-29，距离过年还有 74 天。</p>\n"},{"title":"那一天，那一月，那一年","date":"2018-05-23T01:04:17.000Z","_content":"<br>\n<center>\n\n> *文章首发个人公众号：普度狗生*<br>\n\n那一天，\n我闭目在经殿的香雾中，\n蓦然听见，\n你诵经中的真言；\n\n那一月，\n我摇动所有的经筒，\n不为超度，\n只为触摸你的指尖；\n\n那一年，\n磕长头匍匐在山路，\n不为觐见，\n只为贴着你的温暖；\n\n那一世，\n转山转水转佛塔，\n不为修来世，\n只为途中与你相见；\n\n那一夜，\n我听了一宿梵唱，\n不为参悟，\n只为寻你的一丝气息；\n\n那一月，\n我转过所有经筒，\n不为超度，\n只为触摸你的指纹；\n\n那一年，\n我磕长头拥抱尘埃，\n不为朝佛，\n只为贴着你的温暖；\n\n那一世，\n我翻遍十万大山，\n不为修来世，\n只为路中能与你相遇；\n\n那一瞬，\n我飞升成仙，\n不为长生，\n只为佑你平安喜乐；\n\n**只是，\n就在那一夜，\n我忘却了所有，\n抛却了信仰，\n舍弃了轮回，\n只为，\n那曾在佛前哭泣的玫瑰，\n早已失去旧日的光泽。**\n</center>","source":"_posts/that-day.md","raw":"---\ntitle: 那一天，那一月，那一年\ndate: 2018-5-23 09:04:17\ncategories: [文学,诗词鉴赏]\ntags: [文学,仓央嘉措,诗词]\n---\n<br>\n<center>\n\n> *文章首发个人公众号：普度狗生*<br>\n\n那一天，\n我闭目在经殿的香雾中，\n蓦然听见，\n你诵经中的真言；\n\n那一月，\n我摇动所有的经筒，\n不为超度，\n只为触摸你的指尖；\n\n那一年，\n磕长头匍匐在山路，\n不为觐见，\n只为贴着你的温暖；\n\n那一世，\n转山转水转佛塔，\n不为修来世，\n只为途中与你相见；\n\n那一夜，\n我听了一宿梵唱，\n不为参悟，\n只为寻你的一丝气息；\n\n那一月，\n我转过所有经筒，\n不为超度，\n只为触摸你的指纹；\n\n那一年，\n我磕长头拥抱尘埃，\n不为朝佛，\n只为贴着你的温暖；\n\n那一世，\n我翻遍十万大山，\n不为修来世，\n只为路中能与你相遇；\n\n那一瞬，\n我飞升成仙，\n不为长生，\n只为佑你平安喜乐；\n\n**只是，\n就在那一夜，\n我忘却了所有，\n抛却了信仰，\n舍弃了轮回，\n只为，\n那曾在佛前哭泣的玫瑰，\n早已失去旧日的光泽。**\n</center>","slug":"that-day","published":1,"updated":"2023-12-23T15:35:23.830Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhs00clk9i14f7we7zw","content":"<br>\n<center>\n\n<blockquote>\n<p><em>文章首发个人公众号：普度狗生</em><br></p>\n</blockquote>\n<p>那一天，<br>我闭目在经殿的香雾中，<br>蓦然听见，<br>你诵经中的真言；</p>\n<p>那一月，<br>我摇动所有的经筒，<br>不为超度，<br>只为触摸你的指尖；</p>\n<p>那一年，<br>磕长头匍匐在山路，<br>不为觐见，<br>只为贴着你的温暖；</p>\n<p>那一世，<br>转山转水转佛塔，<br>不为修来世，<br>只为途中与你相见；</p>\n<p>那一夜，<br>我听了一宿梵唱，<br>不为参悟，<br>只为寻你的一丝气息；</p>\n<p>那一月，<br>我转过所有经筒，<br>不为超度，<br>只为触摸你的指纹；</p>\n<p>那一年，<br>我磕长头拥抱尘埃，<br>不为朝佛，<br>只为贴着你的温暖；</p>\n<p>那一世，<br>我翻遍十万大山，<br>不为修来世，<br>只为路中能与你相遇；</p>\n<p>那一瞬，<br>我飞升成仙，<br>不为长生，<br>只为佑你平安喜乐；</p>\n<p><strong>只是，<br>就在那一夜，<br>我忘却了所有，<br>抛却了信仰，<br>舍弃了轮回，<br>只为，<br>那曾在佛前哭泣的玫瑰，<br>早已失去旧日的光泽。</strong></p>\n</center>","excerpt":"","more":"<br>\n<center>\n\n<blockquote>\n<p><em>文章首发个人公众号：普度狗生</em><br></p>\n</blockquote>\n<p>那一天，<br>我闭目在经殿的香雾中，<br>蓦然听见，<br>你诵经中的真言；</p>\n<p>那一月，<br>我摇动所有的经筒，<br>不为超度，<br>只为触摸你的指尖；</p>\n<p>那一年，<br>磕长头匍匐在山路，<br>不为觐见，<br>只为贴着你的温暖；</p>\n<p>那一世，<br>转山转水转佛塔，<br>不为修来世，<br>只为途中与你相见；</p>\n<p>那一夜，<br>我听了一宿梵唱，<br>不为参悟，<br>只为寻你的一丝气息；</p>\n<p>那一月，<br>我转过所有经筒，<br>不为超度，<br>只为触摸你的指纹；</p>\n<p>那一年，<br>我磕长头拥抱尘埃，<br>不为朝佛，<br>只为贴着你的温暖；</p>\n<p>那一世，<br>我翻遍十万大山，<br>不为修来世，<br>只为路中能与你相遇；</p>\n<p>那一瞬，<br>我飞升成仙，<br>不为长生，<br>只为佑你平安喜乐；</p>\n<p><strong>只是，<br>就在那一夜，<br>我忘却了所有，<br>抛却了信仰，<br>舍弃了轮回，<br>只为，<br>那曾在佛前哭泣的玫瑰，<br>早已失去旧日的光泽。</strong></p>\n</center>"},{"title":"心累一月（2020）","date":"2020-01-20T02:10:55.000Z","_content":"\n> 心累累累累累累累累累累累累累累累累啊\n\n又要自我否问了，又要成长了。\n\n---\n\n我一看 2019 的文件夹，加上总结总共才写了 15 篇，这一年我是有多水。说是当回首往事的时候,不因虚度年华而悔恨,也不因碌碌无为而羞耻。真的要羞耻了，怎么能这样呢！生命应是闪耀的，是红色有张力的，是滴入泥潭而不深陷在多遥远第一眼都能望得到的！大家都渴望着，都为之执着着，到了一种什么情境呢，就是那种这辈子我就算看一眼，远远得看一眼就能无比满足的死去。\n\n人有血气那是极其好的，总会是成为人群中的那些目光聚焦点。其实我们本都是带着血气来到这世界的，只是血气本就珍贵，在岁月长河中慢慢就被那些个“主子”给抽了个精光，再打个三五折的折现了。\n\n当我看到自己亲姐姐已是为人妻将是为人母，发现这个世界很多事还是很有意义的。小时候我和我姐常常争吵打架，由于男生嘛发育较晚，她又年长我几岁，奈何我怎能打得过，多是被指手去做事。小时候虽然生活条件没那么好，但是多的是值得回忆的地方，时代不同那些也终将过去难以再重现了。人会回忆，我觉得这个设定很是奇妙。\n\n最近由于域名备案问题导致网站暂时无法访问，之前是在大学时候就备的案，用的自然也是当时的手机号，地址什么的都是合肥。现在那张手机卡早就不用了，上头呢也隔三差五查一次备案问题，本来之前就通知过需要更新信息。可是我这个情况就很麻烦，要么重新激活之前的手机号，去合肥再更改下信息，要么只能注销掉现在的备案号重新在上海备案。由于我当时还没有办上海的居住证也办不了备案就这样不了了之了，没想到时隔大半年，又开始查了，无奈啊，这次我决定注销掉重新在上海办理备案了，居住证要年后才拿到也就只能年后再办了，现在我先把之前的给注销了。不合情合理不够人性啊！\n\n月底传出肺炎的消息，回家在虹桥火车站上看到都是戴着口罩的人，从刚开始的不以为意到后来的惊恐不已。\n\n一整个春节都呆在家，看着电视追踪前线医疗士兵的消息，无话可说，唯有致敬！\n\n2020 年的第一个月就这么坎坷，这到底是天灾呢还是人祸？\n","source":"_posts/tired-january.md","raw":"---\ntitle: 心累一月（2020）\ndate: 2020-01-20 10:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 心累累累累累累累累累累累累累累累累啊\n\n又要自我否问了，又要成长了。\n\n---\n\n我一看 2019 的文件夹，加上总结总共才写了 15 篇，这一年我是有多水。说是当回首往事的时候,不因虚度年华而悔恨,也不因碌碌无为而羞耻。真的要羞耻了，怎么能这样呢！生命应是闪耀的，是红色有张力的，是滴入泥潭而不深陷在多遥远第一眼都能望得到的！大家都渴望着，都为之执着着，到了一种什么情境呢，就是那种这辈子我就算看一眼，远远得看一眼就能无比满足的死去。\n\n人有血气那是极其好的，总会是成为人群中的那些目光聚焦点。其实我们本都是带着血气来到这世界的，只是血气本就珍贵，在岁月长河中慢慢就被那些个“主子”给抽了个精光，再打个三五折的折现了。\n\n当我看到自己亲姐姐已是为人妻将是为人母，发现这个世界很多事还是很有意义的。小时候我和我姐常常争吵打架，由于男生嘛发育较晚，她又年长我几岁，奈何我怎能打得过，多是被指手去做事。小时候虽然生活条件没那么好，但是多的是值得回忆的地方，时代不同那些也终将过去难以再重现了。人会回忆，我觉得这个设定很是奇妙。\n\n最近由于域名备案问题导致网站暂时无法访问，之前是在大学时候就备的案，用的自然也是当时的手机号，地址什么的都是合肥。现在那张手机卡早就不用了，上头呢也隔三差五查一次备案问题，本来之前就通知过需要更新信息。可是我这个情况就很麻烦，要么重新激活之前的手机号，去合肥再更改下信息，要么只能注销掉现在的备案号重新在上海备案。由于我当时还没有办上海的居住证也办不了备案就这样不了了之了，没想到时隔大半年，又开始查了，无奈啊，这次我决定注销掉重新在上海办理备案了，居住证要年后才拿到也就只能年后再办了，现在我先把之前的给注销了。不合情合理不够人性啊！\n\n月底传出肺炎的消息，回家在虹桥火车站上看到都是戴着口罩的人，从刚开始的不以为意到后来的惊恐不已。\n\n一整个春节都呆在家，看着电视追踪前线医疗士兵的消息，无话可说，唯有致敬！\n\n2020 年的第一个月就这么坎坷，这到底是天灾呢还是人祸？\n","slug":"tired-january","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjht00cok9i1by1j03rx","content":"<blockquote>\n<p>心累累累累累累累累累累累累累累累累啊</p>\n</blockquote>\n<p>又要自我否问了，又要成长了。</p>\n<hr>\n<p>我一看 2019 的文件夹，加上总结总共才写了 15 篇，这一年我是有多水。说是当回首往事的时候,不因虚度年华而悔恨,也不因碌碌无为而羞耻。真的要羞耻了，怎么能这样呢！生命应是闪耀的，是红色有张力的，是滴入泥潭而不深陷在多遥远第一眼都能望得到的！大家都渴望着，都为之执着着，到了一种什么情境呢，就是那种这辈子我就算看一眼，远远得看一眼就能无比满足的死去。</p>\n<p>人有血气那是极其好的，总会是成为人群中的那些目光聚焦点。其实我们本都是带着血气来到这世界的，只是血气本就珍贵，在岁月长河中慢慢就被那些个“主子”给抽了个精光，再打个三五折的折现了。</p>\n<p>当我看到自己亲姐姐已是为人妻将是为人母，发现这个世界很多事还是很有意义的。小时候我和我姐常常争吵打架，由于男生嘛发育较晚，她又年长我几岁，奈何我怎能打得过，多是被指手去做事。小时候虽然生活条件没那么好，但是多的是值得回忆的地方，时代不同那些也终将过去难以再重现了。人会回忆，我觉得这个设定很是奇妙。</p>\n<p>最近由于域名备案问题导致网站暂时无法访问，之前是在大学时候就备的案，用的自然也是当时的手机号，地址什么的都是合肥。现在那张手机卡早就不用了，上头呢也隔三差五查一次备案问题，本来之前就通知过需要更新信息。可是我这个情况就很麻烦，要么重新激活之前的手机号，去合肥再更改下信息，要么只能注销掉现在的备案号重新在上海备案。由于我当时还没有办上海的居住证也办不了备案就这样不了了之了，没想到时隔大半年，又开始查了，无奈啊，这次我决定注销掉重新在上海办理备案了，居住证要年后才拿到也就只能年后再办了，现在我先把之前的给注销了。不合情合理不够人性啊！</p>\n<p>月底传出肺炎的消息，回家在虹桥火车站上看到都是戴着口罩的人，从刚开始的不以为意到后来的惊恐不已。</p>\n<p>一整个春节都呆在家，看着电视追踪前线医疗士兵的消息，无话可说，唯有致敬！</p>\n<p>2020 年的第一个月就这么坎坷，这到底是天灾呢还是人祸？</p>\n","excerpt":"","more":"<blockquote>\n<p>心累累累累累累累累累累累累累累累累啊</p>\n</blockquote>\n<p>又要自我否问了，又要成长了。</p>\n<hr>\n<p>我一看 2019 的文件夹，加上总结总共才写了 15 篇，这一年我是有多水。说是当回首往事的时候,不因虚度年华而悔恨,也不因碌碌无为而羞耻。真的要羞耻了，怎么能这样呢！生命应是闪耀的，是红色有张力的，是滴入泥潭而不深陷在多遥远第一眼都能望得到的！大家都渴望着，都为之执着着，到了一种什么情境呢，就是那种这辈子我就算看一眼，远远得看一眼就能无比满足的死去。</p>\n<p>人有血气那是极其好的，总会是成为人群中的那些目光聚焦点。其实我们本都是带着血气来到这世界的，只是血气本就珍贵，在岁月长河中慢慢就被那些个“主子”给抽了个精光，再打个三五折的折现了。</p>\n<p>当我看到自己亲姐姐已是为人妻将是为人母，发现这个世界很多事还是很有意义的。小时候我和我姐常常争吵打架，由于男生嘛发育较晚，她又年长我几岁，奈何我怎能打得过，多是被指手去做事。小时候虽然生活条件没那么好，但是多的是值得回忆的地方，时代不同那些也终将过去难以再重现了。人会回忆，我觉得这个设定很是奇妙。</p>\n<p>最近由于域名备案问题导致网站暂时无法访问，之前是在大学时候就备的案，用的自然也是当时的手机号，地址什么的都是合肥。现在那张手机卡早就不用了，上头呢也隔三差五查一次备案问题，本来之前就通知过需要更新信息。可是我这个情况就很麻烦，要么重新激活之前的手机号，去合肥再更改下信息，要么只能注销掉现在的备案号重新在上海备案。由于我当时还没有办上海的居住证也办不了备案就这样不了了之了，没想到时隔大半年，又开始查了，无奈啊，这次我决定注销掉重新在上海办理备案了，居住证要年后才拿到也就只能年后再办了，现在我先把之前的给注销了。不合情合理不够人性啊！</p>\n<p>月底传出肺炎的消息，回家在虹桥火车站上看到都是戴着口罩的人，从刚开始的不以为意到后来的惊恐不已。</p>\n<p>一整个春节都呆在家，看着电视追踪前线医疗士兵的消息，无话可说，唯有致敬！</p>\n<p>2020 年的第一个月就这么坎坷，这到底是天灾呢还是人祸？</p>\n"},{"title":"旅行五月（2021）","date":"2021-05-31T12:10:55.000Z","_content":"\n> 其实也不应该叫旅行五月，不过心灵上的旅行也算旅行\n\n五一劳动节难得有五天的假期，天气又不错，便带着小邱踏上了旅途。\n\n说是旅途，其实也就是去了几个地方：家、山、水……\n\n浙江金华，金衢盆地，周边就是山多，有了山自然就有了水。于是便有了很多美景，有了很多避暑胜地。\n\n首先回家，在家呆了两天，在浦江虞宅附近的一个小景点逛了一天，太阳底下还是有点晒的，黑了一圈。回家两天吃了不少肉，这得多谢姐夫，让姐夫破费了。之后我俩便去了杭州，主要逛了逛灵隐寺和西湖，时间确实也是有一点仓促，不过灵隐寺的建筑确实是令我颇为震撼。遗憾没有坐船游西湖，反正也近，以后有得是出游的时间。\n\n感谢小鹏在西湖边请了我们一顿火锅，夜间的西湖也是十分静，只有风声和浪声不时交织一起，拍打岸边的古建筑。西湖的夜景没有那么多的商业气息，多是小镇般的静谧。\n\n---\n\n可怜的小邱又是蛀牙又是智齿，去了几趟医院终于是把两颗蛀牙给补了，还有两颗智齿待拔。\n\n平日里的医院也是人山人海，每回去医院不管公立私立都是好多人，可见医疗在人们生活当中的重要性。\n\n什么都不比身体健康重要啊。\n\n---\n\n精神要健康，身体更要健康，适当放松给自己放个假未尝不可。","source":"_posts/tour-may.md","raw":"---\ntitle: 旅行五月（2021）\ndate: 2021-05-31 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 其实也不应该叫旅行五月，不过心灵上的旅行也算旅行\n\n五一劳动节难得有五天的假期，天气又不错，便带着小邱踏上了旅途。\n\n说是旅途，其实也就是去了几个地方：家、山、水……\n\n浙江金华，金衢盆地，周边就是山多，有了山自然就有了水。于是便有了很多美景，有了很多避暑胜地。\n\n首先回家，在家呆了两天，在浦江虞宅附近的一个小景点逛了一天，太阳底下还是有点晒的，黑了一圈。回家两天吃了不少肉，这得多谢姐夫，让姐夫破费了。之后我俩便去了杭州，主要逛了逛灵隐寺和西湖，时间确实也是有一点仓促，不过灵隐寺的建筑确实是令我颇为震撼。遗憾没有坐船游西湖，反正也近，以后有得是出游的时间。\n\n感谢小鹏在西湖边请了我们一顿火锅，夜间的西湖也是十分静，只有风声和浪声不时交织一起，拍打岸边的古建筑。西湖的夜景没有那么多的商业气息，多是小镇般的静谧。\n\n---\n\n可怜的小邱又是蛀牙又是智齿，去了几趟医院终于是把两颗蛀牙给补了，还有两颗智齿待拔。\n\n平日里的医院也是人山人海，每回去医院不管公立私立都是好多人，可见医疗在人们生活当中的重要性。\n\n什么都不比身体健康重要啊。\n\n---\n\n精神要健康，身体更要健康，适当放松给自己放个假未尝不可。","slug":"tour-may","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjht00ctk9i13wds7hk5","content":"<blockquote>\n<p>其实也不应该叫旅行五月，不过心灵上的旅行也算旅行</p>\n</blockquote>\n<p>五一劳动节难得有五天的假期，天气又不错，便带着小邱踏上了旅途。</p>\n<p>说是旅途，其实也就是去了几个地方：家、山、水……</p>\n<p>浙江金华，金衢盆地，周边就是山多，有了山自然就有了水。于是便有了很多美景，有了很多避暑胜地。</p>\n<p>首先回家，在家呆了两天，在浦江虞宅附近的一个小景点逛了一天，太阳底下还是有点晒的，黑了一圈。回家两天吃了不少肉，这得多谢姐夫，让姐夫破费了。之后我俩便去了杭州，主要逛了逛灵隐寺和西湖，时间确实也是有一点仓促，不过灵隐寺的建筑确实是令我颇为震撼。遗憾没有坐船游西湖，反正也近，以后有得是出游的时间。</p>\n<p>感谢小鹏在西湖边请了我们一顿火锅，夜间的西湖也是十分静，只有风声和浪声不时交织一起，拍打岸边的古建筑。西湖的夜景没有那么多的商业气息，多是小镇般的静谧。</p>\n<hr>\n<p>可怜的小邱又是蛀牙又是智齿，去了几趟医院终于是把两颗蛀牙给补了，还有两颗智齿待拔。</p>\n<p>平日里的医院也是人山人海，每回去医院不管公立私立都是好多人，可见医疗在人们生活当中的重要性。</p>\n<p>什么都不比身体健康重要啊。</p>\n<hr>\n<p>精神要健康，身体更要健康，适当放松给自己放个假未尝不可。</p>\n","excerpt":"","more":"<blockquote>\n<p>其实也不应该叫旅行五月，不过心灵上的旅行也算旅行</p>\n</blockquote>\n<p>五一劳动节难得有五天的假期，天气又不错，便带着小邱踏上了旅途。</p>\n<p>说是旅途，其实也就是去了几个地方：家、山、水……</p>\n<p>浙江金华，金衢盆地，周边就是山多，有了山自然就有了水。于是便有了很多美景，有了很多避暑胜地。</p>\n<p>首先回家，在家呆了两天，在浦江虞宅附近的一个小景点逛了一天，太阳底下还是有点晒的，黑了一圈。回家两天吃了不少肉，这得多谢姐夫，让姐夫破费了。之后我俩便去了杭州，主要逛了逛灵隐寺和西湖，时间确实也是有一点仓促，不过灵隐寺的建筑确实是令我颇为震撼。遗憾没有坐船游西湖，反正也近，以后有得是出游的时间。</p>\n<p>感谢小鹏在西湖边请了我们一顿火锅，夜间的西湖也是十分静，只有风声和浪声不时交织一起，拍打岸边的古建筑。西湖的夜景没有那么多的商业气息，多是小镇般的静谧。</p>\n<hr>\n<p>可怜的小邱又是蛀牙又是智齿，去了几趟医院终于是把两颗蛀牙给补了，还有两颗智齿待拔。</p>\n<p>平日里的医院也是人山人海，每回去医院不管公立私立都是好多人，可见医疗在人们生活当中的重要性。</p>\n<p>什么都不比身体健康重要啊。</p>\n<hr>\n<p>精神要健康，身体更要健康，适当放松给自己放个假未尝不可。</p>\n"},{"title":"试用期总结","date":"2018-06-25T10:24:30.000Z","_content":"三个月的试用时间一晃就要到了，我在2018年3月28日有幸来到了公司的系统集成部任职软件开发工程师这一岗位。入职当天同事们的热情我至今都没有忘记，当时我就感觉到了这个肯定是一个很有爱的大家庭，我的选择没有错。事实也证明确实如此。老师们十分和蔼，一点都没有架子，我有不理解的地方也会时常去问老师。在公司领导的关心和指导下，在同事们的热情帮助下，我较快熟悉了公司环境，适应了新的工作岗位，现将我试用期的工作情况作简要小结如下：\n- 严格遵守公司各项规章制度。做到了无迟到、早退、违规现象。\n- 主动学习、尽快适应，迅速熟悉环境，了解工作内容。主动、虚心向领导、同事们请教、学习，基本掌握了相关的工作内容，工作流程和工作方法。\n- 工作积极、认真、负责，通过不断学习、请教，定期自我总结，较好地完成了领导安排的各项工作任务。\n    + 在领导安排下将健康监测项目的源码进行了反编译，并成功运行部署在服务器上\n    + 帮助编写了同济大学土木实验室偏振仪的指令控制代码\n    + 对之前的健康监测项目进行了重构，使其变得精简，可读性大幅提升，并成功接入了倾角仪的数据监测服务\n\n- 虽然之前也是从事物联网相关，但在这短短试用期间深刻认识到自己的涉猎还不够广，之前的NodeJs也只是初步接触，所以希望自己能在这方面加强一些。尤其是当看到身边的许多研究生同学时，在学历上的不足就更需要用不断的学习来弥补了。\n- 存在的问题及解决方法：\n    + 我自己可能是比较慢热的人，所以外表看上去感觉好像不太好相处，会让别人感觉很冷漠。其实只要稍稍了解点就不会这么认为了。也可能我在外面的工位上，再加之大家岗位都比较忙，使得同事间的交流就没有那么多了。这还是需要时间的累积吧。\n    + 由于我是计算机专业，所以对于建筑这方面缺少了解，一些专业名词更是之前都没听过。后来在老师的指导下，我自己也上网买了相关的书籍。毕竟经常会跟建筑打交道，所以决定在这方面也要下点心思学习学习。\n\n- 总之，在短短的三个月时间里我接触到了之前未曾接触过的技术，也更加磨炼了自己的构思能力。之后我将进一步严格要求自己，克服不足，加强学习，认真地完成好每一项工作。","source":"_posts/trial-period-summary.md","raw":"---\ntitle: 试用期总结\ndate: 2018-6-25 18:24:30\ncategories: [开发,总结]\ntags: [Java,js]\n---\n三个月的试用时间一晃就要到了，我在2018年3月28日有幸来到了公司的系统集成部任职软件开发工程师这一岗位。入职当天同事们的热情我至今都没有忘记，当时我就感觉到了这个肯定是一个很有爱的大家庭，我的选择没有错。事实也证明确实如此。老师们十分和蔼，一点都没有架子，我有不理解的地方也会时常去问老师。在公司领导的关心和指导下，在同事们的热情帮助下，我较快熟悉了公司环境，适应了新的工作岗位，现将我试用期的工作情况作简要小结如下：\n- 严格遵守公司各项规章制度。做到了无迟到、早退、违规现象。\n- 主动学习、尽快适应，迅速熟悉环境，了解工作内容。主动、虚心向领导、同事们请教、学习，基本掌握了相关的工作内容，工作流程和工作方法。\n- 工作积极、认真、负责，通过不断学习、请教，定期自我总结，较好地完成了领导安排的各项工作任务。\n    + 在领导安排下将健康监测项目的源码进行了反编译，并成功运行部署在服务器上\n    + 帮助编写了同济大学土木实验室偏振仪的指令控制代码\n    + 对之前的健康监测项目进行了重构，使其变得精简，可读性大幅提升，并成功接入了倾角仪的数据监测服务\n\n- 虽然之前也是从事物联网相关，但在这短短试用期间深刻认识到自己的涉猎还不够广，之前的NodeJs也只是初步接触，所以希望自己能在这方面加强一些。尤其是当看到身边的许多研究生同学时，在学历上的不足就更需要用不断的学习来弥补了。\n- 存在的问题及解决方法：\n    + 我自己可能是比较慢热的人，所以外表看上去感觉好像不太好相处，会让别人感觉很冷漠。其实只要稍稍了解点就不会这么认为了。也可能我在外面的工位上，再加之大家岗位都比较忙，使得同事间的交流就没有那么多了。这还是需要时间的累积吧。\n    + 由于我是计算机专业，所以对于建筑这方面缺少了解，一些专业名词更是之前都没听过。后来在老师的指导下，我自己也上网买了相关的书籍。毕竟经常会跟建筑打交道，所以决定在这方面也要下点心思学习学习。\n\n- 总之，在短短的三个月时间里我接触到了之前未曾接触过的技术，也更加磨炼了自己的构思能力。之后我将进一步严格要求自己，克服不足，加强学习，认真地完成好每一项工作。","slug":"trial-period-summary","published":1,"updated":"2023-12-23T15:35:23.831Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjht00cwk9i19t7d7i30","content":"<p>三个月的试用时间一晃就要到了，我在2018年3月28日有幸来到了公司的系统集成部任职软件开发工程师这一岗位。入职当天同事们的热情我至今都没有忘记，当时我就感觉到了这个肯定是一个很有爱的大家庭，我的选择没有错。事实也证明确实如此。老师们十分和蔼，一点都没有架子，我有不理解的地方也会时常去问老师。在公司领导的关心和指导下，在同事们的热情帮助下，我较快熟悉了公司环境，适应了新的工作岗位，现将我试用期的工作情况作简要小结如下：</p>\n<ul>\n<li><p>严格遵守公司各项规章制度。做到了无迟到、早退、违规现象。</p>\n</li>\n<li><p>主动学习、尽快适应，迅速熟悉环境，了解工作内容。主动、虚心向领导、同事们请教、学习，基本掌握了相关的工作内容，工作流程和工作方法。</p>\n</li>\n<li><p>工作积极、认真、负责，通过不断学习、请教，定期自我总结，较好地完成了领导安排的各项工作任务。</p>\n<ul>\n<li>在领导安排下将健康监测项目的源码进行了反编译，并成功运行部署在服务器上</li>\n<li>帮助编写了同济大学土木实验室偏振仪的指令控制代码</li>\n<li>对之前的健康监测项目进行了重构，使其变得精简，可读性大幅提升，并成功接入了倾角仪的数据监测服务</li>\n</ul>\n</li>\n<li><p>虽然之前也是从事物联网相关，但在这短短试用期间深刻认识到自己的涉猎还不够广，之前的NodeJs也只是初步接触，所以希望自己能在这方面加强一些。尤其是当看到身边的许多研究生同学时，在学历上的不足就更需要用不断的学习来弥补了。</p>\n</li>\n<li><p>存在的问题及解决方法：</p>\n<ul>\n<li>我自己可能是比较慢热的人，所以外表看上去感觉好像不太好相处，会让别人感觉很冷漠。其实只要稍稍了解点就不会这么认为了。也可能我在外面的工位上，再加之大家岗位都比较忙，使得同事间的交流就没有那么多了。这还是需要时间的累积吧。</li>\n<li>由于我是计算机专业，所以对于建筑这方面缺少了解，一些专业名词更是之前都没听过。后来在老师的指导下，我自己也上网买了相关的书籍。毕竟经常会跟建筑打交道，所以决定在这方面也要下点心思学习学习。</li>\n</ul>\n</li>\n<li><p>总之，在短短的三个月时间里我接触到了之前未曾接触过的技术，也更加磨炼了自己的构思能力。之后我将进一步严格要求自己，克服不足，加强学习，认真地完成好每一项工作。</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>三个月的试用时间一晃就要到了，我在2018年3月28日有幸来到了公司的系统集成部任职软件开发工程师这一岗位。入职当天同事们的热情我至今都没有忘记，当时我就感觉到了这个肯定是一个很有爱的大家庭，我的选择没有错。事实也证明确实如此。老师们十分和蔼，一点都没有架子，我有不理解的地方也会时常去问老师。在公司领导的关心和指导下，在同事们的热情帮助下，我较快熟悉了公司环境，适应了新的工作岗位，现将我试用期的工作情况作简要小结如下：</p>\n<ul>\n<li><p>严格遵守公司各项规章制度。做到了无迟到、早退、违规现象。</p>\n</li>\n<li><p>主动学习、尽快适应，迅速熟悉环境，了解工作内容。主动、虚心向领导、同事们请教、学习，基本掌握了相关的工作内容，工作流程和工作方法。</p>\n</li>\n<li><p>工作积极、认真、负责，通过不断学习、请教，定期自我总结，较好地完成了领导安排的各项工作任务。</p>\n<ul>\n<li>在领导安排下将健康监测项目的源码进行了反编译，并成功运行部署在服务器上</li>\n<li>帮助编写了同济大学土木实验室偏振仪的指令控制代码</li>\n<li>对之前的健康监测项目进行了重构，使其变得精简，可读性大幅提升，并成功接入了倾角仪的数据监测服务</li>\n</ul>\n</li>\n<li><p>虽然之前也是从事物联网相关，但在这短短试用期间深刻认识到自己的涉猎还不够广，之前的NodeJs也只是初步接触，所以希望自己能在这方面加强一些。尤其是当看到身边的许多研究生同学时，在学历上的不足就更需要用不断的学习来弥补了。</p>\n</li>\n<li><p>存在的问题及解决方法：</p>\n<ul>\n<li>我自己可能是比较慢热的人，所以外表看上去感觉好像不太好相处，会让别人感觉很冷漠。其实只要稍稍了解点就不会这么认为了。也可能我在外面的工位上，再加之大家岗位都比较忙，使得同事间的交流就没有那么多了。这还是需要时间的累积吧。</li>\n<li>由于我是计算机专业，所以对于建筑这方面缺少了解，一些专业名词更是之前都没听过。后来在老师的指导下，我自己也上网买了相关的书籍。毕竟经常会跟建筑打交道，所以决定在这方面也要下点心思学习学习。</li>\n</ul>\n</li>\n<li><p>总之，在短短的三个月时间里我接触到了之前未曾接触过的技术，也更加磨炼了自己的构思能力。之后我将进一步严格要求自己，克服不足，加强学习，认真地完成好每一项工作。</p>\n</li>\n</ul>\n"},{"title":"震荡七月（2021）","date":"2021-07-30T12:10:55.000Z","_content":"\n> 这个月发生了不少事\n\n[7·20 郑州特大暴雨](https://baike.baidu.com/item/7%C2%B720%E9%83%91%E5%B7%9E%E7%89%B9%E5%A4%A7%E6%9A%B4%E9%9B%A8/58047836?fromtitle=%E9%83%91%E5%B7%9E%E6%9A%B4%E9%9B%A8&fromid=58050415&fr=aladdin)，2021 年 7 月 18 日 18时 至 21 日 0 时，郑州出现罕见持续强降水天气过程，全市普降大暴雨、特大暴雨，累积平均降水量 449 毫米。可怕的暴雨，极罕见的降雨量导致了几十人遇难，天灾。\n\n[住房教育大整顿](https://www.163.com/dy/article/GG5RRFEL0535A6UZ.html)，政策影响还是相当大的，俗话说得好，做什么也不能跟 zf 对着来。一个政策下来，刷刷地，变化快得令人瞋目结舌。就我目前所在的在线教育行业公司，最近政策下来，相关业务马上就停了，大裁员是少不了。有一些大型教育行业公司已经开始出手，听说裁员的裁员，关门的关门，裁员都是 70% 往上。**当潮水褪去后，才知道哪些是在裸泳。**\n\n[中概股的黄昏?](https://www.163.com/dy/article/GG6BPKJ40531LTUZ.html)中概股最近跌得是有点惨。引爆老美的股市没搞成，把自己炸了个半死……科技确实能给人带来便捷与生活质量的大幅提升。试想要是没有滴滴哈啰这类出行科技公司的出现，现在外面会是怎样？要是没有饿了么美团这类外卖科技公司的出现，现在生活会是怎样？要是没有腾讯阿里这些科技巨头，现在市场是不还是乱如一锅粥？当然没有这些种种科技公司的出现，人们还是照样活。不过当这些出现在我们的日常生活中以后，渐渐得发现我们已经很难再去脱离他们了。我还是坚信科技的力量，只不过要保持一份冷静。\n\n[新冠又来了](https://www.thepaper.cn/newsDetail_forward_13821030)，这次据说变异了，传播更快了，短短几天范围就扩散到了几十个省份，太可怕了。现在管控又严格起来，都不能私自离沪了。\n\n[东京奥运会](https://36kr.com/p/1333147773704454)也开始了，也是由于疫情原因推迟了一年，没想到今年疫情还是没有结束。奥运会的吐槽，裁判惊人的眼力。另外，南京要感谢东奥。\n\n写在最后，今年确实是比较难的一年，也许去年说的那句话并不虚。最差的一年，也是未来最好的一年……\n\n共勉。","source":"_posts/turbulent-july.md","raw":"---\ntitle: 震荡七月（2021）\ndate: 2021-07-30 20:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个月发生了不少事\n\n[7·20 郑州特大暴雨](https://baike.baidu.com/item/7%C2%B720%E9%83%91%E5%B7%9E%E7%89%B9%E5%A4%A7%E6%9A%B4%E9%9B%A8/58047836?fromtitle=%E9%83%91%E5%B7%9E%E6%9A%B4%E9%9B%A8&fromid=58050415&fr=aladdin)，2021 年 7 月 18 日 18时 至 21 日 0 时，郑州出现罕见持续强降水天气过程，全市普降大暴雨、特大暴雨，累积平均降水量 449 毫米。可怕的暴雨，极罕见的降雨量导致了几十人遇难，天灾。\n\n[住房教育大整顿](https://www.163.com/dy/article/GG5RRFEL0535A6UZ.html)，政策影响还是相当大的，俗话说得好，做什么也不能跟 zf 对着来。一个政策下来，刷刷地，变化快得令人瞋目结舌。就我目前所在的在线教育行业公司，最近政策下来，相关业务马上就停了，大裁员是少不了。有一些大型教育行业公司已经开始出手，听说裁员的裁员，关门的关门，裁员都是 70% 往上。**当潮水褪去后，才知道哪些是在裸泳。**\n\n[中概股的黄昏?](https://www.163.com/dy/article/GG6BPKJ40531LTUZ.html)中概股最近跌得是有点惨。引爆老美的股市没搞成，把自己炸了个半死……科技确实能给人带来便捷与生活质量的大幅提升。试想要是没有滴滴哈啰这类出行科技公司的出现，现在外面会是怎样？要是没有饿了么美团这类外卖科技公司的出现，现在生活会是怎样？要是没有腾讯阿里这些科技巨头，现在市场是不还是乱如一锅粥？当然没有这些种种科技公司的出现，人们还是照样活。不过当这些出现在我们的日常生活中以后，渐渐得发现我们已经很难再去脱离他们了。我还是坚信科技的力量，只不过要保持一份冷静。\n\n[新冠又来了](https://www.thepaper.cn/newsDetail_forward_13821030)，这次据说变异了，传播更快了，短短几天范围就扩散到了几十个省份，太可怕了。现在管控又严格起来，都不能私自离沪了。\n\n[东京奥运会](https://36kr.com/p/1333147773704454)也开始了，也是由于疫情原因推迟了一年，没想到今年疫情还是没有结束。奥运会的吐槽，裁判惊人的眼力。另外，南京要感谢东奥。\n\n写在最后，今年确实是比较难的一年，也许去年说的那句话并不虚。最差的一年，也是未来最好的一年……\n\n共勉。","slug":"turbulent-july","published":1,"updated":"2023-12-23T15:35:23.825Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjht00d1k9i14l2ieu5o","content":"<blockquote>\n<p>这个月发生了不少事</p>\n</blockquote>\n<p><a href=\"https://baike.baidu.com/item/7%C2%B720%E9%83%91%E5%B7%9E%E7%89%B9%E5%A4%A7%E6%9A%B4%E9%9B%A8/58047836?fromtitle=%E9%83%91%E5%B7%9E%E6%9A%B4%E9%9B%A8&fromid=58050415&fr=aladdin\">7·20 郑州特大暴雨</a>，2021 年 7 月 18 日 18时 至 21 日 0 时，郑州出现罕见持续强降水天气过程，全市普降大暴雨、特大暴雨，累积平均降水量 449 毫米。可怕的暴雨，极罕见的降雨量导致了几十人遇难，天灾。</p>\n<p><a href=\"https://www.163.com/dy/article/GG5RRFEL0535A6UZ.html\">住房教育大整顿</a>，政策影响还是相当大的，俗话说得好，做什么也不能跟 zf 对着来。一个政策下来，刷刷地，变化快得令人瞋目结舌。就我目前所在的在线教育行业公司，最近政策下来，相关业务马上就停了，大裁员是少不了。有一些大型教育行业公司已经开始出手，听说裁员的裁员，关门的关门，裁员都是 70% 往上。<strong>当潮水褪去后，才知道哪些是在裸泳。</strong></p>\n<p><a href=\"https://www.163.com/dy/article/GG6BPKJ40531LTUZ.html\">中概股的黄昏?</a>中概股最近跌得是有点惨。引爆老美的股市没搞成，把自己炸了个半死……科技确实能给人带来便捷与生活质量的大幅提升。试想要是没有滴滴哈啰这类出行科技公司的出现，现在外面会是怎样？要是没有饿了么美团这类外卖科技公司的出现，现在生活会是怎样？要是没有腾讯阿里这些科技巨头，现在市场是不还是乱如一锅粥？当然没有这些种种科技公司的出现，人们还是照样活。不过当这些出现在我们的日常生活中以后，渐渐得发现我们已经很难再去脱离他们了。我还是坚信科技的力量，只不过要保持一份冷静。</p>\n<p><a href=\"https://www.thepaper.cn/newsDetail_forward_13821030\">新冠又来了</a>，这次据说变异了，传播更快了，短短几天范围就扩散到了几十个省份，太可怕了。现在管控又严格起来，都不能私自离沪了。</p>\n<p><a href=\"https://36kr.com/p/1333147773704454\">东京奥运会</a>也开始了，也是由于疫情原因推迟了一年，没想到今年疫情还是没有结束。奥运会的吐槽，裁判惊人的眼力。另外，南京要感谢东奥。</p>\n<p>写在最后，今年确实是比较难的一年，也许去年说的那句话并不虚。最差的一年，也是未来最好的一年……</p>\n<p>共勉。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个月发生了不少事</p>\n</blockquote>\n<p><a href=\"https://baike.baidu.com/item/7%C2%B720%E9%83%91%E5%B7%9E%E7%89%B9%E5%A4%A7%E6%9A%B4%E9%9B%A8/58047836?fromtitle=%E9%83%91%E5%B7%9E%E6%9A%B4%E9%9B%A8&fromid=58050415&fr=aladdin\">7·20 郑州特大暴雨</a>，2021 年 7 月 18 日 18时 至 21 日 0 时，郑州出现罕见持续强降水天气过程，全市普降大暴雨、特大暴雨，累积平均降水量 449 毫米。可怕的暴雨，极罕见的降雨量导致了几十人遇难，天灾。</p>\n<p><a href=\"https://www.163.com/dy/article/GG5RRFEL0535A6UZ.html\">住房教育大整顿</a>，政策影响还是相当大的，俗话说得好，做什么也不能跟 zf 对着来。一个政策下来，刷刷地，变化快得令人瞋目结舌。就我目前所在的在线教育行业公司，最近政策下来，相关业务马上就停了，大裁员是少不了。有一些大型教育行业公司已经开始出手，听说裁员的裁员，关门的关门，裁员都是 70% 往上。<strong>当潮水褪去后，才知道哪些是在裸泳。</strong></p>\n<p><a href=\"https://www.163.com/dy/article/GG6BPKJ40531LTUZ.html\">中概股的黄昏?</a>中概股最近跌得是有点惨。引爆老美的股市没搞成，把自己炸了个半死……科技确实能给人带来便捷与生活质量的大幅提升。试想要是没有滴滴哈啰这类出行科技公司的出现，现在外面会是怎样？要是没有饿了么美团这类外卖科技公司的出现，现在生活会是怎样？要是没有腾讯阿里这些科技巨头，现在市场是不还是乱如一锅粥？当然没有这些种种科技公司的出现，人们还是照样活。不过当这些出现在我们的日常生活中以后，渐渐得发现我们已经很难再去脱离他们了。我还是坚信科技的力量，只不过要保持一份冷静。</p>\n<p><a href=\"https://www.thepaper.cn/newsDetail_forward_13821030\">新冠又来了</a>，这次据说变异了，传播更快了，短短几天范围就扩散到了几十个省份，太可怕了。现在管控又严格起来，都不能私自离沪了。</p>\n<p><a href=\"https://36kr.com/p/1333147773704454\">东京奥运会</a>也开始了，也是由于疫情原因推迟了一年，没想到今年疫情还是没有结束。奥运会的吐槽，裁判惊人的眼力。另外，南京要感谢东奥。</p>\n<p>写在最后，今年确实是比较难的一年，也许去年说的那句话并不虚。最差的一年，也是未来最好的一年……</p>\n<p>共勉。</p>\n"},{"title":"动荡十一月（2023）","date":"2023-12-01T03:42:55.000Z","_content":"\n> 这个月真是起起伏伏，事情颇多。\n\n## 锡山宛马\n\n时隔两年的锡山宛马终于跑上了！这是我第一次跑全马，虽然只是在关门兔前一点到达，但好歹也是完赛了啊！42.195 公里，算是我跑的距离最长的一次了，跑完后大腿酸疼走路只能撅屁股迈小步，过了两三天才算是恢复了回来。\n\n跑步当天天气算不得很好，早上起来下着小雨又遇降温，风吹打脸上那种湿冷令得人不禁打起了寒颤。不知是人多火气旺还是赛道选得好，当大家聚集在跑道上时体感好像都变得不那么冷了，活动脚腕开始跑前热身准备享受跑步的自由。\n\n一路上的补给还是比较充足的，快到最后了也还是有香蕉、黄瓜、葡萄干、饮料这些，但是牛肉等我到的时候也确实是没了……\n\n虽然成绩不怎么样，但是能正常完赛我还是比较满意的了，加强锻炼，每次努力提升一点！\n\n## 裁员\n\n果然不出意外，做的产品线没有新业务需求了，公司降本增效，全力投入到工厂 SAAS，就这样我也就“毕业”了！不过也拿到了赔偿，虽然少了几千块，现在这个大环境也可以理解吧。\n\n“毕业”之后就是整简历啊，投简历啊，可能是年底的缘故再加上如今的市场环境，简历一开始几乎是石沉大海。好在过了几天后慢慢有了面试，到后面也顺利拿到了 offer（还是降薪的，这节骨眼压薪资厉害！）。虽然公司规模不大，但与老板交流下来公司的发展还是蛮不错的，资金流也很稳定，业务也是发展了好多年了，还是值得期待一起成长的。\n\n有件事不吐不快，建设银行办理业务慢就不说了，办张卡还是二类卡，各种限额，提额还得另外提供材料去走审批，我自己卡里的钱我还不能自己自由使用了？\n\n## 大厂还是小厂\n\n说到这我有一个问题，大厂（知名大企业）到底值不值得进，并且值不值得为了刷简历而选择大厂？\n\n首先，有一说一，前期几年工作能选择大厂我还是会愿意进大厂，即使工资并不让我满意。大厂里更多的是规范，当你初入社会做事还没有既定的章法的时候，这些规范会影响到你之后的职业习惯，往往利大于弊。其次，进入大厂还是有一定的门槛，而跟优秀的人共事不仅做事效率高而且感觉会很舒服（当然肯定也有个别那种），重要的是潜移默化，慢慢学习别人的优点、好习惯。\n\n同样大厂由于规范比较全比较细，往往一个人只会负责某个领域，所以就有了所谓的“螺丝钉”。这时候可能自己不去主动汲取，长时间就会变得不那么全面甚至变得只会单项技能（因为一旦业务熟悉了，便就会停滞，温水煮青蛙）。所以要么一直钻研单项变成技术专家，要么就是一直大头兵慢慢没有那么有竞争力。\n\n不过大厂光环还是真蛮有用的，至少一看履历上有过大厂经验就会默认这个人有两把刷子，便会有更多的机会。\n\n其实现在的互联网环境对大厂的压力是很大的，就稳定性来说可能还真不如一些小公司，而这些大厂经历也会变得像一种负担（预期高了，现实可能就很骨感）。想要综合提升自己的能力，而不甘于一味只是追求技术（有一句话说道：技术是最不值钱的），那就应该在自己做事有所章法之后去寻找那种能多方面提升的环境，历练实战成长最快。\n\n当互联网红利慢慢消失，脚步慢下来，大家都是一样的。","source":"_posts/turbulent-november.md","raw":"---\ntitle: 动荡十一月（2023）\ndate: 2023-12-01 11:42:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个月真是起起伏伏，事情颇多。\n\n## 锡山宛马\n\n时隔两年的锡山宛马终于跑上了！这是我第一次跑全马，虽然只是在关门兔前一点到达，但好歹也是完赛了啊！42.195 公里，算是我跑的距离最长的一次了，跑完后大腿酸疼走路只能撅屁股迈小步，过了两三天才算是恢复了回来。\n\n跑步当天天气算不得很好，早上起来下着小雨又遇降温，风吹打脸上那种湿冷令得人不禁打起了寒颤。不知是人多火气旺还是赛道选得好，当大家聚集在跑道上时体感好像都变得不那么冷了，活动脚腕开始跑前热身准备享受跑步的自由。\n\n一路上的补给还是比较充足的，快到最后了也还是有香蕉、黄瓜、葡萄干、饮料这些，但是牛肉等我到的时候也确实是没了……\n\n虽然成绩不怎么样，但是能正常完赛我还是比较满意的了，加强锻炼，每次努力提升一点！\n\n## 裁员\n\n果然不出意外，做的产品线没有新业务需求了，公司降本增效，全力投入到工厂 SAAS，就这样我也就“毕业”了！不过也拿到了赔偿，虽然少了几千块，现在这个大环境也可以理解吧。\n\n“毕业”之后就是整简历啊，投简历啊，可能是年底的缘故再加上如今的市场环境，简历一开始几乎是石沉大海。好在过了几天后慢慢有了面试，到后面也顺利拿到了 offer（还是降薪的，这节骨眼压薪资厉害！）。虽然公司规模不大，但与老板交流下来公司的发展还是蛮不错的，资金流也很稳定，业务也是发展了好多年了，还是值得期待一起成长的。\n\n有件事不吐不快，建设银行办理业务慢就不说了，办张卡还是二类卡，各种限额，提额还得另外提供材料去走审批，我自己卡里的钱我还不能自己自由使用了？\n\n## 大厂还是小厂\n\n说到这我有一个问题，大厂（知名大企业）到底值不值得进，并且值不值得为了刷简历而选择大厂？\n\n首先，有一说一，前期几年工作能选择大厂我还是会愿意进大厂，即使工资并不让我满意。大厂里更多的是规范，当你初入社会做事还没有既定的章法的时候，这些规范会影响到你之后的职业习惯，往往利大于弊。其次，进入大厂还是有一定的门槛，而跟优秀的人共事不仅做事效率高而且感觉会很舒服（当然肯定也有个别那种），重要的是潜移默化，慢慢学习别人的优点、好习惯。\n\n同样大厂由于规范比较全比较细，往往一个人只会负责某个领域，所以就有了所谓的“螺丝钉”。这时候可能自己不去主动汲取，长时间就会变得不那么全面甚至变得只会单项技能（因为一旦业务熟悉了，便就会停滞，温水煮青蛙）。所以要么一直钻研单项变成技术专家，要么就是一直大头兵慢慢没有那么有竞争力。\n\n不过大厂光环还是真蛮有用的，至少一看履历上有过大厂经验就会默认这个人有两把刷子，便会有更多的机会。\n\n其实现在的互联网环境对大厂的压力是很大的，就稳定性来说可能还真不如一些小公司，而这些大厂经历也会变得像一种负担（预期高了，现实可能就很骨感）。想要综合提升自己的能力，而不甘于一味只是追求技术（有一句话说道：技术是最不值钱的），那就应该在自己做事有所章法之后去寻找那种能多方面提升的环境，历练实战成长最快。\n\n当互联网红利慢慢消失，脚步慢下来，大家都是一样的。","slug":"turbulent-november","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjht00d4k9i18aor0l2s","content":"<blockquote>\n<p>这个月真是起起伏伏，事情颇多。</p>\n</blockquote>\n<h2 id=\"锡山宛马\"><a href=\"#锡山宛马\" class=\"headerlink\" title=\"锡山宛马\"></a>锡山宛马</h2><p>时隔两年的锡山宛马终于跑上了！这是我第一次跑全马，虽然只是在关门兔前一点到达，但好歹也是完赛了啊！42.195 公里，算是我跑的距离最长的一次了，跑完后大腿酸疼走路只能撅屁股迈小步，过了两三天才算是恢复了回来。</p>\n<p>跑步当天天气算不得很好，早上起来下着小雨又遇降温，风吹打脸上那种湿冷令得人不禁打起了寒颤。不知是人多火气旺还是赛道选得好，当大家聚集在跑道上时体感好像都变得不那么冷了，活动脚腕开始跑前热身准备享受跑步的自由。</p>\n<p>一路上的补给还是比较充足的，快到最后了也还是有香蕉、黄瓜、葡萄干、饮料这些，但是牛肉等我到的时候也确实是没了……</p>\n<p>虽然成绩不怎么样，但是能正常完赛我还是比较满意的了，加强锻炼，每次努力提升一点！</p>\n<h2 id=\"裁员\"><a href=\"#裁员\" class=\"headerlink\" title=\"裁员\"></a>裁员</h2><p>果然不出意外，做的产品线没有新业务需求了，公司降本增效，全力投入到工厂 SAAS，就这样我也就“毕业”了！不过也拿到了赔偿，虽然少了几千块，现在这个大环境也可以理解吧。</p>\n<p>“毕业”之后就是整简历啊，投简历啊，可能是年底的缘故再加上如今的市场环境，简历一开始几乎是石沉大海。好在过了几天后慢慢有了面试，到后面也顺利拿到了 offer（还是降薪的，这节骨眼压薪资厉害！）。虽然公司规模不大，但与老板交流下来公司的发展还是蛮不错的，资金流也很稳定，业务也是发展了好多年了，还是值得期待一起成长的。</p>\n<p>有件事不吐不快，建设银行办理业务慢就不说了，办张卡还是二类卡，各种限额，提额还得另外提供材料去走审批，我自己卡里的钱我还不能自己自由使用了？</p>\n<h2 id=\"大厂还是小厂\"><a href=\"#大厂还是小厂\" class=\"headerlink\" title=\"大厂还是小厂\"></a>大厂还是小厂</h2><p>说到这我有一个问题，大厂（知名大企业）到底值不值得进，并且值不值得为了刷简历而选择大厂？</p>\n<p>首先，有一说一，前期几年工作能选择大厂我还是会愿意进大厂，即使工资并不让我满意。大厂里更多的是规范，当你初入社会做事还没有既定的章法的时候，这些规范会影响到你之后的职业习惯，往往利大于弊。其次，进入大厂还是有一定的门槛，而跟优秀的人共事不仅做事效率高而且感觉会很舒服（当然肯定也有个别那种），重要的是潜移默化，慢慢学习别人的优点、好习惯。</p>\n<p>同样大厂由于规范比较全比较细，往往一个人只会负责某个领域，所以就有了所谓的“螺丝钉”。这时候可能自己不去主动汲取，长时间就会变得不那么全面甚至变得只会单项技能（因为一旦业务熟悉了，便就会停滞，温水煮青蛙）。所以要么一直钻研单项变成技术专家，要么就是一直大头兵慢慢没有那么有竞争力。</p>\n<p>不过大厂光环还是真蛮有用的，至少一看履历上有过大厂经验就会默认这个人有两把刷子，便会有更多的机会。</p>\n<p>其实现在的互联网环境对大厂的压力是很大的，就稳定性来说可能还真不如一些小公司，而这些大厂经历也会变得像一种负担（预期高了，现实可能就很骨感）。想要综合提升自己的能力，而不甘于一味只是追求技术（有一句话说道：技术是最不值钱的），那就应该在自己做事有所章法之后去寻找那种能多方面提升的环境，历练实战成长最快。</p>\n<p>当互联网红利慢慢消失，脚步慢下来，大家都是一样的。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个月真是起起伏伏，事情颇多。</p>\n</blockquote>\n<h2 id=\"锡山宛马\"><a href=\"#锡山宛马\" class=\"headerlink\" title=\"锡山宛马\"></a>锡山宛马</h2><p>时隔两年的锡山宛马终于跑上了！这是我第一次跑全马，虽然只是在关门兔前一点到达，但好歹也是完赛了啊！42.195 公里，算是我跑的距离最长的一次了，跑完后大腿酸疼走路只能撅屁股迈小步，过了两三天才算是恢复了回来。</p>\n<p>跑步当天天气算不得很好，早上起来下着小雨又遇降温，风吹打脸上那种湿冷令得人不禁打起了寒颤。不知是人多火气旺还是赛道选得好，当大家聚集在跑道上时体感好像都变得不那么冷了，活动脚腕开始跑前热身准备享受跑步的自由。</p>\n<p>一路上的补给还是比较充足的，快到最后了也还是有香蕉、黄瓜、葡萄干、饮料这些，但是牛肉等我到的时候也确实是没了……</p>\n<p>虽然成绩不怎么样，但是能正常完赛我还是比较满意的了，加强锻炼，每次努力提升一点！</p>\n<h2 id=\"裁员\"><a href=\"#裁员\" class=\"headerlink\" title=\"裁员\"></a>裁员</h2><p>果然不出意外，做的产品线没有新业务需求了，公司降本增效，全力投入到工厂 SAAS，就这样我也就“毕业”了！不过也拿到了赔偿，虽然少了几千块，现在这个大环境也可以理解吧。</p>\n<p>“毕业”之后就是整简历啊，投简历啊，可能是年底的缘故再加上如今的市场环境，简历一开始几乎是石沉大海。好在过了几天后慢慢有了面试，到后面也顺利拿到了 offer（还是降薪的，这节骨眼压薪资厉害！）。虽然公司规模不大，但与老板交流下来公司的发展还是蛮不错的，资金流也很稳定，业务也是发展了好多年了，还是值得期待一起成长的。</p>\n<p>有件事不吐不快，建设银行办理业务慢就不说了，办张卡还是二类卡，各种限额，提额还得另外提供材料去走审批，我自己卡里的钱我还不能自己自由使用了？</p>\n<h2 id=\"大厂还是小厂\"><a href=\"#大厂还是小厂\" class=\"headerlink\" title=\"大厂还是小厂\"></a>大厂还是小厂</h2><p>说到这我有一个问题，大厂（知名大企业）到底值不值得进，并且值不值得为了刷简历而选择大厂？</p>\n<p>首先，有一说一，前期几年工作能选择大厂我还是会愿意进大厂，即使工资并不让我满意。大厂里更多的是规范，当你初入社会做事还没有既定的章法的时候，这些规范会影响到你之后的职业习惯，往往利大于弊。其次，进入大厂还是有一定的门槛，而跟优秀的人共事不仅做事效率高而且感觉会很舒服（当然肯定也有个别那种），重要的是潜移默化，慢慢学习别人的优点、好习惯。</p>\n<p>同样大厂由于规范比较全比较细，往往一个人只会负责某个领域，所以就有了所谓的“螺丝钉”。这时候可能自己不去主动汲取，长时间就会变得不那么全面甚至变得只会单项技能（因为一旦业务熟悉了，便就会停滞，温水煮青蛙）。所以要么一直钻研单项变成技术专家，要么就是一直大头兵慢慢没有那么有竞争力。</p>\n<p>不过大厂光环还是真蛮有用的，至少一看履历上有过大厂经验就会默认这个人有两把刷子，便会有更多的机会。</p>\n<p>其实现在的互联网环境对大厂的压力是很大的，就稳定性来说可能还真不如一些小公司，而这些大厂经历也会变得像一种负担（预期高了，现实可能就很骨感）。想要综合提升自己的能力，而不甘于一味只是追求技术（有一句话说道：技术是最不值钱的），那就应该在自己做事有所章法之后去寻找那种能多方面提升的环境，历练实战成长最快。</p>\n<p>当互联网红利慢慢消失，脚步慢下来，大家都是一样的。</p>\n"},{"title":"倏忽八月（2022）","date":"2022-08-30T13:10:55.000Z","_content":"\n\n\n这也过得太快了吧，这就八月份都过去了？\n\n八月也没干啥，就这样过了。\n\n其实现在已经九月二十二了。。","source":"_posts/tutu-august.md","raw":"---\ntitle: 倏忽八月（2022）\ndate: 2022-08-30 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n\n\n这也过得太快了吧，这就八月份都过去了？\n\n八月也没干啥，就这样过了。\n\n其实现在已经九月二十二了。。","slug":"tutu-august","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhu00d9k9i1afnb3alu","content":"<p>这也过得太快了吧，这就八月份都过去了？</p>\n<p>八月也没干啥，就这样过了。</p>\n<p>其实现在已经九月二十二了。。</p>\n","excerpt":"","more":"<p>这也过得太快了吧，这就八月份都过去了？</p>\n<p>八月也没干啥，就这样过了。</p>\n<p>其实现在已经九月二十二了。。</p>\n"},{"title":"温暖三月（2023）","date":"2023-04-01T13:10:55.000Z","_content":"\n> 这刚连续下了几天雨，终于迎来了温暖的好天气。\n\n春暖花开，经过连续几天的雨水冲刷，终于迎来了几天的好天气。\n各地桃花樱花盛开，朋友圈纷纷出现了春游打卡景象，正是一年春来到。\n\n由于种种原因，这次没去成苏州马拉松。今年怕是也没有机会了，养精蓄锐，明年再战！前段时间周末一直在各地跑，也终于搞定了一些事情，下个月也开始要拍婚纱照了，减肥减肥说了大半年了，体重还是在这水平上下浮动，难矣！事情一大堆，就在等着慢慢处理解决，希望随着时间一个个都迎刃而解，船到桥头自然直。\n\n刚说完问题，最近这就出现了问题。事情一多，问题也就越多。处理不好就很容易上升为矛盾，情绪再那么一差，总是闹得不可开交。生活，也确实，一路平坦的那就不叫生活。\n\n4.5算是我们周年纪念，今年刚好就是清明，好巧不巧。吃一顿日料自助满足下期待已久的味蕾。\n\n周末好天气，躺在阳台的椅子上晒太阳，躺在客厅的沙发上晒太阳，真是舒服啊！","source":"_posts/warm-march.md","raw":"---\ntitle: 温暖三月（2023）\ndate: 2023-04-01 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这刚连续下了几天雨，终于迎来了温暖的好天气。\n\n春暖花开，经过连续几天的雨水冲刷，终于迎来了几天的好天气。\n各地桃花樱花盛开，朋友圈纷纷出现了春游打卡景象，正是一年春来到。\n\n由于种种原因，这次没去成苏州马拉松。今年怕是也没有机会了，养精蓄锐，明年再战！前段时间周末一直在各地跑，也终于搞定了一些事情，下个月也开始要拍婚纱照了，减肥减肥说了大半年了，体重还是在这水平上下浮动，难矣！事情一大堆，就在等着慢慢处理解决，希望随着时间一个个都迎刃而解，船到桥头自然直。\n\n刚说完问题，最近这就出现了问题。事情一多，问题也就越多。处理不好就很容易上升为矛盾，情绪再那么一差，总是闹得不可开交。生活，也确实，一路平坦的那就不叫生活。\n\n4.5算是我们周年纪念，今年刚好就是清明，好巧不巧。吃一顿日料自助满足下期待已久的味蕾。\n\n周末好天气，躺在阳台的椅子上晒太阳，躺在客厅的沙发上晒太阳，真是舒服啊！","slug":"warm-march","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhu00dck9i19uu3184c","content":"<blockquote>\n<p>这刚连续下了几天雨，终于迎来了温暖的好天气。</p>\n</blockquote>\n<p>春暖花开，经过连续几天的雨水冲刷，终于迎来了几天的好天气。<br>各地桃花樱花盛开，朋友圈纷纷出现了春游打卡景象，正是一年春来到。</p>\n<p>由于种种原因，这次没去成苏州马拉松。今年怕是也没有机会了，养精蓄锐，明年再战！前段时间周末一直在各地跑，也终于搞定了一些事情，下个月也开始要拍婚纱照了，减肥减肥说了大半年了，体重还是在这水平上下浮动，难矣！事情一大堆，就在等着慢慢处理解决，希望随着时间一个个都迎刃而解，船到桥头自然直。</p>\n<p>刚说完问题，最近这就出现了问题。事情一多，问题也就越多。处理不好就很容易上升为矛盾，情绪再那么一差，总是闹得不可开交。生活，也确实，一路平坦的那就不叫生活。</p>\n<p>4.5算是我们周年纪念，今年刚好就是清明，好巧不巧。吃一顿日料自助满足下期待已久的味蕾。</p>\n<p>周末好天气，躺在阳台的椅子上晒太阳，躺在客厅的沙发上晒太阳，真是舒服啊！</p>\n","excerpt":"","more":"<blockquote>\n<p>这刚连续下了几天雨，终于迎来了温暖的好天气。</p>\n</blockquote>\n<p>春暖花开，经过连续几天的雨水冲刷，终于迎来了几天的好天气。<br>各地桃花樱花盛开，朋友圈纷纷出现了春游打卡景象，正是一年春来到。</p>\n<p>由于种种原因，这次没去成苏州马拉松。今年怕是也没有机会了，养精蓄锐，明年再战！前段时间周末一直在各地跑，也终于搞定了一些事情，下个月也开始要拍婚纱照了，减肥减肥说了大半年了，体重还是在这水平上下浮动，难矣！事情一大堆，就在等着慢慢处理解决，希望随着时间一个个都迎刃而解，船到桥头自然直。</p>\n<p>刚说完问题，最近这就出现了问题。事情一多，问题也就越多。处理不好就很容易上升为矛盾，情绪再那么一差，总是闹得不可开交。生活，也确实，一路平坦的那就不叫生活。</p>\n<p>4.5算是我们周年纪念，今年刚好就是清明，好巧不巧。吃一顿日料自助满足下期待已久的味蕾。</p>\n<p>周末好天气，躺在阳台的椅子上晒太阳，躺在客厅的沙发上晒太阳，真是舒服啊！</p>\n"},{"title":"向往的最好","date":"2020-08-22T01:10:55.000Z","_content":"\n花开有黯时，花谢有艳时。\n\n不知赛上谁与同，无愧于心，尽其所能，耐力追逐，争为最上人。\n\n---\n\n邻居大爷望我脸，识我本命“福”字，拇哥翘起，赞赏：必为大富大贵之人。\n\n面带羞涩笑容，将必不负大爷所望。\n\n---\n\n我并非沙发，没有必要让每一个人舒服。\n\n各自的性格个性造就众多个体，臭味相投，属性相克。\n\n磁铁互斥强行捆绑，暂看浪静风平，一旦松懈，具损。\n\n磁性也许会随着时间减弱，也许终能等到紧挨的时候，\n\n磁石已不再是磁石，磁石变成了普通的石头。\n\n---\n\n无所谓所认为的对与不对，好与不好，正不正常，\n\n自己舒服，最好。\n\n---\n\n年少总是自命不凡，所以是年少。\n\n所有一切都是循环往复，在自然自己规律中稳步进行。\n\n就像所有大人教育自己的孩子，总是感到无可奈何，低头感叹：当年的自己不也一副模样。\n\n---\n\n人们总是喜欢给自己定目标。\n\n来，先给自己定一个小目标，挣它个 XXX\n\n定了目标后就会觉得这下有了方向，接下来的日子我就要朝着这个方向，先别管之后，我先完成这个小目标。\n\n目标既然有了，那就是怎么去实现了，这就是生活。\n\n所谓的目标，所谓的计划，所谓的生活。\n\n---\n\n心中并没有什么远大的理想与抱负。\n\n拥有一个和睦的家庭，幸福美满，即为最好。\n\n而这几个字，却没有个一致定义，各有各的理解与思考。\n\n那就稍微改下。\n\n理解彼此，信任彼此，温暖彼此，守护彼此。\n\n共同方向，共同规划，共同努力，共同生活。\n\n此上，我向往的“最好”。","source":"_posts/wonderful-life.md","raw":"---\ntitle: 向往的最好\ndate: 2020-08-22 09:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n花开有黯时，花谢有艳时。\n\n不知赛上谁与同，无愧于心，尽其所能，耐力追逐，争为最上人。\n\n---\n\n邻居大爷望我脸，识我本命“福”字，拇哥翘起，赞赏：必为大富大贵之人。\n\n面带羞涩笑容，将必不负大爷所望。\n\n---\n\n我并非沙发，没有必要让每一个人舒服。\n\n各自的性格个性造就众多个体，臭味相投，属性相克。\n\n磁铁互斥强行捆绑，暂看浪静风平，一旦松懈，具损。\n\n磁性也许会随着时间减弱，也许终能等到紧挨的时候，\n\n磁石已不再是磁石，磁石变成了普通的石头。\n\n---\n\n无所谓所认为的对与不对，好与不好，正不正常，\n\n自己舒服，最好。\n\n---\n\n年少总是自命不凡，所以是年少。\n\n所有一切都是循环往复，在自然自己规律中稳步进行。\n\n就像所有大人教育自己的孩子，总是感到无可奈何，低头感叹：当年的自己不也一副模样。\n\n---\n\n人们总是喜欢给自己定目标。\n\n来，先给自己定一个小目标，挣它个 XXX\n\n定了目标后就会觉得这下有了方向，接下来的日子我就要朝着这个方向，先别管之后，我先完成这个小目标。\n\n目标既然有了，那就是怎么去实现了，这就是生活。\n\n所谓的目标，所谓的计划，所谓的生活。\n\n---\n\n心中并没有什么远大的理想与抱负。\n\n拥有一个和睦的家庭，幸福美满，即为最好。\n\n而这几个字，却没有个一致定义，各有各的理解与思考。\n\n那就稍微改下。\n\n理解彼此，信任彼此，温暖彼此，守护彼此。\n\n共同方向，共同规划，共同努力，共同生活。\n\n此上，我向往的“最好”。","slug":"wonderful-life","published":1,"updated":"2023-12-23T15:35:23.824Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhu00dgk9i1eppq1uee","content":"<p>花开有黯时，花谢有艳时。</p>\n<p>不知赛上谁与同，无愧于心，尽其所能，耐力追逐，争为最上人。</p>\n<hr>\n<p>邻居大爷望我脸，识我本命“福”字，拇哥翘起，赞赏：必为大富大贵之人。</p>\n<p>面带羞涩笑容，将必不负大爷所望。</p>\n<hr>\n<p>我并非沙发，没有必要让每一个人舒服。</p>\n<p>各自的性格个性造就众多个体，臭味相投，属性相克。</p>\n<p>磁铁互斥强行捆绑，暂看浪静风平，一旦松懈，具损。</p>\n<p>磁性也许会随着时间减弱，也许终能等到紧挨的时候，</p>\n<p>磁石已不再是磁石，磁石变成了普通的石头。</p>\n<hr>\n<p>无所谓所认为的对与不对，好与不好，正不正常，</p>\n<p>自己舒服，最好。</p>\n<hr>\n<p>年少总是自命不凡，所以是年少。</p>\n<p>所有一切都是循环往复，在自然自己规律中稳步进行。</p>\n<p>就像所有大人教育自己的孩子，总是感到无可奈何，低头感叹：当年的自己不也一副模样。</p>\n<hr>\n<p>人们总是喜欢给自己定目标。</p>\n<p>来，先给自己定一个小目标，挣它个 XXX</p>\n<p>定了目标后就会觉得这下有了方向，接下来的日子我就要朝着这个方向，先别管之后，我先完成这个小目标。</p>\n<p>目标既然有了，那就是怎么去实现了，这就是生活。</p>\n<p>所谓的目标，所谓的计划，所谓的生活。</p>\n<hr>\n<p>心中并没有什么远大的理想与抱负。</p>\n<p>拥有一个和睦的家庭，幸福美满，即为最好。</p>\n<p>而这几个字，却没有个一致定义，各有各的理解与思考。</p>\n<p>那就稍微改下。</p>\n<p>理解彼此，信任彼此，温暖彼此，守护彼此。</p>\n<p>共同方向，共同规划，共同努力，共同生活。</p>\n<p>此上，我向往的“最好”。</p>\n","excerpt":"","more":"<p>花开有黯时，花谢有艳时。</p>\n<p>不知赛上谁与同，无愧于心，尽其所能，耐力追逐，争为最上人。</p>\n<hr>\n<p>邻居大爷望我脸，识我本命“福”字，拇哥翘起，赞赏：必为大富大贵之人。</p>\n<p>面带羞涩笑容，将必不负大爷所望。</p>\n<hr>\n<p>我并非沙发，没有必要让每一个人舒服。</p>\n<p>各自的性格个性造就众多个体，臭味相投，属性相克。</p>\n<p>磁铁互斥强行捆绑，暂看浪静风平，一旦松懈，具损。</p>\n<p>磁性也许会随着时间减弱，也许终能等到紧挨的时候，</p>\n<p>磁石已不再是磁石，磁石变成了普通的石头。</p>\n<hr>\n<p>无所谓所认为的对与不对，好与不好，正不正常，</p>\n<p>自己舒服，最好。</p>\n<hr>\n<p>年少总是自命不凡，所以是年少。</p>\n<p>所有一切都是循环往复，在自然自己规律中稳步进行。</p>\n<p>就像所有大人教育自己的孩子，总是感到无可奈何，低头感叹：当年的自己不也一副模样。</p>\n<hr>\n<p>人们总是喜欢给自己定目标。</p>\n<p>来，先给自己定一个小目标，挣它个 XXX</p>\n<p>定了目标后就会觉得这下有了方向，接下来的日子我就要朝着这个方向，先别管之后，我先完成这个小目标。</p>\n<p>目标既然有了，那就是怎么去实现了，这就是生活。</p>\n<p>所谓的目标，所谓的计划，所谓的生活。</p>\n<hr>\n<p>心中并没有什么远大的理想与抱负。</p>\n<p>拥有一个和睦的家庭，幸福美满，即为最好。</p>\n<p>而这几个字，却没有个一致定义，各有各的理解与思考。</p>\n<p>那就稍微改下。</p>\n<p>理解彼此，信任彼此，温暖彼此，守护彼此。</p>\n<p>共同方向，共同规划，共同努力，共同生活。</p>\n<p>此上，我向往的“最好”。</p>\n"},{"title":"阳十二月（2022）","date":"2022-12-25T13:10:55.000Z","_content":"\n> 这个月属实有点迷幻……\n\n公司接二连三的同事消失，大街上的车和人也一天比一天少，退烧药变成了黄金药救命药。\n\n放开的政策一出，各地传播速度极快，中招的人都是发烧喉咙吞刀片，导致退烧药抢购一空，甚至于加价十倍也有人买单。\n\n高烧到40往上的人比比皆是，即使快速退烧体温恢复正常，高烧导致的器官损伤无法彻底痊愈也是事实。如今阳的是常态，未阳的反而觉得变成了另类，未阳的期待着变阳。\n\n中招程度因人而异，有些轻症有些重症，更甚者因此毙命。所以这看似与一般发烧流感类似，但是其威力还是要大得多的，大家都“躲”在家，尽量少外出。这么一来，经济反而变得更差，这些人因为疫情真的绝大生意都不好做，经济再不刺激真的要倒退几年。\n\n元旦也定是哪也去不了了，看情势发展，人们的恢复程度了。\n\n注意身体。共勉。","source":"_posts/yang-december.md","raw":"---\ntitle: 阳十二月（2022）\ndate: 2022-12-25 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 这个月属实有点迷幻……\n\n公司接二连三的同事消失，大街上的车和人也一天比一天少，退烧药变成了黄金药救命药。\n\n放开的政策一出，各地传播速度极快，中招的人都是发烧喉咙吞刀片，导致退烧药抢购一空，甚至于加价十倍也有人买单。\n\n高烧到40往上的人比比皆是，即使快速退烧体温恢复正常，高烧导致的器官损伤无法彻底痊愈也是事实。如今阳的是常态，未阳的反而觉得变成了另类，未阳的期待着变阳。\n\n中招程度因人而异，有些轻症有些重症，更甚者因此毙命。所以这看似与一般发烧流感类似，但是其威力还是要大得多的，大家都“躲”在家，尽量少外出。这么一来，经济反而变得更差，这些人因为疫情真的绝大生意都不好做，经济再不刺激真的要倒退几年。\n\n元旦也定是哪也去不了了，看情势发展，人们的恢复程度了。\n\n注意身体。共勉。","slug":"yang-december","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhu00dkk9i19uqwf92c","content":"<blockquote>\n<p>这个月属实有点迷幻……</p>\n</blockquote>\n<p>公司接二连三的同事消失，大街上的车和人也一天比一天少，退烧药变成了黄金药救命药。</p>\n<p>放开的政策一出，各地传播速度极快，中招的人都是发烧喉咙吞刀片，导致退烧药抢购一空，甚至于加价十倍也有人买单。</p>\n<p>高烧到40往上的人比比皆是，即使快速退烧体温恢复正常，高烧导致的器官损伤无法彻底痊愈也是事实。如今阳的是常态，未阳的反而觉得变成了另类，未阳的期待着变阳。</p>\n<p>中招程度因人而异，有些轻症有些重症，更甚者因此毙命。所以这看似与一般发烧流感类似，但是其威力还是要大得多的，大家都“躲”在家，尽量少外出。这么一来，经济反而变得更差，这些人因为疫情真的绝大生意都不好做，经济再不刺激真的要倒退几年。</p>\n<p>元旦也定是哪也去不了了，看情势发展，人们的恢复程度了。</p>\n<p>注意身体。共勉。</p>\n","excerpt":"","more":"<blockquote>\n<p>这个月属实有点迷幻……</p>\n</blockquote>\n<p>公司接二连三的同事消失，大街上的车和人也一天比一天少，退烧药变成了黄金药救命药。</p>\n<p>放开的政策一出，各地传播速度极快，中招的人都是发烧喉咙吞刀片，导致退烧药抢购一空，甚至于加价十倍也有人买单。</p>\n<p>高烧到40往上的人比比皆是，即使快速退烧体温恢复正常，高烧导致的器官损伤无法彻底痊愈也是事实。如今阳的是常态，未阳的反而觉得变成了另类，未阳的期待着变阳。</p>\n<p>中招程度因人而异，有些轻症有些重症，更甚者因此毙命。所以这看似与一般发烧流感类似，但是其威力还是要大得多的，大家都“躲”在家，尽量少外出。这么一来，经济反而变得更差，这些人因为疫情真的绝大生意都不好做，经济再不刺激真的要倒退几年。</p>\n<p>元旦也定是哪也去不了了，看情势发展，人们的恢复程度了。</p>\n<p>注意身体。共勉。</p>\n"},{"title":"年味一月（2023）","date":"2023-02-05T13:10:55.000Z","_content":"\n> 风风火火又一年\n\n\n今年过年我们那都可以放烟花了，说是庆祝疫情过去（也有说是因为禁烟才来的疫情），反正随你放不抓就是。但街上还是不给卖，还得去隔壁县镇买，这钱都给别人赚去了！\n\n有了烟花就会显得有些动静，不像往常过年跟平时过周末一样。\n\n有件让人生气的事不吐不快。年前想买个冰柜的，然后看了下淘宝上有春节不打烊也保证了发货时效，就在淘宝上下单了。很好，确实是及时发货了，但是中途运输运了七天，眼看就要配送了，结果说配送人员还没上班，想要的话可以自己来取（离我家还有个五公里的样子），不然还得等个三四天。一个冰柜啊，说好的送货上门的，而且本来也是急着用才买的。顺便提下，这是德邦发的。这服务太差了，我马上就拒签又在京东上买了一款，结果第二天就给我送到家了。以后买大件的还是找京东靠谱！！\n\n这次去南通通州搓了一回澡，实惠还舒服，根本不输之前去扬州的，扬州找的百年老店还死贵。\n\n每次去通州都得吃吃那边的炸串，蘸着酱，实在是太香了！\n\n短暂的快乐结束了，又要回归打工人生活了。","source":"_posts/year-january.md","raw":"---\ntitle: 年味一月（2023）\ndate: 2023-02-05 21:10:55\ncategories: [生活,杂侃]\ntags: []\n---\n\n> 风风火火又一年\n\n\n今年过年我们那都可以放烟花了，说是庆祝疫情过去（也有说是因为禁烟才来的疫情），反正随你放不抓就是。但街上还是不给卖，还得去隔壁县镇买，这钱都给别人赚去了！\n\n有了烟花就会显得有些动静，不像往常过年跟平时过周末一样。\n\n有件让人生气的事不吐不快。年前想买个冰柜的，然后看了下淘宝上有春节不打烊也保证了发货时效，就在淘宝上下单了。很好，确实是及时发货了，但是中途运输运了七天，眼看就要配送了，结果说配送人员还没上班，想要的话可以自己来取（离我家还有个五公里的样子），不然还得等个三四天。一个冰柜啊，说好的送货上门的，而且本来也是急着用才买的。顺便提下，这是德邦发的。这服务太差了，我马上就拒签又在京东上买了一款，结果第二天就给我送到家了。以后买大件的还是找京东靠谱！！\n\n这次去南通通州搓了一回澡，实惠还舒服，根本不输之前去扬州的，扬州找的百年老店还死贵。\n\n每次去通州都得吃吃那边的炸串，蘸着酱，实在是太香了！\n\n短暂的快乐结束了，又要回归打工人生活了。","slug":"year-january","published":1,"updated":"2023-12-23T15:35:23.826Z","comments":1,"layout":"post","photos":[],"_id":"clqiekjhu00dok9i1ehfa7zpz","content":"<blockquote>\n<p>风风火火又一年</p>\n</blockquote>\n<p>今年过年我们那都可以放烟花了，说是庆祝疫情过去（也有说是因为禁烟才来的疫情），反正随你放不抓就是。但街上还是不给卖，还得去隔壁县镇买，这钱都给别人赚去了！</p>\n<p>有了烟花就会显得有些动静，不像往常过年跟平时过周末一样。</p>\n<p>有件让人生气的事不吐不快。年前想买个冰柜的，然后看了下淘宝上有春节不打烊也保证了发货时效，就在淘宝上下单了。很好，确实是及时发货了，但是中途运输运了七天，眼看就要配送了，结果说配送人员还没上班，想要的话可以自己来取（离我家还有个五公里的样子），不然还得等个三四天。一个冰柜啊，说好的送货上门的，而且本来也是急着用才买的。顺便提下，这是德邦发的。这服务太差了，我马上就拒签又在京东上买了一款，结果第二天就给我送到家了。以后买大件的还是找京东靠谱！！</p>\n<p>这次去南通通州搓了一回澡，实惠还舒服，根本不输之前去扬州的，扬州找的百年老店还死贵。</p>\n<p>每次去通州都得吃吃那边的炸串，蘸着酱，实在是太香了！</p>\n<p>短暂的快乐结束了，又要回归打工人生活了。</p>\n","excerpt":"","more":"<blockquote>\n<p>风风火火又一年</p>\n</blockquote>\n<p>今年过年我们那都可以放烟花了，说是庆祝疫情过去（也有说是因为禁烟才来的疫情），反正随你放不抓就是。但街上还是不给卖，还得去隔壁县镇买，这钱都给别人赚去了！</p>\n<p>有了烟花就会显得有些动静，不像往常过年跟平时过周末一样。</p>\n<p>有件让人生气的事不吐不快。年前想买个冰柜的，然后看了下淘宝上有春节不打烊也保证了发货时效，就在淘宝上下单了。很好，确实是及时发货了，但是中途运输运了七天，眼看就要配送了，结果说配送人员还没上班，想要的话可以自己来取（离我家还有个五公里的样子），不然还得等个三四天。一个冰柜啊，说好的送货上门的，而且本来也是急着用才买的。顺便提下，这是德邦发的。这服务太差了，我马上就拒签又在京东上买了一款，结果第二天就给我送到家了。以后买大件的还是找京东靠谱！！</p>\n<p>这次去南通通州搓了一回澡，实惠还舒服，根本不输之前去扬州的，扬州找的百年老店还死贵。</p>\n<p>每次去通州都得吃吃那边的炸串，蘸着酱，实在是太香了！</p>\n<p>短暂的快乐结束了，又要回归打工人生活了。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clqiekjh30009k9i1cqjz8idc","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh6000vk9i1dbcsbj31"},{"post_id":"clqiekjh30009k9i1cqjz8idc","category_id":"clqiekjh5000kk9i1eofgdcjn","_id":"clqiekjh60010k9i10ply4rig"},{"post_id":"clqiekjh00001k9i1ggtr0x4a","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh70013k9i143hq51w6"},{"post_id":"clqiekjh00001k9i1ggtr0x4a","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjh70016k9i17ybu9rvf"},{"post_id":"clqiekjh4000bk9i16m02bqq4","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh7001ak9i1hrdcgi62"},{"post_id":"clqiekjh4000bk9i16m02bqq4","category_id":"clqiekjh5000kk9i1eofgdcjn","_id":"clqiekjh7001ek9i14xf026fi"},{"post_id":"clqiekjh4000ek9i1gotb7l6p","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh7001gk9i12mz55its"},{"post_id":"clqiekjh4000ek9i1gotb7l6p","category_id":"clqiekjh5000kk9i1eofgdcjn","_id":"clqiekjh8001kk9i1bov48bs7"},{"post_id":"clqiekjh10003k9i1ha80g54g","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh8001pk9i1dn71eor6"},{"post_id":"clqiekjh10003k9i1ha80g54g","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjh8001sk9i12tsd7itb"},{"post_id":"clqiekjh4000fk9i1c189azei","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh8001vk9i1acbbcaki"},{"post_id":"clqiekjh4000fk9i1c189azei","category_id":"clqiekjh5000kk9i1eofgdcjn","_id":"clqiekjh8001zk9i1ejioguch"},{"post_id":"clqiekjh8001mk9i1ann25ex1","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh90023k9i1driyhd88"},{"post_id":"clqiekjh8001mk9i1ann25ex1","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjh90027k9i108qvcqm0"},{"post_id":"clqiekjh5000ik9i17zcmhplk","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh9002ak9i1bzvlgfzk"},{"post_id":"clqiekjh5000ik9i17zcmhplk","category_id":"clqiekjh5000kk9i1eofgdcjn","_id":"clqiekjh9002fk9i1gofterwn"},{"post_id":"clqiekjh8001tk9i1ats75pl0","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjh9002ik9i1gtqwa0ic"},{"post_id":"clqiekjh8001tk9i1ats75pl0","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjha002nk9i112lrc6zg"},{"post_id":"clqiekjh30007k9i11wpaa9ja","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhb002qk9i1cxwg4jp5"},{"post_id":"clqiekjh30007k9i11wpaa9ja","category_id":"clqiekjh5000kk9i1eofgdcjn","_id":"clqiekjhb002vk9i1gcbo4gly"},{"post_id":"clqiekjh5000jk9i1dq6m53b5","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhc002yk9i14los1k7b"},{"post_id":"clqiekjh5000jk9i1dq6m53b5","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhc0033k9i1cl4jfjqa"},{"post_id":"clqiekjh90028k9i10f2v8hi8","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhc0036k9i1dq1gbm09"},{"post_id":"clqiekjh90028k9i10f2v8hi8","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhc003bk9i1bajt4u26"},{"post_id":"clqiekjh5000mk9i1ad2neh25","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhc003ek9i18ksqdd68"},{"post_id":"clqiekjh5000mk9i1ad2neh25","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhc003jk9i1cgltcjcg"},{"post_id":"clqiekjh5000ok9i17ssobc8p","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhd003mk9i10as6esrr"},{"post_id":"clqiekjh5000ok9i17ssobc8p","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhd003rk9i1hxu44042"},{"post_id":"clqiekjh6000sk9i1cztk50rf","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhd003uk9i1d5ty1c1x"},{"post_id":"clqiekjh6000sk9i1cztk50rf","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhd003zk9i1h69reo90"},{"post_id":"clqiekjh6000uk9i1boo76p2e","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhd0042k9i161we1iqp"},{"post_id":"clqiekjh6000uk9i1boo76p2e","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhe0047k9i1g7fhaeua"},{"post_id":"clqiekjh6000zk9i1f97ag6bb","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhe004ak9i19t3i7u5f"},{"post_id":"clqiekjh6000zk9i1f97ag6bb","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhe004fk9i1f7hkd3zu"},{"post_id":"clqiekjhc003fk9i17gmzbm9k","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhe004ik9i19huj3aoe"},{"post_id":"clqiekjhc003fk9i17gmzbm9k","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhe004nk9i1ekrd39et"},{"post_id":"clqiekjh60011k9i1dir1dpru","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhe004qk9i1f7piatl6"},{"post_id":"clqiekjh60011k9i1dir1dpru","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhf004vk9i17l65gqhu"},{"post_id":"clqiekjhd003nk9i1b25j4upl","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhf004yk9i1dgy98ob3"},{"post_id":"clqiekjhd003nk9i1b25j4upl","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhf0053k9i14dzk0682"},{"post_id":"clqiekjh70015k9i11z5jd2iz","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhf0056k9i1dta3etgk"},{"post_id":"clqiekjh70015k9i11z5jd2iz","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhf005bk9i1f0fge6zk"},{"post_id":"clqiekjh70018k9i19syfgsht","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhf005ek9i16tp683qc"},{"post_id":"clqiekjh70018k9i19syfgsht","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhg005ik9i17mokgzvl"},{"post_id":"clqiekjh7001dk9i1g95t5zr9","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhg005kk9i191e3dgvt"},{"post_id":"clqiekjh7001dk9i1g95t5zr9","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhg005nk9i17vcw9aq5"},{"post_id":"clqiekjh7001fk9i18z9v1qp3","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhg005rk9i156d4h20s"},{"post_id":"clqiekjh7001fk9i18z9v1qp3","category_id":"clqiekjh90022k9i1cten7lj7","_id":"clqiekjhg005vk9i12q7a1ma9"},{"post_id":"clqiekjh7001jk9i186lgd5cm","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhg005zk9i15i13173r"},{"post_id":"clqiekjh7001jk9i186lgd5cm","category_id":"clqiekjhe004kk9i188myaqxi","_id":"clqiekjhh0063k9i1d7dl2n52"},{"post_id":"clqiekjhh006ak9i19d8ug2kz","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhi006kk9i14j6c0w9p"},{"post_id":"clqiekjhh006ak9i19d8ug2kz","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhi006nk9i1h7vuh92k"},{"post_id":"clqiekjhh006gk9i1c9sqdjbq","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhi006qk9i1cffdhmo8"},{"post_id":"clqiekjhh006gk9i1c9sqdjbq","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhi006tk9i1f7bhfvb4"},{"post_id":"clqiekjhi006mk9i1b9awby77","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhi006vk9i17nm05xe8"},{"post_id":"clqiekjhi006mk9i1b9awby77","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhj006zk9i16xjsacu9"},{"post_id":"clqiekjhi006ok9i1f5305ufb","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhj0071k9i11v61htqp"},{"post_id":"clqiekjhi006ok9i1f5305ufb","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhj0075k9i1cdit0kwc"},{"post_id":"clqiekjhi006sk9i16m49axag","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhj0078k9i1a2761tqt"},{"post_id":"clqiekjhi006sk9i16m49axag","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhj007dk9i1by0tfswv"},{"post_id":"clqiekjhi006uk9i17ueh6qap","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhj007gk9i12jng0l3w"},{"post_id":"clqiekjhi006uk9i17ueh6qap","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhk007lk9i1f1b3gb27"},{"post_id":"clqiekjhi006yk9i1d64heyhk","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhk007ok9i183hmdw2y"},{"post_id":"clqiekjhi006yk9i1d64heyhk","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhk007sk9i120wabso4"},{"post_id":"clqiekjhj0070k9i10a83fekm","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhk007wk9i178u10zza"},{"post_id":"clqiekjhj0070k9i10a83fekm","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhk0080k9i14yexf8sm"},{"post_id":"clqiekjhj0074k9i14kkmcr4e","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhl0083k9i153v3ada8"},{"post_id":"clqiekjhj0074k9i14kkmcr4e","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhl0087k9i1e9jq3vcd"},{"post_id":"clqiekjhj0077k9i1hvrgbxek","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhl008ak9i1cx0bbb3b"},{"post_id":"clqiekjhj0077k9i1hvrgbxek","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhl008dk9i1bgin56es"},{"post_id":"clqiekjhj007ck9i139wa8p18","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhl008gk9i1gpzh5jzk"},{"post_id":"clqiekjhj007ck9i139wa8p18","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhl008kk9i1apq24ore"},{"post_id":"clqiekjhc003ck9i177k2hlaw","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhl008nk9i1f7gh6zc6"},{"post_id":"clqiekjhc003ck9i177k2hlaw","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjhm008sk9i1gmfr1n65"},{"post_id":"clqiekjhj007fk9i19namamyg","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhm008vk9i18z4o5fs7"},{"post_id":"clqiekjhj007fk9i19namamyg","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhm0090k9i12ciy21ex"},{"post_id":"clqiekjhk007rk9i1hr2thjso","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhm0093k9i16mmdhtny"},{"post_id":"clqiekjhk007rk9i1hr2thjso","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjhm0098k9i11tr30vo8"},{"post_id":"clqiekjhk007vk9i17l9nf8qx","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhm009bk9i1dxl91jgk"},{"post_id":"clqiekjhk007vk9i17l9nf8qx","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjhn009gk9i194i3d8su"},{"post_id":"clqiekjhk007zk9i1fyzwc7z6","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhn009jk9i1bsjfgd42"},{"post_id":"clqiekjhk007zk9i1fyzwc7z6","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjhn009ok9i1bu5g115u"},{"post_id":"clqiekjhk0082k9i14ew0epcn","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhn009rk9i1dey97lf6"},{"post_id":"clqiekjhk0082k9i14ew0epcn","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjhn009wk9i1ciuecw12"},{"post_id":"clqiekjhl0086k9i1be797xe4","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhn009zk9i15ifrevv3"},{"post_id":"clqiekjhl0086k9i1be797xe4","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjho00a4k9i19h7c8gu0"},{"post_id":"clqiekjhl0089k9i1abom2a4j","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjho00a7k9i1cr7q784e"},{"post_id":"clqiekjhl0089k9i1abom2a4j","category_id":"clqiekjhj007ak9i19lkl8xyt","_id":"clqiekjho00ack9i1fwt3deal"},{"post_id":"clqiekjhl008ck9i134yv2ghs","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjho00afk9i136463ifg"},{"post_id":"clqiekjhl008ck9i134yv2ghs","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjho00akk9i1e5jrdi8p"},{"post_id":"clqiekjhl008mk9i15mgf7f26","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhp00ank9i172wp9v4i"},{"post_id":"clqiekjhl008mk9i15mgf7f26","category_id":"clqiekjh6000pk9i19jhr1msr","_id":"clqiekjhp00ask9i11mv5g5e0"},{"post_id":"clqiekjhm008yk9i13q5l3tzf","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhp00avk9i1b70fhqky"},{"post_id":"clqiekjhm008yk9i13q5l3tzf","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhp00b0k9i1fne99011"},{"post_id":"clqiekjhe004gk9i1dfu0cos7","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhq00b3k9i199ug2jkg"},{"post_id":"clqiekjhe004gk9i1dfu0cos7","category_id":"clqiekjhe004kk9i188myaqxi","_id":"clqiekjhq00b8k9i1c7yu3tcc"},{"post_id":"clqiekjhn009uk9i11xuq166m","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhq00bbk9i17sel7a23"},{"post_id":"clqiekjhn009uk9i11xuq166m","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhq00bgk9i16ycnerpz"},{"post_id":"clqiekjhf004wk9i14a1h8cn6","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhq00bjk9i1bnvc2v88"},{"post_id":"clqiekjhf004wk9i14a1h8cn6","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhr00bnk9i1eutg9c18"},{"post_id":"clqiekjhn009xk9i10axxcf9w","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhr00brk9i190w319zn"},{"post_id":"clqiekjhn009xk9i10axxcf9w","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhr00bvk9i1he0lfdt6"},{"post_id":"clqiekjhn00a1k9i1f541f97o","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhr00bzk9i11c58ek7w"},{"post_id":"clqiekjhn00a1k9i1f541f97o","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhs00c3k9i1521i44ss"},{"post_id":"clqiekjh8001rk9i12st9gkfc","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhs00c7k9i152ehf0g7"},{"post_id":"clqiekjh8001rk9i12st9gkfc","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhs00cbk9i111t2anwk"},{"post_id":"clqiekjho00a5k9i1fkf3e8wu","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhs00cfk9i19nyl6978"},{"post_id":"clqiekjho00a5k9i1fkf3e8wu","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhs00cjk9i1fyrh9iaw"},{"post_id":"clqiekjho00a9k9i1a822gowl","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhs00cnk9i1c2sphajz"},{"post_id":"clqiekjho00a9k9i1a822gowl","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjht00crk9i12n4o28d5"},{"post_id":"clqiekjhf004zk9i18njib511","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjht00cvk9i1d2pl58b0"},{"post_id":"clqiekjhf004zk9i18njib511","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjht00czk9i1fjne1wm1"},{"post_id":"clqiekjho00adk9i17kwrh0ch","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjht00d3k9i1hpz3h860"},{"post_id":"clqiekjho00adk9i17kwrh0ch","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjht00d7k9i11k2mdhqf"},{"post_id":"clqiekjhf0054k9i1eyzkal7a","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhu00dbk9i10l8oh3nn"},{"post_id":"clqiekjhf0054k9i1eyzkal7a","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhu00dfk9i1g46uh20y"},{"post_id":"clqiekjho00alk9i1502t3ywu","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhu00djk9i16ifh347s"},{"post_id":"clqiekjho00alk9i1502t3ywu","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhu00dnk9i1a2l84e3x"},{"post_id":"clqiekjhp00apk9i1bspt4gdw","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhu00dqk9i1ahc598mr"},{"post_id":"clqiekjhp00apk9i1bspt4gdw","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhu00duk9i1dg945ogn"},{"post_id":"clqiekjh8001xk9i1823h29ea","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhv00dwk9i1d5waab4n"},{"post_id":"clqiekjh8001xk9i1823h29ea","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhv00e0k9i1dedj9gua"},{"post_id":"clqiekjhp00atk9i1eclmbj1o","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhv00e2k9i15u5yhzrt"},{"post_id":"clqiekjhp00atk9i1eclmbj1o","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhv00e6k9i1eama76h7"},{"post_id":"clqiekjhp00axk9i178zogx8x","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhv00e8k9i11r3cgicm"},{"post_id":"clqiekjhp00axk9i178zogx8x","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhv00eck9i19arz31yj"},{"post_id":"clqiekjhf0057k9i1gi380im2","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhv00eek9i1f1ing4ek"},{"post_id":"clqiekjhf0057k9i1gi380im2","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhv00ehk9i13tvhgpz7"},{"post_id":"clqiekjhp00b1k9i19u0d4bi3","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhv00ejk9i147ks7o14"},{"post_id":"clqiekjhp00b1k9i19u0d4bi3","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhv00elk9i1gireadqp"},{"post_id":"clqiekjhq00b5k9i1ctps2q57","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhv00enk9i19oar4yis"},{"post_id":"clqiekjhq00b5k9i1ctps2q57","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhv00eok9i1bufd8mk7"},{"post_id":"clqiekjhf005ck9i15h9vfjqd","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhv00erk9i11549gmty"},{"post_id":"clqiekjhf005ck9i15h9vfjqd","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhv00etk9i1dyo7011b"},{"post_id":"clqiekjhq00b9k9i16uupgwsb","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhw00exk9i13uy8c3b7"},{"post_id":"clqiekjhq00b9k9i16uupgwsb","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhw00ezk9i1gpuk2fm1"},{"post_id":"clqiekjhq00bck9i1gjd9e45f","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhw00f3k9i1gfs65r9l"},{"post_id":"clqiekjhq00bck9i1gjd9e45f","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhw00f5k9i1bk26bn6x"},{"post_id":"clqiekjh80020k9i1c2ftdrok","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhw00f8k9i10uo5fsw7"},{"post_id":"clqiekjh80020k9i1c2ftdrok","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhw00fbk9i1669c2n1v"},{"post_id":"clqiekjhq00bhk9i18x317jke","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhw00fek9i1bl0a67sq"},{"post_id":"clqiekjhq00bhk9i18x317jke","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhw00fhk9i1adbl2o62"},{"post_id":"clqiekjhf005fk9i13yaydbc4","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhw00fjk9i1emx94cf0"},{"post_id":"clqiekjhf005fk9i13yaydbc4","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhw00flk9i1aqpfd3q1"},{"post_id":"clqiekjhr00bpk9i111ra6a1s","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhw00fok9i15shb968e"},{"post_id":"clqiekjhr00bpk9i111ra6a1s","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhw00frk9i14lnog1nv"},{"post_id":"clqiekjhr00bsk9i1b22m8cwg","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhw00fuk9i1aeo3cppf"},{"post_id":"clqiekjhr00bsk9i1b22m8cwg","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhx00fwk9i18lzu7tep"},{"post_id":"clqiekjhg005jk9i172xd5ckk","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhx00fyk9i149bs7mbn"},{"post_id":"clqiekjhg005jk9i172xd5ckk","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhx00fzk9i1514w5ff5"},{"post_id":"clqiekjhr00bxk9i1d5nh2050","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhx00g2k9i1d9wo2vyz"},{"post_id":"clqiekjhr00bxk9i1d5nh2050","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhx00g3k9i1f78pfheh"},{"post_id":"clqiekjhr00c0k9i1bec8acco","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhx00g6k9i1b39kgx7c"},{"post_id":"clqiekjhr00c0k9i1bec8acco","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhx00g8k9i18vfdfpg8"},{"post_id":"clqiekjh90025k9i1elcwahfn","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhx00gck9i1gtjygwnx"},{"post_id":"clqiekjh90025k9i1elcwahfn","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhx00gek9i1dkez9s5s"},{"post_id":"clqiekjhs00c5k9i1315dae8q","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhx00gik9i16kmr87er"},{"post_id":"clqiekjhs00c5k9i1315dae8q","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhx00gkk9i15e6e215p"},{"post_id":"clqiekjhs00c8k9i1bzmbcl21","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhx00gnk9i181wz7yn0"},{"post_id":"clqiekjhs00c8k9i1bzmbcl21","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhx00gpk9i1h1cwbklj"},{"post_id":"clqiekjhg005lk9i1f7sjhzhm","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhx00gsk9i1c8wvafru"},{"post_id":"clqiekjhg005lk9i1f7sjhzhm","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhx00guk9i12rgd7dzs"},{"post_id":"clqiekjhs00cdk9i11rz02x3l","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00gwk9i1e76ic899"},{"post_id":"clqiekjhs00cdk9i11rz02x3l","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00gxk9i1eqld2a90"},{"post_id":"clqiekjhs00cgk9i1g9bm3wab","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00gzk9i1at7w5uu3"},{"post_id":"clqiekjhs00cgk9i1g9bm3wab","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00h0k9i12gvvdk5q"},{"post_id":"clqiekjh9002ck9i1797g8bbw","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00h2k9i1bvqvhq89"},{"post_id":"clqiekjh9002ck9i1797g8bbw","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00h3k9i16x250xur"},{"post_id":"clqiekjht00cok9i1by1j03rx","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00h5k9i1g7294wuz"},{"post_id":"clqiekjht00cok9i1by1j03rx","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00h6k9i1eieod3zt"},{"post_id":"clqiekjhg005sk9i1g01ue2xz","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00h8k9i150bmagoz"},{"post_id":"clqiekjhg005sk9i1g01ue2xz","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00h9k9i171ykfeq0"},{"post_id":"clqiekjht00ctk9i13wds7hk5","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00hbk9i1h7op7p1l"},{"post_id":"clqiekjht00ctk9i13wds7hk5","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00hck9i18wnef9q6"},{"post_id":"clqiekjht00cwk9i19t7d7i30","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhy00hek9i1cx304mxv"},{"post_id":"clqiekjht00cwk9i19t7d7i30","category_id":"clqiekjh70019k9i185dsevf7","_id":"clqiekjhy00hfk9i17pqd91hu"},{"post_id":"clqiekjhg005wk9i18kroga95","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00hhk9i17j119xmk"},{"post_id":"clqiekjhg005wk9i18kroga95","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00hik9i19pgaer7o"},{"post_id":"clqiekjht00d1k9i14l2ieu5o","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00hkk9i19m9b3s1z"},{"post_id":"clqiekjht00d1k9i14l2ieu5o","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00hlk9i1b7u7cj3b"},{"post_id":"clqiekjht00d4k9i18aor0l2s","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00hnk9i14mlh51bz"},{"post_id":"clqiekjht00d4k9i18aor0l2s","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00hok9i129g5fs8l"},{"post_id":"clqiekjh9002gk9i11id30759","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00hqk9i1fl1qh1ba"},{"post_id":"clqiekjh9002gk9i11id30759","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00hrk9i102trbyud"},{"post_id":"clqiekjhu00d9k9i1afnb3alu","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhy00htk9i10y162gbf"},{"post_id":"clqiekjhu00d9k9i1afnb3alu","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhy00huk9i1co1d4hw4"},{"post_id":"clqiekjhu00dck9i19uu3184c","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00hwk9i10o1bfm93"},{"post_id":"clqiekjhu00dck9i19uu3184c","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00hxk9i1f2uwgd82"},{"post_id":"clqiekjhg0060k9i17zi443lr","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00hzk9i1d97r3386"},{"post_id":"clqiekjhg0060k9i17zi443lr","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00i0k9i1gd90gr0j"},{"post_id":"clqiekjhu00dgk9i1eppq1uee","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00i2k9i15ppb8wh7"},{"post_id":"clqiekjhu00dgk9i1eppq1uee","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00i3k9i1dfw67hp8"},{"post_id":"clqiekjhu00dkk9i19uqwf92c","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00i5k9i1gjgb47zh"},{"post_id":"clqiekjhu00dkk9i19uqwf92c","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00i6k9i1aiy57qic"},{"post_id":"clqiekjhh0064k9i18amgdy4b","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00i8k9i15h6oe0hy"},{"post_id":"clqiekjhh0064k9i18amgdy4b","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00i9k9i1ecjqhwkx"},{"post_id":"clqiekjhu00dok9i1ehfa7zpz","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iak9i1fqv7dxft"},{"post_id":"clqiekjhu00dok9i1ehfa7zpz","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ibk9i16epc2i9i"},{"post_id":"clqiekjh9002kk9i1d38a3094","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00ick9i1802cbd15"},{"post_id":"clqiekjh9002kk9i1d38a3094","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00idk9i1drbt2bqk"},{"post_id":"clqiekjhh0067k9i13t9u1x7l","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iek9i13w04hpe5"},{"post_id":"clqiekjhh0067k9i13t9u1x7l","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ifk9i16p0x55hp"},{"post_id":"clqiekjha002ok9i1bhm3eq1s","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00igk9i174xc8i1z"},{"post_id":"clqiekjha002ok9i1bhm3eq1s","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ihk9i17cmb3pfy"},{"post_id":"clqiekjhh006dk9i1arvce6hi","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iik9i16z7y22at"},{"post_id":"clqiekjhh006dk9i1arvce6hi","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ijk9i14iep024u"},{"post_id":"clqiekjhb002rk9i17zexfgrt","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00ikk9i11zvs4t6j"},{"post_id":"clqiekjhb002rk9i17zexfgrt","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ilk9i1703z3lsn"},{"post_id":"clqiekjhb002wk9i10m6q03zc","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00imk9i1c80bao4i"},{"post_id":"clqiekjhb002wk9i10m6q03zc","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ink9i15k4v91mw"},{"post_id":"clqiekjhc002zk9i17lru8se7","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iok9i17s1u09m8"},{"post_id":"clqiekjhc002zk9i17lru8se7","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ipk9i13rzr40wq"},{"post_id":"clqiekjhc0034k9i199acfeef","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iqk9i1cwdy2twx"},{"post_id":"clqiekjhc0034k9i199acfeef","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00irk9i1culx5boz"},{"post_id":"clqiekjhc0037k9i1ag6meaft","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00isk9i10h8ohxh2"},{"post_id":"clqiekjhc0037k9i1ag6meaft","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00itk9i15qi8dikn"},{"post_id":"clqiekjhj007jk9i1cz4q2xkp","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iuk9i15l339z6q"},{"post_id":"clqiekjhj007jk9i1cz4q2xkp","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ivk9i14v6wd4fy"},{"post_id":"clqiekjhc003kk9i1cx3bd0yy","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iwk9i1euumcrlh"},{"post_id":"clqiekjhc003kk9i1cx3bd0yy","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00ixk9i14x8wacgj"},{"post_id":"clqiekjhk007nk9i1h6y06qnf","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00iyk9i1eq0zaxrc"},{"post_id":"clqiekjhk007nk9i1h6y06qnf","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00izk9i17thk9hag"},{"post_id":"clqiekjhd003sk9i174bc9hzo","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00j0k9i1eu7e7xu2"},{"post_id":"clqiekjhd003sk9i174bc9hzo","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00j1k9i1bf5f4zxe"},{"post_id":"clqiekjhd003vk9i1gvm55a4e","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00j2k9i17qn6e4l8"},{"post_id":"clqiekjhd003vk9i1gvm55a4e","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00j3k9i170kgay98"},{"post_id":"clqiekjhd0040k9i10wn07iwc","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00j4k9i1byco991q"},{"post_id":"clqiekjhd0040k9i10wn07iwc","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00j5k9i1bfych5hs"},{"post_id":"clqiekjhd0043k9i1g2ik3yt2","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00j6k9i17pz80ekc"},{"post_id":"clqiekjhd0043k9i1g2ik3yt2","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00j7k9i14ci02iba"},{"post_id":"clqiekjhl008ek9i1f6vu93xy","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00j8k9i1fsc1gmu8"},{"post_id":"clqiekjhl008ek9i1f6vu93xy","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00j9k9i19opvfj8g"},{"post_id":"clqiekjhl008jk9i1angu6gma","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jak9i17w62dbmd"},{"post_id":"clqiekjhl008jk9i1angu6gma","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jbk9i137rq1i2o"},{"post_id":"clqiekjhe0048k9i16mzignq9","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jck9i18axu0xw9"},{"post_id":"clqiekjhe0048k9i16mzignq9","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jdk9i131m30kt2"},{"post_id":"clqiekjhm008qk9i15d9m0fvx","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jek9i15peyg9ox"},{"post_id":"clqiekjhm008qk9i15d9m0fvx","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jfk9i1c55khae9"},{"post_id":"clqiekjhe004bk9i139skh13w","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jgk9i122rq9tgz"},{"post_id":"clqiekjhe004bk9i139skh13w","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jhk9i19iex906u"},{"post_id":"clqiekjhm008tk9i1fyt62qk6","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jik9i19w9ngfo4"},{"post_id":"clqiekjhm008tk9i1fyt62qk6","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jjk9i13ozw70jb"},{"post_id":"clqiekjhm0091k9i1dh3kc5lm","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jkk9i111f0145q"},{"post_id":"clqiekjhm0091k9i1dh3kc5lm","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jlk9i105pt5c14"},{"post_id":"clqiekjhm0096k9i1fq718h9r","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jmk9i167l3f1ij"},{"post_id":"clqiekjhm0096k9i1fq718h9r","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jnk9i1ef2wf88q"},{"post_id":"clqiekjhe004jk9i1giqe4rdj","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jok9i1gqjvcbbs"},{"post_id":"clqiekjhe004jk9i1giqe4rdj","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jpk9i185jgh7od"},{"post_id":"clqiekjhm0099k9i1he090q6s","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jqk9i11f536f1y"},{"post_id":"clqiekjhm0099k9i1he090q6s","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jrk9i19tgh2oy5"},{"post_id":"clqiekjhn009ek9i1e91oezq0","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jsk9i1cqob8iq6"},{"post_id":"clqiekjhn009ek9i1e91oezq0","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jtk9i1dmfvg8co"},{"post_id":"clqiekjhe004ok9i10t0ta5ge","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00juk9i10660fv1c"},{"post_id":"clqiekjhe004ok9i10t0ta5ge","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jvk9i1fb7mfanl"},{"post_id":"clqiekjhn009hk9i11lvjd423","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jwk9i10d4dfvuj"},{"post_id":"clqiekjhn009hk9i11lvjd423","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jxk9i15ket5l1r"},{"post_id":"clqiekjhn009mk9i17xdtatlv","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00jyk9i1h5fvekvh"},{"post_id":"clqiekjhn009mk9i17xdtatlv","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00jzk9i1c8k76ud9"},{"post_id":"clqiekjhf004rk9i18bu363v1","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00k0k9i13mcb2awe"},{"post_id":"clqiekjhf004rk9i18bu363v1","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00k1k9i193loemzm"},{"post_id":"clqiekjhn009pk9i15bhm0mpl","category_id":"clqiekjhf004tk9i18nej76og","_id":"clqiekjhz00k2k9i12bnh1ojv"},{"post_id":"clqiekjhn009pk9i15bhm0mpl","category_id":"clqiekjhn009tk9i1a87z944p","_id":"clqiekjhz00k3k9i1bj1g9kvb"},{"post_id":"clqiekjho00ahk9i17uymezbk","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekjhz00k4k9i18eqsew63"},{"post_id":"clqiekjho00ahk9i17uymezbk","category_id":"clqiekjhy00hvk9i18mb2940r","_id":"clqiekjhz00k5k9i169qigrry"},{"post_id":"clqiekjhr00bkk9i183qm05ac","category_id":"clqiekjh20004k9i13bhcbe93","_id":"clqiekji000k6k9i16sbn2yx8"},{"post_id":"clqiekjhr00bkk9i183qm05ac","category_id":"clqiekjhy00hvk9i18mb2940r","_id":"clqiekji000k7k9i15tgr6d9s"},{"post_id":"clqiekjhi006jk9i1cmhh1gjj","category_id":"clqiekjhv00ekk9i1g8hmfza7","_id":"clqiekji000k8k9i19irvhjv3"},{"post_id":"clqiekjhi006jk9i1cmhh1gjj","category_id":"clqiekjhz00i4k9i1daco6cuz","_id":"clqiekji000k9k9i1f0ky1yzh"},{"post_id":"clqiekjhs00clk9i14f7we7zw","category_id":"clqiekjhv00ekk9i1g8hmfza7","_id":"clqiekji000kak9i1bpmk3s5q"},{"post_id":"clqiekjhs00clk9i14f7we7zw","category_id":"clqiekjhz00i7k9i14n1oc0jo","_id":"clqiekji000kbk9i1dm0tblk1"}],"PostTag":[{"post_id":"clqiekjh00001k9i1ggtr0x4a","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjh5000nk9i172ifax6v"},{"post_id":"clqiekjh00001k9i1ggtr0x4a","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh6000qk9i1b0v011cv"},{"post_id":"clqiekjh00001k9i1ggtr0x4a","tag_id":"clqiekjh5000hk9i18w5ac72u","_id":"clqiekjh6000tk9i11eto4fr6"},{"post_id":"clqiekjh10003k9i1ha80g54g","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh6000wk9i12phygvsy"},{"post_id":"clqiekjh30007k9i11wpaa9ja","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh70017k9i1881l995m"},{"post_id":"clqiekjh30007k9i11wpaa9ja","tag_id":"clqiekjh6000yk9i11uwfb30p","_id":"clqiekjh7001bk9i10rhrhc1z"},{"post_id":"clqiekjh30009k9i1cqjz8idc","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh8001lk9i1d3mge0q4"},{"post_id":"clqiekjh30009k9i1cqjz8idc","tag_id":"clqiekjh6000yk9i11uwfb30p","_id":"clqiekjh8001nk9i196zibluf"},{"post_id":"clqiekjh4000bk9i16m02bqq4","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh8001yk9i16upba44f"},{"post_id":"clqiekjh4000bk9i16m02bqq4","tag_id":"clqiekjh6000yk9i11uwfb30p","_id":"clqiekjh90021k9i1du8c81xs"},{"post_id":"clqiekjh8001tk9i1ats75pl0","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh90026k9i1g18854fi"},{"post_id":"clqiekjh4000ek9i1gotb7l6p","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh90029k9i127iigj9e"},{"post_id":"clqiekjh4000ek9i1gotb7l6p","tag_id":"clqiekjh6000yk9i11uwfb30p","_id":"clqiekjh9002ek9i111axgjj0"},{"post_id":"clqiekjh4000fk9i1c189azei","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjh9002hk9i1cs33dbb1"},{"post_id":"clqiekjh4000fk9i1c189azei","tag_id":"clqiekjh6000yk9i11uwfb30p","_id":"clqiekjha002mk9i15dt01t9y"},{"post_id":"clqiekjh5000ik9i17zcmhplk","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhb002pk9i143uj9mka"},{"post_id":"clqiekjh5000ik9i17zcmhplk","tag_id":"clqiekjh6000yk9i11uwfb30p","_id":"clqiekjhb002uk9i1ch6ehdku"},{"post_id":"clqiekjh5000jk9i1dq6m53b5","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhc002xk9i12tkw9fxz"},{"post_id":"clqiekjh5000jk9i1dq6m53b5","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhc0032k9i11yct9s31"},{"post_id":"clqiekjh5000mk9i1ad2neh25","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhc0035k9i15epfcydq"},{"post_id":"clqiekjh5000mk9i1ad2neh25","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhc003ak9i12an4euhj"},{"post_id":"clqiekjh5000ok9i17ssobc8p","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhc003dk9i155wx8skz"},{"post_id":"clqiekjh5000ok9i17ssobc8p","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhc003ik9i1e3zdbf70"},{"post_id":"clqiekjh6000sk9i1cztk50rf","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhd003lk9i155am9pik"},{"post_id":"clqiekjh6000sk9i1cztk50rf","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhd003qk9i15b4n3n3v"},{"post_id":"clqiekjh6000uk9i1boo76p2e","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhd003tk9i18y746sv1"},{"post_id":"clqiekjh6000uk9i1boo76p2e","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhd003yk9i150666mhx"},{"post_id":"clqiekjh6000zk9i1f97ag6bb","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhd0041k9i1gpqtbilq"},{"post_id":"clqiekjh6000zk9i1f97ag6bb","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhe0046k9i1225ifo1l"},{"post_id":"clqiekjh60011k9i1dir1dpru","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhe0049k9i12ha9huwl"},{"post_id":"clqiekjh60011k9i1dir1dpru","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhe004ek9i15j0s6exm"},{"post_id":"clqiekjh70015k9i11z5jd2iz","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhe004hk9i17kbbdzif"},{"post_id":"clqiekjh70015k9i11z5jd2iz","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhe004mk9i15qivdswf"},{"post_id":"clqiekjh70018k9i19syfgsht","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhe004pk9i10dam3q95"},{"post_id":"clqiekjh70018k9i19syfgsht","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhf004uk9i1duml8h3c"},{"post_id":"clqiekjh7001dk9i1g95t5zr9","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhf004xk9i1be7pgr94"},{"post_id":"clqiekjh7001dk9i1g95t5zr9","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhf0052k9i15c3mgoyt"},{"post_id":"clqiekjh7001fk9i18z9v1qp3","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhf0055k9i15d070dwe"},{"post_id":"clqiekjh7001fk9i18z9v1qp3","tag_id":"clqiekjh9002jk9i1cxvd8gqe","_id":"clqiekjhf005ak9i1hpn8c6zr"},{"post_id":"clqiekjh7001jk9i186lgd5cm","tag_id":"clqiekjhf0050k9i16bspacbv","_id":"clqiekjhf005dk9i12cjk5dg2"},{"post_id":"clqiekjh8001mk9i1ann25ex1","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhg005qk9i1cbvke37s"},{"post_id":"clqiekjh8001mk9i1ann25ex1","tag_id":"clqiekjhf0058k9i1bqy57f6t","_id":"clqiekjhg005uk9i1d09xeesv"},{"post_id":"clqiekjh8001mk9i1ann25ex1","tag_id":"clqiekjhg005hk9i1h6t5btce","_id":"clqiekjhg005yk9i1h18vd245"},{"post_id":"clqiekjh90028k9i10f2v8hi8","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhh0062k9i146910yfg"},{"post_id":"clqiekjh90028k9i10f2v8hi8","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhh0066k9i13g3h5iuh"},{"post_id":"clqiekjh90028k9i10f2v8hi8","tag_id":"clqiekjhg005ok9i1d0ik9ikk","_id":"clqiekjhh0069k9i15fgk0wz5"},{"post_id":"clqiekjhc003ck9i177k2hlaw","tag_id":"clqiekjhg005xk9i14pq11th0","_id":"clqiekjhh006ck9i18ax0ezp5"},{"post_id":"clqiekjhc003fk9i17gmzbm9k","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhh006fk9i19woc5117"},{"post_id":"clqiekjhc003fk9i17gmzbm9k","tag_id":"clqiekjhh0065k9i10z4p8ujq","_id":"clqiekjhh006hk9i121k1exnr"},{"post_id":"clqiekjhd003nk9i1b25j4upl","tag_id":"clqiekjhh006bk9i12678dz1i","_id":"clqiekjhj0076k9i16exdev79"},{"post_id":"clqiekjhd003nk9i1b25j4upl","tag_id":"clqiekjhh006ik9i15ntn29ef","_id":"clqiekjhj0079k9i1gfraff8e"},{"post_id":"clqiekjhd003nk9i1b25j4upl","tag_id":"clqiekjhi006pk9i1g1ojbs95","_id":"clqiekjhj007ek9i1fabn0whs"},{"post_id":"clqiekjhd003nk9i1b25j4upl","tag_id":"clqiekjhi006wk9i16f141gen","_id":"clqiekjhj007hk9i1akf88v1c"},{"post_id":"clqiekjhe004gk9i1dfu0cos7","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhk007mk9i15i0e60wo"},{"post_id":"clqiekjhe004gk9i1dfu0cos7","tag_id":"clqiekjhj0073k9i156d4dntt","_id":"clqiekjhk007qk9i1dtw9226o"},{"post_id":"clqiekjhe004gk9i1dfu0cos7","tag_id":"clqiekjhj007bk9i15nau6jgw","_id":"clqiekjhk007uk9i1a15u02ak"},{"post_id":"clqiekjhh006ak9i19d8ug2kz","tag_id":"clqiekjhk007kk9i1al6ihc5k","_id":"clqiekjhk007yk9i10eb5axzv"},{"post_id":"clqiekjhh006gk9i1c9sqdjbq","tag_id":"clqiekjhk007tk9i1hhcu7sdm","_id":"clqiekjhl0084k9i19v9e083h"},{"post_id":"clqiekjhi006jk9i1cmhh1gjj","tag_id":"clqiekjhk0081k9i12cca1oq6","_id":"clqiekjhl008ik9i1h64qcoin"},{"post_id":"clqiekjhi006jk9i1cmhh1gjj","tag_id":"clqiekjhl0088k9i18wa692lb","_id":"clqiekjhl008lk9i17yrp57sh"},{"post_id":"clqiekjhi006mk9i1b9awby77","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhm008rk9i11cei3byb"},{"post_id":"clqiekjhi006mk9i1b9awby77","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhm008uk9i109cr412w"},{"post_id":"clqiekjhi006mk9i1b9awby77","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhm008zk9i1cjrjcjcn"},{"post_id":"clqiekjhi006ok9i1f5305ufb","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhm0092k9i1ho8f8qjr"},{"post_id":"clqiekjhi006ok9i1f5305ufb","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhm0097k9i1d9lp3igq"},{"post_id":"clqiekjhi006ok9i1f5305ufb","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhm009ak9i1f0sg83bf"},{"post_id":"clqiekjhi006sk9i16m49axag","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhn009fk9i12jru9xrw"},{"post_id":"clqiekjhi006sk9i16m49axag","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhn009ik9i19bkhem6w"},{"post_id":"clqiekjhi006sk9i16m49axag","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhn009nk9i10jmk0vqu"},{"post_id":"clqiekjhi006uk9i17ueh6qap","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhn009qk9i1ctehh2wb"},{"post_id":"clqiekjhi006uk9i17ueh6qap","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhn009vk9i12jutdoe2"},{"post_id":"clqiekjhi006uk9i17ueh6qap","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhn009yk9i125kb6ba6"},{"post_id":"clqiekjhi006yk9i1d64heyhk","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjho00a3k9i14c6gagp2"},{"post_id":"clqiekjhi006yk9i1d64heyhk","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjho00a6k9i1a1idhem9"},{"post_id":"clqiekjhi006yk9i1d64heyhk","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjho00abk9i110hqgirs"},{"post_id":"clqiekjhj0070k9i10a83fekm","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjho00aek9i19wcsespf"},{"post_id":"clqiekjhj0070k9i10a83fekm","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjho00ajk9i1b9uaf2tl"},{"post_id":"clqiekjhj0070k9i10a83fekm","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhp00amk9i12yfb807y"},{"post_id":"clqiekjhj0074k9i14kkmcr4e","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhp00ark9i1aywe8dmg"},{"post_id":"clqiekjhj0074k9i14kkmcr4e","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhp00auk9i12llo529a"},{"post_id":"clqiekjhj0074k9i14kkmcr4e","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhp00azk9i14pbq8er6"},{"post_id":"clqiekjhj0077k9i1hvrgbxek","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhq00b2k9i13btc573m"},{"post_id":"clqiekjhj0077k9i1hvrgbxek","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhq00b7k9i15vb4bmza"},{"post_id":"clqiekjhj0077k9i1hvrgbxek","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhq00bak9i14dbca7kr"},{"post_id":"clqiekjhj007ck9i139wa8p18","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhq00bfk9i19zx5cszb"},{"post_id":"clqiekjhj007ck9i139wa8p18","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhq00bik9i19v4d6ot5"},{"post_id":"clqiekjhj007ck9i139wa8p18","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhr00bmk9i1cdgifi0e"},{"post_id":"clqiekjhj007fk9i19namamyg","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhr00bqk9i1ghdn41vx"},{"post_id":"clqiekjhj007fk9i19namamyg","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhr00buk9i1f56m8opx"},{"post_id":"clqiekjhj007fk9i19namamyg","tag_id":"clqiekjhl008fk9i18rmvar8u","_id":"clqiekjhr00byk9i1b2xb2lbe"},{"post_id":"clqiekjho00alk9i1502t3ywu","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhs00c2k9i19o2b31g7"},{"post_id":"clqiekjho00alk9i1502t3ywu","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhs00c6k9i1g47dfuma"},{"post_id":"clqiekjhk007nk9i1h6y06qnf","tag_id":"clqiekjhp00aok9i1bsln6doe","_id":"clqiekjhs00cak9i14nub4p3w"},{"post_id":"clqiekjhk007nk9i1h6y06qnf","tag_id":"clqiekjhp00awk9i11gwh1ue9","_id":"clqiekjhs00cek9i1em6u37uy"},{"post_id":"clqiekjhk007nk9i1h6y06qnf","tag_id":"clqiekjhq00b4k9i1fu6df7di","_id":"clqiekjhs00cik9i1hjtpejg4"},{"post_id":"clqiekjhk007rk9i1hr2thjso","tag_id":"clqiekjhq00bek9i1hv1a03gb","_id":"clqiekjhs00cmk9i1e7xw9ylp"},{"post_id":"clqiekjhk007vk9i17l9nf8qx","tag_id":"clqiekjhq00bek9i1hv1a03gb","_id":"clqiekjht00cqk9i1eqdj3dja"},{"post_id":"clqiekjhr00bxk9i1d5nh2050","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjht00cuk9i14h7banie"},{"post_id":"clqiekjhk007zk9i1fyzwc7z6","tag_id":"clqiekjhq00bek9i1hv1a03gb","_id":"clqiekjht00cyk9i10tchbmz4"},{"post_id":"clqiekjhr00c0k9i1bec8acco","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjht00d2k9i11d5n86k0"},{"post_id":"clqiekjhk0082k9i14ew0epcn","tag_id":"clqiekjhq00bek9i1hv1a03gb","_id":"clqiekjht00d6k9i1hxrt61f3"},{"post_id":"clqiekjhl0086k9i1be797xe4","tag_id":"clqiekjhq00bek9i1hv1a03gb","_id":"clqiekjhu00dak9i1g3mefn8u"},{"post_id":"clqiekjhl0089k9i1abom2a4j","tag_id":"clqiekjhq00bek9i1hv1a03gb","_id":"clqiekjhu00dek9i1ga5rfek6"},{"post_id":"clqiekjhl008ck9i134yv2ghs","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhu00dik9i190vt7l2r"},{"post_id":"clqiekjhl008ck9i134yv2ghs","tag_id":"clqiekjht00csk9i1dgbt5cxo","_id":"clqiekjhu00dmk9i11ptpavw3"},{"post_id":"clqiekjht00cwk9i19t7d7i30","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhu00dpk9i11c335jy9"},{"post_id":"clqiekjht00cwk9i19t7d7i30","tag_id":"clqiekjhf0050k9i16bspacbv","_id":"clqiekjhu00dtk9i11qou3u5y"},{"post_id":"clqiekjhl008mk9i15mgf7f26","tag_id":"clqiekjh30005k9i10rmq4kof","_id":"clqiekjhv00dvk9i1c3h8bfl2"},{"post_id":"clqiekjhl008mk9i15mgf7f26","tag_id":"clqiekjht00d0k9i12bda04g7","_id":"clqiekjhv00dzk9i1b7z2h5yj"},{"post_id":"clqiekjhm008yk9i13q5l3tzf","tag_id":"clqiekjht00d8k9i16ukjhssm","_id":"clqiekjhv00e1k9i1aydmg5v4"},{"post_id":"clqiekjhn009uk9i11xuq166m","tag_id":"clqiekjhu00dhk9i122up695o","_id":"clqiekjhv00e5k9i18i67b7ql"},{"post_id":"clqiekjho00adk9i17kwrh0ch","tag_id":"clqiekjhu00drk9i1dwvmfene","_id":"clqiekjhv00e7k9i1ckczc5l4"},{"post_id":"clqiekjho00ahk9i17uymezbk","tag_id":"clqiekjhv00dxk9i167zhcxcv","_id":"clqiekjhv00ebk9i1ahmi8zyq"},{"post_id":"clqiekjhp00atk9i1eclmbj1o","tag_id":"clqiekjhv00e3k9i1gg1r0g3r","_id":"clqiekjhv00edk9i11dxy4iw8"},{"post_id":"clqiekjhp00atk9i1eclmbj1o","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhv00egk9i1140d1biz"},{"post_id":"clqiekjhq00b5k9i1ctps2q57","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhv00esk9i1debd0v57"},{"post_id":"clqiekjhq00b5k9i1ctps2q57","tag_id":"clqiekjhv00eak9i1glsggn5p","_id":"clqiekjhw00evk9i143fw6uz7"},{"post_id":"clqiekjhq00b5k9i1ctps2q57","tag_id":"clqiekjhv00eik9i17hzb056n","_id":"clqiekjhw00eyk9i1cf5j3wow"},{"post_id":"clqiekjhq00b5k9i1ctps2q57","tag_id":"clqiekjhv00emk9i18yvjh4h9","_id":"clqiekjhw00f1k9i1htdudivc"},{"post_id":"clqiekjhq00b9k9i16uupgwsb","tag_id":"clqiekjhv00eqk9i1e6xyc4uv","_id":"clqiekjhw00f4k9i10h3m7zja"},{"post_id":"clqiekjhq00b9k9i16uupgwsb","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhw00f7k9i17arz487n"},{"post_id":"clqiekjhq00bck9i1gjd9e45f","tag_id":"clqiekjhv00eqk9i1e6xyc4uv","_id":"clqiekjhw00fak9i16nk8e9c4"},{"post_id":"clqiekjhq00bck9i1gjd9e45f","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhw00fdk9i18zqua00b"},{"post_id":"clqiekjhq00bck9i1gjd9e45f","tag_id":"clqiekjhw00f2k9i1h5a7bchx","_id":"clqiekjhw00fgk9i15gocgqpg"},{"post_id":"clqiekjhq00bhk9i18x317jke","tag_id":"clqiekjhv00eqk9i1e6xyc4uv","_id":"clqiekjhw00fnk9i1eauxe31m"},{"post_id":"clqiekjhq00bhk9i18x317jke","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhw00fpk9i15smhgxmu"},{"post_id":"clqiekjhq00bhk9i18x317jke","tag_id":"clqiekjhw00ffk9i14q936g40","_id":"clqiekjhw00ftk9i180rg1dhc"},{"post_id":"clqiekjhr00bkk9i183qm05ac","tag_id":"clqiekjhw00fkk9i19d8gbxq8","_id":"clqiekjhx00g7k9i1bvqh1ttd"},{"post_id":"clqiekjhr00bkk9i183qm05ac","tag_id":"clqiekjhw00fqk9i1877d99ym","_id":"clqiekjhx00gak9i19xuge0hg"},{"post_id":"clqiekjhr00bkk9i183qm05ac","tag_id":"clqiekjhx00fvk9i14j43gxjs","_id":"clqiekjhx00gdk9i1g4d78645"},{"post_id":"clqiekjhr00bkk9i183qm05ac","tag_id":"clqiekjhx00g1k9i1dd8rcfrr","_id":"clqiekjhx00ggk9i16mkg7vp8"},{"post_id":"clqiekjhr00bpk9i111ra6a1s","tag_id":"clqiekjhx00g5k9i199tm84xu","_id":"clqiekjhx00gjk9i1h1846s0m"},{"post_id":"clqiekjhr00bpk9i111ra6a1s","tag_id":"clqiekjh4000dk9i17ixohkzn","_id":"clqiekjhx00gmk9i1e6qn23nr"},{"post_id":"clqiekjhs00clk9i14f7we7zw","tag_id":"clqiekjhk0081k9i12cca1oq6","_id":"clqiekjhx00gok9i11j9o1d2o"},{"post_id":"clqiekjhs00clk9i14f7we7zw","tag_id":"clqiekjhx00gbk9i1ckgj6gci","_id":"clqiekjhx00grk9i1750i8aat"},{"post_id":"clqiekjhs00clk9i14f7we7zw","tag_id":"clqiekjhx00ghk9i14iy10du0","_id":"clqiekjhx00gtk9i1hubgamgh"}],"Tag":[{"name":"算法","_id":"clqiekjh30005k9i10rmq4kof"},{"name":"Java","_id":"clqiekjh4000dk9i17ixohkzn"},{"name":"动态规划","_id":"clqiekjh5000hk9i18w5ac72u"},{"name":"JVM","_id":"clqiekjh6000yk9i11uwfb30p"},{"name":"多线程","_id":"clqiekjh9002jk9i1cxvd8gqe"},{"name":"js","_id":"clqiekjhf0050k9i16bspacbv"},{"name":"反射","_id":"clqiekjhf0058k9i1bqy57f6t"},{"name":"注解","_id":"clqiekjhg005hk9i1h6t5btce"},{"name":"二分搜索","_id":"clqiekjhg005ok9i1d0ik9ikk"},{"name":"ClickHouse","_id":"clqiekjhg005xk9i14pq11th0"},{"name":"Lambda","_id":"clqiekjhh0065k9i10z4p8ujq"},{"name":"Windows","_id":"clqiekjhh006bk9i12678dz1i"},{"name":"CMD","_id":"clqiekjhh006ik9i15ntn29ef"},{"name":"Linux","_id":"clqiekjhi006pk9i1g1ojbs95"},{"name":"Git","_id":"clqiekjhi006wk9i16f141gen"},{"name":"Face++","_id":"clqiekjhj0073k9i156d4dntt"},{"name":"BootStrapFileInput","_id":"clqiekjhj007bk9i15nau6jgw"},{"name":"indexedDB","_id":"clqiekjhk007kk9i1al6ihc5k"},{"name":"Kong","_id":"clqiekjhk007tk9i1hhcu7sdm"},{"name":"文学","_id":"clqiekjhk0081k9i12cca1oq6"},{"name":"散文","_id":"clqiekjhl0088k9i18wa692lb"},{"name":"LeetCode","_id":"clqiekjhl008fk9i18rmvar8u"},{"name":"Hexo","_id":"clqiekjhp00aok9i1bsln6doe"},{"name":"melody","_id":"clqiekjhp00awk9i11gwh1ue9"},{"name":"blog","_id":"clqiekjhq00b4k9i1fu6df7di"},{"name":"MySQL","_id":"clqiekjhq00bek9i1hv1a03gb"},{"name":"Netty4","_id":"clqiekjht00csk9i1dgbt5cxo"},{"name":"链表","_id":"clqiekjht00d0k9i12bda04g7"},{"name":"事务","_id":"clqiekjht00d8k9i16ukjhssm"},{"name":"RESTful","_id":"clqiekjhu00dhk9i122up695o"},{"name":"自律","_id":"clqiekjhu00drk9i1dwvmfene"},{"name":"Shell","_id":"clqiekjhv00dxk9i167zhcxcv"},{"name":"Spring Data JPA","_id":"clqiekjhv00e3k9i1gg1r0g3r"},{"name":"SpringBoot2","_id":"clqiekjhv00eak9i1glsggn5p"},{"name":"JPA","_id":"clqiekjhv00eik9i17hzb056n"},{"name":"REST","_id":"clqiekjhv00emk9i18yvjh4h9"},{"name":"SpingBoot2","_id":"clqiekjhv00eqk9i1e6xyc4uv"},{"name":"ShardingJDBC","_id":"clqiekjhw00f2k9i1h5a7bchx"},{"name":"WebSocket","_id":"clqiekjhw00ffk9i14q936g40"},{"name":"Ubuntu","_id":"clqiekjhw00fkk9i19d8gbxq8"},{"name":"ssh","_id":"clqiekjhw00fqk9i1877d99ym"},{"name":"脚本","_id":"clqiekjhx00fvk9i14j43gxjs"},{"name":"开机自启","_id":"clqiekjhx00g1k9i1dd8rcfrr"},{"name":"Stream","_id":"clqiekjhx00g5k9i199tm84xu"},{"name":"仓央嘉措","_id":"clqiekjhx00gbk9i1ckgj6gci"},{"name":"诗词","_id":"clqiekjhx00ghk9i14iy10du0"}]}}